{"Blogs/post/Android刷机的一般步骤":{"slug":"Blogs/post/Android刷机的一般步骤","filePath":"Blogs/post/Android刷机的一般步骤.md","title":"Android 刷机的一般步骤","links":[],"tags":["android","刷机"],"content":"1. 事前准备\n\n先想好为什么要刷机？想清楚了吗？真的想清楚了吗！好的，接下来我们要做的事应该是打开一堆网页，一堆对应自己机型的刷机教程帖，还要做好重要数据备份，确保“不成功，也不能成仁”。好的，那就开始吧：\n确定设备解锁状态\n设备锁，也称 Bootloader 锁（BL 锁），通常是厂家为了防止用户乱刷第三方系统设置的屏障，同时，它也是一些诸如「找回手机」、「抹除数据」等安全功能的基础。你应当时刻假设捡到你手机的人是一个专业人士，只要设备在他手里，那么人家就有一百种方法破解你的密码。但是一般人也就只能通过刷入 Recovery 来取缔你手机原有的 rec，进而在里面做文章（比如删除你的密码文件，这样再次开机时，密码就不复存在）。我们可以把 Recovery 想像成电脑的 Bios，于是只要设备在我手上，我想重装多少次系统都可以。也就是说我是可以使用你的设备的，并不像你想的那样：“我设了密码，你用不了。”\n而设备锁，恰恰就是一个安全保障，在对方想要取缔官方 rec 的时候，它出来阻拦：不让你换！而大多数官方的 rec 功能相对简单，并且有官方自己写的保护程序在里面。如果要强行刷机，至少也得先把数据丢了。这某种程度上说明，对方拿不到你的数据，即使他拥有了你的设备！所以对一些商务高层人士，这层防护显得尤为重要。\n至此，你应当明白，解开设备锁的风险！那么如何判断手机是否已经解锁了呢？方法至少有两种，其一是进入 bootloader 界面（关于如何进入BL界面以及adb工具的设置请先自己解决，暂时没时间写），执行\n$ fastboot oem get-bootinfo\n    1. Bootloader Lock State : UNLOCKED =&gt; 表示已经解锁，可以刷机\n    2. Bootloader Lock State : LOCKED =&gt; 表示未解锁，自行百度设备解锁方法\n\n其二，如果手机还是可用的。进入开发者选项查看，下图是一个已解锁的例子：\n\n如果未解锁，请自行搜索自己设备对应的解锁方法。一般来说小米、一加等厂商较为开放，可在官网申请解锁，可能需要等待 2~3 天的时间。\n\n数据备份\n\n建议使用钛备份：可对逐个应用以及系统数据（包括 WIFI 信息，系统设置，短信，联系人，另外还有版本控制）进行备份，root 备份首选。\nAdb 备份\nTWRP 备份\n\n配置电脑 Android 调试环境\n打开一个终端，敲 adb 或者 fastboot，如果未显示异常，则说明已经配置好。如下：\n$ adb --version\nAndroid Debug Bridge version 1.0.40\nVersion 9.0.0_r3\nInstalled as /usr/bin/adb\n\n若没有配置，安装软件包：pacman -S android-tools (Arch Linux ver.) Windows 下载对应的工具包，解压即可。不过需要配置一下路径，或者直接把所有的文件都弄到解压的文件夹下操作。\n另说一下驱动，在 Linux 和 Mac OS 下，均不需要考虑驱动的问题。在 Windows 下，需要在网上找到相应设备的驱动，安装好之后，才可以用 adb 进行刷机。这里一个显式的标志是：\n\n右键开始菜单 ⇒ 设备管理器 ⇒ ADB interface\n\n如果有这个 ADB 设备，则说明设备驱动已经安装好。\n下载刷机包\n这个就考验个人搜索能力了。一般而言在各自机型的官方论坛上找：一加论坛，MIUI论坛都是不错的选择。\n其次可以在 XDA 上找，这是个国外比较活跃的 Android 论坛，里面有很多大牛发各种第三方 Rom 包。一般热门机型都可以在 XDA 上找到自己满意的 Rom.\n下载合适的 Recovery\n推荐TWRP, 专门做第三方 Rec 的团队，首选！在这个网站上基本上可以下载到自己机型对应的 Rec.\n2. 刷机\n\n其实事前准备做得足够好的话，刷机很简单，而且风险非常低。\n可以使用 MTP 协议事先将刷机包拷贝到手机存储目录 (一般是/storage/emulated/0/，在 Rec 下的目录结构可能会发生改变/sdcard). 也可以在 Rec 下使用 adb 传输。但前提是你要有功能完备的 Rec. 一般官方的 Rec 非常简陋，没什么功能。所以我们首先得刷入第三方 Rec.\n刷入第三方 Recovery\n在确保手机与电脑正确（开启USB调试）连接下，在命令行敲\n$ adb devices\n    xxxxxx device\n\n会列出所有已连接的 Android 设备。在高版本的 Android 系统中应该会弹出一个对话框询问是否允许电脑调试本机，点击一律允许即可。\n确保手机已经解锁，开机状态连接电脑。在命令行输入\n$ adb reboot bootloader\n\n手机会重启进入 bootloader，也就是 fastboot 模式。\n确保执行目录里面有之前下载的 twrp-xxx.img 文件，命令行输入\n$ fastboot flash recovery twrp-xxx.img\n\n即完成第三方 Rec 的刷入。\n\nNote: 此时也可以选择 fastboot boot twrp-xxx.img 临时从第三方 rec 启动\n\n进入第三方 Recovery\n在命令行输入\n$ fastboot reboot\n\n重启手机，然后同时按住电源键 + 音量下键（有些手机不一样，自行摸索） 进入 rec. 也可以等开机后输入\n$ adb reboot recovery\n\n进入rec.\n刷机\nTwrp 的 rec 界面十分友好，可以设置语言时区等等。刷机之前先要清理（特别提醒：这里已经默认你做好备份了）。我们经常清理的有四个分区\nsystem                  # 系统分区\ndata                    # 数据分区：应用数据（设置，帐号，习惯等）\ncache/davik cache       # 缓存分区：应用缓存，系统缓存\ninternal storage        # 个人资料存储：包含照片视频音乐等所有个人资料\n\n一般 internal storage 是不会动的，把其他三个分区清掉。\n然后安装刷机包，找到事先放好的刷机包位置，刷入，重启！\n\nNote: 或者事先没有拷贝的话，确保命令执行目录中有你的刷机包，使用\nadb push aex-xxx-rom.zip /sdcard\n即可将刷机包拷贝至手机存储目录。\n再或者，使用 ADB sideload 功能边传文件边刷。具体操作在 rec 中：高级 ⇒ ADB sideload\n然后再命令行输入\nadb sideload aex-xxx-rom.zip\n即可开始刷机\n\n完了！一般重启需要一些时间，请耐心等待一下。\n补丁（root包， gapps包）\n\nRoot：推荐 Supersu 或者 Magisk\nGapps：推荐 Opengapps. Google 大法好，不带 Google 框架的安卓不是 Android！\nCustom kernel\n\n\nNote: 注意刷包步骤：先 rom 包，后补丁包。不过还是建议刷完 rom 重启一次，再进 rec 刷补丁包比较稳妥。\n\n3. Troubleshooting\n\nadb 或 fastboot 报错：insufficient permission / permission denied\n请按照 developer.android.com/studio/run/device 提示操作，唯一需要注意的是USB供应商ID. 可以用 lsusb 来判断。\n连接手机之前：\n$ lsusb\nBus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub\nBus 001 Device 004: ID 8087:0a2b Intel Corp. \nBus 001 Device 003: ID 04f3:0c1a Elan Microelectronics Corp. \nBus 001 Device 002: ID 04f2:b5a3 Chicony Electronics Co., Ltd \nBus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub\n\n连接手机之后：\n$ lsusb\nBus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub\nBus 001 Device 004: ID 8087:0a2b Intel Corp. \nBus 001 Device 003: ID 04f3:0c1a Elan Microelectronics Corp. \nBus 001 Device 002: ID 04f2:b5a3 Chicony Electronics Co., Ltd \nBus 001 Device 041: ID 2717:ff48  \nBus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub\n\n这样就可以判断该设备的供应商 ID 为 2717.\n然后重启 udev 服务： udevadm control --reload（Arch Linux ver.）\n拔掉手机线重新插入，再用 adb devices 列举一遍，就应该可以了。\n\nNote: 另外可以尝试使用 root 权限执行命令： sudo adb 和 sudo fastboot\n\nReference\n\n在硬件设备上运行应用\nfastboot and adb not working with sudo\n"},"Blogs/post/Exponetial-Distribution":{"slug":"Blogs/post/Exponetial-Distribution","filePath":"Blogs/post/Exponetial-Distribution.md","title":"Exponential Distribution","links":["Blogs/post/Geometric-Distribution.html"],"tags":["math","probability"],"content":"Story\n\nThe Exponential distribution is the continuous counterpart to the Geometric distribution. The story of the Exponential distribution is analogous, but we are now waiting for a success in continuous time, where successes arrive at a rate of \\lambda successes per unit of time. The average number of successes in a time interval of length t is \\lambda t, though the actual number of successes varies randomly. An Exponential random variable represents the waiting time until the first arrival of a success.\n——adapted from Book BH\n\n\nBasic\nDefinition: A continuous r.v. X is said to have the Exponential distribution with parameter \\lambda if its PDF is\nf(x) = \\lambda e^{-\\lambda x}, \\quad x &gt; 0\nThe corresponding CDF is\nF(x) = 1 - e^{-\\lambda x}, \\quad x &gt; 0\nTo calculate the expectation and variance, we first consider X \\sim Exp(1) with PDF f(x) = e^{-x}, then\n\\begin{split}\nE(X) &amp;= \\int_0^{\\infty} x e^{-x} dx = 1  \\newline\nE(X^2) &amp;= \\int_0^{\\infty} x^2 e^{-x} dx \\newline\n&amp;= -x^2e^{-x}|_0^{\\infty} + 2\\int_0^{\\infty} x e^{-x} dx \\newline\n&amp;= 2E(X) = 2 \\newline\nVar(X) &amp;= E(X^2) - E^2(X) = 2-1 = 1 \\newline\nM_X(t) &amp;= E(e^{tX}) = \\int_0^{\\infty} e^{tx} e^{-x} dx \\newline\n&amp;= \\int_0^{\\infty} e^{-(1-t)x} dx = \\frac{1}{1-t} \\quad \\text{for }t&lt;1\n\\end{split}\nNow let Y=\\frac{X}{\\lambda} \\sim Exp(\\lambda) for\nf_Y(y) = f_X(X(y))\\frac{dx}{dy} = e^{-\\lambda y}\\cdot\\lambda \\sim Exp(\\lambda)\nor\nP(Y\\le y) = P(X\\le \\lambda y) = 1 - e^{-\\lambda y} \\sim Exp(\\lambda).\nHence, we can get\n\nE(Y) = E(X/\\lambda) = 1/\\lambda\nVar(Y) = Var(X/\\lambda) = 1/\\lambda^2\nMGF (moment generating function):\n\n\\begin{split}\n  M_Y(t) &amp;= E(e^{tY}) =E(e^{tX/\\lambda}) \\newline\n\t&amp;= E(e^{\\frac{t}{\\lambda}X}) = M_X(\\frac{t}{\\lambda}) = \\frac{1}{1-t/\\lambda} \\newline\n  &amp;= \\frac{\\lambda}{\\lambda -t} \\quad \\text{for }t&lt;\\lambda\n  \\end{split}\nMemeoryless Property\nMemoryless is something like P(X \\ge s+t ~|~ X \\ge s) = P(X \\ge t), let X \\sim Exp(\\lambda), then\n\\begin{split}\nP(X \\ge s+t ~|~ X \\ge s) &amp;= \\frac{P(X \\ge s+t, ~X \\ge s)}{P(X \\ge s)} \\newline\n&amp;= \\frac{P(X \\ge s+t)}{P(X \\ge s)} \\newline\n&amp;= \\frac{e^{-\\lambda (s+t)}}{e^{-\\lambda s}} = e^{-\\lambda t} \\newline\n&amp;= P(X \\ge t)\n\\end{split}\nTheorem: If X is a positive continuous r.v. with memoryless property, then X has an exponential distribution. Similarly, if X is discrete, then it has a geometric distribution.\n\nProof idea: use survival function and solve differential equations.\n\nExamples\neg.1 X_1 \\sim Exp(\\lambda_1), ~X_2 \\sim Exp(\\lambda_2), and X_1 \\perp X_2. Then P(X_1 &lt; X_2) = \\frac{\\lambda_1}{\\lambda_1 + \\lambda_2}.\nProof: By LOTP (law of total probability),\n\\begin{split}\nP(X_1 &lt; X_2) &amp;= \\int_0^{\\infty} f_{X_1}(x) P(X_2 &gt; X_1 ~|~ X_1=x) dx \\newline\n&amp;= \\int_0^{\\infty} f_{X_1}(x) P(X_2 &gt; x ~|~ X_1=x) dx \\newline\n&amp;= \\int_0^{\\infty} f_{X_1}(x) P(X_2 &gt; x) dx \\quad \\text{(independence)} \\newline\n&amp;= \\int_0^{\\infty} \\lambda_1 e^{-\\lambda_1 x} e^{-\\lambda_2 x} dx \\newline\n&amp;= \\lambda_1 \\int_0^{\\infty} e^{-(\\lambda_1 + \\lambda_2) x} dx \\newline\n&amp;= \\frac{\\lambda_1}{\\lambda_1 + \\lambda_2}\n\\end{split}\neg.2 \\{X_i\\}_{i=1}^n are independent with X_j \\sim Exp(\\lambda_j). Let L = \\min(X_1, \\cdots, X_n), then L \\sim Exp(\\lambda_1 + \\cdots \\lambda_n).\nProof:\n\\begin{split}\nP(L &gt; t) &amp;= P\\left(\\min(X_1,\\cdots,X_n) &gt; t\\right) \\newline\n&amp;= P(X_1 &gt; t, \\cdots, X_n &gt;t) \\newline\n&amp;= P(X_1 &gt; t) \\cdots P(X_n &gt;t) \\quad \\text{indep.} \\newline\n&amp;= e^{-\\lambda_1 t}\\cdots e^{-\\lambda_n t} \\newline\n&amp;= e^{-(\\lambda_1 + \\cdots \\lambda_n)t} \\sim Exp\\left(\\sum_j \\lambda_j\\right)\n\\end{split}\nThe intuition of this result is that if you consider n Poisson processes with rate \\lambda_j,\n\nX_1 as the waiting time for a green car\nX_2 as the waiting time for a red car\n…\n\nThen L is the waiting time for a car of any color (i.e., any car). So it makes sense, the rate is \\lambda_1 + \\cdots + \\lambda_n.\neg.3 (Difference of two exponetial) Let X \\sim Exp(\\lambda) and Y \\sim Exp(\\mu), X \\perp Y. Then what is the PDF of Z=X-Y?\nSolution:\nRecall the story of exponential, one can think of X and Y as waiting times for two independent things. For example,\n\nX as the waiting time for a red car passing by\nY as the waiting time for a blue car\n\nIf we see a blue car passing by, then the further waiting time for a red car is still distributed as same distribution as Y, for the memoryless property of exponential. Likewise, if we see a red car passing by, then the further waiting time is distributed as same as X. The further waiting time is somehow what we are interested in, say Z.\nThe above intuition says that, the conditional distribution of X-Y given X &gt; Y is the distribution of X, and the conditional distribution of X-Y given X \\le Y is the distribution of -Y (or in other words, the conditional distribution of Y-X given Y \\ge X is same as the distribution of Y).\n\nTo make full use of our intuition, we know that\n\nIf X&gt;Y, which means Z&gt;0, then Z~|~X&gt;Y = X a.s. holds, that is\n\n\\begin{gathered}\nf_Z(z~|~X&gt;Y) = \\lambda e^{-\\lambda z} \\newline\n\\text{and since }P(X&lt;Y) = 0 \\newline\n\\implies f_Z(z) = f_Z(z~|~X&gt;Y)P(X&gt;Y) \\newline\n= \\frac{\\mu}{\\lambda + \\mu}\\lambda e^{-\\lambda z}.\n\\end{gathered}\n\nIf X &lt; Y, which means Z &lt; 0, then Z~|~X&lt;Y = -Y a.s. holds, that is\n\n\\begin{gathered}\nf_Z(z~|~X&lt;Y) = f_Y(y(z))\\left|\\frac{dy}{dz}\\right| = \\mu e^{\\mu z} \\newline\n\\implies f_Z(z) = f_Z(z~|~X&lt;Y)P(X&lt;Y) \\\\\n= \\frac{\\lambda}{\\lambda + \\mu} \\mu e^{\\mu z}\n\\end{gathered}\nHowever, this is just a sketch. Later we will see how to derivate the form mathematically.\n\nFrom the above point of view, the PDF of Z had better be discussed by the sign of Z.\n\nIf Z &gt; 0, which implies X &gt; Y \\implies P(X &gt; Y) = 0, then\n\n\\begin{split}\nP(Z &gt; z) &amp;= P(X-Y&gt;z ~|~ X&gt;Y)P(X&gt;Y) + P(Z&gt;z~|~X&lt;Y)P(X&lt;Y) \\newline\n&amp;= P(X&gt;z)P(X&gt;Y) + 0 \\quad \\text{(memoryless)} \\newline\n&amp;= \\frac{\\mu}{\\lambda + \\mu} e^{-\\lambda z} \\quad \\text{(by eg.1)}  \\newline\n\\implies f_Z(z) &amp;= \\frac{\\lambda\\mu}{\\lambda + \\mu} e^{-\\lambda z} \\quad \\text{for }z&gt;0 \n\\end{split}\n\nIf Z \\le 0, which implies X \\le Y, then\n\n\\begin{split}\nP(Z &lt; z) &amp;= P(Z&lt;z ~|~ X\\&gt;Y)P(X&gt;Y) + P(X-Y&lt;z~|~X&lt;Y)P(X&lt;Y) \\newline\n&amp;= 0 + P(Y-X &gt; -z ~|~ Y&gt;X)P(Y&gt;X)  \\newline\n&amp;= P(Y&gt;X)P(Y &gt; -z) \\quad \\text{(memoryless)}  \\newline\n&amp;= \\frac{\\lambda}{\\lambda + \\mu}e^{\\mu z} \\quad \\text{(by eg.1)} \\newline\n\\implies f_Z(z) &amp;= \\frac{\\lambda\\mu}{\\lambda + \\mu}e^{\\mu z} \\quad \\text{for }z&lt;0\n\\end{split}\nTherefore, the PDF of Z has the form\nf_Z(z) = \\frac{\\lambda\\mu}{\\lambda + \\mu} \n\\begin{cases}\ne^{-\\lambda z} &amp;\\quad z&gt;0 \\newline\ne^{\\mu z} &amp;\\quad z&lt;0\n\\end{cases}\n\nNote: P(X=Y)=0 since the integral domain is a line (y=x) whose measure is 0. That is P(Z=0) = 0. This is why we can give no care of the case X=Y.\n"},"Blogs/post/HTML-美化-Markdown-排版":{"slug":"Blogs/post/HTML-美化-Markdown-排版","filePath":"Blogs/post/HTML-美化-Markdown-排版.md","title":"HTML 美化 Markdown 排版","links":[],"tags":["排版","美化","html"],"content":"Markdown 是一门轻量标记型语言，因其简单易用而受众甚广。但是正因其简单，故而也有一部分局限性（虽然说它保留的即是最常用、最基本的排版功能）。本文就来说说在使用 Markdown 排版的时候，如何引入一点 HTML 的技巧来帮助我们排版的更加好看。\n\n1. 对齐控制\n标准的 Markdown 只支持居左对齐。\n&lt;center&gt;I am centered&lt;/center&gt;\n会排版出居中的效果：\n\nI am centered\n&lt;!-- right-aligned --&gt;\n&lt;div style=&quot;text-align:right&quot;&gt;I am right aligned&lt;/div&gt;\n会排版出居右的效果：\nI am right aligned\n\n2. 字体控制\n通过 HTML 标签，我们可以精确的控制字体族，字体大小，字体颜色，字体形态（粗体，斜体，下划线，删除线）等等。具体参见w3school.\n&lt;font size=&#039;3&#039; color=&quot;red&quot;&gt;I am red of size 3&lt;/font&gt;\n&lt;font size=5px color=&quot;#66CCFF&quot;&gt;I am 天依蓝 of size 5px&lt;/font&gt;\n&lt;font face=&quot;verdana&quot; color=&quot;green&quot;&gt;I am verdana of color green&lt;/font&gt;\n&lt;u&gt;I am underlined&lt;/u&gt;\n&lt;s&gt;I am deleted :(&lt;/s&gt;\n&lt;b&gt;I am bolded&lt;/b&gt;\n&lt;i&gt;I am italic&lt;/i&gt;\n&lt;big&gt;I am bigger than you&lt;/big&gt;\n&lt;small&gt;I am smaller than you&lt;/small&gt;\nlook&lt;sup&gt;at&lt;/sup&gt;&lt;sub&gt;me&lt;/sub&gt;\n&lt;kbd&gt;Ctrl+Shift+D&lt;/kbd&gt;\n&lt;q&gt;using this for short quote&lt;/q&gt;\n&lt;div style=&quot;background-color:black&quot;&gt;举世皆白我独黑&lt;/div&gt;\n的排版效果：\nI am red of size 3\nI am 天依蓝 of size 5px\nI am verdana of color green\nI am underlined\nI am deleted :(\nI am bolded\nI am italic\nI am bigger than you\nI am smaller than you\nlookatme\nCtrl+Shift+D\nusing this for short quote\n举世皆白我独黑\n3. 使用 FontAwesome 图标\nFontAwesome 是一款图标字体集合。以下 Icon 的名称均可以在官网查到：\n&lt;i class=&quot;fa fa-check-square&quot;&gt; &lt;/i&gt; completed\n&lt;i class=&quot;fa fa-square&quot;&gt; &lt;/i&gt; uncompleted\n&lt;i class=&quot;fa fa-github&quot;&gt; &lt;/i&gt; github icon\n&lt;i class=&quot;fa fa-weixin&quot;&gt; &lt;/i&gt; wechat icon\n&lt;i class=&quot;fa fa-rss&quot;&gt; &lt;/i&gt; rss icon\n&lt;i class=&quot;fa fa-twitter&quot;&gt; &lt;/i&gt; twitter icon\n&lt;i class=&quot;fa fa-weibo&quot;&gt; &lt;/i&gt; weibo icon\n&lt;i class=&quot;fa fa-weibo fa-lg&quot;&gt; &lt;/i&gt; large weibo icon\n&lt;i class=&quot;fa fa-weibo fa-2x&quot;&gt; &lt;/i&gt; 2\\*weibo icon\n&lt;i class=&quot;fa fa-weibo fa-4x&quot;&gt; &lt;/i&gt; 4\\*weibo icon\n的排版效果如下：\n  completed\n  uncompleted\n  github icon\n  wechat icon\n  rss icon\n  twitter icon\n  weibo icon\n  large weibo icon\n  2*weibo icon\n  4*weibo icon\n4. 插图控制\n大小控制\n&lt;!-- 类似的可以设置 height=&quot;100&quot; --&gt;\n&lt;img src=&quot;miwa.png&quot; width=&quot;100&quot; alt=&quot;miwa-width=100&quot; /&gt;\n![miwa](miwa.png)\n下面是排版结果的对比：\n\n\n图标题\n![hover text](hbimg.huaban.com/fe01cdf198b7da8ffec56f52fcf505acffca258a1fb3a-j6MBCO_/fw/480/format/webp &quot;sample caption&quot;)\n&lt;figcaption&gt;颇有意境的美少女&lt;/figcaption&gt;\n\n颇有意境的美少女\n如此能生效的原因是本站加载了名为figcaption的css，所以这个标签能够被正确排版。使用本主题1只需要在主题文件夹下的_custom.scss中增加:\n// file: &lt;site-root&gt;/themes/even/assets/sass/_custom/_custom.scss\nfigcaption {\n  // background-color: #222;\n  color: gray;\n  padding: 3px;\n  text-align: center;\n  margin-top: -20px;\n  margin-bottom: 20px;\n}\n即可。\n5. ShortCode\nHugo提供了ShortCode功能，简单来说就是强大的html替换模版，因为直接在markdown里面写html会显得冗长，所以将一个个排版样式作为ShortCode提供给用户使用。详情参考文档，这里列举一些本主题1提供的ShortCode.\n\n不建议使用ShortCode，因为脱离了hugo，这些元素就无法渲染了。为了保持markdown源文件的兼容性，不推荐使用此功能。\n\n{{% center %}}\n{{% bilibili BV1qs411D7Po %}}\nsample b23 video desc\n{{% /center %}}\n\n完球，上述代码段已经是展开后的形式了，应该是hugo转网页的时候一定会做替换，目前还没找到escape的方法，先将就着看吧。\n\n可排版出如下内容\n{{% center %}}\n{{% bilibili BV1qs411D7Po %}}\nsample bilibli video desc\n{{% /center %}}\n但其实上述内容在普通\n\nShortCode在vscode中的排版效果\n6. 代码高亮\n\nNOTE: 这个功能依赖hugo，不建议使用。\n\nCf. gohugo.io/content-management/syntax-highlighting/#highlighting-in-code-fences\n```go  {linenos=table,hl_lines=[8,&quot;15-17&quot;],linenostart=199}\n// GetTitleFunc returns a func that can be used to transform a string to\n// title case.\n//\n// The supported styles are\n//\n// - &quot;Go&quot; (strings.Title)\n// - &quot;AP&quot; (see www.apstylebook.com/)\n// - &quot;Chicago&quot; (see www.chicagomanualofstyle.org/home.html)\n//\n// If an unknown or empty style is provided, AP style is what you get.\nfunc GetTitleFunc(style string) func(s string) string {\n  switch strings.ToLower(style) {\n  case &quot;go&quot;:\n    return strings.Title\n  case &quot;chicago&quot;:\n    return transform.NewTitleConverter(transform.ChicagoStyle)\n  default:\n    return transform.NewTitleConverter(transform.APStyle)\n  }\n}\n```\n\n会排版出如下效果\n// GetTitleFunc returns a func that can be used to transform a string to\n// title case.\n//\n// The supported styles are\n//\n// - &quot;Go&quot; (strings.Title)\n// - &quot;AP&quot; (see www.apstylebook.com/)\n// - &quot;Chicago&quot; (see www.chicagomanualofstyle.org/home.html)\n//\n// If an unknown or empty style is provided, AP style is what you get.\nfunc GetTitleFunc(style string) func(s string) string {\n  switch strings.ToLower(style) {\n  case &quot;go&quot;:\n    return strings.Title\n  case &quot;chicago&quot;:\n    return transform.NewTitleConverter(transform.ChicagoStyle)\n  default:\n    return transform.NewTitleConverter(transform.APStyle)\n  }\n}\nReference\n\n没有内容的 HTML 元素被称为空元素。空元素是在开始标签中关闭的。&lt;br&gt; 就是没有关闭标签的空元素（&lt;br&gt; 标签定义换行）。在 XHTML、XML 以及未来版本的 HTML 中，所有元素都必须被关闭。在开始标签中添加斜杠，比如 &lt;br /&gt;，是关闭空元素的正确方法，HTML、XHTML 和 XML 都接受这种方式。即使 &lt;br&gt; 在所有浏览器中都是有效的，但使用 &lt;br /&gt; 其实是更长远的保障。\n——w3shcool\n\n\n[HEXO] NexT 主题提高博客颜值\nHTML 元素\n\nFootnotes\n\n\nHugo theme even ↩ ↩2\n\n\n"},"Blogs/post/LeetCode-Sum-of-Two-Integers":{"slug":"Blogs/post/LeetCode-Sum-of-Two-Integers","filePath":"Blogs/post/LeetCode-Sum-of-Two-Integers.md","title":"LeetCode: Sum of Two Integers","links":[],"tags":["cpp","leetcode","位运算"],"content":"记录一下LeetCode做的一道题。要求实现两个整数的加法，但不能使用内置的+或-. 原题地址：leetcode.com/problems/sum-of-two-integers/\n我们来看一下答案：\nclass Solution {\npublic:\n    int getSum(int a, int b) {\n        return b == 0? a : getSum(a^b, (a&amp;b)&lt;&lt;1);\n    }\n};\n乍一看，似乎很难看，位运算毕竟不是很直观。重写一下，\nclass Solution {\npublic:\n    int getSum(int a, int b) {\n        int sum = a;\n        while (b != 0) {\n            sum = a^b; // sum w/o carry\n            b = (a&amp;b) &lt;&lt; 1; // calculate the carry\n            a = sum; // add this sum to next-&gt;a\n        }\n        return sum;\n    }\n}\nor\nclass Solution {\npublic:\n    int getSum(int a, int b) {\n        int sum = a;\n        if (b != 0) {\n            sum = a^b;\n            b = (a&amp;b) &lt;&lt; 1;\n            return getSum(sum, b);\n        }\n        else {\n            return sum;\n        }\n    }\n}\n除了将递归写成了迭代，其余部分都是照着第一段代码来的。重要的是为什么是这样？为什么会有\na + b == (a^b) + (a&amp;b)&lt;&lt;1\n\n现在我们挨个来看看a^b、a&amp;b到底是啥？首先a^b，^是C++中的按位异或运算符，它的运算表为：\n\n1^1 = 0\n0^0 = 0\n1^0 = 1\n0^1 = 1\n\n现在我们把它竖过来看，或许你会发现一点东西：\n       1011  &lt;---+ a   X           1011\n     ^ 1010  &lt;---+ b   X         + 1010\na^b= -------           X    a+b= -------\n       0001            X          10101\n\n这好像就是二进制的加法呀？除了没有进位！那么进位在哪里呢？我们把目光转向a&amp;b，&amp;是C++按位与运算符，它的运算表如下：\n\n0&amp;0 = 0\n0&amp;1 = 0\n1&amp;0 = 0\n1&amp;1 = 1\n\n可以看到，与运算只有一种情况为1，这恰好对应着二进制加法中需要进位的情况。再加上进位需要向左边进一位，所以还应该左移一位加上之前的a^b，正好就是加法需要的结果。到这里你应该明白为什么a+b == (a^b) + (a&amp;b)&lt;&lt;1.\n接着，又有一个问题：随着程序的执行，b为什么会变成0？我们看看b是如何更新的，\nsum = a^b;\nb = (a&amp;b) &lt;&lt; 1; // b is updated\na = sum;\n假设a&amp;b = 1010 0111，那么b的值就会更新为：1010 0111 =&gt; 0100 1110，b的最低位每次都会引入一个0，而最高位被丢弃，这样的结果就是b中的1越来越少，0越来越多，最终一定会变成0. 而每次b中削减的值，全部间接通过sum被加到a中去了。如此以来，当b为0的时候，此时的a已经加到两者之和了。可以想象有两堆小球，每次迭代都将b这一堆的某些球挪到a中去，那么当b被挪完的时候，a中就有了全部的小球。\n还有一个问题，目前我还没有解决。上述答案贴到LeetCode里面是不通过的，因为接受的参数是int型的，可以为负，而将负数左移是未定义的行为。来日有时间再看看…\n小结\n位运算牛逼！无奈本人没文化，只能喊出这样的口号了。另外在做题的过程中，搜到了CSDN上的一篇文章，总结了很多位运算的技巧：here.\nReferences\n\n原题讨论帖\n一人跟帖解释\n又\n"},"Blogs/post/Linux-相关信息速查":{"slug":"Blogs/post/Linux-相关信息速查","filePath":"Blogs/post/Linux-相关信息速查.md","title":"Linux 使用指北","links":[],"tags":["常用命令","reference"],"content":"本文主要引用 Liam Huang 的博客。\n系统相关\nlsb_release -a              # 查看操作系统版本\nhead -n 1 /etc/issue        # 查看操作系统版本\ncat /proc/version           # 查看操作系统内核信息\nuname -a                    # 查看操作系统内核信息、CPU 信息\ncat /proc/cpuinfo           # 查看 CPU 信息\nhostname                    # 查看计算机名字\nenv                         # 列出环境变量\nlsmod                       # 列出加载的内核模块\nuptime                      # 查看系统运行时间、负载、用户数量\ncat /proc/loadavg           # 查看系统负载\nln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime # 更改时区\n\n内存外存\nfree -m                     # 查看物理内存和交换区的使用情况\ngrep MemTotal /proc/meminfo # 查看内存总量\ngrep MemFree /proc/meminfo  # 查看空闲内存总量\ndf -h                       # 查看各分区使用情况\nfdisk -l                    # 查看所有分区\nswapon -s                   # 查看所有交换分区\nhdparm -i /dev/hda          # 查看 IDE 磁盘的参数\ndmesg | grep IDE            # 查看系统启动时 IDE 磁盘的状态\nmount | column -t           # 查看各分区的挂载状态\ndu -sh &lt;目录名&gt;              # 查看指定目录的大小\n网络状态\nifconfig                    # 查看所有网络接口的属性\nip addr show                # 同上\niptables -L                 # 查看 iptables 防火墙\nroute -n                    # 查看本机路由表\nnetstat -lntp               # 查看所有监听端口\nnetstat -antp               # 查看所有已建立的连接\nnetstat -s                  # 查看网络统计信息\nubuntu设置接口ip地址：ubuntu默认是用netplan作为网络管理器，而archlinux使用NetworkManager.\n参考：www.51cto.com/article/721393.html\ncd /etc/netplan\nvim 00-installer-config.yaml # 在里面配置接口ip\n...\nnetplan apply # 应用配置\n用户状态相关\nw                           # 查看活动用户以及他们在做什么\nwho                         # 查看活动用户\nid &lt;用户名&gt;                  # 查看用户的 ID、组信息\ncut -d: -f1 /etc/passwd     # 查看系统中所有用户\ncut -d: -f1 /etc/group      # 查看系统所有组\nusermod -a -G group1,group2 user  # 将用户追加到组\ngroups user                 # 查看用户所属的组\n参考：linux.cn/article-10768-1.html\n进程状态相关\nps -ef                      # 查看所有进程\nps aux                      # 同上\ntop                         # 动态显示进程状态\n添加用户到组\nusermod -aG &lt;group&gt; &lt;user&gt;\n查看文件夹内所有文件\nls -lR somedir | grep &quot;^-&quot; | wc -l"},"Blogs/post/Matrix-Factorization":{"slug":"Blogs/post/Matrix-Factorization","filePath":"Blogs/post/Matrix-Factorization.md","title":"Matrix Factorization","links":[],"tags":["math","algebra"],"content":"Preliminaries\nDef: A matrix A \\in M_n is normal if AA^∗ = A^∗A, that is, if A commutes with its conjugate transpose.\nDef: A complex matrix A is unitary if AA^∗ = I or A^∗A = I, and a real matrix B is orthogonal if BB^T = I or B^TB = I.\n\nThere is no so-called “orthonormal” matrix. There is just an orthogonal matrix whose rows or columns are orthonormal vectors.\n\nNotice that\n\\begin{gathered}\nU^*U = I \\Longleftrightarrow U^{\\star}UU^{\\star} = IU^{\\star} = U^{\\star} \\\\\n\\Longleftrightarrow UU^{\\star} = (U^{\\star})^{-1}U^{\\star} = I\n\\end{gathered}\nthe columns of U are orthonormal if and only if the rows are orthonormal.\nSo the definition can be summarized as below:\n\nHermitian: A=A^{\\star}\nUnitary: A^{\\star}A=AA^{\\star}=I\nSymmetric: A = A^{T}\nOrthogonal: A^TA=AA^T=I\n\nEigenvalue Decomposition\nSingular Value Decomposition\nLU Factorization\nQR Factorization"},"Blogs/post/Newifi-Mini安装PandoraBox":{"slug":"Blogs/post/Newifi-Mini安装PandoraBox","filePath":"Blogs/post/Newifi-Mini安装PandoraBox.md","title":"Newifi Mini 安装 PandoraBox","links":[],"tags":["路由器","个性化","刷机"],"content":"首先 Newifi mini 是一款很小巧美观的路由器，颜值即是正义嘛。再加上性价比高，易于刷写第三方系统，所以嘛，值得一买。\n规格参数\n\nWAN(10/100Mbps)\nLAN(10/100Mbps)*2\n双频：2.4GHz:300Mbps+5GHz:867Mbps\nUSB2.0接口\n外置天线*2\n天线增益：3dBi\n128MB内存\n\n\n资源\n\nPandoraBox 下载源：downloads.pandorabox.com.cn\n旧版(2015年1月)：设备代号Lenovo-Y1_RY-1S\n新版(2017年1月)：newifi-mini 附Changelog\n\n我用旧版安装shadowsocks时碰到很多问题，一时无解于是刷了新版，顺便说一下新版网页端是Material Design，很好看。\n下面开始刷入PandoraBox：\n\n下载好相应固件\n通过有线连接路由器和PC，将PC端IP设置为192.168.1.254，子网掩码255.255.255.0，网关192.168.1.1\n拔下路由器电源，再次插上，迅速按下RESET键，若设备两个蓝灯连续闪烁，说明已经进入恢复模式\n在浏览器中输入192.168.1.1进入恢复模式页面，选择之前下好的固件开始刷入\n等候1-2分钟，将PC端IP设置为自动获取，在浏览器中输入192.168.1.1即可开始常规配置\n\n配置路由器\n\n配置SSH远程登录，默认配置允许，输入 ssh root@&lt;hostname&gt;以登录路由器\n配置Samba文件共享，也可以在网页端配置，以便传输必要文件到路由器\n配置opkg软件源，写下这篇文章时，以下源可用\n\ndest root /\ndest ram /tmp\nlists_dir ext /var/opkg-lists\noption overlay_root /overlay\n\nsrc/gz 17.01_core downloads.pandorabox.com.cn/pandorabox/targets/ralink/mt7620/packages\nsrc/gz 17.01_base downloads.pandorabox.com.cn/pandorabox/packages/mipsel_24kec_dsp/base\nsrc/gz 17.01_lafite downloads.pandorabox.com.cn/pandorabox/packages/mipsel_24kec_dsp/lafite\nsrc/gz 17.01_luci downloads.pandorabox.com.cn/pandorabox/packages/mipsel_24kec_dsp/luci\nsrc/gz 17.01_mtkdrv downloads.pandorabox.com.cn/pandorabox/packages/mipsel_24kec_dsp/mtkdrv\nsrc/gz 17.01_packages downloads.pandorabox.com.cn/pandorabox/packages/mipsel_24kec_dsp/packages\n\n接下来安装SS：\n\n远程登录路由器\n执行 opkg update\n执行 opkg install shadowsocks-libev\n执行 opkg install luci-app-shadowsocks\n浏览器中输入192.168.1.1，服务栏目里应该多了一个Shadowsocks\n\n上述安装过程可能会报密钥校验不通过，此时可以在opkg里加强制选项绕过，还有些情况需要手动下载软件包上传到路由器进行本地安装，总之还有一些小问题没有提到的。未尽之处，尽力而为吧。\n刷入步骤参考了LinuxToy网站的博客：Newifi Mini 安装 OpenWrt\n如有侵权，请通知我，我会修改的0v0"},"Blogs/post/Polybar-的配置笔记":{"slug":"Blogs/post/Polybar-的配置笔记","filePath":"Blogs/post/Polybar-的配置笔记.md","title":"Polybar 的配置笔记","links":[],"tags":["polybar","个性化"],"content":"前略。\n今年早些时候，从 Gnome 换到 i3，原因是因为原来的 gnome 被我弄崩溃了。一时难以解决，又想到之前好几次隐约感觉到 gnome 的不稳定，一气之下决定换一个轻量，稳定的，可定制的窗口管理工具。至于为什么换 i3？去知乎吸收一下各个管理器间的哲学就知道了。以前从 Windows 转 Linux，也是这么过来的，知乎真是个好地方！\n换成 i3 之后，经过一番配置，桌面终于有点样子了。但是看了一眼 i3 默认的状态栏，emmm…，有点不堪入目。几经搜索之下，发现了这款名为 polybar 的状态栏工具。起初，我被他的描述深深吸引了：\n\nPolybar: A fast and easy-to-use status bar.\n\n事实上它并不是那么 easy-to-use，至少对我这个一开始接触它的人来说。我甚至不知道如何开启它（可能我真的太笨了:(）。然后我开始在网上寻找一些现成的配置，结果不是报错，就是乱码。那些看着好看的配置，你拿过来却用不了。这很气人，然后就告一段落了。我顶着简陋的 i3bar 用了好几个月。直到最近闲下来，要想起来这位老朋友，这才拿出来叙叙旧。\n\n有些事情，你当时攻不下来。那就先放一放，择日再战有奇效。\n\n\n由浅入深\n这次呢，我从一个最简单的例子入手。从这里找到一个既好看，又简约的模板：\n\n我将对应的配置复制到我自己的配置文件（~/.config/polybar/config）中:\n[bar/bar]\nbackground = #D93d3c3b\nforeground = #b6a49b\nwidth                    = 24%\nheight                   = 70\nradius                   = 15\nline-size                = 0\nbottom                   = true\nborder-bottom-size       = 0\npadding-left             = 0\npadding-right            = 0\n#module-margin-left       = 1\n#module-margin-right      = 1\n \nfixed-center = true\nfont-0 = San Francisco Display Regular:size=24;1\nfont-1 = unifont:fontformat=truetype:size=24:antialias=false;0\nfont-2 = &quot;MaterialIcons:size=24:antialias=false;1&quot;\nfont-3 = &quot;icomoon-extended-ultra:size=24:antialias=false;1&quot;\nfont-4 = &quot;Ubuntu Nerd Font:size=24:antialias=false;1&quot;\nfont-5 = FontAwesome:size=24;1\n \nmodules-left = \nmodules-center =\nmodules-right = date volume eth poweroff \nmodule-margin = 2\n \n;left - center - right - none\ntray-position = none\ntray-maxsize = 24\ntray-detached = false\ntray-transparent = false\ntray-padding = 2\ntray-scale = 1.0\n \n \noverride-redirect = true\noffset-x = 2900\noffset-y = 20\n \npadding = 0\n \nwm-name = bar\n \n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n \n[module/date]\ntype = internal/date\ninterval = 60\ndate = %a %d %b\ntime = %l:%M %p\nlabel =    %date%      %time%\n;label =  %time%\nformat-padding = 1\n \n[module/volume]\ntype = internal/volume\nformat-volume =   &lt;ramp-volume&gt;  &lt;label-volume&gt;\nformat-muted = 0% \nramp-volume-0 = \nramp-volume-1 = \nramp-volume-2 =  \n \n[module/poweroff]\ntype = custom/script\nexec = echo &quot;  &quot;\nclick-left = rofi -modi run,drun,window -show drun\nclick-right = i3lock-fancy -pg &amp;\nclick-middle = /usr/bin/rofi-logout\nformat-padding = 1\n \n[module/rofi]\ntype = custom/script\nexec = echo &quot;  &quot;\nclick-left = rofi -modi run,drun,window -show drun\nformat-padding = 1\n \n[module/eth]\ntype = internal/network\ninterface = enp2s0\ninterval = 3.0\nformat-connected = &lt;label-connected&gt;\nformat-connected-prefix = &quot;  &quot;\nformat-connected-prefix-foreground = #b6a49b\nlabel-connected = %downspeed:9%\nformat-disconnected = &lt;label-disconnected&gt;\nlabel-disconnected = not connected\nlabel-disconnected-foreground = #66ffffff\nformat-padding = 1\nCode adapted from ref\n可以看到，配置文件前半部分为 bar 本身的配置：位置，大小，颜色等等。后半部分则是对应模块的配置。其中，我们看到的一些字符未显示，那是由于我的本地并没有可以显示它的字体。其中的乱码主要是 Font Awesome 字体，首先我们得安装该字体。看看这个 bar 到底能不能如预期一样正常显示。\n执行\npolybar bar\n来运行配置文件中的 bar，其中“bar”为自定义的名字，在上面的配置文件中，这个 bar 的名字就是 “bar”。（参见[bar/bar]）\n不知道是什么原因，运行没有报错，但是我却看不见 bar 在哪里。╮(╯_╰)╭ 可能是它画在了屏幕之外的地方。于是我就将上面的参数改了改，终于，我看到了着个可爱又迷人的 bar 出现在我的桌面上。不过还是有几处乱码，可能是我安装的 Font Awesome 支持的字符不完整吧。\n然后就开始了漫长的折腾过程，循着错误信息去改对应的地方，然后看效果。再微调，再看效果，直到满意为止。\n下面是我调整完成的样子：\n\n了解构造\n其实通过配置文件，我们可以学到很多东西。当然，前提是要有一个好的蓝本给你看。这就不得不提 polybar 的 wiki，以及作者给出的一些示例了。\n好了，现在蓝本已经有了。我想添加一个新的模块：比如现在的 Wi-Fi 模块只有下行速度，我要加一个上行速度，并且加上下行箭头。参照 wiki 中的 network 模块，我们可以修改如下：\n[module/wlan]\ntype = internal/network\ninterface = wlp2s0\ninterval = 3.0\nformat-connected = &lt;label-connected&gt;\nformat-connected-prefix = &quot; &quot;\nformat-connected-prefix-foreground = #b6a49b\nlabel-connected = %upspeed:5% %downspeed:5%\nformat-disconnected = &lt;label-disconnected&gt;\nlabel-disconnected = not connected\nlabel-disconnected-foreground = #66ffffff\nformat-padding = 0\n可以看到，被改动的实际上只有一行：\n; before\nlabel-connected = %downspeed:9%\n; after\nlabel-connected = %upspeed:5% %downspeed:5%\n这样就完成了所期望的改变。\n\nNote: 要输入 Font Awesome 字符，可以打开官网的字符集 cheatsheet，然后直接复制到编辑器中。\n\n例如，通过浏览器搜索找到上行箭头，复制之。\n另外如果使用 vim，可以直接输入对应的十六进制编码来完成字符的输入。比如，我要输入上行箭头（fa-arrow-up），它的十六进制码为 f062（在 cheatsheet 中可查）：\n\n按 i 进入插入模式\n按 Ctrl + v\n按 u 进入十六进制输入模式\n输入 f062\n按 Esc 返回正常模式\n\ninputing…  \n\n\n另，:help i_CTRL-V_digit\nIn insert-mode, type control+V followed by\n\na decimal number\nx then a hex number\nu then a 4-hexchar unicode sequence\nU then an 8-hexchar unicode sequence\n\n\n摄入取景\n好了，通过上面的一点小小的改动，我们已经大致了解 polybar 的配置方式了。现在，通过一步一步加模块，我们会更进一步的了解它的工作方式。建议每添加一个模块前，先读一读 wiki 上对应模块的设置。然后找一个不错的模板进行改动。\n内存和 CPU 模块\n;;; CPU usage {{{\n[module/cpu]\ntype = internal/cpu\n \n; Seconds to sleep between updates\n; Default: 1\ninterval = 3.0\n; Available tags:\n;   &lt;label&gt; (default)\n;   &lt;bar-load&gt;\n;   &lt;ramp-load&gt;\n;   &lt;ramp-coreload&gt;\nformat = &lt;label&gt;&lt;ramp-load&gt;\n \n; Available tokens:\n;   %percentage% (default) - total cpu load averaged over all cores\n;   %percentage-sum% - Cumulative load on all cores\n;   %percentage-cores% - load percentage for each core\n;   %percentage-core[1-9]% - load percentage for specific core\nlabel = CPU %percentage\n顾名思义，它会输出CPU加一个变量，这个变量是一个百分比，就是当前CPU的平均使用率。可选的变量已经在 wiki 中给出。想要什么自己替换就行。\n再来看看第二部分，\nramp-load-0 = ▁\nramp-load-1 = ▂\nramp-load-2 = ▃\nramp-load-3 = ▄\nramp-load-4 = ▅\nramp-load-5 = ▆\nramp-load-6 = ▇\nramp-load-7 = █\nramp-load共有7个值，他会根据CPU使用率选择合适的值。简而言之，就是将100分成7个等级，使用率越高，就选用等级越高的图案显示。整合起来的效果就是随着百分比增加，显示的高度越高，类似一个性能监视窗，上下浮动。\n这还不够，我们还可以做一点微小的工作。请看\nramp-load-0-foreground = #aaff77\nramp-load-1-foreground = #aaff77\nramp-load-2-foreground = #aaff77\nramp-load-3-foreground = #aaff77\nramp-load-4-foreground = #fba922\nramp-load-5-foreground = #fba922\nramp-load-6-foreground = #ff5555\nramp-load-7-foreground = #ff5555\n这里我们定义了每个等级展示字符的前景色。等级越高，颜色越红，表示警告CPU使用快超标了！这样整个变化就有了颜色相伴，更加直观！最后完成的效果如下：\n\n内存模块也是类似的。先看一下配置，\n[module/memory]\ntype = internal/memory\n \n; Seconds to sleep between updates\n; Default: 1\ninterval = 3.0\n; Available tags:\n;   &lt;label&gt; (default)\n;   &lt;bar-used&gt;\n;   &lt;bar-free&gt;\n;   &lt;ramp-used&gt;\n;   &lt;ramp-free&gt;\n;   &lt;bar-swap-used&gt;\n;   &lt;bar-swap-free&gt;\n;   &lt;ramp-swap-used&gt;\n;   &lt;ramp-swap-free&gt;\nformat = &lt;label&gt;&lt;ramp-used&gt;\n \n; Available tokens:\n;   %percentage_used% (default)\n;   %percentage_free%\n;   %gb_used%\n;   %gb_free%\n;   %gb_total%\n;   %mb_used%\n;   %mb_free%\n;   %mb_total%\n;   %percentage_swap_used%\n;   %percentage_swap_free%\n;   %mb_swap_total%\n;   %mb_swap_free%\n;   %mb_swap_used%\n;   %gb_swap_total%\n;   %gb_swap_free%\n;   %gb_swap_used%\n \nlabel = RAM %percentage_used%%\n;label-font = 3\n \n; Only applies if &lt;bar-used&gt; is used\nbar-used-indicator =\nbar-used-width = 50\nbar-used-foreground-0 = #55aa55\nbar-used-foreground-1 = #557755\nbar-used-foreground-2 = #f5a70a\nbar-used-foreground-3 = #ff5555\nbar-used-fill = ▐\nbar-used-empty = ▐\nbar-used-empty-foreground = #444444\n \n; Only applies if &lt;ramp-used&gt; is used\nramp-used-0 = ▁\nramp-used-1 = ▂\nramp-used-2 = ▃\nramp-used-3 = ▄\nramp-used-4 = ▅\nramp-used-5 = ▆\nramp-used-6 = ▇\nramp-used-7 = █\nramp-used-0-foreground = #aaff77\nramp-used-1-foreground = #aaff77\nramp-used-2-foreground = #aaff77\nramp-used-3-foreground = #aaff77\nramp-used-4-foreground = #fba922\nramp-used-5-foreground = #fba922\nramp-used-6-foreground = #ff5555\nramp-used-7-foreground = #ff5555\n \n; Only applies if &lt;ramp-free&gt; is used\nramp-free-0 = ▁\nramp-free-1 = ▂\nramp-free-2 = ▃\nramp-free-3 = ▄\nramp-free-4 = ▅\nramp-free-5 = ▆\nramp-free-6 = ▇\nramp-free-7 = █\n;;; }}}\n配置出来的效果见上图。\n电池模块\n同理可参考 wiki 配置电池模块。\n;;; battery {{{\n[module/battery]\ntype = internal/battery\nfull-at = 98\n \nformat-charging = &lt;animation-charging&gt; &lt;label-charging&gt;\nformat-discharging = &lt;ramp-capacity&gt; &lt;label-discharging&gt;\nformat-full = %{F#666}%{F#ccfafafa} &lt;label-full&gt;\n#label-charging-font = 3\n#label-discharing-font = 3\n \nramp-capacity-0 = \nramp-capacity-1 = \nramp-capacity-2 = \n; low power alert\nramp-capacity-0-foreground = #ff5555\n \n; it will display over the three pattern when charing\n; at a framerate 750\n; and each has a foreground color\nanimation-charging-0 = \nanimation-charging-1 = \nanimation-charging-2 = \nanimation-charging-2-foreground = #aaff77\nanimation-charging-1-foreground = #fba922\nanimation-charging-0-foreground = #ff5555\nanimation-charging-framerate = 750\n;;; }}}\n可以看到电池的显示类型共有三个，\nformat-charging = &lt;animation-charging&gt; &lt;label-charging&gt;\nformat-discharging = &lt;ramp-capacity&gt; &lt;label-discharging&gt;\nformat-full = %{F#666}%{F#ccfafafa} &lt;label-full&gt;\n第一个控制了充电时的显示，第二个控制了非充电时的显示，第三个则是满电时的显示。配置语言通俗易懂，比如，充电的时候会显示一个充电动画和电池电量（&lt;label-charing&gt;），其他的可以依次类推。\nanimation-charging-0 = \nanimation-charging-1 = \nanimation-charging-2 = \nanimation-charging-2-foreground = #aaff77\nanimation-charging-1-foreground = #fba922\nanimation-charging-0-foreground = #ff5555\nanimation-charging-framerate = 750\n上面这段配置定义了充电时的动画，当你插上电源，电池图标会依次按照0、1、2的图案切换。然后每个图案都有各自的前景色，切换的速率是 750. 完成后的效果如下：\n\nMPD 模块\nMPD 全称 Music Player Daemon.\n\nMPD (music player daemon) is an audio player that has a server-client architecture. It plays audio files, organizes playlists and maintains a music database, all while using very few resources. In order to interface with it, a separate client is needed.\n──adpted from archwiki\n\nMPD是一个轻量的本地音乐播放框架。需要和客户端（mpc）一起使用。大致分为几步：\n\n$ mpd 启动 mpd 进程\n$ mpc add &lt;MusicDir&gt; 添加本地音乐文件夹\n$ mpc play 开始播放\n\n如我们所见，非常轻量。但是 mpc 是命令行工具，使用起来难免有些不顺手。好在 polybar 已经内置了 mpd 模块，我们只需要改改样式就可以了。\n;;; mpd config {{{\n[module/mpd]\ntype = internal/mpd\n \n; format-online = &lt;label-song&gt;  &lt;label-time&gt;  &lt;bar-progress&gt;  &lt;icon-prev&gt; &lt;icon-seekb&gt; &lt;icon-stop&gt; &lt;toggle&gt; &lt;icon-seekf&gt; &lt;icon-next&gt;  &lt;icon-repeat&gt; &lt;icon-random&gt;\nformat-online = &lt;toggle&gt; &lt;label-song&gt; &lt;icon-next&gt;\nformat-offline = &lt;label-offline&gt;\nformat-offline-foreground = #66\nlabel-offline = mpd is off\n \nlabel-song-maxlen = 20\nlabel-song-font = 8\n \nicon-prev = \nicon-seekb = \nicon-stop = stop\nicon-play = \nicon-pause = \nicon-next = \nicon-seekf = \n \nicon-random = \nicon-repeat = \n \ntoggle-on-foreground = #2278ff\ntoggle-off-foreground = #66\n \nbar-progress-width = 15\nbar-progress-indicator = \nbar-progress-indicator-foreground = #bb\nbar-progress-fill = ─\nbar-progress-fill-foreground = #bb\nbar-progress-fill-font = 3\nbar-progress-empty = ─\nbar-progress-empty-foreground = #44\nbar-progress-empty-font = 3\n \nlabel-time-foreground = #55\nlabel-time-font = 8\n;;; }}}\n配置好我们需要的样式就大功告成啦，看一下效果：\n\n总结\n一路折腾下来，发现 polybar 其实很友好。配置逻辑也非常清晰，有点怀疑自己当初为什么没有配置好它，反而觉得很难用。所以啊，作者写这个软件也不是为了刁难人的，一开始的时候也并没有这么复杂。我们入手呢，就要从作者一开始写出来的那样，能用出最基础的功能就好了。然后需求都是后来加上去的。有用户提，作者考虑做，或者作者自己想到的功能，才会在后面一步步添加上去。最终成为一个功能相对完善的软件。每个东西都有它的学习曲线，我们可能已经适应了平缓的山坡，突然面对一个陡峭的山峰之时，便不好应对了。但是千里之行，始于足下！我们始终要抓住它们最初的样子，或者说雏形，然后想一想它们是如何发展过来的，顺着这条线路走下去，自然觉得一切合情合理，也有勇气和信心去学了！然后当我们学会一个又一个软件之后，或许会发现它们可能有异曲同工之妙。那便是学到了！\nReference\n\nPolybar wiki\nPolybar example\nHow to get polybar icons working\nShow Us Your Polybar - Artwork / Polybar &amp; Tint2 Configs - ArchLabs Linux\n"},"Blogs/post/SICP-Learning-Notes":{"slug":"Blogs/post/SICP-Learning-Notes","filePath":"Blogs/post/SICP-Learning-Notes.md","title":"SICP Learning Notes","links":[],"tags":[],"content":"当我们考察一门语言时，主要看三点\n\nprimitives：元操作是什么\nmeans of combinations：如何组合\nmeans of abstraction：如何抽象，构造更复杂的程序\n\n数据和过程之间没有本质的区别\n在写完构造器（constrcutor）之后，记得写上选择器（selector）。\n+---------+       rule          +--------+\n| pattern +--------------------&gt;+skeleton|\n+----+----+                     +----+---+\n     |                               |\n     |                               |\n     |match                          |instantiation\n     |                               |\n     v                               v\n+----+-----+                    +----+-----+\n|expression|                    |expression|\n|  source  +-------------------&gt;+  target  |\n+----------+                    +----------+\n\npattern match\nfoo — matches exactly foo\n(f a b) — matches a list, whose first element is f, etc.\n(? x) — matches anything, call it x\n(?c x) — matches a constant, call it x\n(?v x) — matches a variable, call it x\nskeletons\nfoo — instantiates to itself\n(f a b) — instantiates to a 3-list, results of instatiating each of f, a, b\n(: x) — instatantiates to the value of x in the pattern matched\n任何一个复杂的大程序都是由简单的小部分组成。纵然递归模式非常复杂，最重要的事情就是：不去思考它。如果取思考它的实际行为，大家就会迷惑。\nConvince yourself something is right.\n好的编程或设计方法就是你知道什么不用去思考！\nWishful thinking is crucial!\nLisp没有循环，靠递归的procedure实现迭代，这并不表示procedure展开的process也是递归的。区分递归和迭代的核心是是否需要辅助空间跟踪程序运行的状态。\nCase analysis is more powerful than you thought! Trust me."},"Blogs/post/The-Beauty-of-Recursion":{"slug":"Blogs/post/The-Beauty-of-Recursion","filePath":"Blogs/post/The-Beauty-of-Recursion.md","title":"The Beauty of Recursion","links":[],"tags":["recursion","programming-thought"],"content":"Declaration: this article is in long time editing…\n\nHere comes some beautiful recursive solutions to some problems.\nExamples\nSome of the problems have a very nice recursive structure, we can deal with them just using one step recursion.\nFibonacci Numbers\nThe first comes very famous Fibonacci Numbers, which is a sequence of\n0, 1, 1, 2, 3, 5, 8, 13 …\nThe structure is easily captured, if we use \\text{fib}(n) to denote the n^{\\text{th}} Fibonacci Number (n is assumed to start from 0).\n\\text{fib}(n) = \\begin{cases}\nn, &amp;\\text{ if } n \\le 1 \\newline\n\\text{fib}(n-1) + \\text{fib}(n-2), &amp;\\text{ if } n &gt; 1.\n\\end{cases}\nThat is why we can write easily a procedure to compute the fibs. If we use MIT Scheme, we can write as follows:\n(define (fib n)\n    (if (&lt;= n 1)\n        n\n        (+ (fib (- n 1))\n           (fib (- n 2)))))\nor write a iterative version, since the above recursion has time complexity O(2^n),\n(define (fib n)\n    (define (fib-iter a b cnt)\n        (if (= cnt 0)\n            b\n            (fib-iter (+ a b) a (- cnt 1))))\n    (fib-iter 1 0 n))\nThis is called tail recursion in Lisp, it generates a iterative process so that in scheme it is iterative, though in many other languages it may belong to recursive thing. Following is a cpp version.\n// iterative fibonacci\nclass Solution {\npublic:\n    int fib(int n) {\n        return fib_iter(1, 0, n);\n    }\n \n    // tail recursion &lt;=&gt; iteration\n    // please refer to SICP Ch. 1.2.2\n    int fib_iter(int a, int b, int cnt) {\n        if (cnt == 0) return b;\n        else\n            return fib_iter(a+b, a, cnt-1);\n    }\n};\nJump Floor\nA frog is jumping, it can either jump one or two steps at a time. How many ways can he jump from 0 to nth floor? For instance, from 0 to 3, there are 3 ways:\n\n1,2 (first one, then it jumps two steps and reach 3)\n2,1 (first two, then it jumps one step and reach 3)\n1,1,1\n\nMake sure you catch the problem. It will indeed reduce to Fibonacci Numbers. Let’s see. Always try the First-Case Analysis. Denote \\text{opt}(n) to be the number of ways it jumps from 0 to n^{\\text{th}} floor. If we condition on the first step, then\n\nit jumps 1 at first time, then the remaining is the number of ways to jump from 0 to (n-1)^{\\text{th}} floor, which is \\text{opt}(n-1).\nit jumps 2 at first time, then the remaining \\text{opt}(n-2).\n\nHence we get the following:\n\\text{opt}(n) =\n\\begin{cases}\nn, &amp; n \\le 2 \\newline\n\\text{opt}(n-1) + \\text{opt}(n-2), &amp; n &gt; 2.\n\\end{cases}\nNote that the above is a Fibonacci sequence except the index shifting.\nclass Solution {\npublic:\n    // top-down fashion, recursive and O(2^n)\n    int jumpFloor(int n) {\n        if (n == 1) return 1;\n        if (n == 2) return 2;\n        return jumpFloor(n-1) + jumpFloor(n-2);\n    }\n \n    // iterative O(n)\n    int opt(int n) {\n        if (n &lt;= 2) return n;\n \n        // else\n        int a = 1, b = 2;\n        /* apply the transform n-2 times\n         * then `b` is fib(n)\n         *    a = b\n         *    b = a + b\n         */\n        for (; n &gt; 2; --n) {\n            b = a + b;\n            a = b - a; // `a` is the previous `b`\n        }\n        return b;\n    }\n};\nLinked-List Reverse\nYou are given a linked list, which is defined by a cxx struct or class. Can you output the reversed linked list?\n// Problem: Reverse a linked list.\n// A linked list can be reversed either iteratively\n// or recursively.\n// Could you implement both?\n \nclass ListNode {\npublic:\n    int val;\n    ListNode * next;\n    ListNode(int x) : val(x), next(nullptr) {}\n};\n \nclass Solution {\npublic:\n    // iterative\n    ListNode* reverseList(ListNode* head) {\n        // base case\n        if (!head || head -&gt; next == nullptr)\n            return head;\n \n        auto origin_head = head;\n        auto p = head -&gt; next;\n        while (p) {\n            // a copy for next iteration\n            auto newp = p -&gt; next;\n            p -&gt; next = head; // relink\n            head = p; // update head\n            p = newp; // ready for next iteration\n        }\n        // set origin head -&gt; next point to null\n        origin_head -&gt; next = nullptr;\n        return head;\n    }\n \n    // recursive\n    ListNode* ReverseList(ListNode* head) {\n        if (!head || head -&gt; next == nullptr)\n            return head;\n        \n        // suppose it can already do the job\n        auto p = ReverseList(head -&gt; next);\n        auto tmp = p;\n        // move tmp until reaching the end\n        while (tmp -&gt; next) {\n            tmp = tmp -&gt; next;\n        }\n        tmp -&gt; next = head; // relink\n        head -&gt; next = nullptr;\n        return p;\n    }\n};\nReverse Print\nYou are given a linked list, can you print it’s elements from end to begining?\n// Problem: print from the end to begining of\n// a given linked list.\n \n/*\n * 1. use stack\n * 2. use recursion\n */\n \n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;stack&gt;\n \nusing namespace std;\n \nclass ListNode {\npublic:\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(nullptr) {}\n};\n \nclass Solution {\n    vector&lt;int&gt; printListFromTailToHead(ListNode* head) {\n        vector&lt;int&gt; ret;\n        // boundary case\n        if (head == nullptr) return ret;\n \n        stack&lt;int&gt; s;\n        for (auto p = head; p != nullptr; p = p -&gt; next) {\n            s.push(p -&gt; val);\n        }\n \n        while (!s.empty()) {\n            ret.push_back(s.top());\n            s.pop();\n        }\n        return ret;\n    }\n \n    // recursive needs a member variable\n    // use recursion stack, tricky\n    vector&lt;int&gt; arr;\n    vector&lt;int&gt; reversePrint(ListNode* head) {\n        if (head) {\n            reversePrint(head -&gt; next);\n            arr.push_back(head -&gt; val);\n        }\n        return arr;\n    }\n    /*\n     * Consider the closure, at one recursive step,\n     * what I should do? Let&#039;s drop all the details,\n     * just look one recursive step.\n     * What had I done?\n     *     Oh gee, I see if the head is not null,\n     *     I must push the value to the vector,\n     *     but before this, I should take a look at\n     *     `head -&gt; next`, since I have to push\n     *     the tail first. So which one can help me\n     *     do this? Yes, the function itself! Then\n     *     after I have addressed the tail, now I&#039;m\n     *     going to push current value to the vector.\n     *     That&#039;s all I need!\n     * The key is you work in one recursive step, and\n     * form a closure for the next, and do not forget\n     * the base case (stopping rules). That how\n     * recursion runs! And you are free of those\n     * confusing details.\n     */\n};\nBinary representation\nCf. www.learncpp.com/cpp-tutorial/recursion/\nWrite a program that asks the user to enter a positive integer, and then uses a recursive function to print out the binary representation for that number.\n\nHint: Using method 1, we want to print the bits from the “bottom up”, which means in reverse order. This means your print statement should be after the recursive call.\n\n#include &lt;iostream&gt;\n \n// h/t to reader Gapo for this solution\nvoid printBinary(int x)\n{\n        // Termination case\n\tif (x == 0)\n\t\treturn;\n \n\t// Recurse to the next bit\n\tprintBinary(x / 2);\n \n\t// Print out the remainders (in reverse order)\n\tstd::cout &lt;&lt; x % 2;\n}\n \nint main()\n{\n\tint x;\n\tstd::cout &lt;&lt; &quot;Enter a positive integer: &quot;;\n\tstd::cin &gt;&gt; x;\n \n\tprintBinary(x);\n}\nUpdate your code to handle the case where the user may enter 0 or a negative number. Here’s a sample output (assuming 32-bit integers):\nEnter an integer: -15\n11111111111111111111111111110001\n\nHint: You can turn a negative integer into a positive one by converting it to an unsigned integer. These have identical bit representations (the type is used to determine how to interpret the number into decimal).\n// h/t to reader Donlod for this solution\n#include &lt;iostream&gt;\n \nvoid printBinary(unsigned int n)\n{\n\tif (n &gt; 1) // we only recurse if n &gt; 1, so this is our termination case for n == 0\n\t{\n\t\tprintBinary(n / 2);\n\t}\n \n\tstd::cout &lt;&lt; n % 2;\n}\n \nint main()\n{\n\tint x{};\n\tstd::cout &lt;&lt; &quot;Enter an integer: &quot;;\n\tstd::cin &gt;&gt; x;\n \n\tprintBinary(static_cast&lt;unsigned int&gt;(x));\n}\nConclusions\nWhat can we do use recursions? How shall we consider when wrting recursions? The most important thing, I think, is closure. You must have the experience that some day you were working with a recursive procedure, getting stuck in the conditions and inputs/outputs of the recursion, you came up with a mess when trying to understanding or simulating the process in your brain, and finally, you even did not know why it works, what happened inside it, how did it reach the boundary cases, etc.\nThe key is not to consider! Stop digging your pit and bury yourself. Leave all the details behind, all your focus is just one recursion step. You deal with each recursion step like a blackbox, with its inputs and outputs. Each time, you should form a closure. Specifically, you must formulate your outputs of the current recursion step so that it can fit to next recursion step as a input. And you are focusing to find the common pattern that each recursion step should do. That depends on situations, but you should have the ability to extract some common pattterns in some problems.\nDo not forget your base cases (or boundary cases, stopping rules). That’s the export of recursion. Once you have done in recursion steps, the next thing to consider is the base cases. Where can the procedure exit, how many cases will it reach. Usually these base cases are very hard to find, and can be very confusing. Be careful to deal with them.\nOnce you had completed the above, you are almost done! Now you are free of those confusing details. The key is sometimes you know what you have no need to consider."},"Blogs/post/Use-Reference-in-Beamer":{"slug":"Blogs/post/Use-Reference-in-Beamer","filePath":"Blogs/post/Use-Reference-in-Beamer.md","title":"在 Beamer 中使用参考文献","links":[],"tags":["latex","beamer","排版"],"content":"Needs polish!\n前略。\nBeamer 引用参考文献与文章类似，只是一开始听说 beamer 不支持 \\cite，搞得我走了不少弯路（其实是可以的）。\n\n使用 bibtex\n假设你有 mybeamer.tex 文件，在同目录下新建 mybeamer.bib 文件（其实只是纯文本，特殊后缀而已）。将你所有需要引用的文献条目写入该文献中。比如，\n% ./mybeamer.tex\n \n\\usepackage{cite}\n% Removes icon in bibliography\n\\setbeamertemplate{bibliography item}[text]\n...\n\\begin{document}\n...\n%%% end of your presentation slides\n\\begin{frame}[allowframebreaks]{References}\n\t%\\bibliographystyle{plain}\n\t\\bibliographystyle{amsalpha}\n\t%\\bibliography{mybeamer} also works\n\t\\bibliography{./mybeamer.bib}\n\\end{frame}\n\\end{document}\n\nNote: bib 文件可以不于 tex 文件同名，作相应改动即可。\n\n编译顺序（这很重要）\n首先用pdflatex或者xelatex编译你的 tex 文件mybeamer.tex，\npdflatex mybeamer.tex\n这样会在当前目录产生一个.aux文件。然后使用bibtex编译该文件，\nbibtex mybeamer\n然后再用pdflatex编译一遍。此时应该会出现应用错误，小问号等警告。此时再用pdflatex编译一遍即可。如果出现了其他错误，删掉所有 .bbl, .aux 文件，重复以上操作。\n总结一下四个步骤：\n\npdflatex mybeamer.tex\nbibtex mybeamer\npdflatex mybeamer.tex\npdflatex mybeamer.tex\n\nReferences\n\nLaTeX/Presentations\nLaTeX到底怎么加bib？？ - 知乎\n"},"Blogs/post/Vim命令速查":{"slug":"Blogs/post/Vim命令速查","filePath":"Blogs/post/Vim命令速查.md","title":"Vim Quick Reference","links":[],"tags":["vim","reference"],"content":"This article needs polish, do not truely trust it!\nVim is so-called the god of editors, but not so friendly to new users. Today we will cover some techniques and trick of vim, for further reference.\n\nGeneral Pattern\nA vim operation consists of three parts, namely\n[OPERATOR][NUMBER][MOTION]\n\nwhere\n\nOPERATOR - what you want to do? This mainly covers copy, cut, paste, etc.\nNUMBER - how many times do you want? It’s nothing but repeating the operation NUMBER times, and it’s optional.\nMOTION - where do you want to go? This point out the scope where the OPERATOR applies.\n\n\nNote: order does not matter sometimes.\n\nOperators\nCopy, Cut, Paste\n\nv - visual mode, now you can select what you want\nV - visual in line, this is extremely useful when you want to copy a line, just V+y!\ny - yank, like Ctrl+C, copy the selected text to clipboard (&quot;)\n\n\nyy: copy current line\n5yy: copy 5 lines below\ny+MOTION: copy the motion scope\n\ny0: copy from here to BOL (beginning of line)\ny$: copy from here to EOL\ny4G: copy from here to line 4\ny?bar: copy from here to previous occurrence of bar\n\n\n\n\n\nd - delete &amp; yank, not only delete, but also yank\np - paste after the cursor\nP - paste before the cursor\n\nEdit\n\ni - insert\na - insert after the cursor\no - insert a line below and insert\nO - insert a line above and insert\nr - replace, replace the character inplace\nx - delete current character\ns - delete the character and insert\nu - recall the last command\n^r - recall the last recall, namely redo\n. - repeat the last command\n\n\nNote: all deleted things were automatically yanked in buffers, i.e., register &quot;\n\nMotions\nBasic\n\nh - move left\nl - move right\nj - move down\nk - move up\n\nNote: view (h, l) and (j, k) as pairs\n\n\nG - jump to EOF (end of file)\ngg - jump to BOF\nx + (gg | G) - jump to line x (must be a valid line number)\n\nSome additional movements:\n\nw - next word, points to the first letter\nb - back, previous word, points to the first letter\ne - end, jump to the end of the word\n\n\n% - find the bracket matches (( ),{ }, [ ]…)\n\n\n^e - scroll down\n^y - scroll up\n^d - half-screen down\n^u - half-screen up\n\n\n* - jump to next occurrence of current word\n# - jump to previous occurrence of current word\n\n\nNote: view (w, b) as a pair\n\nInline movement\n\n^: jump to the first character which is not a blank (space, tab, \\n, \\r)\ng_: jump to the last character which isn’t a blank\n\n\n0: jump to the beginning\n$: jump to the end\n\n\nfx: find next x in current line\n\nNote: you can use ;(alongside) and ,(reverse side) to repeat this in two directions\n\n\nFx: find previous x in current line\n\nNote: same rules can be applied\n\n\n\ntx: find next x and move 1 backward\nTx: find previous x and move 1 backward\n\n\n\nCommands\nSearch &amp; Replace\n\n/keyword - search keyword after the cursor\n?keyword - search\tkeyword before the cursor\n\nNote: use n(search next) or N(search previous) for quick search\n\n\n:{search_scope}s/{target}/{replace}/{replace_flag} - replace {target} to {replace}\n\n\ns stands for substitute.\n:%s/a/b/g: global (%) search a, replace it to b at every (g) occurrence\n:%s/a/b/gc: interact with every replace\n\n\n\n\nMore detail\nIt has a general pattern:\n:[range]s/from/to/[flags]\n\nThe default range is current line. See some examples:\n\n:1,10s/from/to - search and replace between line 1 and 10 (included)\n:10s/from/to/ - search and replace only in line 10\n:%s/from/to/ - in global scope\n\nflags can be\n\ng: replace all matches in whole line w/o confirmation\nc: confirm before replace\ni: ignore lower/upper case\ne: ignore error\n\nNote that flags can be combined together, e.g., :%s/from/to/gc means search and replace in global and ask for confirmation before each replacement.\nUse regular expression\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMeta characterExplanation.Matches any character[abc]Matches any char from the list[^abc]Matches any char except from the list\\dMatches numers == [0-9]\\DOpposite to above == [^0-9]\\xMatches hex numbers == [0-9A-Fa-f]\\XOpposite to above == [^0-9A-Fa-f]\\lMatches lower case letters == [a-z]\\Lopposite to above == [^a-z]\\uMatches upper case letters == [A-Z]\\UOpposite to above == [^A-Z]\\wMatches alphanumeric chars == [0-9A-Za-z_]\\WOpposite to above == [^0-9A-Za-z_]\\tMatches &lt;TAB&gt;\\sMatches space == [\\t]\\SOpposite to above\nSpecial characters need to be escaped. Some of them are .[]\\*/, if you want to match some of them, put the backslash &quot;&quot; ahead. For example: * -&gt; \\*.\nThere are also some special form to express how much do you expect to match the specific pattern.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMeta charExplanation*match &gt;= 0 times\\+match &gt;= 1 times\\?match 0 or 1 time\\{n,m}match n⇐x⇐m times\\{n}match n times\\{n,}match &gt;= n times\\{,m}match ⇐ m times\nAlso, some postional characters.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMeta charExplanation$end of line^beginning of line\\&lt;beginning of word\\&gt;end of word\nSome examples:\n\nremove the spaces of eol: %s/\\s+$//g\nremove spaces of bol: %s/^\\s*// or %s/^ *//\ndelete empty line: %s/^$// or g/^$/d\ndelete lines with &lt;space&gt; or &lt;tab&gt; as beginning: %s/^[ |\\t]*$// or g/^[ |\\t]*$/d\n\nNote that pattern in regex scoped by \\(&lt;pattern&gt;\\) can be refered as \\1, \\2, etc. in the latter statement. For example, I want to replace every “abc…xyz” to “xyz…abc”, just write like this\n%s/\\(abc\\)\\(.*\\)\\(xyz\\)/\\3\\2\\1/g\n\n\nAdvanced Tricks\nAuto Complete\nIn insert mode, press ^p, vim will give you a list of all words you have typed, kind of auto complete.\n\nMarkers\n\n:marks - list of marks\nmk - mark current position (can use a-z)\n\nalso known as :mark k\n\n\n&#039;k - move to mark k\nd&#039;k - delete from current position to mark k\n&#039;a-z - same file\n&#039;A-Z - between files\n\n\nA straight tick &#039; refers to the line, use a backtick ` to also include the column, see [here][foo].\n\nIt seems that the marker . will mark the last edit position, so if you open your last edited file again, `. will take you to that position!\nBlock Editing\nOne of the magic of vim is block editing. Just press ^V to enter block mode. Then select some block you are interested, then make some modifications. Finally press Esc, then those modifications you have just made will be applied onto every line of the block.\nSee this magic:\n\n^ jump to BOL\n^V enter block mode\n4j move 4 lines down\nI enter insert mode and add something\nEsc to see the effect\n\n\nAdditionally, you can\n\n^v/v/V enter visual mode\nJ joint them into one line\n&lt; or &gt; modify indents\n= auto indent (extremely powerful?)\n\n\nor\n\n^v enter block mode\nselect some line\n$ jump to EOL\nA append something\nEsc see the effect\n\n\nMacro Recording\nPress qx, where x is the macro name, will enter macro recording mode, all actions will be recorded, just like a tape recorder. If you don’t want to record anymore, press q to stop recording.\nTo replay the record, press @x. Moreover, @@ will replay the last recorded macro.\nSummarization:\nqa - record macro a\nq - stop recording macro\n@a - run macro a\n@@ - rerun last run macro\nClipboard\nVim provides 12 clipboards (registers): 0, 1, 2 .. 9, a, &quot;. If your vim support system clipboard, there will be two additional register: + and *. Use :reg to see what are in your registers.\nFor X11 systems, things selected or highlighted will be saved in register *, while things yanked or cutted will be saved in register +.\n\nTo see whether your vim support system clipboard, type $ vim --version\n\nIn general, all your copy and paste operations are performed at register &quot; by default. To use other register, add a prefix &quot;6 to your yank or paste commands. For example:\n&quot;6p\t\t&quot; put the buffer in register 6 to file\n&quot;8yy\t\t&quot; yank current line to register 8\n:put {reg}\t&quot; put things in {reg} to file, &lt;=&gt; &quot;{reg}p\nMulti-file\n\n:e &lt;file&gt; - edit &lt;file&gt; in new buffer\nbnext - go to the next buffer\nbprev - go previous\nbd - delete a buffer (close a file)\nls - list all open buffers\n\nMulti-window\n\n:sp &lt;file&gt; - split horizontally and open &lt;file&gt;\n:vsp - split vertically and open filename optionally, same file by default\n^w + h/j/k/l - focus left/down/up/right window\n:close - close current window (buffer &amp; file)\n\nMulti-tab\n\ntabnew &lt;file&gt; - open &lt;file&gt; in new tab, empty file by default\ngt or :tabnext - move to the next tab\ngT or :tabprev - move to previous\n&lt;num&gt;gt - move to tab number &lt;num&gt;\n:tabclose - close the current tab (windows &amp; files)\n:tabonly - close all tabs except for the current one\n:tabdo &lt;cmd&gt; - apply the &lt;cmd&gt; to all tabs\n\ntabdo q will close all tabs\n\n\n\nSpell Check\n\n:set spell - toggle on spell checker\n:set nospell - toggle off spell checker\n]s - move to next mistake\n[s - move tp previous mistake\nz= - choose an alternative\nzg - add to userdict\nzw - remove from userdict\n\nReference\n\nVim操作\n在 Vim 中优雅地查找和替换\n简明 Vim 练级攻略\nVim Cheat Sheet\nVim cheatsheet\nVim查找替换及正则表达式的使用\n"},"Blogs/post/archlinx-keyring-broken":{"slug":"Blogs/post/archlinx-keyring-broken","filePath":"Blogs/post/archlinx-keyring-broken.md","title":"Archlinx重置keyring","links":["Blogs/post/mailto:santiago@archlinux.org.html"],"tags":[],"content":"今天pacman安装一个软件包的时候，突然提示XX作者的GPG key不受信任，网上一查1，原来是GPG存的key需要更新信息了。由于\npacman-key --refresh-keys\n执行过程漫长，我新开了一个窗口直接pacman -Syu了。果不其然，看起来一切都好了。然后回头发现还在更新keyring，心想：我都完活了，你还没执行完，遂直接杀了进程。\n\n一切看起来相安无事，但当我下次执行pacman相关指令的时候，会频繁报错，keyring有问题，然后我再想像之前那样刷新的时候呢，gpg报了一大堆看不懂的错误。这下糟了，看起来我是把所有key都弄坏了。于是一不做二不休，直接重置算了。\n重置过程参考此处，摘要如下\nrm -rf /etc/pacman.d/gnupg\npacman-key --init\npacman-key --populate\npacman -Syu\nReferences\n\nGnuPG-2.1 与 pacman 密钥环\n\nFootnotes\n\n\nArchlinux 长时间未更新报错：containerd: 来自 “Santiago Torres-Arias santiago@archlinux.org” 的签名是未知信任的 ↩\n\n\n"},"Blogs/post/bit-field-struct":{"slug":"Blogs/post/bit-field-struct","filePath":"Blogs/post/bit-field-struct.md","title":"位域结构体简介","links":[],"tags":["cpp","结构体","位运算"],"content":"最近实习接触到一个新的知识点，C/C++的位域结构体。\n以下开始摘抄自：here\n位段(bit-field)是以位为单位来定义结构体(或联合体)中的成员变量所占的空间。含有位段的结构体(联合体)称为位段结构。采用位段结构既能够节省空间，又方便于操作。\n位段的定义格式为:\ntype [var]: digits\n\n其中type只能为int，unsigned int，signed int三种类型(int型能不能表示负数视编译器而定，比如VC中int就默认是signed int，能够表示负数)。位段名称var是可选参数，即可以省略。digits表示该位段所占的二进制位数。\n举个例子，你可以这样定义一个位域结构体：\n// sizeof(A): 4\nstruct A\n{\n  uint32_t a: 12;\n  uint32_t b: 10;\n  uint32_t c: 10;\n};\n \n// sizeof(B): 12\nstruct B\n{\n  uint32_t a;\n  uint32_t b;\n  uint32_t c;\n};\nuint32_t实际上是unsigned int的别名，并且指定了用4个字节存储int类型的数据，而 1byte = 8bits, 4个字节共计32bits，结构体A使用了位域的方式，指定了每个成员所占用的bit数。可以看到，A中三个成员总共占用的比特数为32，也就是4个字节。所以结构体A所占用的空间就是4字节，而B没有使用位域，则3个成员各占4个字节，共计12字节。说白了，位域就是将结构体的成员在比特位上编排的更紧凑，更节省空间。\n以下开启一段摘抄：\n关于位域结构体有以下几点说明：(以下“位段就是位域”，c.f. ref1)\n\n位段的类型只能是int，unsigned int，signed int三种类型，不能是char型或者浮点型；\n位段占的二进制位数不能超过该基本类型所能表示的最大位数，比如在VC中int是占4个字节，那么最多只能是32位；\n无名位段不能被访问，但是会占据空间；\n不能对位段进行取地址操作；\n若位段占的二进制位数为0，则这个位段必须是无名位段，下一个位段从下一个位段存储单元(这里的位段存储单元经测试在VC环境下是4个字节)开始存放；\n若位段出现在表达式中，则会自动进行整型升级，自动转换为int型或者unsigned int。\n对位段赋值时，最好不要超过位段所能表示的最大范围，否则可能会造成意想不到的结果。\n位段不能出现数组的形式。\n\n对于位段结构，编译器会自动进行存储空间的优化，主要有这几条原则:\n\n如果一个位段存储单元能够存储得下位段结构中的所有成员，那么位段结构中的所有成员只能放在一个位段存储单元中，不能放在两个位段存储单元中；如果一个位段存储单元不能容纳下位段结构中的所有成员，那么从剩余的位段从下一个位段存储单元开始存放。(在VC中位段存储单元的大小是4字节).\n如果一个位段结构中只有一个占有0位的无名位段，则只占1或0字节的空间(C语言中是占0字节，而C++中占1字节)；否则其他任何情况下，一个位段结构所占的空间至少是一个位段存储单元的大小；\n\n#include &lt;iostream&gt;\n \nusing namespace std;\n \n// sizeof(A): 4\nstruct A {\n  uint32_t a: 4;\n  uint32_t b: 3;\n  uint32_t c: 1;\n};\n \n// sizeof(B): 12\nstruct B {\n  uint32_t a;\n  uint32_t b;\n  uint32_t c;\n};\n \n// sizeof(C): 8\nstruct C {\n  uint32_t a: 1;\n  uint32_t : 0;\n  uint32_t c: 2;  // 不会和a凑在一起，新开一个字节存\n};\n \n// sizeof(D): 12\nstruct D {\n  uint32_t a: 1;\n  uint32_t: 0;    // 隔断\n  uint32_t: 6;    // 开启新的位域存储单元\n  uint32_t d: 32; // 前一个位域不够放，开启新的存放单元\n};\n \n// sizeof(E): 4\n// 内存分布简图\n// 0000 0000 0000 0000\n// a--- b--- cd-------\nstruct E {\n  uint32_t a: 1;\n  char b;        // 隔断\n  uint32_t c: 1; // 在下一个存储单元\n  uint32_t d: 15; // 四个成员刚好占用32bits，即4个字节\n};\n \ntemplate &lt;typename T&gt;\nvoid Print(const T&amp;)\n{\n  std::cout &lt;&lt; sizeof(T) &lt;&lt; std::endl;\n}\n \n// test\nint main()\n{\n  A a;\n  B b;\n  C c;\n  D d;\n  E e;\n  Print(a); // 4\n  Print(b); // 12\n  Print(c); // 8\n  Print(d); // 12\n  Print(e); // 4\n  return 0;\n}\n以下测试用法：\n#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n \nusing namespace std;\n \n// sizeof: 4\nstruct TcpMsgHead {\n  uint32_t length: 16;\n  uint32_t flags: 8;\n  int      num: 8;\n};\n \nvoid Print(const TcpMsgHead&amp; msg)\n{\n  printf(&quot;length: %8d\\n&quot;, msg.length);\n  printf(&quot;flags:  %8d\\n&quot;, msg.flags);\n  printf(&quot;num:    %8d\\n&quot;, msg.num);\n}\n \n// test\nint main()\n{\n  TcpMsgHead head;\n  head.length = 0xffff; // 2^16 - 1 = 65535\n  head.flags = 0xff;    // 2^8 - 1 = 255\n  head.num = 0xff;\n  Print(head);\n  return 0;\n}\n上述程序的输出为：\nlength:    65535\nflags:       255\nnum:          -1\n\n解释一下为什么num成员的值为-1：\n首先num设置的比特位为8，而num的类型为int，是有符号的。对于有符号的整数，计算机内部使用补码表示的。\n0xff 换成二进制\n1111 1111\n这正好是-1的补码。\n其实，Ycm给出的提示已经很明确了：\n\nYcm提示这里发生了隐式截断。255被截断成了-1. 如果换成 0x11 也就是二进制的 0001 0001, 则不会发生截断，因为8比特足够描述0x11，符号位是0，表示正数，所以这很符合我们的预期。但是如果再加一个2呢？\n\n可以看到Ycm提示发生截断，\n529被截断成了17, 即\n0010 0001 0001 被截断成了 0001 0001\n也就是说，我结构体定义的时候已经确定了num只有8比特位可以存。高于8比特的数据全都截断。如果最高位是1，则会被转成负数，这可能和你的预期不符。所以一定不要设置超过容量的数据。\nReference\n\n浅谈C语言中的位段\n"},"Blogs/post/blog-trans":{"slug":"Blogs/post/blog-trans","filePath":"Blogs/post/blog-trans.md","title":"博客迁移记录","links":[],"tags":["字体","美化","个性化"],"content":"终于还是干了！很早以前就有了这个想法，起初使用Hexo搭的博客，折腾了一段时间，选了一个不错的主题Melody。一切都进行的很好，直到有一天又发现Hugo这么个东西，登时就忍不住了，不是说原来的不好，二十Hugo太特么快了，无论是渲染速度还是博客生成，几乎就像是在本地打开html一样。相比之下Hexo的生成速度就显得很慢了，思来想去，博客应该更多关注内容，之前那个配置的有些花哨了，现在换了Hugo，也使用了一个比较简单的主题，相比之下更轻量，打开速度更快，以后就该专注于内容了。这里烧纸纪念下一下我之前的皮肤：\n\n如你所见，还可以在 guyueshui.github.io/blog_archive 访问它，但以后的更新还是主要在现在这个博客上。\n这里简单记录一下迁移过程中遇到的一些问题。\nFrontmatter 不匹配\nHexo博文的frontmatter格式如下\n---\ntitle: GDB 基本用法\ndate: 2019-08-18 16:14:24\ncategories: Techniques \ntags:\n- debug\n- linux\n- gdb\n- c++\n---\n而Hugo博文的frontmatter如下\n---\ntitle: GDB 基本用法\ndate: 2019-08-18 16:14:24\ncategories: [tech]\ntags: [&#039;debug&#039;, &#039;linux&#039;, &#039;gdb&#039;, &#039;c++&#039;]\n---\n还好我的文章不算多，一个个改吧！\n时间格式\nHexo的时间格式很简单：2006-01-02 15:04. 但是Hugo的时间格式就比较麻烦了。默认模板archetypes/defalut.md中定义的frontmatter如下：\n---\ntitle: &quot;{{ replace .Name &quot;-&quot; &quot; &quot; | title }}&quot;\ndate: {{ .Date }}\n---\n先不管title，默认的.Date变量生成出来的时间格式是这样的：2006-01-02T15:04:59-0700, 看着怪难受的。我想让它变得简单直观一些，于是改成如下格式：\n---\ntitle: &quot;{{ replace .Name &quot;-&quot; &quot; &quot; | title }}&quot;\ndate: {{ dateFormat &quot;Mon Jan 2 2006&quot; .Date }}\nlastmod: {{ .Date }}\n---\n使用dataFormat函数将输出格式转换成喜欢的格式，所有支持的格式参见Hugo文档1。这里我将它转换成“Mon Jan 2 2006”这种格式，但是它丢失了时间信息，所以我加了一个lastmod表示最后更改日期，而且没有做格式转换。\n\n注意：貌似是Go语言的原因，Go语言所有的时间计算都是有一个基准的，这个基准时间就是：2006-01-02 15:04:05 0700, 所有日期的格式设置都要根据这个时间来设，否则就会计算出错误的时间。至于为什么？可能是因为它比较好记：1月2日3点4分5秒6年7时区。开个玩笑:)\n\n公式渲染\n这个我是真的头大，这是先前阻止我转Hugo的唯一理由。Hexo那边有专门的插件解决这个事情，而且可以配置markdown解析规则，因此比较完美的解析出公式段并正确渲染。但Hugo貌似就要自己动手了，之前也在网上找了很多解决方案，要么是主题自带，要么是手动添加mathjax支持到head里面。这样所有的页面都会加载mathjax，但是还是避免不了解析错误的问题：比如在markdown里面_可以表示斜体的开头，但在LaTeX里面表示下标。诸如此类的字符冲突还有很多，如果不能自定义markdown的解析规则，那么就会导致有些公式无法正常渲染。另外我也试过KaTeX+mmark的方案，未果。\n到目前为止，我还是没有找到满意的解决方案。现在用的是even主题自带的mathjax，所以可能还是会有一些公式无法正常渲染(ﾟДﾟ≡ﾟдﾟ)!?\n自定义字体\n有了之前在Melody主题自定字体的经验，这次修改字体没有太费什么功夫。主要将主题的font-family改一下，以及将对应的字体放到网站中去。\n//! file: themes/even/src/css/_variables.scss\n// Font family of the site.\n$global-font-family: Linux Libertine O, &#039;Source Sans Pro&#039;, &#039;Helvetica Neue&#039;, Arial, sans-serif !default;\n \n// Serif font family of the site.\n$global-serif-font-family: Linux Biolinum O, Athelas, STHeiti, Microsoft Yahei, serif !default;\nEven主题还是比较好的，将serif和sans分成了两族，这应该是很自然的。之前Melody里面只能设置全局，一换所有字体都换了，也可能是我不会换orz. 可以看到这里可以自定义字体族，我只是在前面加了两个而已，\n\nserif：Linux Libertine O\nsans: Linux Biolinum O\n\n这两个字体我十分推荐，源于SICP的排版字体，非常耐看！Sans用于标题等粗文本，serif用于排版正文。关于字体名字的获得：\n$ fc-list | grep Linux\n/home/yychi/.local/share/fonts/Libertine/LinLibertine_RBI.otf: Linux Libertine O:style=Bold Italic\n/home/yychi/.local/share/fonts/Libertine/LinLibertine_DR.otf: Linux Libertine Display O:style=Regular\n/home/yychi/.local/share/fonts/Libertine/LinLibertine_RI.otf: Linux Libertine O:style=Italic\n/home/yychi/.local/share/fonts/Libertine/LinBiolinum_R.otf: Linux Biolinum O:style=Regular\n/home/yychi/.local/share/fonts/Monaco_Linux.ttf: Monaco:style=Regular\n然后将字体文件复制到博客根目录的static/fonts/Libertine文件夹，这样hugo生成网站的时候就会把字体文件一并获得。最后在_variables.scss或_custom.scss中设置一下字体目录就行了。\n@font-face {\n  font-family: Linux Libertine O;\n  src: url(&quot;/fonts/Libertine/LinLibertine_DR.otf&quot;);\n}\n \n@font-face {\n  font-family: Linux Biolinum O;\n  src: url(&quot;/fonts/Libertine/LinBiolinum_R.otf&quot;);\n}\n另外可以使用Google Font API直接使用字体而不用下载字体文件\n因为中文字体文件一般比较大，而且放在Github上加载很慢，所以如果有线上字体可以用，自然优先考虑。之前我只换了英文字体，中文还保留着黑体。于是乎中文sans西文serif放在一起非常不协调。最后还是折腾一下，把中文字体也给换了。\n具体方法很简单，找到主题定义字体的地方：\n//! file: themes/even/src/css/_variables.scss\n// Font family of the site.\n$global-font-family: &#039;Linux Libertine O&#039;, &#039;Noto Serif SC&#039;, &#039;Source Sans Pro&#039;, &#039;Helvetica Neue&#039;, Arial, sans-serif !default;\n这里我将西文优先选择Linux Libertine O字体，而中文则使用Noto Serif SC字体。\n\n注意：这里的在线字体必须是存在于Google Fonts里面的字体。\n\n然后就是在网页上添加一个表单2：\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;link rel=&quot;stylesheet&quot;\n          href=&quot;fonts.googleapis.com/css\n    &lt;style&gt;\n      body {\n        font-family: &#039;Tangerine&#039;, serif;\n        font-size: 48px;\n      }\n    &lt;/style&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div&gt;Making the Web Beautiful!&lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n由于主题的head.html在每个网页都会调用，所以我将表单直接添加到该文件中：\n&lt;!-- file: even/layouts/partials/head.html --&gt;\n{{ range .Site.Params.customCSS -}}\n&lt;link rel=&quot;stylesheet&quot; href=&quot;{{ &quot;/css/&quot; | relURL }}{{ . }}&quot;&gt;\n{{ end }}\n \n&lt;!-- Insert style sheet here --&gt;\n&lt;link rel=&quot;stylesheet&quot;\n          href=&quot;fonts.googleapis.com/css+Serif+SC&quot;&gt;\n这样一来，网站就会加载来自Google Font API的线上字体，如下图：\n\n图片和表格居中\n因为Even主题默认是居左的，所以这里改为居中3。\n//! file: themes/even/src/css/_partial/_post/_content.scss\n \n// 图片居中\nimg {\n  display: inline-block;\n  max-width: 100%;\n  /* make img centerd @yychi */\n  height: auto;\n  padding: 0.6em 0;\n  position: relative;\n  left: 50%;\n  -webkit-transform: translateX(-50%); // for Safari and iOS\n  -ms-transform: translateX(-50%); // for IE9\n  transform: translateX(-50%);\n}\n \n// 表格居中\n.table-wrapper {\n  overflow-x: auto;\n \n  &gt; table {\n    max-width: 100%;\n    margin: 0 auto; // make table centered @yychi\n    border-spacing: 0;\n    box-shadow: 2px 2px 3px rgba(0,0,0,.125);\n \n    thead {\n      background: $deputy-color;\n    }\n \n    th, td {\n      padding: 5px 15px;\n      border: 1px double $content-table-border-color;\n    }\n \n    tr:hover {\n      background-color: $deputy-color;\n    }\n  }\n}\n部署\nHugo的部署，没有Hexo那样一步到位，每次都要手动操作。以至于一开始载了很多跟头。按照Hugo中文文档中的方法试了不行（好像坊间流传Hugo的文档写的不行），于是去翻英文文档。对照着做，其实还好，没那么困难。就是一开始走了点弯路，因为我的blog仓库并不是空的，之前的Hexo生成的网站还在。所以走流程的时候出了一些问题，各种文件冲突。后来干脆将Hexo page部署到另一个仓库，将blog仓库清空。然后按照流程走，终于走完了。\n其实还有一个问题，一开始我Hugo设置了输出markdown源文件，Hugo会把它放到生成博文的同目录下，原本只有一个index.html, 现在多了一个index.md. 我想这很好啊，不用另外开一个仓库保存原始的md文件了，但是部署上去，github报错，说生成的md文件里有语法错误，网站构建失败。没办法，现在不想折腾了，就在Hugo中把这个选项关了。\n部署过程参考文档即可：Host on Github. 我还是大致翻译一下吧：\n\n在你的Github上新建一个仓库，假设叫blog. 这个仓库将用来存放Hugo工程文件，也就是你本地的Hugo site根目录。\n在你的Github上创建仓库&lt;username&gt;.github.io，其中&lt;username&gt;为你的Github账户名，这个仓库将用来存放Hugo生成的整个网站。如果你已经有这个仓库了，清空之。\ngit clone git@github.com:&lt;username&gt;/blog.git &amp;&amp; cd blog\n将你的本地Hugo文件夹复制到blog中去，确保你的网站可以在本地正常运作（使用hugo server或hugo --config &lt;your-config&gt;.toml server）然后访问localhost:1313\n如果你觉得网站已经符合你的预期了：\n\n\n按下Ctrl+C终止本地服务\nrm -rf public删除整个public文件夹，不用担心，你总可以使用hugo --config &lt;your-config&gt;.toml来生成它\n\n\n将&lt;username&gt;.github.io添加为本仓库的submodule, 这样一来public文件夹下的内容就会推送到&lt;username&gt;.github.io这个仓库。使用如下命令来完成：git submodule add -b master git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git public\n使用hugo --config &lt;your-config&gt;.toml来生成你的网站，生成的文件将在public文件夹下\n进入public文件夹，使用git完成推送\n\n\n注意：此前需要在你的Hugo配置文件中更改相应的baseURL. 例如，更改为baseURL = &quot;https://&lt;username&gt;.github.io&quot;\n\n近日，又发现一个比较好的迁移指引4，文章十分翔实。\nFootnotes\n\n\n.Format | Hugo ↩\n\n\nGet Started with the Google Fonts API ↩\n\n\nHugo 建站记录 ↩\n\n\nHugo 与 Hexo 的异同 ↩\n\n\n"},"Blogs/post/build-your-ladder":{"slug":"Blogs/post/build-your-ladder","filePath":"Blogs/post/build-your-ladder.md","title":"V3Ray的配置笔记","links":[],"tags":[],"content":"学生时代曾为整个课题组的师生搭建过一个梯子，稳定运行两年多，最近突然爬不上去了。\n寻思是哪里出了问题，经过一番定位，原来是之前的免费域名到期了。遂于昨晚开启修补\n之旅，无奈运气不太好，每一环节都出了问题，最终搞到凌晨3点才重新爬上了梯子。\n想来主要是之前对照的教程遗失，整个流程又有很多细节，难免忘记，遂记此篇。（顺便\n吐槽如今网上教程已经不胜枚举，但优质的教程却少有输出。以至于想要弄清楚某个事情\n的来龙去脉，就必须博采众家所长，取其精华，弃其糟粕。有没有一个教程站出来拍拍\n胸脯说：少年，你只要看我就够了Orz！当然，此篇仅是个笔记，不为服务他人，只为提醒\n自己。）\nV2Ray是一个较为先进的网络工具，他的用途很多，但大多数人用它来搞建筑。原理就是\n你有一台可访问外网的机器A，你与该机器可以通信，在A中运行一个v2ray（充当服务端），\n在终端设备运行一个v2ray（充当客户端），然后两方配制能对得上，就可以将你访问外网\n的流量转发给机器A，由A发出该请求，收到回复后还是通过A转发回给终端机。这就完成了\n一次外网访问。\nv2ray的难点在于配置文件1的编写，不过好在现在有很多辅助你生成配置文件的工具。\n咱当初可是辛辛苦苦对着文档敲的，不贴上来太可惜了：\n/// config_server.json\n{\n  &quot;log&quot;: {\n    &quot;access&quot;: &quot;/var/log/v2ray/access.log&quot;,\n    &quot;error&quot;: &quot;/var/log/v2ray/error.log&quot;,\n    &quot;loglevel&quot;: &quot;warning&quot;\n  },\n  &quot;dns&quot;: {},\n  &quot;stats&quot;: {},\n  &quot;inbounds&quot;: [\n    {\n      &quot;port&quot;: 443,\n      &quot;protocol&quot;: &quot;vmess&quot;,\n      &quot;settings&quot;: {\n        &quot;clients&quot;: [\n          {\n            &quot;id&quot;: &quot;your_uuid&quot;,\n            &quot;alterId&quot;: 32\n          }\n        ]\n      },\n      &quot;tag&quot;: &quot;in-0&quot;,\n      &quot;streamSettings&quot;: {\n        &quot;network&quot;: &quot;ws&quot;,\n        &quot;security&quot;: &quot;tls&quot;,\n        &quot;wsSettings&quot;: {\n          &quot;path&quot;: &quot;/somepath&quot;,\n          &quot;headers&quot;: {\n            &quot;host&quot;: &quot;somehost.com&quot;\n          }\n        },\n        &quot;tlsSettings&quot;: {\n          &quot;certificates&quot;: [\n            {\n              &quot;certificateFile&quot;: &quot;/etc/v2ray/v2ray.crt&quot;,\n              &quot;keyFile&quot;: &quot;/etc/v2ray/v2ray.key&quot;\n            }\n          ]\n        }\n      }\n    }\n  ],\n  &quot;outbounds&quot;: [\n    {\n      &quot;tag&quot;: &quot;direct&quot;,\n      &quot;protocol&quot;: &quot;freedom&quot;,\n      &quot;settings&quot;: {}\n    },\n    {\n      &quot;tag&quot;: &quot;blocked&quot;,\n      &quot;protocol&quot;: &quot;blackhole&quot;,\n      &quot;settings&quot;: {}\n    }\n  ],\n  &quot;routing&quot;: {\n    &quot;domainStrategy&quot;: &quot;AsIs&quot;,\n    &quot;rules&quot;: [\n      {\n        &quot;type&quot;: &quot;field&quot;,\n        &quot;ip&quot;: [\n          &quot;geoip:private&quot;\n        ],\n        &quot;outboundTag&quot;: &quot;blocked&quot;\n      }\n    ]\n  },\n  &quot;policy&quot;: {},\n  &quot;reverse&quot;: {},\n  &quot;transport&quot;: {}\n}\n/// config_client.json\n{\n  &quot;log&quot;:{},\n  &quot;dns&quot;:{},\n  &quot;stats&quot;:{},\n  &quot;inbounds&quot;:[\n    {\n      &quot;port&quot;:&quot;1080&quot;,\n      &quot;protocol&quot;:&quot;socks&quot;,\n      &quot;settings&quot;:{\n        &quot;auth&quot;:&quot;noauth&quot;,\n        &quot;udp&quot;:true\n      },\n      &quot;tag&quot;:&quot;in-0&quot;\n    },\n    {\n      &quot;port&quot;:&quot;8080&quot;,\n      &quot;protocol&quot;:&quot;http&quot;,\n      &quot;settings&quot;:{},\n      &quot;tag&quot;:&quot;in-1&quot;\n    }\n  ],\n  &quot;outbounds&quot;:[\n    {\n      &quot;protocol&quot;:&quot;vmess&quot;,\n      &quot;settings&quot;:{\n        &quot;vnext&quot;:[\n          {\n            &quot;address&quot;:&quot;your_host_address&quot;,\n            &quot;port&quot;:443,\n            &quot;users&quot;:[\n              {\n                &quot;id&quot;:&quot;your_uuid&quot;,\n                &quot;alterId&quot;:32\n              }\n            ]\n          }\n        ]\n      },\n      &quot;tag&quot;:&quot;out-0&quot;,\n      &quot;streamSettings&quot;:{\n        &quot;network&quot;:&quot;ws&quot;,\n        &quot;security&quot;:&quot;tls&quot;,\n        &quot;wsSettings&quot;:{\n          &quot;path&quot;:&quot;/somepath&quot;,\n          &quot;headers&quot;: {\n            &quot;host&quot;: &quot;somehost.com&quot;\n          }\n        },\n        &quot;tlsSettings&quot;:{\n          &quot;allowInsecure&quot;: true\n        }\n      }\n    },\n    {\n      &quot;tag&quot;:&quot;direct&quot;,\n      &quot;protocol&quot;:&quot;freedom&quot;,\n      &quot;settings&quot;:{}\n    },\n    {\n      &quot;tag&quot;:&quot;blocked&quot;,\n      &quot;protocol&quot;:&quot;blackhole&quot;,\n      &quot;settings&quot;:{}\n    }\n  ],\n  &quot;routing&quot;:{\n    &quot;domainStrategy&quot;:&quot;IPOnDemand&quot;,\n    &quot;rules&quot;:[\n      {\n        &quot;type&quot;:&quot;field&quot;,\n        &quot;ip&quot;:[\n          &quot;geoip:private&quot;\n        ],\n        &quot;outboundTag&quot;:&quot;direct&quot;\n      },\n      {\n        &quot;type&quot;:&quot;field&quot;,\n        &quot;ip&quot;:[\n          &quot;geoip:cn&quot;\n        ],\n        &quot;inboundTag&quot;:[\n          &quot;in-0&quot;,\n          &quot;in-1&quot;\n        ],\n        &quot;outboundTag&quot;:&quot;direct&quot;\n      }\n    ]\n  },\n  &quot;policy&quot;:{},\n  &quot;reverse&quot;:{},\n  &quot;transport&quot;:{}\n}\n仔细看看server的配置，其实用到了WS+TLS的方式，这样的配置隐蔽性较好，不容易被封。\n但这种配置的成本也相对较高，首先得弄个域名和机器A的ip绑定。即通过ping somehost.com能够翻译成机器A的ip。\n注册域名\n上免费域名注册站：my.freenom.com/domains.php ，\n\n随便敲一个域名，检查是否可用，注册成功后如下图所示：\n\n\n\n此处需要为域名配置解析服务器，可以用腾讯云域名解析服务，下图中点击“添加域名”，配置成功后会得到两个域名解析服务器地址，将这两个地址填入上图的Nameserver1和Nameserver2中即可。\n\n至此，一个域名到ip的绑定关系就配置完成，可以ping一下试试：\nme@~&gt; ping somehost.com\nPING somehost.com (xxx.yyy.zzz.aaa) 56(84) 字节的数据。\n64 字节，来自 xx.com (xxx.yyy.zzz.aaa): icmp_seq=1 ttl=52 时间=193 毫秒\n--- somehost.com ping 统计 ---\n已发送 4 个包， 已接收 4 个包, 0% packet loss, time 3003ms\nrtt min/avg/max/mdev = 159.025/202.023/239.194/29.721 ms\n其中，somehost.com为之前申请的域名，xxx.yyy.zzz.aaa为机器A的ip。\n证书生成\n此段摘抄自guide.v2fly.org/advanced/tls.html#证书生成\nTLS 是证书认证机制，所以使用 TLS 需要证书，证书也有免费付费的，同样的这里使用免费证书，证书认证机构为Let’s Encrypt。 证书的生成有许多方法，这里使用的是比较简单的方法：使用acme.sh脚本生成，本部分说明部分内容参考于acme.sh README。\n证书有两种，一种是 ECC 证书（内置公钥是 ECDSA 公钥），一种是 RSA 证书（内置 RSA 公钥）。简单来说，同等长度 ECC 比 RSA 更安全,也就是说在具有同样安全性的情况下，ECC 的密钥长度比 RSA 短得多（加密解密会更快）。但问题是 ECC 的兼容性会差一些，Android 4.x 以下和 Windows XP 不支持。只要您的设备不是非常老的老古董，建议使用 ECC 证书。\n以下只给出 ECC 证书的部分。\n证书生成只需在服务器上操作。\n安装 acme.sh\n执行以下命令，acme.sh 会安装到 ~/.acme.sh 目录下。\n$ curl  get.acme.sh | sh\n% Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                               Dload  Upload   Total   Spent    Left  Speed\n100   671  100   671    0     0    680      0 --:--:-- --:--:-- --:--:--   679\n% Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                               Dload  Upload   Total   Spent    Left  Speed\n100  112k  100  112k    0     0   690k      0 --:--:-- --:--:-- --:--:--  693k\n[Fri 30 Dec 01:03:32 GMT 2016] Installing from online archive.\n[Fri 30 Dec 01:03:32 GMT 2016] Downloading github.com/Neilpang/acme.sh/archive/master.tar.gz\n[Fri 30 Dec 01:03:33 GMT 2016] Extracting master.tar.gz\n[Fri 30 Dec 01:03:33 GMT 2016] Installing to /home/user/.acme.sh\n[Fri 30 Dec 01:03:33 GMT 2016] Installed to /home/user/.acme.sh/acme.sh\n[Fri 30 Dec 01:03:33 GMT 2016] Installing alias to &#039;/home/user/.profile&#039;\n[Fri 30 Dec 01:03:33 GMT 2016] OK, Close and reopen your terminal to start using acme.sh\n[Fri 30 Dec 01:03:33 GMT 2016] Installing cron job\nno crontab for user\nno crontab for user\n[Fri 30 Dec 01:03:33 GMT 2016] Good, bash is found, so change the shebang to use bash as preferred.\n[Fri 30 Dec 01:03:33 GMT 2016] OK\n[Fri 30 Dec 01:03:33 GMT 2016] Install success!\n如果安装报错，那么可能是因为系统缺少 acme.sh 所需要的依赖项，acme.sh 的依赖项主要是 socat，我们通过以下命令来安装这些依赖项，然后重新安装一遍 acme.sh:\n$ sudo apt-get install openssl cron socat curl\n使用 acme.sh 生成证书\n证书生成\n执行以下命令生成证书：\n以下的命令会临时监听 80 端口，请确保执行该命令前 80 端口没有使用\n$ ~/.acme.sh/acme.sh --issue -d mydomain.me --standalone --keylength ec-256 --force\n[Fri Dec 30 08:59:12 HKT 2016] Standalone mode.\n[Fri Dec 30 08:59:12 HKT 2016] Single domain=&#039;mydomain.me&#039;\n[Fri Dec 30 08:59:12 HKT 2016] Getting domain auth token for each domain\n[Fri Dec 30 08:59:12 HKT 2016] Getting webroot for domain=&#039;mydomain.me&#039;\n[Fri Dec 30 08:59:12 HKT 2016] _w=&#039;no&#039;\n[Fri Dec 30 08:59:12 HKT 2016] Getting new-authz for domain=&#039;mydomain.me&#039;\n[Fri Dec 30 08:59:14 HKT 2016] The new-authz request is ok.\n[Fri Dec 30 08:59:14 HKT 2016] mydomain.me is already verified, skip.\n[Fri Dec 30 08:59:14 HKT 2016] mydomain.me is already verified, skip http-01.\n[Fri Dec 30 08:59:14 HKT 2016] mydomain.me is already verified, skip http-01.\n[Fri Dec 30 08:59:14 HKT 2016] Verify finished, start to sign.\n[Fri Dec 30 08:59:16 HKT 2016] Cert success.\n-----BEGIN CERTIFICATE-----\nMIIEMTCCAxmgAwIBAgISA1+gJF5zwUDjNX/6Xzz5fo3lMA0GCSqGSIb3DQEBCwUA\nMEoxCzAJBgNVBAYTAlVTMRYwFAYDVQQKEw1MZXQncyBFbmNyeXB0MSMwIQYDVQQD\nExpMZXQncyBFbmNyeXB0IEF1dGhvcml0eSBYMzAeFw0xNjEyMjkyMzU5MDBaFw0x\nNzAzMjkyMzU5MDBaMBcxFTATBgNVBAMTDHdlYWtzYW5kLmNvbTBZMBMGByqGSM49\n****************************************************************\n4p40tm0aMB837XQ9jeAXvXulhVH/7/wWZ8/vkUUvuHSCYHagENiq/3DYj4a85Iw9\n+6u1r7atYHJ2VwqSamiyTGDQuhc5wdXIQxY/YQQqkAmn5tLsTZnnOavc4plANT40\nzweiG8vcIvMVnnkM0TSz8G1yzv1nOkruN3ozQkLMu6YS7lk/ENBN7DBtYVSmJeU2\nVAXE+zgRaP7JFOqK6DrOwhyE2LSgae83Wq/XgXxjfIo1Zmn2UmlE0sbdNKBasnf9\ngPUI45eltrjcv8FCSTOUcT7PWCa3\n-----END CERTIFICATE-----\n[Fri Dec 30 08:59:16 HKT 2016] Your cert is in  /root/.acme.sh/mydomain.me_ecc/mydomain.me.cer\n[Fri Dec 30 08:59:16 HKT 2016] Your cert key is in  /root/.acme.sh/mydomain.me_ecc/mydomain.me.key\n[Fri Dec 30 08:59:16 HKT 2016] The intermediate CA cert is in  /root/.acme.sh/mydomain.me_ecc/ca.cer\n[Fri Dec 30 08:59:16 HKT 2016] And the full chain certs is there:  /root/.acme.sh/mydomain.me_ecc/fullchain.cer\n--keylength 表示密钥长度，后面的值可以是 ec-256 、ec-384、2048、3072、4096、8192，带有 ec 表示生成的是 ECC 证书，没有则是 RSA 证书。在安全性上 256 位的 ECC 证书等同于 3072 位的 RSA 证书。\n证书更新\n由于 Let’s Encrypt 的证书有效期只有 3 个月，因此需要 90 天至少要更新一次证书，acme.sh 脚本会每 60 天自动更新证书。也可以手动更新。\n手动更新证书，执行：\n$ ~/.acme.sh/acme.sh --renew -d mydomain.com --force --ecc\n由于本例中将证书生成到 /etc/v2ray/ 文件夹，更新证书之后还得把新证书生成到 /etc/v2ray。\n安装证书和密钥\n将证书和密钥安装到 /etc/v2ray 中：\n$ sudo ~/.acme.sh/acme.sh --installcert -d mydomain.me --ecc \\\n                          --fullchain-file /etc/v2ray/v2ray.crt \\\n                          --key-file /etc/v2ray/v2ray.key\n注意：无论什么情况，密钥(即上面的 v2ray.key)都不能泄漏，如果你不幸泄漏了密钥，可以使用 acme.sh 将原证书吊销，再生成新的证书，吊销方法请自行参考acme.sh 的手册\n摘抄完毕。\n启动\n在机器A上执行\n$ /usr/bin/v2ray/v2ray\nV2Ray 4.44.0 (V2Fly, a community-driven edition of V2Ray.) Custom (go1.17.3 linux/amd64)\nA unified platform for anti-censorship.\n2021/12/11 00:22:25 Using config from env:  /usr/bin/v2ray/config.json\n2021/12/11 00:22:25 [Info] main/jsonem: Reading config: /usr/bin/v2ray/config.json\n2021/12/11 00:22:26 [Warning] V2Ray 4.44.0 started\n但是这样会占用终端，虽然可以让它后台运行，但始终不优雅。我们可以将v2ray做成一项system service.\n编写服务单元文件2:\n# file:///etc/systemd/system/v2ray.service\n[Unit]\nDescription=V2Ray Service\nAfter=network.target\nWants=network.target\n \n[Service]\n# This service runs as root. You may consider to run it as another user for security concerns.\n# By uncommenting the following two lines, this service will run as user v2ray/v2ray.\n# More discussion at github.com/v2ray/v2ray-core/issues/1011\n# User=v2ray\n# Group=v2ray\nType=simple\nPIDFile=/run/v2ray.pid\nEnvironment=V2RAY_LOCATION_ASSET=/etc/v2ray\nExecStart=/usr/bin/v2ray/v2ray -config /etc/v2ray/config.json\nRestart=on-failure\n# Don&#039;t restart in the case of configuration error\nRestartPreventExitStatus=23\n \n[Install]\nWantedBy=multi-user.target\n这样一来可以使用systemctl来管理其启动和关闭，使用\nsystemctl start v2ray   # 启动\nsystemctl restart v2ray # 重新启动\nsystemclt stop v2ray    # 停止\nsystemctl enable/disable v2ray  # 设置是否开机启动\nsystemctl status v2ray  # 查看服务运行情况\n暂时写到这里，客户端连接，以及服务器安装等，网上教程较多，不再赘述。因原教程被ban，故摘录部分，有条件的推荐去看原教程，十分详细！\nReferences\n\n新 V2Ray 白话文指南\n\nFootnotes\n\n\nV2Ray配置文档 ↩\n\n\n如何编写一个Systemd Service ↩\n\n\n"},"Blogs/post/coding-problems":{"slug":"Blogs/post/coding-problems","filePath":"Blogs/post/coding-problems.md","title":"A collection of some coding problems","links":["求职/算法题/场景题.html","求职/算法题/模式匹配.html","求职/算法题/树相关.html","求职/算法题/栈和队列.html"],"tags":["算法","动态规划","编程"],"content":"场景题\n场景题\n题三：进制转换\n\n2019哈罗单车实习生笔试题\n\n将一个10进制整数转换成36进制的数，可以用0-9A-Z表示0-35.\n/** \n *  Hellobike 2019 interview.\n */\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n \nusing namespace std;\n \nclass Solution {\npublic:\n    string itob36(int n) {\n        int r = 0; // remainder of n mod 36\n        string tmp;\n        // iteratively divde by 36 to get each digit\n        while (n) {\n            r = n % 36;\n            tmp += MAP[r];\n            n /= 36;\n        }\n        // reverse tmp to ret\n        string ret;\n        cout &lt;&lt; &quot;tmp is &quot; &lt;&lt; tmp &lt;&lt; endl;\n        for (auto iter = tmp.rbegin(); iter != tmp.rend(); ++iter)\n            ret.push_back(*iter);\n        return ret;\n    }\nprivate:\n    string MAP[36] = {&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;,     \\\n                      &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;A&quot;, &quot;B&quot;,     \\\n                      &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;,     \\\n                      &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, &quot;N&quot;,     \\\n                      &quot;O&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;,     \\\n                      &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;};\n};\n \n// test\nint main() {\n  int number = 12345;\n  cout &lt;&lt; Solution().itob36(number);\n  return 0;\n}\n题五：输出数组的全排列\n给定一个数组，求其全排列。\n\nIdea: pick one element as prefix, then add to the permutations of the rest n-1 elems.\nReference: www.cnblogs.com/ranjiewen/p/8059336.html\n\n#include &lt;iostream&gt;\n#include &lt;iterator&gt;\n#include &lt;algorithm&gt;\n \nvoid Permute(int arr[], int beg, int end)\n{\n  if (beg == end)\n  {\n    std::copy(arr, arr + end, std::ostream_iterator&lt;int&gt;(std::cout));\n    std::cout &lt;&lt; std::endl;\n  }\n \n  for (int i = beg; i != end; ++i)\n  {\n    std::swap(arr[i], arr[beg]);\n    Permute(arr, beg + 1, end);\n    std::swap(arr[i], arr[beg]);\n  } \n}\n \nint main()\n{\n  int arr[] = {0,1,2,3,4,5,6,7,8,9};\n  Permute(arr, 0, 5);\n  return 0;\n}\n题六：斜线填充\n给定n x m的矩阵，按照从右上往左下的斜线填充 1 到 n*m 的值。\n例如，对于一个3x3的矩阵,\n1 2 4\n3 5 7\n6 8 9 (3x3)\n\n1  2  4  7\n3  5  8 10\n6  9 11 12  (3x4)\n\n\n思路：干就完了。先填充左上角的三角区域，再填充右下角的三角区域。注意边界条件，无论行或列到达边界，记得跳转。\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n \nusing namespace std;\n \nclass Solution {\npublic:\n    Solution(int n, int m)\n    {\n        // fill with 0\n        for (int i = 0; i != n; ++i)\n            mat.push_back(vector&lt;int&gt;(m, 0));\n    }\n \n    void skewFill(int n, int m)\n    {\n        int cnt = 1;\n        // fill the up-left triangle\n        for (auto col = 0; col != m; ++col)\n        {\n            for (auto i = 0, j = col; i != n &amp;&amp; j &gt;= 0; ++i)\n                mat[i][j--] = cnt++;\n        }\n        // fill the bottom-right triangle\n        for (auto row = 1; row != n; ++row)\n        {\n            for (auto j = m-1, i = row; i != n &amp;&amp; j &gt;= 0; ++i)\n                mat[i][j--] = cnt++;\n        }\n    }\n \n    /// print the matrix\n    void printer()\n    {\n        for (auto &amp;row : mat)\n        {\n            for (auto &amp;col : row)\n                printf(&quot;%3d &quot;, col);\n            cout &lt;&lt; endl;\n        }\n    }\n \nprivate:\n    vector&lt;vector&lt;int&gt;&gt; mat;\n};\n \n// test\nint main()\n{\n    int n = 0, m = 0;\n    cin &gt;&gt; n &gt;&gt; m;\n    Solution s(n, m);\n    s.skewFill(n, m);\n    s.printer();\n    return 0;\n}\n题七：螺旋矩阵\n按顺时针填充螺旋填充矩阵。例如：\n9 8 7\n2 1 6\n3 4 5 (3x3)\n\n12 11 10 9\n 3  2  1 8\n 4  5  6 7 (3x4)\n\n\nIdea: Imagine there are for borders that surround the matrix. We walk through the mat, and once achieve a border, we change the direction. Each time we finished a circle, we will shrink our border, and start next circle. After we fill (row * col) elems in the matrix, we are done!\nNote: this solution is the most elegant in my opinion, for it’s simple boundray case.\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n \nusing std::vector;\n \nclass Solution\n{\npublic:\n  Solution(int rows, int cols)\n    : mat_(rows, vector&lt;int&gt;(cols, 0))\n  {\n  }\n \n  void BuildMat()\n  {\n    // 4 border\n    int top = 0;\n    int bot = mat_.size() - 1;\n    int left = 0;\n    int right = mat_[0].size() - 1;\n \n    int N = (bot + 1) * (right + 1);\n    for (int i = 0, j = 0; N != 0; --N)\n    {\n      // make sure fill exactly one element at each loop\n      mat_[i][j] = N;\n \n      if (i == top)\n      {\n        if (j &lt; right) ++j;       // go right\n        else if (j == right) ++i; // checkpoint\n      }\n      else if (j == right)\n      {\n        if (i &lt; bot) ++i;         // go down\n        else if (i == bot) --j;\n      }\n      else if (i == bot)\n      {\n        if (j &gt; left) --j;        // go left\n        else if (j == left) --i;\n      }\n      else if (j == left)\n      {\n        if (i &gt; top + 1) --i;     // go up\n        else if (i == top + 1)\n        {\n          ++j;\n          // shrink borders\n          ++top, --bot, ++left, --right;\n        }\n      }\n      else\n      {\n        throw std::runtime_error(&quot;not behaved expectedly&quot;);\n      }\n    }\n  }\n \n  void Print()\n  {\n    for (auto &amp;r : mat_)\n    {\n      for (auto &amp;c : r)\n        printf(&quot;%2d &quot;, c);\n      std::cout &lt;&lt; std::endl;\n    }\n  }\n \nprivate:\n  vector&lt;vector&lt;int&gt; &gt; mat_;\n};\n \n// test\nint main()\n{\n  Solution so(3, 4);\n  so.BuildMat();\n  so.Print();\n  return 0;\n}\n模式匹配\n扔骰子的期望\n\n拼多多2019校招正式批\n\n扔n个骰子，第i个骰子有可能掷出X_i种等概率的不同结果，数字从1到X_i. 比如X_i = 2, 就等可能的出现1点或2点。所有骰子的结果的最大值将作为最终结果。求最终结果的期望。\n输入描述：\n第一行一个整数n，表示n个骰子。（1 ⇐ n ⇐ 50）\n第二行n个整数，表示每个骰子的结果数X_i. (2 \\le X_i \\le 50)\n输出描述：\n输出最终结果的期望，保留两位小数。\n示例输入：\n2\n2 2\n\n示例输出：\n1.75\n\n\n主要考察事件概率的计算。\n\n假设有3个骰子，最大点数分别为2,3,4点。那么扔n个骰子，最终结果为1的概率如下\nP(1) = \\frac{1}{2\\times 3 \\times 4} = \\frac{1}{24}\n同理，最终结果为2, 也就是说三个骰子中最大的点数为2, 考虑每个骰子都点数都小于或等于2的概率，再减去每个骰子都小于或等于1的概率，即为\n\\begin{gathered}\nP(2) = \\frac{2\\times 2\\times 2}{2 \\times 3 \\times 4} - \\frac{1}{2\\times 3 \\times 4} = \\frac{7}{24} \\newline\nP(3) = \\frac{2 \\times 3 \\times 3}{2 \\times 3 \\times 4} - \\frac{2\\times 2\\times 2}{2 \\times 3 \\times 4} = \\frac{10}{24} \\newline\nP(4) = \\frac{2 \\times 3 \\times 4}{2 \\times 3 \\times 4} - \\frac{2\\times 3\\times 3}{2 \\times 3 \\times 4} = \\frac{6}{24}\n\\end{gathered}\n这就求得了最终结果的所有可能的值对应的概率，可以看出相加为1, 现在可以求期望了。\n\n注意，当要求的点数大于当前骰子的最大点数时，那么该骰子掷出小于该点数的概率为1. 比如让一个最大点数为2的骰子掷出小于3的点数，显然概率为1.\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n \nusing namespace std;\n \nvector&lt;double&gt; Distribution(const vector&lt;int&gt;&amp; die_ranges, int support)\n{\n  vector&lt;double&gt; probs;\n  for (int i = 1; i &lt;= support; ++i)\n  {\n    double pprob = 1.0; // for previous prob\n    double prob = 1.0;  // for current prob\n    for (auto e : die_ranges)\n    {\n      pprob *= min(double(i-1) / double(e), 1.0);\n      prob *= min(double(i) / double(e), 1.0);\n    }\n    probs.push_back(prob - pprob);\n  }\n  return probs;\n}\n \nint main()\n{\n  int num_die;\n  cin &gt;&gt; num_die;\n \n  int maxpoint = 0;\n  vector&lt;int&gt; die_ranges;\n  for (int i = 0, tmp; i != num_die; ++i)\n  {\n    cin &gt;&gt; tmp;\n    if (tmp &gt; maxpoint)\n      maxpoint = tmp;\n    die_ranges.push_back(tmp);\n  }\n  // io done\n  vector&lt;double&gt; probs = Distribution(die_ranges, maxpoint);\n  \n  double expectation = 0.0;\n  for (int i = 1; i &lt;= maxpoint; ++i)\n  {\n    expectation += (probs[i-1] * i);\n  }\n  printf(&quot;%.2f&quot;, expectation);\n \n  return 0;\n}\n树相关\n数据结构相关\n大部分出自《剑指Offer》\n栈和队列\n反向打印链表\n给定一个单链表，反向打印每个节点的值。\n/*\n * 1. use stack\n * 2. use recursion\n */\n \n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;stack&gt;\n \nusing namespace std;\n \nclass ListNode {\npublic:\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(nullptr) {}\n};\n \nclass Solution {\n    vector&lt;int&gt; printListFromTailToHead(ListNode* head) {\n        vector&lt;int&gt; ret;\n        // boundary case\n        if (head == nullptr) return ret;\n \n        stack&lt;int&gt; s;\n        for (auto p = head; p != nullptr; p = p -&gt; next) {\n            s.push(p -&gt; val);\n        }\n \n        while (!s.empty()) {\n            ret.push_back(s.top());\n            s.pop();\n        }\n        return ret;\n    }\n \n    // recursive needs a member variable\n    // use recursion stack, tricky\n    vector&lt;int&gt; arr;\n    vector&lt;int&gt; reversePrint(ListNode* head) {\n        if (head) {\n            reversePrint(head -&gt; next);\n            arr.push_back(head -&gt; val);\n        }\n        return arr;\n    }\n    /*\n     * Consider the closure, at one recursive step,\n     * what I should do? Let&#039;s drop all the details,\n     * just look one recursive step.\n     * What had I done?\n     *     Oh gee, I see if the head is not null,\n     *     I must push the value to the vector,\n     *     but before this, I should take a look at\n     *     `head -&gt; next`, since I have to push\n     *     the tail first. So which one can help me\n     *     do this? Yes, the function itself! Then\n     *     after I have addressed the tail, now I&#039;m\n     *     going to push current value to the vector.\n     *     That&#039;s all I need!\n     * The key is you work in one recursive step, and\n     * form a closure for the next, and do not forget\n     * the base case (stopping rules). That how\n     * recursion runs! And you are free of those\n     * confusing details.\n     */\n};\n栈和队列\n模式匹配\n求整数的二进制表示中“1”的个数\n输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。\n/*\n * `n` and `n-1` are the same from high bit position\n * to low, they differs from the last bit of 1 of n,\n * let&#039;s name it x. Have a look from x to the lowest \n * bit position,\n * n:   010101000\n * &amp;         x      &lt;--- position x\n * n-1: 010100111\n * ---------------\n *      010100000   &lt;--- n&amp;(n-1)\n * It erases the last bit of 1 in n!!!\n *\n * This is why the following procedure will work. :)\n */\n \n#include &lt;iostream&gt;\n \nint NumOf1(int n) {\n    int cnt = 0;\n    while (n) {\n        n = n &amp; (n-1);\n        ++cnt;\n    }\n    return cnt;\n}\n \nint main() {\n    int N = 0;\n    std::cin &gt;&gt; N;\n    std::cout &lt;&lt; NumOf1(N);\n    return 0;\n}\n不可描述\n求出113的整数中1出现的次数,并算出1001300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有\n1、10、11、12、13\n因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。\n/*\n * Credits: unknown\n *\n * Idea:\n *   1) Focus exactly one decimal position, calculate the\n *      number of ones.\n *   2) Run out from lowest to highest position, add them\n *      together, it&#039;s the answer.\n *\n *  Imaging the numbers from 1 to n sits in a line in\n *  front of you. Now you&#039;re required to calculates all\n *  the ones in the sequence. A basic way is that, each\n *  time I focus on the same digit pos, and count all\n *  ones in that pos. Next time I focus on another pos.\n *  And I sum them all together, finally got the answer.\n *\n *  See how can we count the num of ones in a specific\n *  decimal pos? Let&#039;s do that! Suppose N = 301563. \n *\n *  Step 1.\n *  Now I focus the hundred position, and split N into `a`\n *  and `b`, where\n *\n *  a = ceil(N / 100) = 3015\n *  b = N % 100 = 63\n *\n *  1). There are (a / 10 + 1) = 302 hits of one\n *  2). Each of length 100\n *  3). Totally (a/10 + 1) * 100 hits of one\n *\n *  Let me explain a little:\n *  (000-301)5(00-99) -&gt; (000-301)1(00-99)\n *  \n *  The digits above hundred pos have 302 variants, and\n *  the digits under hundred pos has 100 variants, thus\n *  gives a total (a/10 + 1) * 100.\n *\n *  Step 2.\n *  This time I focus on thousand pos, and now\n *\n *  a = N / 1,000 = 301\n *  b = N % 1,000 = 563\n *\n *  1). There are (a/10) = 30 hits of one\n *  2). Each of length 1000\n *  3). And a tail hits of 564\n *\n *  (00-29)1(000-999) + 301(000-563)\n *  This gives 30 * 1000 + 564 = (a/10)*1000+(b+1)\n *\n *  Step 3.\n *  Now move to ten thousand pos, with\n *\n *  a = N / 10,000 = 30\n *  b = N % 10,000 = 1563\n *\n *  1). There are total (a/10)=3 hit\n *  2). Each of length 10,000\n *\n *  (0-2)1(0000-9999)\n *  gives 3 * 10,000 = (a/10).\n *\n *  That&#039;s all 3 cases. Let&#039;s write!\n */\n \nclass Solution {\npublic:\n    int NumOnes(int n) {\n        int ones = 0;\n        for (long long m = 1; m &lt;= n; m *= 10) {\n            ones +=\n                /*\n                 * this covers case 1 &amp; 3\n                 * since (a+8)/10 = a/10 + 1 if a%10 &gt;= 2\n                 * (a+8)/10 = a/10 if a%10 == 0\n                 */\n                (n/m + 8) / 10 * m\n                +\n                // case 2\n                (n/m % 10 == 1) * (n%m + 1);\n        }\n        return ones;\n    }\n};\nK轮换\n原题：leetcode.com/problems/rotate-array/\nGiven an array, rotate the array to the right by k steps, where k is non-negative.\nExample 1:\nInput: [1,2,3,4,5,6,7] and k = 3\nOutput: [5,6,7,1,2,3,4]\nExplanation:\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]\n\nExample 2:\nInput: [-1,-100,3,99] and k = 2\nOutput: [3,99,-1,-100]\nExplanation: \nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]\n\nNote:\n\nTry to come up as many solutions as you can, there are at least 3 different ways to solve this problem.\nCould you do it in-place with O(1) extra space?\n\n\n提供三种方法：第一种，效率最低，因为vector从头插入元素开销很大；第二种，花费额外的空间，来降低时间开销；第三种，挺好的，std::reverse用的是首尾交换元素，无额外空间开销。\n\nclass Solution {\npublic:\n    void rotate(vector&lt;int&gt;&amp; nums, int k) {\n#if false   // method 1.\n        if (k == 0) return;\n        nums.insert(nums.begin(), nums.back());\n        nums.pop_back();\n        rotate(nums, k-1);\n#elif false  // method 2.\n        vector&lt;int&gt; dummy(nums);\n        for (int i = 0; i != dummy.size(); ++i)\n        {\n            nums[(i+k) % nums.size()] = dummy[i];\n        }\n#elif true  // method 3.\n        k %= nums.size();\n        std::reverse(nums.begin(), nums.end());\n        std::reverse(nums.begin(), nums.begin() + k);\n        std::reverse(nums.begin() + k, nums.end());\n#endif\n    }\n};\nMove zeros\n原题：leetcode.com/problems/move-zeroes/\nGiven an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.\nExample:\nInput: [0,1,0,3,12]\nOutput: [1,3,12,0,0]\n\nNote:\n\nYou must do this in-place without making a copy of the array.\nMinimize the total number of operations.\n\n\n思路：记录数字0出现的个数count。如果当前数字是0，给count加一；如果不是0，将这个值往前挪count位。最后将最后count个元素置0.\n\nclass Solution {\npublic:\n    void moveZeroes(vector&lt;int&gt;&amp; nums) {\n        if (nums.size() &lt; 2) return;\n        \n        // c.f. leetcode.com/explore/interview/card/top-interview-questions-easy/92/array/727/\n        int numzeros = 0;\n        for (int i = 0; i != nums.size(); ++i)\n        {\n            if (nums[i] == 0)\n                ++numzeros;\n            else\n                nums[i-numzeros] = nums[i];\n        }\n        // set the tails to 0\n        while (numzeros)\n        {\n            nums[nums.size() - numzeros] = 0;\n            --numzeros;\n        }\n    }\n};\nKth Largest Element in an Array\nFrom: LeetCode125.\nFind the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.\nExample 1:\nInput: [3,2,1,5,6,4] and k = 2\nOutput: 5\n\nExample 2:\nInput: [3,2,3,1,2,4,5,5,6] and k = 4\nOutput: 4\n\nNote: You may assume k is always valid, 1 ≤ k ≤ array’s length.\n\n思路：利用快排的partition思想，每次选取一个pivot，将数组分为小于pivot和大于pivot的两部分。此时pivot的index就是排好序之后的index，与k相比，如果出较小，则在后半部分（大于pivot）再次划分，如果较大，则在前半部分划分。直到划分出来的pivot的index等于k。还要注意的是，这样找出来的是第k小，用数组长度减一下，才是第k大，注意index的变换。\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n \nclass Solution {\npublic:\n  int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {\n    // from 王小康：快排partition知道吧？\n    // 就一刀一刀地劈开，劈一次你知道pivot的index，\n    // 如果比k小，继续在右边劈，如果比k大，就在左边劈！\n    \n    if (nums.empty()) throw std::invalid_argument(&quot;empty arr&quot;);\n    if (nums.size() == 1) return nums.front();\n    // else @nums has &gt;= 2 elems\n    int mid = Partition(nums, 0, nums.size());\n    k = nums.size() - k; // kth large = len+1-k small\n    while (mid != k)\n    {\n        if (mid &lt; k)\n            mid = Partition(nums, mid + 1, nums.size());\n        else\n            mid = Partition(nums, 0, mid);\n    }\n    return nums[mid];\n  }\n  \n  size_t Partition(vector&lt;int&gt;&amp; arr, size_t beg, size_t end)\n  {\n    size_t pivot = beg;\n    size_t i = pivot + 1;\n    for (auto j = pivot + 1; j &lt; end; ++j)\n    {\n      if (arr[j] &lt; arr[pivot])\n      {\n        std::swap(arr[j], arr[i]);\n        ++i;\n      }\n    }\n    std::swap(arr[i-1], arr[pivot]);\n    return i - 1;\n  }\n};\n \nint main()\n{\n  vector&lt;int&gt; nums = {3,2,1,5,6,4};\n  Solution so;\n  cout &lt;&lt; so.findKthLargest(nums, 2);\n  return 0;\n}\n最大连续子列\nFrom: LeetCode53.\nGiven an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\nExample:\nInput: [-2,1,-3,4,-1,2,1,-5,4],\nOutput: 6\nExplanation: [4,-1,2,1] has the largest sum = 6.\n\n\n设置两个变量，一个记录当前连加的值，另一个记录目前位置最大连续子序列，迭代更新。\n\nint MaxSubArray(const vector&lt;int&gt;&amp; arr)\n{\n  int max_so_far = INT_MIN;\n  int sum = 0;\n  for (int e : arr)\n  {\n    if (sum &gt; 0)\n      sum += e;\n    else\n      sum = e;\n \n    max_so_far = max(max_so_far, sum);\n  }\n  return max_so_far;\n}"},"Blogs/post/concurrent-programming":{"slug":"Blogs/post/concurrent-programming","filePath":"Blogs/post/concurrent-programming.md","title":"多线程学习笔记","links":[],"tags":["多线程","并发"],"content":"开一篇多线程学习笔记，记录下在实习过程中遇到的一些简单问题。\n\n注意：这是一篇以学习笔记，难免有误，主要写给自己参考。请酌情判别，如有错误，也欢迎指正！\n\n互斥\n互斥的本质就是等待！\n互斥的特性\n\n无死锁\n无饥饿\n等待\n\n并发系统中存在两种类型的通信：\n\n瞬时通信：要求通信双方在同一时刻都参与通信。\n持续通信：允许发送者和接收者在不同时间参与通信。\n\n互斥需要的是持续通信。并发系统中常用的一种通信协议：中断。现在操作系统中，一个线程要引起另一个线程注意的常用方法就是发送中断信号。更准确的说，线程A通过设置一个位向线程B发出一个中断信号，线程B周期地检查这个位。一旦B检测到该位置被设置，则做出相应的响应。响应结束后，通常由B进行复位（A不能复位）。虽然中断不能解决互斥问题。但它仍是非常有用的。例如，Java中的wait()调用和notifyall()调用的本质就是中断。\n编写多线程需要注意的点\n\n在脑中先大致想好每个线程的工作是什么，什么时候开始，什么时候结束。\n捋清楚了之后再开始动手写。\n\n调用t.join()的作用类似于，如果线程结束，主线程执行到join就可以立即返回，如果线程为结束，主线程执行到join会阻塞，直到线程结束。然后主线程继续执行。\n            main  thread1\n              +      +\n              |      |\n              |      |\n              |      |\n              |      |\nthread1.join()+------+\n              |\n              |\n              |\n              v\n\n如果某线程申请占有互斥量时，该互斥量被其他线程占有，则会引起该线程阻塞。\n一般来说线程安全性很难保证，但只有两种操作可以保证线程安全性，\n\n基本的原子操作\nCAS（compare and swap) 操作\n\n使用std::conditional_variable注意事项\n\n调用wait的线程必须占有mutex，否则undefined\n所有并发线程（如果使用同一个条件变量交互）必须使用同一个mutex，否则undefined\n\n使用std::thread注意事项\n\nthread对象构造完成即开始执行\n使用detach之后，程序失去该线程的控制权，线程结束之后资源全部释放\n使用detach之后，主线程结束时，所有资源都被释放，即便该线程还未停止\n线程之间没有父/子关系。如果线程A创建线程B，然后线程A终止，则线程B将继续执行。但如果主线程终止，则整个进程终止，自然进程下的所有线程都终止，资源释放\nAny thread can potentially access any object in the program (objects with automatic and thread-local storage duration may still be accessed by another thread through a pointer or by reference).\n\n使用std::atomic注意事项\n\natomic is neither copyable nor movable\nmutex is neither copyable nor movable\n\n加一次锁耗时大概25ns，使用lock-free的话能够提高到十几纳秒，事实上提升不大。加锁并没有想象中那么耗时，提高效率的关键是减少锁的碰撞。即一个线程占有锁的时候，其他线程不会去申请锁，因为在锁被占用的情况下去申请锁比较耗时，会先去loop一段时间，拿不到锁才会进入内核陷入睡眠等待锁，这样的耗时是比较浪费的。所以关键要减少锁的碰撞。\n有原子的函数吗，就是要么执行成功，要么失败？\n不存在，一个函数内部多少指令，在多线程的情况下，很难保证可以全部的顺序的原子的执行完成。\nFrom Shuo’s blog\n依据《Java 并发编程实践》/《Java Concurrency in Practice》一书，一个线程安全的 class 应当满足三个条件：\n\n从多个线程访问时，其表现出正确的行为\n无论操作系统如何调度这些线程，无论这些线程的执行顺序如何交织\n调用端代码无需额外的同步或其他协调动作\n\n对象构造要做到线程安全，惟一的要求是在构造期间不要泄露 this 指针，即\n\n不要在构造函数中注册任何回调\n也不要在构造函数中把 this 传给跨线程的对象\n即便在构造函数的最后一行也不行\n\n作为 class 数据成员的 Mutex 只能用于同步本 class 的其他数据成员的读和写，它不能保护安全地析构。因为成员 mutex 的生命期最多与对象一样长，而析构动作可说是发生在对象身故之后（或者身亡之时）。另外，对于基类对象，那么调用到基类析构函数的时候，派生类对象的那部分已经析构了，那么基类对象拥有的 mutex 不能保护整个析构过程。"},"Blogs/post/design-pattern-notes":{"slug":"Blogs/post/design-pattern-notes","filePath":"Blogs/post/design-pattern-notes.md","title":"设计模式学习笔记","links":[],"tags":["设计模式"],"content":"如无特殊声明：本文所有UML图均出自《图说设计模式》。在此特别鸣谢！\nSingleton\n单例模式解决了全局变量的问题，全局只能创建一个实例，保证任何请求该实例的调用均返回同一个对象，保证不会被意外析构。\n\n// A singleton class\n// c.f. zhuanlan.zhihu.com/p/37469260\n \n/**\n * This is so-called lazy-singleton, since it creates the\n * instance until you ask for it.\n *\n * However, it may cause memory leak, since you have no\n * way to delete the instance you created.\n */\nclass SingletonV1\n{\npublic:\n  static SingletonV1* GetInstance()\n  {\n    if (pinstance_ == nullptr)\n      pinstance_ = new SingletonV1();\n    return pinstance_;\n  }\nprivate:\n  SingletonV1() = default;\n  ~SingletonV1() = default;\n  SingletonV1(const SingletonV1&amp;) = delete;\n  SingletonV1&amp; operator=(const SingletonV1&amp;) = delete;\nprivate: \n  static SingletonV1* pinstance_;\n};\n// static member initialization\nSingletonV1* SingletonV1::pinstance_ = nullptr;\nDCL Singleton\n#include &lt;iostream&gt;\n#include &lt;mutex&gt;\nusing namespace std;\n \nstd::mutex gm;\n \n/**\n * This is also a lazy-singleton, but it&#039;s thread-safe.\n * It is so-called Double-Checked Locking Pattern (DCL).\n */\nclass SingletonV2\n{\npublic:\n  static SingletonV2* GetInstance()\n  {\n    if (pinstance_ == nullptr)\n    {\n      // Attention here: see if &gt;= 2 threads meets here,\n      // only one thread can hold the mutex, then create\n      // the instance, this is can only occur on your first\n      // request on instance, once the instance is created,\n      // we can return it immediately.\n      std::lock_guard&lt;std::mutex&gt; lk(gm);\n \n      // See why double check here?\n      // Cause if &gt;= 2 threads have already run across here,\n      // they&#039;ve waited and finally held the mutex, w/o this\n      // check, all of these threads will create a instance,\n      // that&#039;s not what you want.\n      if (pinstance_ == nullptr)  // double check\n        pinstance_ = new SingletonV2();\n    }\n    return pinstance_;\n  }\nprivate:\n  SingletonV2() = default;\n  ~SingletonV2() = default;\n  SingletonV2(const SingletonV2&amp;) = delete;\n  SingletonV2&amp; operator=(const SingletonV2&amp;) = delete;\nprivate: \n  static SingletonV2* pinstance_;\n};\n// static member initialization\nSingletonV2* SingletonV2::pinstance_ = nullptr;\nMeyer’s Singleton\n/**\n * C++11 ensures the mt-safety of local static object. Taking\n * the advantage of this, &lt;&lt;Effective C++&gt;&gt; provides us an elegant\n * implemention of mt-safe singleton.\n */\nclass SingletonV3\n{\npublic:\n  static SingletonV3* GetInstance()\n  {\n    // Note that instance will be created only at the first time.\n    static SingletonV3 instance;\n    return &amp;instance;\n  }\nprivate:\n  SingletonV3() = default;\n  ~SingletonV3() = default;\n  SingletonV3(const SingletonV3&amp;) = delete;\n  SingletonV3&amp; operator=(const SingletonV3&amp;) = delete;\n};\n💡 注意这种单例写法需要C++11。因为是从C++11标准才开始规定 static变量是线程安全的。也就是说无需我们自己写加锁保护的代码，编译器能够帮我们做到。\nEager Singleton\n/**\n * This is an eager-singleton which create an instance at first,\n * then return it as required.\n *\n * It&#039;s mt-safe since the instance initiliazation is before main()\n * function.\n */\nclass SingletonV4\n{\npublic:\n  static SingletonV4* GetInstance()\n  {\n    return &amp;instance_;\n  }\nprivate:\n  SingletonV4() = default;\n  ~SingletonV4() = default;\n  SingletonV4(const SingletonV4&amp;) = delete;\n  SingletonV4&amp; operator=(const SingletonV4&amp;) = delete;\nprivate:\n  // note that here is not a pointer, since a pointer will not own\n  // a memory range by default.\n  static SingletonV4 instance_;\n};\n// initialize the static member\nSingletonV4 SingletonV4::instance_;\nFactory\n工厂模式将对象的创建和对象本身的业务分离，适合那些不关心对象如何创建，对象的创建相对独立的情形。工厂模式又分三种，谓之工厂三兄弟：\n\nSimple Factory\nFactory Method\nAbstract Factory\n\nSimple Factory\n简单工厂模式就是有一个工厂类，你给我什么参数我就给你创造什么对象。\n\n// This file implements a demo for simple factory pattern.\n//\n#include &lt;cstdio&gt;\n#include &lt;string&gt;\n \n#define PRINT_NAME printf(&quot;%s\\n&quot;, __FUNCTION__)\n \nusing namespace std;\n \nclass Product // abstract product\n{\npublic:\n  virtual ~Product() { PRINT_NAME; }\npublic:\n  virtual void Operation() = 0;\n};\n \nclass ProductA : public Product // concrete product\n{\npublic:\n  ~ProductA() { PRINT_NAME; }\npublic:\n  void Operation() override { printf(&quot;%s\\n&quot;, &quot;A::Operation()&quot;); }\n};\n \nclass ProductB : public Product // concrete product\n{\npublic:\n  ~ProductB() { PRINT_NAME; }\npublic:\n  void Operation() override { printf(&quot;%s\\n&quot;, &quot;B::Operation()&quot;); }\n};\n \nclass Factory // factory\n{\npublic:\n  ~Factory() { PRINT_NAME; }\npublic:\n  static Product* CreateProduct(const string&amp; name)\n  {\n    if (name == &quot;A&quot;)\n      return new ProductA();\n    else if (name == &quot;B&quot;)\n      return new ProductB;\n    else\n      return nullptr;\n  }\n};\n \n///\nint main()\n{\n  Product* pa = Factory::CreateProduct(&quot;A&quot;);\n  Product* pb = Factory::CreateProduct(&quot;B&quot;);\n  pa-&gt;Operation();\n  pb-&gt;Operation();\n \n  delete pb;\n  delete pa;\n  return 0;\n}\nFactory Method\n工厂方法模式，是指有一个抽象工厂，他不负责实际的创建任务，所有不同类型的对象由其不同的子类创建。\n\n#include &lt;cstdio&gt;\n \n#define PRINT_NAME printf(&quot;%s\\n&quot;, __FUNCTION__)\n \nclass Product\n{\npublic:\n  virtual ~Product() { PRINT_NAME; }\npublic:\n  virtual void Operation() = 0;\n};\n \nclass ProductA : public Product\n{\npublic:\n  ~ProductA() { PRINT_NAME; }\npublic:\n  void Operation() override\n  {\n    printf(&quot;%s\\n&quot;, &quot;ProductA::Operation()&quot;);\n  }\n};\n \nclass ProductB : public Product\n{\npublic:\n  ~ProductB() { PRINT_NAME; }\npublic:\n  void Operation() override\n  {\n    printf(&quot;%s\\n&quot;, &quot;ProductB::Operation()&quot;);\n  }\n};\n \nclass Creator\n{\npublic:\n  virtual ~Creator() { PRINT_NAME; }\npublic:\n  virtual Product* CreateProduct() = 0;\n};\n \nclass CreatorA : public Creator\n{\npublic:\n  ~CreatorA() { PRINT_NAME; }\npublic:\n  Product* CreateProduct() override\n  {\n    return new ProductA();\n  }\n};\n \nclass CreatorB : public Creator\n{\npublic:\n  ~CreatorB() { PRINT_NAME; }\npublic:\n  Product* CreateProduct() override\n  {\n    return new ProductB();\n  }\n};\n \n// test\nint main()\n{\n  Creator* ca = new CreatorA;  \n  Product* pa = ca-&gt;CreateProduct();\n  pa-&gt;Operation();\n \n  Creator* cb = new CreatorB;\n  Product* pb = cb-&gt;CreateProduct();\n  pb-&gt;Operation();\n \n  delete pb;\n  delete cb;\n  delete pa;\n  delete ca;\n  return 0;\n}\nAbstract Factory\n抽象工厂模式，是指有一个抽象工厂，他不负责实际的创建任务。它会有很多个子类，每个子类负责创建一族具有某种特定属性的对象。如果把工厂所需要创建的对象称为产品，同样有一个抽象产品，他有多个子类，代表不同产品，但每一个产品又有不同属性。所以，把具有相同属性的所有产品的创建任务交给一个工厂（抽象工厂的一个子类），把具有另一个属性的所有产品的创建任务交给另一个工厂（抽象工厂的另一个子类）。\n\n// This file implements a demo of abstract factory pattern.\n//\n#include &lt;cstdio&gt;\n \n#define PRINT_NAME printf(&quot;%s\\n&quot;, __FUNCTION__)\n \n// cats\nclass Cat\n{\npublic:\n  virtual ~Cat() { PRINT_NAME; }\npublic:\n  virtual void Meow() = 0;\n};\n \nclass BlackCat : public Cat\n{\npublic:\n  ~BlackCat() { PRINT_NAME; }\npublic:\n  void Meow() override { printf(&quot;%s\\n&quot;, &quot;b::meow~&quot;); }\n};\n \nclass WhiteCat : public Cat\n{\npublic:\n  ~WhiteCat() { PRINT_NAME; }\npublic:\n  void Meow() override { printf(&quot;%s\\n&quot;, &quot;w::meow~&quot;); }\n};\n \n// dogs\nclass Dog\n{\npublic:\n  virtual ~Dog() { PRINT_NAME; }\npublic:\n  virtual void Bark() = 0;\n};\n \nclass BlackDog : public Dog\n{\npublic:\n  ~BlackDog() { PRINT_NAME; }\npublic:\n  void Bark() override { printf(&quot;%s\\n&quot;, &quot;b::wang~&quot;); }\n};\n \nclass WhiteDog : public Dog\n{\npublic:\n  ~WhiteDog() { PRINT_NAME; }\npublic:\n  void Bark() override { printf(&quot;%s\\n&quot;, &quot;w::wang~&quot;); }\n};\n \n// here comes factory\nclass Factory\n{\npublic:\n  virtual ~Factory() { PRINT_NAME; }\npublic:\n  virtual Cat* CreateCat() = 0;\n  virtual Dog* CreateDog() = 0;\n};\n \nclass BlackFactory : public Factory  // factory that dyes animals black\n{\npublic:\n  ~BlackFactory() { PRINT_NAME; }\npublic:\n  Cat* CreateCat() override { return new BlackCat(); }\n  Dog* CreateDog() override { return new BlackDog(); }\n};\n \nclass WhiteFactory : public Factory  // factory that dyes animals white\n{\npublic:\n  ~WhiteFactory() { PRINT_NAME; }\npublic:\n  Cat* CreateCat() override { return new WhiteCat(); }\n  Dog* CreateDog() override { return new WhiteDog(); }\n};\n \n///\nint main()\n{\n  Factory* pblack = new BlackFactory();\n  Factory* pwhite = new WhiteFactory();\n \n  Cat* black_cat = pblack-&gt;CreateCat();\n  Cat* white_cat = pwhite-&gt;CreateCat();\n \n  Dog* black_dog = pblack-&gt;CreateDog();\n  Dog* white_dog = pwhite-&gt;CreateDog();\n \n  black_cat-&gt;Meow();\n  black_dog-&gt;Bark();\n  white_cat-&gt;Meow();\n  white_dog-&gt;Bark();\n \n  delete white_dog;\n  delete black_dog;\n  delete white_cat;\n  delete black_cat;\n  delete pwhite;\n  delete pblack;\n  return 0;\n}\nObserver\n观察者模式很重要，在计算机系统里有大量应用。就是说有一群观察者，希望观察某个目标，进而相应的动作。比方说很多人需要了解天气预报的信息，那么天气预报就是观察目标，如果人们知道天气预报说下雨，那么他可能会带把伞。这就是相应的操作。如何更新目标的状态是个很有意思的问题。常见的有两种，一是观察目标发生变化，主动通知所有的观察者；而是观察者不断轮询，监听观察目标，一旦发生变化，立刻做出相应的动作。前者称为reactor，后者称为proactor. 两种方式各有所用！比方说，如果订阅天气预报的人数寥寥无几，那么气象站完全可以向所有订阅者推送天气更新信息，但是如果全国上亿人都订阅了天气预报，那么此时完全推送可能就代价太大了。而有些订阅者，他时刻关注天气，比如地方气象站，而有些订阅者，他对实时性不要求那么高，比方说天气预报APP（通常1-2小时更新一次），对于这两种不同的订阅者，很显然需要两种不同的更新方式：前者轮询，后者推送。\n\n// This file implements a demo of observer pattern.\n//\n#include &lt;cstdio&gt;\n#include &lt;list&gt;\n#include &lt;string&gt;\n \n#define PRINT_NAME printf(&quot;%s\\n&quot;, __FUNCTION__)\n \n// front declaration\nclass Subject;\nclass Observer;\n \nclass Subject\n{\npublic:\n  virtual ~Subject() { PRINT_NAME; }\n \npublic:\n  virtual void attach(Observer* ob);\n  virtual void detach(Observer* ob);\n  virtual void notify();  // notify all observers\n  \n  virtual void set_state(int state) = 0;\n  virtual int get_state() = 0;\n \nprivate:\n  std::list&lt;Observer*&gt; observers_;\n};\n \nclass Observer\n{\npublic:\n  virtual ~Observer() { PRINT_NAME; }\npublic:\n  virtual void update(Subject* sb) = 0;\n};\n \n//================ impl subject ==============\nvoid Subject::attach(Observer* ob) { observers_.push_back(ob); }\n \nvoid Subject::detach(Observer* ob)\n{\n  for (auto it = observers_.begin(); it != observers_.end(); ++it)\n  {\n    if (*it == ob)\n    {\n      observers_.erase(it);\n      break;\n    }\n  }\n}\n \nvoid Subject::notify()\n{\n  for (auto ob : observers_)\n    ob-&gt;update(this);\n}\n \n/* a specific subject */\nclass Weather : public Subject\n{\npublic:\n  ~Weather() { PRINT_NAME; }\n \npublic:\n  void set_state(int s) override { state_ = s; }\n  int get_state() override { return state_; }\n \nprivate:\n  int state_;\n};\n \n/* a specific observer */\nclass WeatherAPP : public Observer\n{\npublic:\n  WeatherAPP(const std::string&amp; name): name_(name) {}\n  ~WeatherAPP() { PRINT_NAME; }\n \npublic:\n  void update(Subject* sb) override\n  {\n    state_ = sb-&gt;get_state(); \n \n    printf(&quot;Observer %s: &quot;, name_.data());\n    switch (state_)\n    {\n      case 0: printf(&quot;default\\n&quot;);\n              break;\n      case 1: printf(&quot;rainy\\n&quot;);\n              break;\n      case 2: printf(&quot;cloudy\\n&quot;);\n              break;\n      case 3: printf(&quot;foggy\\n&quot;);\n              break;\n      default: break;\n    }\n  }\n \nprivate:\n  int state_;\n  std::string name_;\n};\n \n///\nint main()\n{\n  Subject* weather = new Weather();\n  Observer* ob1 = new WeatherAPP(&quot;Color TianQi&quot;);\n  Observer* ob2 = new WeatherAPP(&quot;Moji TianQi&quot;);\n  weather-&gt;attach(ob1);\n  weather-&gt;attach(ob2);\n \n  weather-&gt;set_state(1); // rainy\n  weather-&gt;notify();\n \n  weather-&gt;detach(ob2);\n  weather-&gt;set_state(3); // foggy\n  weather-&gt;notify();\n  \n  delete ob2;\n  delete ob1;\n  delete weather;\n  return 0;\n}\nReferences\n\n图说设计模式\n"},"Blogs/post/gnome-app-slow-start":{"slug":"Blogs/post/gnome-app-slow-start","filePath":"Blogs/post/gnome-app-slow-start.md","title":"Gnome应用启动缓慢","links":[],"tags":["折腾"],"content":"先看环境：\n$ neofetch\n                   -`                    yychi@MiBook-Air \n                  .o+`                   ---------------- \n                 `ooo/                   OS: Arch Linux x86_64 \n                `+oooo:                  Host: TM1604 XMAKB3M0P0202 \n               `+oooooo:                 Kernel: 5.5.13-arch2-1 \n               -+oooooo+:                Uptime: 5 mins \n             `/:-:++oooo+:               Packages: 1153 (pacman) \n            `/++++/+++++++:              Shell: zsh 5.8 \n           `/++++++++++++++:             Resolution: 1920x1080 \n          `/+++ooooooooooooo/`           WM: i3 \n         ./ooosssso++osssssso+`          Theme: Adwaita [GTK2] \n        .oossssso-````/ossssss+`         Icons: Adwaita [GTK2] \n       -osssssso.      :ssssssso.        Terminal: urxvt \n      :osssssss/        osssso+++.       Terminal Font: DejaVu Sans Mono for Powerline \n     /ossssssss/        +ssssooo/-       CPU: Intel i5-7200U (4) @ 3.100GHz \n   `/ossssso+/:-        -:/+osssso+-     GPU: NVIDIA GeForce MX150 \n  `+sso+:-`                 `.-/+oso:    GPU: Intel HD Graphics 620 \n `++:.                           `-/+/   Memory: 1608MiB / 7881MiB \n .`                                 `/\n\n再看问题：Gnome系软件（gedit, baobab, nautilus等）启动龟速，通常需要等待10-30s.\n思考：我看你就是在为难我，我压根不知道问题出在哪里。大概就是几天前更新系统的时候看到需要更新很多gnome的包，心想着我都不用gnome了，留这么多gnome的包干吗呢？于是删了很多，这一删我以往的经验就告诉我可能会出什么幺蛾子。果不其然，这些天有时候浏览器调用文件管理器（gnome家nautilus）的时候，非常之满，我一度以为死机。细看来又不是，等了十几秒文件窗口忽然蹦出来，怎么这么慢！\n换做以前，应该是直接重装系统了。可是这次没时间这么折腾，加上年纪大了不想折腾，毕竟这个本子用了这么久了，积累了好多东西。于是死马当活马医，硬着头皮去google相关问题。循着蛛丝马迹，找到可能出问题的一些点。最后还是要看log！\n$ journalctl --since=2020-3-25\n...\n...\n最终我发现这几行有嫌疑：\n4月 01 13:15:01 MiBook-Air xdg-desktop-portal-gtk[139187]: Unable to init server: 无法连接：拒绝连接\n4月 01 13:15:01 MiBook-Air xdg-desktop-por[139187]: cannot open display: \n4月 01 13:15:01 MiBook-Air systemd[520]: xdg-desktop-portal-gtk.service: Main process exited, code=exited, status=1/FAILURE\n4月 01 13:15:01 MiBook-Air systemd[520]: xdg-desktop-portal-gtk.service: Failed with result &#039;exit-code&#039;.\n4月 01 13:15:01 MiBook-Air systemd[520]: Failed to start Portal service (GTK+/GNOME implementation).\n\n结果一查，果然查到一篇相关的帖子1，我的问题和他一模一样。结果就解决了，就解决了，解决了，决了，了！\n问题的原因其实我不太懂，谨此写下折腾记录。\nFootnotes\n\n\nGnome applications slow start due to failing services ↩\n\n\n"},"Blogs/post/hello-world":{"slug":"Blogs/post/hello-world","filePath":"Blogs/post/hello-world.md","title":"Hello World","links":[],"tags":[],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick Start\nCreate a new post\n$ hexo new &quot;My New Post&quot;\nMore info: Writing\nRun server\n$ hexo server\nMore info: Server\nGenerate static files\n$ hexo generate\nMore info: Generating\nDeploy to remote sites\n$ hexo deploy\nMore info: Deployment"},"Blogs/post/latexmk-basic":{"slug":"Blogs/post/latexmk-basic","filePath":"Blogs/post/latexmk-basic.md","title":"Latexmk基础用法","links":[],"tags":[],"content":"怎么想到用latexmk的呢？写论文呗！\n本来呢，我一直习惯于使用命令行手敲\npdflatex someting.tex\n千万别小看这种重复劳动，它不仅帮你加深记忆，还有最完整的输出，让你一窥Tex排版系统的内裤（→_→，一本正经胡说八道中……）。还记得Archlinux的哲学名言吗？—Keep it simple and stupid (KISS)—说得太对了呀！\n但是啊说到写论文，肯定要有引用文献的啦，这就麻烦了，每次更新参考文献和交叉引用都需要四步走：\npdflatex a.tex  # 生成aux文件，下一步bibtex才能知道需要引用哪几个文献\nbibtex a        # 生成bbl文件，及将.bib里面的元数据展开成符合tex语法的bibitem\npdflatex a.tex  # 刷新引用，可能残留一些问号\npdflatex a.tex  # 产生最终结果，所有引用正确显示\n这就忍不了了吧？其实我还是能忍的，因为不是每次更新文献就重新编译，可以写一大段再更新一次，这就省事儿多了。真正原因是我像用VS code写latex，下了一个插件叫Latex Workshop，它默认使用pdflatex编译，但我写中文必须要用xelatex编译，而且必须要完成自动化。\n我看到可以用latexmk，所以就去简单研究了下，下面进入正题。\n命令行使用\nlatexmk\n默认情况下会自动编译当前文件夹下所有tex文件，默认使用pdflatex引擎。\n如果想编译得到PDF文件，则直接加上选项：\nlatexmk -pdf\n如果想编译单个文件：\nlatexmk single_file.tex\n要删除临时文件：\nlatexmk -c\nlatexmk -C ## 删除（包含输出文件）\n配置文件\n\n~/.latexmkrc：用户全局配置\n$PWD/latexmkrc：局部文件夹配置\n\n一个简单的配置文件：\n$dvi_previewer = &#039;start xdvi -watchfile 1.5&#039;;\n$ps_previewer  = &#039;start gv --watch&#039;;\n$pdf_previewer = &#039;start evince&#039;;\n \n$pdf_mode = 1;                              # tex -&gt; pdf\n# $pdf_mode = 2;                            # tex -&gt; ps -&gt; pdf\n# $pdf_mode = 5;                            # use xelatex, see `man latexmk`\n$postscript_mode = 1;                       # tex -&gt; ps\n@defalut_files = (&#039;main.tex&#039;, &#039;niam.tex&#039;);  # 指定要编译的文件\n \n$pdflatex = &#039;pdflatex -interaction=nonstopmode -synctex=1 %O %S&#039;;\n$xelatex = &#039;xelatex -no-pdf -interaction=nonstopmode -synctex=1 %O %S&#039;;\nReferences\n\nUsing Latexmk\nMake latexmk 4.54c use synctex with xelatex\n"},"Blogs/post/linux-hibernate":{"slug":"Blogs/post/linux-hibernate","filePath":"Blogs/post/linux-hibernate.md","title":"Linux的休眠","links":["Blogs/记一次重装linux.html"],"tags":["hibernate"],"content":"先区分一下两个名词：睡眠（sleep）和休眠（hibernate）。\n\n睡眠：将工作镜像写入内存（RAM），以便快速恢复。内存读写很快，所以睡眠的特点就是“睡得快”和“醒得快”。对于笔记本来说，合上盖子就睡了，打开盖子你的工作区间即刻就能恢复，很是方便。但是睡眠有一个缺点，就是要给内存供电，一旦断电，你的镜像数据就会丢失，工作区间将不复存在。当然这来自于内存的固有特点，建议百度RAM。\n休眠：将工作镜像写入硬盘（disk，ROM），这样你也可以恢复工作区间。只是睡下去和醒过来的时间比内存慢不少。但是，它有一个好处就是断电了也不会丢失数据。当你再次开机，系统就会从硬盘里面读取镜像，恢复你的工作区间。\n\n\n作为一个不求甚解的小白，我用linux这么些年，一直都只用过睡眠，每天晚上合上笔记本的盖子，第二天早上打开，工作区间即刻恢复，其实也是非常方便的，再也不用忍受关机开机的痛苦。这样一夜下来，大概要耗费7-8%的电量，还可以接受不是=。= 但是一旦你很长时间没用电脑，比如说放长假回家了，好久没碰电脑，那么笔记本的电池是会耗尽的，此时你的工作区间就丢了。（当然，这样的情况并不多见）\n其实我以前也是鼓捣过linux休眠的，大概3-4年前，刚接触linux那会儿，在网上一通乱搜，一顿瞎试，未果。现在想来，失败的原因一是当时太菜，而是当时那个电脑太老旧了。据我所知，GPT分区下搞休眠的坑是比较多的。现在的电脑大都是EFI分区，更加简单易用。\n总体来说，休眠还是值得折腾的，因为支持断电！而且现在普遍使用固态硬盘，休眠和恢复的速度也并不是很慢。还有一个很重要的原因，笔记本电池的寿命很短，我的本子买了3年了，现在电池容量已经缩水2/3了！\n好了，闲话少叙，进入正题。\n确保swap分区足够大\n拟使用swap分区作为写入镜像的目标分区。\n一般建议swap分区为本机内存的一半，不过我认为有条件的还是将swap分区设置的略大于内存。此处，由于睡眠是将镜像写到内存，要确保swap分区能够容得下这个镜像，就必须将swap分区设置的大于内存。这并不是说swap小于内存就无法休眠了1，具体还是要看工作区间的镜像大小了。我现在的swap就只有本机内存的一半，但还是休眠成功了。\n查看fstab\n$ cat /etc/fstab\n# &lt;file system&gt;             &lt;mount point&gt;  &lt;type&gt;  &lt;options&gt;  &lt;dump&gt;  &lt;pass&gt;\n# /dev/nvme0n1p5\nUUID=547054ce-bb1b-40e4-a38d-24507d31d5ca   /           ext4        rw,relatime   0 1\n \nUUID=6E76-7D08          /boot/efi   vfat        rw,relatime,fmask=0022,dmask=0022,codepage=437,iocharset=iso8859-1,shortname=mixed,utf8,errors=remount-ro   0 2\n \n# /dev/nvme0n1p7\nUUID=4227170f-0a4f-4a8e-a4fd-0d91f46f54af   none        swap        defaults,pri=-0 0\n系统启动时会读取该文件，按照其中的描述挂载对应的分区。默认生成的fstab中，swap分区的类型是swap，将它改为none.\n以下命令均可以查看分区信息：\n$ lsblk\nNAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT\nsda           8:0    0 223.6G  0 disk \n├─sda1        8:1    0   110G  0 part /home/yychi/EXTRA\n└─sda2        8:2    0 113.6G  0 part \nnvme0n1     259:0    0 238.5G  0 disk \n├─nvme0n1p1 259:1    0   100M  0 part /boot/efi\n├─nvme0n1p2 259:2    0    16M  0 part \n├─nvme0n1p3 259:3    0 119.5G  0 part \n├─nvme0n1p4 259:4    0   798M  0 part \n├─nvme0n1p5 259:5    0    65G  0 part /\n├─nvme0n1p6 259:6    0    49G  0 part /home\n└─nvme0n1p7 259:7    0   4.1G  0 part [SWAP]\n \n$ sudo blkid -o list\ndevice           fs_type  label     mount point          UUID\n----------------------------------------------------------------------------------------------\n/dev/nvme0n1p1   vfat     ESP       /boot/efi            6E76-7D08\n/dev/nvme0n1p2                      （未挂载）      \n/dev/nvme0n1p3   ntfs     OS        （未挂载）      CADC772DDC7712C5\n/dev/nvme0n1p4   ntfs               （未挂载）      624AD5CA4AD59B5D\n/dev/nvme0n1p5   ext4     ROOT      /                    547054ce-bb1b-40e4-a38d-24507d31d5ca\n/dev/nvme0n1p6   ext4     HOME      /home                1e23c2e3-6b73-465a-bd60-355b1bc4060b\n/dev/nvme0n1p7   swap               [SWAP]               4227170f-0a4f-4a8e-a4fd-0d91f46f54af\n/dev/sda1        ext4     DATA      /home/yychi/EXTRA    e66f87ee-33d8-4aaa-bff0-400df2276ef7\n/dev/sda2        ntfs               （未挂载）      07B60D0A64472B59\n添加恢复分区的内核参数\n# 查看当前内核启动命令\n$ cat /proc/cmdline\n\\\\boot\\vmlinuz-linux ro root=/dev/nvme0n1p5 rw resume=/dev/nvme0n1p7 initrd=boot\\initramfs-linux.img\n可以看到，内核的启动参数中resume=/dev/nvme0n1p7这一项就指定了从该分区恢复，而该分区正是swap分区。\n那么如何修改内核的命令行参数呢？找到你所使用的boot manager（启动引导）程序，更改相应的配置。我使用的是rEFInd，需要做的更改为：\n# file: /boot/refind_linux.conf\n&quot;Boot with standard options&quot;  &quot;ro root=/dev/nvme0n1p5 rw resume=/dev/nvme0n1p7&quot;\n&quot;Boot to single-user mode&quot;    &quot;ro root=/dev/nvme0n1p5 single&quot;\n直接在第一行最后的参数列表里加上rw resume=/dev/nvme0n1p7即可。Ubuntu默认使用grub作为引导，这个网上教程更为详尽，此处就不再复制粘贴了。\n重新生成启动镜像\n作完更改之后，使用\n$ mkinitcpio -P\n重新生成启动镜像，使更改生效，最后重启系统。\n重新进入系统之后，\n$ cat /proc/cmdline\n\\\\boot\\vmlinuz-linux ro root=/dev/nvme0n1p5 rw resume=/dev/nvme0n1p7 initrd=boot\\initramfs-linux.img\n如果参数列表里有resume=/dev/nvme0n1p7则说明设置成功。你可以打开一个程序，然后\nsystemctl hibernate\n令系统休眠，然后再按下电源开关，系统会自动恢复之前的工作环境。\n今天先这样，写的不够详细，改日再完善吧~\n\nRe: hibernation\n万万没想到，今日（2022-05-04 00:14），我又为了休眠的事儿排查了两天之久。\n自文章写完之后，一年多来，休眠一直工作的很好。直到这次五一，我准备解决一下之前一直悬而未决的屏幕撕裂问题。在此过程中，我尝试了启用笔记本的独显NVIDIA Corporation GP108M [GeForce MX150], 也为此做了很多工作，甚至从Nvidia官网下载了驱动进行安装，就是这个过程，安装报错了，然后我打算放弃，执行了卸载，卸载也报错了。最后实现的效果，确实X和picom都运行在独显上了，但是进入X之后，屏幕一片漆黑。彼时夜已深，我就打算放弃了。直接电脑休眠，而我去睡觉了。\n第二天打开电脑，才发现大事不妙。直接变成开机了，之前的工作状态并未还原。思来想去这期间干了什么呢？尝试安装独显驱动，解决屏幕撕裂，archlinux-keyring损坏并重置，进行了系统全量更新（内核升级到5.17.5-arch1-1）, 很难排查到底是什么原因导致的。只能打开journal细细排查可能的原因，\n$ journalctl -b\n...\n5月 04 00:01:11 MiBook-Air kernel: ACPI BIOS Error (bug): Could not resolve symbol [\\_PR.PR00._CPC], AE_NOT_FOUND (20211217/psargs-330)\n5月 04 00:01:11 MiBook-Air kernel: ACPI Error: Aborting method \\_PR.PR01._CPC due to previous error (AE_NOT_FOUND) (20211217/psparse-529)\n5月 04 00:01:11 MiBook-Air kernel: ACPI BIOS Error (bug): Could not resolve symbol [\\_PR.PR00._CPC], AE_NOT_FOUND (20211217/psargs-330)\n5月 04 00:01:11 MiBook-Air kernel: ACPI Error: Aborting method \\_PR.PR02._CPC due to previous error (AE_NOT_FOUND) (20211217/psparse-529)\n5月 04 00:01:11 MiBook-Air kernel: ACPI BIOS Error (bug): Could not resolve symbol [\\_PR.PR00._CPC], AE_NOT_FOUND (20211217/psargs-330)\n5月 04 00:01:11 MiBook-Air kernel: ACPI Error: Aborting method \\_PR.PR03._CPC due to previous error (AE_NOT_FOUND) (20211217/psparse-529)\n...\n第一个疑似的原因就是这个，但经过一番搜索，他也仅仅是个内核的bug2，并不能证明他和休眠失败有直接关系。\n接着我直接找到这段时间的系统日志，一行一行的查看，凡是有疑似的都搜索之，未果。期间我发现，之前正常休眠恢复的日志序列大概是下面这个样子：\n4月 28 23:59:06 MiBook-Air systemd-sleep[515989]: Entering sleep state &#039;hibernate&#039;...\n4月 28 23:59:06 MiBook-Air kernel: PM: hibernation: hibernation entry\n4月 29 19:48:53 MiBook-Air kernel: Filesystems sync: 0.004 seconds\n4月 29 19:48:53 MiBook-Air kernel: Freezing user space processes ... (elapsed 0.001 seconds) done.\n4月 29 19:48:53 MiBook-Air kernel: OOM killer disabled.\n4月 29 19:48:53 MiBook-Air kernel: PM: hibernation: Marking nosave pages: [mem 0x00000000-0x00000fff]\n4月 29 19:48:53 MiBook-Air kernel: PM: hibernation: Marking nosave pages: [mem 0x00058000-0x00058fff]\n4月 29 19:48:53 MiBook-Air kernel: PM: hibernation: Marking nosave pages: [mem 0x0009e000-0x000fffff]\n4月 29 19:48:53 MiBook-Air kernel: PM: hibernation: Marking nosave pages: [mem 0x71d1c000-0x71d1cfff]\n4月 29 19:48:53 MiBook-Air kernel: PM: hibernation: Marking nosave pages: [mem 0x71d48000-0x71d48fff]\n4月 29 19:48:53 MiBook-Air kernel: PM: hibernation: Marking nosave pages: [mem 0x725dc000-0x725dcfff]\n4月 29 19:48:53 MiBook-Air kernel: PM: hibernation: Marking nosave pages: [mem 0x725ec000-0x725ecfff]\n4月 29 19:48:53 MiBook-Air kernel: PM: hibernation: Marking nosave pages: [mem 0x7312f000-0x73130fff]\n4月 29 19:48:53 MiBook-Air kernel: PM: hibernation: Marking nosave pages: [mem 0x75388000-0x75c87fff]\n4月 29 19:48:53 MiBook-Air kernel: PM: hibernation: Marking nosave pages: [mem 0x7c026000-0x7c02bfff]\n4月 29 19:48:53 MiBook-Air kernel: PM: hibernation: Marking nosave pages: [mem 0x8be9e000-0x8cffdfff]\n4月 29 19:48:53 MiBook-Air kernel: PM: hibernation: Marking nosave pages: [mem 0x8cfff000-0xffffffff]\n4月 29 19:48:53 MiBook-Air kernel: PM: hibernation: Basic memory bitmaps created\n4月 29 19:48:53 MiBook-Air kernel: PM: hibernation: Preallocating image memory\n4月 29 19:48:53 MiBook-Air kernel: PM: hibernation: Allocated 676076 pages for snapshot\n4月 29 19:48:53 MiBook-Air kernel: PM: hibernation: Allocated 2704304 kbytes in 0.38 seconds (7116.58 MB/s)\n4月 29 19:48:53 MiBook-Air kernel: Freezing remaining freezable tasks ... (elapsed 0.001 seconds) done.\n4月 29 19:48:53 MiBook-Air kernel: printk: Suspending console(s) (use no_console_suspend to debug)\n可以看到，日志从4月28日23:59:06一下子跳到4月29日19:48:53，也就是说我在28日晚上发起了休眠，在29日晚上再度打开电脑，成功恢复了工作区。\n而在休眠失败后日志是下面这样：\n5月 01 02:13:41 MiBook-Air systemd[1]: Reached target Sleep.\n5月 01 02:13:41 MiBook-Air systemd[1]: Starting Hibernate...\n5月 01 02:13:41 MiBook-Air kernel: PM: Image not found (code -16)\n5月 01 02:13:41 MiBook-Air dhcpcd[463]: wlp2s0: old hardware address: f8:63:3f:4d:a1:8e\n5月 01 02:13:41 MiBook-Air dhcpcd[463]: wlp2s0: new hardware address: 66:34:25:c7:18:31\n5月 01 02:13:41 MiBook-Air systemd-sleep[13740]: Entering sleep state &#039;hibernate&#039;...\n5月 01 02:13:41 MiBook-Air dhcpcd[463]: wlp2s0: old hardware address: 66:34:25:c7:18:31\n5月 01 02:13:41 MiBook-Air dhcpcd[463]: wlp2s0: new hardware address: f8:63:3f:4d:a1:8e\n5月 01 02:13:41 MiBook-Air kernel: PM: hibernation: hibernation entry\n-- Boot a60e8709e7b945abbcdb13a477011e7b --\n5月 01 18:43:13 MiBook-Air kernel: Linux version 5.17.5-arch1-1 (linux@archlinux) (gcc (GCC) 11.2.0, GNU ld (GNU Binutils) 2.38) #1 SMP PREEMPT Wed, 27 Apr 2022 20:56:11 +0000\n5月 01 18:43:13 MiBook-Air kernel: Command line: ro root=/dev/nvme0n1p5 rw resume=/dev/nvme0n1p7 initrd=boot\\initramfs-linux.img\n5月 01 18:43:13 MiBook-Air kernel: x86/fpu: Supporting XSAVE feature 0x001: &#039;x87 floating point registers&#039;\n5月 01 18:43:13 MiBook-Air kernel: x86/fpu: Supporting XSAVE feature 0x002: &#039;SSE registers&#039;\n5月 01 18:43:13 MiBook-Air kernel: x86/fpu: Supporting XSAVE feature 0x004: &#039;AVX registers&#039;\n5月 01 18:43:13 MiBook-Air kernel: x86/fpu: Supporting XSAVE feature 0x008: &#039;MPX bounds registers&#039;\n5月 01 18:43:13 MiBook-Air kernel: x86/fpu: Supporting XSAVE feature 0x010: &#039;MPX CSR&#039;\n5月 01 18:43:13 MiBook-Air kernel: x86/fpu: xstate_offset[2]:  576, xstate_sizes[2]:  256\n5月 01 18:43:13 MiBook-Air kernel: x86/fpu: xstate_offset[3]:  832, xstate_sizes[3]:   64\n5月 01 18:43:13 MiBook-Air kernel: x86/fpu: xstate_offset[4]:  896, xstate_sizes[4]:   64\n5月 01 18:43:13 MiBook-Air kernel: x86/fpu: Enabled xstate features 0x1f, context size is 960 bytes, using &#039;compacted&#039; format.\n同样在时间跳跃节点看，此前的日志看起来是休眠成功了，此后竟然直接走了boot流程！因此我猜测肯定是恢复（resume）过程出了问题，休眠（hibernation）是正常工作的。\n我尝试过将内涵参数中的resume=/dev/xxx改为resume=UUID=xxx-xxxx-xx，也还是不行。最让人无奈的是，到现在没有发现问题所在，一直在摸黑尝试。\n后来看到两篇文章（其实就是Ref2中提及的）:\n\nDebugging hibernation and suspend\nBEST PRACTICE TO DEBUG LINUX* SUSPEND/HIBERNATE ISSUES\n\n开始对休眠过程进行更具针对性的debug，推荐从第一篇文章开始。经过一番debug，发现我的休眠功能确实没啥问题，恢复功能也没问题，即第一篇文章提到的：\n\nThat test can be used to check if failures to resume from hibernation are\nrelated to bad interactions with the platform firmware.  That is, if the above\nworks every time, but resume from actual hibernation does not work or is\nunreliable, the platform firmware may be responsible for the failures.\n\n但即便知道了可能是硬件问题，我也看不出来是哪里的问题啊（太菜了orz）。无奈之下尝试第二篇的debug方法，在鼓捣了一对内核参数之后，日志确实更详尽了，但其中暴露出的问题，google都没有搜索结果。我哪看得懂啊？最后带着快要放弃的心情，再次翻开了ArchWiki（再次高呼，ArchWiki YYDS！）上的一篇文章（Ref7）, 其中提到：\n\nThe kernel parameters will only take effect after rebooting. To be able to hibernate right away, obtain the volume’s major and minor device numbers from lsblk and echo them in format *major*:*minor* to /sys/power/resume. If using a swap file, additionally echo the resume offset to /sys/power/resume_offset.[2]\n\n我就试探性的照做了，\nyychi@~&gt; lsblk\nNAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS\nsda           8:0    0 223.6G  0 disk \n├─sda1        8:1    0   110G  0 part /home/yychi/EXTRA\n└─sda2        8:2    0 113.6G  0 part \nnvme0n1     259:0    0 238.5G  0 disk \n├─nvme0n1p1 259:1    0   100M  0 part /boot/efi\n├─nvme0n1p2 259:2    0    16M  0 part \n├─nvme0n1p3 259:3    0 119.5G  0 part \n├─nvme0n1p4 259:4    0   798M  0 part \n├─nvme0n1p5 259:5    0    65G  0 part /\n├─nvme0n1p6 259:6    0    49G  0 part /home\n└─nvme0n1p7 259:7    0   4.1G  0 part [SWAP]\nyychi@~&gt; echo 259:7 &gt; /sys/power/resume\n以及此处提及\n\nWhen an initramfs with the base hook is used, which is the default, the resume hook is required in /etc/mkinitcpio.conf. Whether by label or by UUID, the swap partition is referred to with a udev device node, so the resume hook must go after the udev hook. This example was made starting from the default hook configuration:\n\nHOOKS=(base udev autodetect keyboard modconf block filesystems **resume** fsck)\n\nRemember to regenerate the initramfs for these changes to take effect.\n\nWhen an initramfs with the systemd hook is used, a resume mechanism is already provided, and no further hooks need to be added.\n\n总结一下：就是往/sys/power/resume里写入正确的数值，以及在/etc/mkinitcpio.conf里加上resumehook，重新mkinitcpio -P，然后休眠恢复就成功了！\n小尝试\n经过尝试，把/etc/mkinitcpio.conf中HOOKS中的resume去掉，再mkinitcpio -P，再次休眠后就无法恢复，直接走boot流程了。并且启动后/sys/power/resume的值丢失了（恢复默认）:\n$ cat /sys/power/resume\n0:0\n而将HOOKS中的resume加上之后，再mkinitcpio -P生效之，重启后\n$ cat /sys/power/resume\n259:7\n有值了，而且休眠之后可以成功恢复。\n看起来就是这里的原因了，恢复的时候由于找不到swap分区导致fallback到boot流程，而resume hook就是起到告诉kernel swap分区的标识，因此才能成功恢复。但有一个问题，之前我没有动过这些，也能休眠并恢复成功。从ArchWiki上的描述来看，HOOKS中使用了systemd的，不需要加resume；使用了base的，需要加resume。看来是某些操作改了我的/etc/mkinitcpio.conf？\nBonus: 使用sleep hook在休眠时上锁\n此前使用休眠的场景是这样的：terminal里面敲systemctl hibernate，等待休眠成功，合上盖子，time flies, 打开盖子，启动电源，恢复工作区。这个过程没有涉及到用户验证，所以如果此间别人拿了你的电脑，自然能一窥你的裙底风光。所以，合理的做法应该是休眠时顺便锁个屏。\n其实ArchWiki也有提到34，利用systemd管理的service可以做到。具体说来，可以创建如下文件：\n# /etc/systemd/system/suspend@.service\n# see: wiki.archlinux.org/title/Power_management#Sleep_hooks\n \n[Unit]\nDescription=User suspend actions\nBefore=sleep.target\n \n[Service]\nUser=%I\nType=simple\nEnvironment=DISPLAY=:0\nExecStart=/usr/bin/slock\nExecStartPost=/usr/bin/sleep 1\n \n[Install]\nWantedBy=sleep.target\n形如xxx@.service的文件称为template service，它可以带一个参数拼接成一个instantiated service文件，比如xxx@username.service，具体可参考man 5 systemd.service. 上述我创建了一个suspend@.service，然后我们启用（enable on boot）一个instantiated service\n$ systemctl enable suspend@yychi.service\n接着reload一下使其立刻生效，\n$ systemctl daemon-reload\n然后调用systemctl hibernate看看效果，果然在挂起、恢复之后，出现了锁屏界面5。\n热心观众可能发现，上述service对systemctl suspend同样生效，其原因是suspend和hibernate同样都在sleep.target之后，而我们的service定义了Before=sleep.target，说明suspend@yychi.service要在sleep.target之前执行。因此无论是sleep还是hibernate都能用上。印证如下：\nyychi@/etc/systemd/system&gt; systemctl cat suspend.target                                21:15\n[Unit]\nDescription=Suspend\nDocumentation=man:systemd.special(7)\nDefaultDependencies=no\nRequires=systemd-suspend.service\nAfter=systemd-suspend.service\nStopWhenUnneeded=yes\n \nyychi@/etc/systemd/system&gt; systemctl cat systemd-suspend.service                       21:37\n[Unit]\nDescription=System Suspend\nDocumentation=man:systemd-suspend.service(8)\nDefaultDependencies=no\nRequires=sleep.target\nAfter=sleep.target  # 注意此处\n \n[Service]\nType=oneshot\nExecStart=/usr/lib/systemd/systemd-sleep suspend\n \nyychi@/etc/systemd/system&gt; systemctl cat hibernate.target                              21:37\n[Unit]\nDescription=System Hibernation\nDocumentation=man:systemd.special(7)\nDefaultDependencies=no\nRequires=systemd-hibernate.service\nAfter=systemd-hibernate.service\nStopWhenUnneeded=yes\n \nyychi@/etc/systemd/system&gt; systemctl cat systemd-hibernate.service                     21:38\n# /usr/lib/systemd/system/systemd-hibernate.service\n[Unit]\nDescription=Hibernate\nDocumentation=man:systemd-hibernate.service(8)\nDefaultDependencies=no\nRequires=sleep.target\nAfter=sleep.target  # 注意此处\n \n[Service]\nType=oneshot\nExecStart=/usr/lib/systemd/systemd-sleep hibernate\n关于休眠，暂时探索至此…\nReferences\n\nIs Hybrid Sleep the same in Linux as in Windows?\nHow can I hibernate on Ubuntu 16.04?\nHow do I use pm-suspend-hybrid by default instead of pm-suspend?\nKernel parameters\nError resume: no device specified for hibernation\nHibernation: Resume Can’t Find Swap\nPower management/Suspend and hibernate - ArchWiki\n\nFootnotes\n\n\nSee Arch wiki ↩\n\n\nACPI BIOS Error (bug): Could not resolve symbol [\\_PR.PR00._CPC] ↩\n\n\nSuspend/resume service files ↩\n\n\nSlock - lock on suspend ↩\n\n\n此处我用的是slock，X下一个非常简单轻巧的锁屏工具。简单到什么程度呢？它连配置文件都没有，想要自定义，必须改config.h然后重新编译！ ↩\n\n\n"},"Blogs/post/linux开机无声音":{"slug":"Blogs/post/linux开机无声音","filePath":"Blogs/post/linux开机无声音.md","title":"Linux开机无声音","links":["Blogs/post/output:hdmi-stereo-extra1+input:analog-stereo.html"],"tags":[],"content":"问题描述：个人笔记本电脑长久以来都有一个问题，开机之后扬声器没声音，从应用层看毫无问题，所有音乐视频照常播放，能调音量，就是没声音。必须插一下耳机，耳机里有声音。然后再拔出耳机，外部扬声器也有声音了。因此使用起来并无大碍，只需要准备一个耳机，开机之后插拔一下即可。\n但问题始终要解决的，我总不可能每次开机的时候旁边都有个有限耳机吧。所以要解决这个问题，可从以下两个路子着手：\n\n彻底解决这个问题，每次开机正常有声音，插入耳机，则声音通过耳机输出；\n退而求其次，能在开机之后不需要插拔耳机，也能将外部扬声器声音释放出来，比如一个shell命令激活。\n\n目前我只做到了第二种，尚未完美解决。\n记录一下排查问题的大致流程：\n首先上网查了一下相关问题，怀疑是pulseaudio的问题，结果偶然某一次正常播放音频的时候，我发现杀掉pulseaudio的进程竟然毫无影响，因此可能不是它的问题。\n然后查看alsamixer得知：\n\n可以看到有两张声卡，一个是default，一个是HDA Intel PCH，但其实我只有一张声卡\n$ aplay -l\n**** List of PLAYBACK Hardware Devices ****\ncard 0: PCH [HDA Intel PCH], device 0: ALC255 Analog [ALC255 Analog]\n  Subdevices: 1/1\n  Subdevice #0: subdevice #0\ncard 0: PCH [HDA Intel PCH], device 3: HDMI 0 [HDMI 0]\n  Subdevices: 1/1\n  Subdevice #0: subdevice #0\ncard 0: PCH [HDA Intel PCH], device 7: HDMI 1 [HDMI 1]\n  Subdevices: 1/1\n  Subdevice #0: subdevice #0\ncard 0: PCH [HDA Intel PCH], device 8: HDMI 2 [HDMI 2]\n  Subdevices: 1/1\n  Subdevice #0: subdevice #0\ncard 0: PCH [HDA Intel PCH], device 9: HDMI 3 [HDMI 3]\n  Subdevices: 1/1\n  Subdevice #0: subdevice #0\ncard 0: PCH [HDA Intel PCH], device 10: HDMI 4 [HDMI 4]\n  Subdevices: 1/1\n  Subdevice #0: subdevice #0\n此时我观察到在无声音的状态下使用\nyychi@~&gt; speaker-test -c 2\n \nspeaker-test 1.2.6\n \nPlayback device is default\nStream parameters are 48000Hz, S16_LE, 2 channels\nUsing 16 octaves of pink noise\nRate set to 48000Hz (requested 48000Hz)\nBuffer size range from 96 to 1048576\nPeriod size range from 32 to 349526\nUsing max buffer size 1048576\nPeriods = 4\nwas set period_size = 262144\nwas set buffer_size = 1048576\n 0 - Front Left\n 1 - Front Right\n^CTime per period = 10.942892\nyychi@~&gt; speaker-test -c 2 -D hw:0\n \nspeaker-test 1.2.6\n \nPlayback device is hw:0\nStream parameters are 48000Hz, S16_LE, 2 channels\nUsing 16 octaves of pink noise\nRate set to 48000Hz (requested 48000Hz)\nBuffer size range from 64 to 1048576\nPeriod size range from 32 to 524288\nUsing max buffer size 1048576\nPeriods = 4\nwas set period_size = 262144\nwas set buffer_size = 1048576\n 0 - Front Left\n 1 - Front Right\n^CTime per period = 5.761266\n测试扬声器的时候，指定device为hw:0总能够发出声音，此时便想到很可能是系统默认的播放设备（playback）不对，因此按照archwiki上的教程设置了默认声卡。其实就是新建一个文件然后重启：\n# file: ~/.asoundrc\n \npcm.!default {\n   type hw\n   card PCH\n}\n \nctl.!default {\n   type hw\n   card PCH\n}\n重启之后果然立刻就有声音了，正当我被折腾成功的喜悦包围之时，我试着将耳机插入耳机孔，tmd根本就没效果。这部完犊子了吗，修好了外放，耳机失效了。接着就是一顿找，\nalsactl restore\n拯救了耳机的输出，但没有完全拯救，因为这个时候耳机和外部扬声器都有声音。也就是说，他不会根据耳机的插拔而切换输出了，而是两方都有输出。\n然而就是根据耳机插拔自动切换输出设备的功能，在我设置了默认声卡之后，一直得不到解决。此前，虽然需要插拔一下耳机，外部扬声器才能播放声音，好歹耳机的插拔还是能正常生效的。所以，我还是删掉了默认声卡的配置，转而寻求“开机后如何切换sound playback”。直到我找到参考1.\n其中提到”card-profile”这个概念，听起来像是声卡的情景模式，通过如下命令列出所有支持的card-profiles:\nyychi@~&gt; pacmd list-cards\n1 card(s) available.\n    index: 0\n\tname: &lt;alsa_card.pci-0000_00_1f.3&gt;\n\tdriver: &lt;module-alsa-card.c&gt;\n\towner module: 6\n\tproperties:\n\t\talsa.card = &quot;0&quot;\n\t\talsa.card_name = &quot;HDA Intel PCH&quot;\n\t\talsa.long_card_name = &quot;HDA Intel PCH at 0xb4220000 irq 135&quot;\n\t\talsa.driver_name = &quot;snd_hda_intel&quot;\n\t\tdevice.bus_path = &quot;pci-0000:00:1f.3&quot;\n\t\tsysfs.path = &quot;/devices/pci0000:00/0000:00:1f.3/sound/card0&quot;\n\t\tdevice.bus = &quot;pci&quot;\n\t\tdevice.vendor.id = &quot;8086&quot;\n\t\tdevice.vendor.name = &quot;Intel Corporation&quot;\n\t\tdevice.product.id = &quot;9d71&quot;\n\t\tdevice.product.name = &quot;Sunrise Point-LP HD Audio&quot;\n\t\tdevice.form_factor = &quot;internal&quot;\n\t\tdevice.string = &quot;0&quot;\n\t\tdevice.description = &quot;内置音频&quot;\n\t\tmodule-udev-detect.discovered = &quot;1&quot;\n\t\tdevice.icon_name = &quot;audio-card-pci&quot;\n\tprofiles:\n\t\tinput:analog-stereo: 模拟立体声 输入 (priority 32833, available: unknown)\n\t\toutput:analog-stereo: 模拟立体声 输出 (priority 39268, available: unknown)\n\t\toutput:analog-stereo+input:analog-stereo: 模拟立体声双工 (priority 39333, available: unknown)\n\t\toutput:hdmi-stereo: Digital Stereo (HDMI) 输出 (priority 5900, available: no)\n\t\toutput:hdmi-stereo+input:analog-stereo: Digital Stereo (HDMI) 输出 + 模拟立体声 输入 (priority 5965, available: unknown)\n\t\toutput:hdmi-surround: Digital Surround 5.1 (HDMI) 输出 (priority 800, available: no)\n\t\toutput:hdmi-surround+input:analog-stereo: Digital Surround 5.1 (HDMI) 输出 + 模拟立体声 输入 (priority 865, available: unknown)\n\t\toutput:hdmi-surround71: Digital Surround 7.1 (HDMI) 输出 (priority 800, available: no)\n\t\toutput:hdmi-surround71+input:analog-stereo: Digital Surround 7.1 (HDMI) 输出 + 模拟立体声 输入 (priority 865, available: unknown)\n\t\toutput:hdmi-stereo-extra1: Digital Stereo (HDMI 2) 输出 (priority 5700, available: no)\n\t\toutput:hdmi-stereo-extra1+input:analog-stereo: Digital Stereo (HDMI 2) 输出 + 模拟立体声 输入 (priority 5765, available: unknown)\n\t\toutput:hdmi-surround-extra1: Digital Surround 5.1 (HDMI 2) 输出 (priority 600, available: no)\n\t\toutput:hdmi-surround-extra1+input:analog-stereo: Digital Surround 5.1 (HDMI 2) 输出 + 模拟立体声 输入 (priority 665, available: unknown)\n\t\toutput:hdmi-surround71-extra1: Digital Surround 7.1 (HDMI 2) 输出 (priority 600, available: no)\n\t\toutput:hdmi-surround71-extra1+input:analog-stereo: Digital Surround 7.1 (HDMI 2) 输出 + 模拟立体声 输入 (priority 665, available: unknown)\n\t\toutput:hdmi-stereo-extra2: Digital Stereo (HDMI 3) 输出 (priority 5700, available: no)\n\t\toutput:hdmi-stereo-extra2+input:analog-stereo: Digital Stereo (HDMI 3) 输出 + 模拟立体声 输入 (priority 5765, available: unknown)\n\t\toutput:hdmi-surround-extra2: Digital Surround 5.1 (HDMI 3) 输出 (priority 600, available: no)\n\t\toutput:hdmi-surround-extra2+input:analog-stereo: Digital Surround 5.1 (HDMI 3) 输出 + 模拟立体声 输入 (priority 665, available: unknown)\n\t\toutput:hdmi-surround71-extra2: Digital Surround 7.1 (HDMI 3) 输出 (priority 600, available: no)\n\t\toutput:hdmi-surround71-extra2+input:analog-stereo: Digital Surround 7.1 (HDMI 3) 输出 + 模拟立体声 输入 (priority 665, available: unknown)\n\t\toutput:hdmi-stereo-extra3: Digital Stereo (HDMI 4) 输出 (priority 5700, available: no)\n\t\toutput:hdmi-stereo-extra3+input:analog-stereo: Digital Stereo (HDMI 4) 输出 + 模拟立体声 输入 (priority 5765, available: unknown)\n\t\toutput:hdmi-surround-extra3: Digital Surround 5.1 (HDMI 4) 输出 (priority 600, available: no)\n\t\toutput:hdmi-surround-extra3+input:analog-stereo: Digital Surround 5.1 (HDMI 4) 输出 + 模拟立体声 输入 (priority 665, available: unknown)\n\t\toutput:hdmi-surround71-extra3: Digital Surround 7.1 (HDMI 4) 输出 (priority 600, available: no)\n\t\toutput:hdmi-surround71-extra3+input:analog-stereo: Digital Surround 7.1 (HDMI 4) 输出 + 模拟立体声 输入 (priority 665, available: unknown)\n\t\toutput:hdmi-stereo-extra4: Digital Stereo (HDMI 5) 输出 (priority 5700, available: no)\n\t\toutput:hdmi-stereo-extra4+input:analog-stereo: Digital Stereo (HDMI 5) 输出 + 模拟立体声 输入 (priority 5765, available: unknown)\n\t\toutput:hdmi-surround-extra4: Digital Surround 5.1 (HDMI 5) 输出 (priority 600, available: no)\n\t\toutput:hdmi-surround-extra4+input:analog-stereo: Digital Surround 5.1 (HDMI 5) 输出 + 模拟立体声 输入 (priority 665, available: unknown)\n\t\toutput:hdmi-surround71-extra4: Digital Surround 7.1 (HDMI 5) 输出 (priority 600, available: no)\n\t\toutput:hdmi-surround71-extra4+input:analog-stereo: Digital Surround 7.1 (HDMI 5) 输出 + 模拟立体声 输入 (priority 665, available: unknown)\n\t\toff: 关 (priority 0, available: unknown)\n\tactive profile: &lt;output:hdmi-stereo-extra1+input:analog-stereo&gt;\n\tsinks:\n\t\talsa_output.pci-0000_00_1f.3.hdmi-stereo-extra1/#0: 内置音频 Digital Stereo (HDMI 2)\n\tsources:\n\t\talsa_output.pci-0000_00_1f.3.hdmi-stereo-extra1.monitor/#0: Monitor of 内置音频 Digital Stereo (HDMI 2)\n\t\talsa_input.pci-0000_00_1f.3.analog-stereo/#1: 内置音频 模拟立体声\n\tports:\n\t\tanalog-input-mic: Microphone (priority 8700, latency offset 0 usec, available: unknown)\n\t\t\tproperties:\n\t\t\t\tdevice.icon_name = &quot;audio-input-microphone&quot;\n\t\tanalog-output-speaker: Speakers (priority 10000, latency offset 0 usec, available: unknown)\n\t\t\tproperties:\n\t\t\t\tdevice.icon_name = &quot;audio-speakers&quot;\n\t\tanalog-output-headphones: Headphones (priority 9900, latency offset 0 usec, available: no)\n\t\t\tproperties:\n\t\t\t\tdevice.icon_name = &quot;audio-headphones&quot;\n\t\thdmi-output-0: HDMI / DisplayPort (priority 5900, latency offset 0 usec, available: no)  # available: yes if headphone plugged\n\t\t\tproperties:\n\t\t\t\tdevice.icon_name = &quot;video-display&quot;\n\t\thdmi-output-1: HDMI / DisplayPort 2 (priority 5800, latency offset 0 usec, available: no)\n\t\t\tproperties:\n\t\t\t\tdevice.icon_name = &quot;video-display&quot;\n\t\thdmi-output-2: HDMI / DisplayPort 3 (priority 5700, latency offset 0 usec, available: no)\n\t\t\tproperties:\n\t\t\t\tdevice.icon_name = &quot;video-display&quot;\n\t\thdmi-output-3: HDMI / DisplayPort 4 (priority 5600, latency offset 0 usec, available: no)\n\t\t\tproperties:\n\t\t\t\tdevice.icon_name = &quot;video-display&quot;\n\t\thdmi-output-4: HDMI / DisplayPort 5 (priority 5500, latency offset 0 usec, available: no)\n\t\t\tproperties:\n\t\t\t\tdevice.icon_name = &quot;video-display&quot;\n \n接着\npacmd set-card-profile alsa_card.pci-0000_00_1f.3 output:analog-stereo+input:analog-stereo\n设置声卡的情景模式，敲完之后外部扬声器就有声音了，而且耳机插拔也是正常生效的。值得注意的是，插入耳机后，上述注释处就变成yes了。\n这个问题暂时解决到这里，等以后有时间看能否完全解决！\n当天更新：重启之后发现不用重新再走一遍上述流程，可以看到”active profile: output:hdmi-stereo-extra1+input:analog-stereo”已经持久化改变了。那么这个问题就算解决啦！\nReferences\n\nHow can I switch between different audio output hardware using the shell?\nArchwiki: Advanced Linux Sound Architecture\n[SOLVED] sound not working\n"},"Blogs/post/melody-theme-customization":{"slug":"Blogs/post/melody-theme-customization","filePath":"Blogs/post/melody-theme-customization.md","title":"Melody 主题的一些个人更改","links":[],"tags":["美化","个性化"],"content":"更改字体\nMelody 主题字体配置文件在 $BLOG/themes/melody/source/css/var.styl，其中 $BLOG 为 Hexo 博客根目录。截取一段如下：\n// Global Variables\n$font-size = 16px\n$font-color = #1F2D3D\n$rem = 20px\n$font-family = Martel Sans, Spectral, Lato, Helvetica Neue For Number, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, PingFang SC, Hiragino Sans GB, Microsoft YaHei, Helvetica Neue, Helvetica, Arial, sans-serif\n$code-font = Monaco, consolas, Menlo, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, monospace, Helvetica Neue For Number\n$text-line-height = 2\n这样的话就可以使用自定义的字体 Martel Sans 了。但是这仅限于在本地使用，因为别人的计算机中可能没有这个字体。所以必须制定网页去哪儿加载这个字体。一个方法是，将你系统的字体文件复制到博客根目录的 source/fonts 文件夹。\n\ncp /usr/share/fonts/userfonts/MartelSans-Regular.ttf $BLOG/source/fonts/\n然后编辑主题文件夹下的 index.styl 文件，在文件末尾加上\n// $BLOG/themes/melody/source/css/index.styl\n...\n...\n \n// custom fonts\n@font-face{\n  font-family: Martel Sans;\n  src: url(&#039;/fonts/MartelSans-Regular.ttf&#039;);\n}\n \n// 要添加多个字体，亦复如是\n@font-face{\n  font-family: IM FELL DW Pica;\n  src: url(&#039;/fonts/IMFePIrm28P.ttf&#039;);\n}\n在修改完这个文件之后，运行 hexo clean &amp;&amp; hexo g 则会自动在生成的 CSS 文件中加上这段代码，使用指定字体。具体请看\n// $BLOG/public/css/index.css\n...\n...\n \n@font-face {\n  font-family: Martel Sans;\n  src: url(&quot;/fonts/MartelSans-Regular.ttf&quot;);\n}\n@font-face {\n  font-family: IM FELL DW Pica;\n  src: url(&quot;/fonts/IMFePIrm28P.ttf&quot;);\n}\n\n\n从上面两张图可以看出，指定的字体是从网络加载而非本地。这样以来，执行 hexo deploy 命令部署之后，指定字体将会从正确的网络地址被加载，从而正确应用。\n去除hrline的动画效果\nMelody主题对于默认的hrline分割线做了效果，我不太喜欢，认为有失简约，移除之。另外hrline的上下间距也改小了一点。\n// $BLOG/themes/melody/source/css/_global/index.styl\n \nhr\n  position: relative\n  margin: 1.1rem auto\n  width: calc(100% - 4px)\n  border: 2px dashed $pale-blue\n  background: $white\n \n## add by yychi for removing the\n## animation of hrline, 2019-3-16\n#  &amp;:hover\n#    &amp;:before\n#      left: calc(95% - 20px)\n \n  &amp;:before\n    position: absolute\n    top: -10px\n    left: 5%\n    z-index: 1\n    color: $light-blue\n    content: &quot;\\f0c4&quot;\n    font: normal normal normal 14px / 1 FontAwesome\n    font-size: 20px\n    transition: all 1s ease-in-out\n去除列表样式\nMelody主题对markdown的有序和无序列表做了css样式，不喜，移除之。\n// $BLOG/themes/melody/source/css/_layout/post.styl\n \n// add by yychi for removing the\n// ol,ul styles\n// 2019-3-16\n// 注释掉以下全部代码即可\n \nol,\nul\n  margin-top: 0.4rem\n  padding: 0 0 0 0.8rem\n  list-style: none\n  counter-reset: li\n \n  p\n    margin: 0\n \n  ol,\n  ul\n    padding-left: 0.5rem\n \n  li\n    position: relative\n    margin: 0.2rem 0\n    padding: 0.1rem 0.5rem 0.1rem 1.5rem\n \n    &amp;:hover\n      &amp;:before\n        transform: rotate(360deg)\n \n    &amp;:before\n      position: absolute\n      top: 0\n      left: 0\n      background: $light-blue\n      color: #FF0000\n      cursor: pointer\n      transition: all 0.3s ease-out\n \nol\n  &gt; li\n    &amp;:before\n      margin-top: 0.2rem\n      width: w = 1.2rem\n      height: h = w\n      border-radius: 0.5 * w\n      content: counter(li)\n      counter-increment: li\n      text-align: center\n      font-size: 0.6rem\n      line-height: h\n \nul\n  &gt; li\n    &amp;:hover\n      &amp;:before\n        border-color: $ruby\n \n    &amp;:before\n      $w = 0.3rem\n      top: 10px\n      margin-left: 0.45rem\n      width: w = $w\n      height: h = w\n      border: 0.5 * w solid $light-blue\n      border-radius: w\n      background: $white\n      content: &quot;&quot;\n      line-height: h\nReference\n\nUse multiple @font-face rules in CSS\nNext主题自定义CSS样式（字体）\n使用自定义字体\n"},"Blogs/post/metapost":{"slug":"Blogs/post/metapost","filePath":"Blogs/post/metapost.md","title":"Metapost学习笔记","links":[],"tags":["metapost","作图"],"content":"想必你也有过这样的疑问，中学数学书上的那些精美的作图是如何画出来的？一直以来，我都想学习一门绘图语言，只是久久未能行动orz…\n\n闲话少叙，开始学习！\nMetapost\n介绍什么的，我其实不太关心，所以就不写了……\n一个简单的例子\n和C语言一样，Metapost有一个源文件xxx.mp，有一个编译器mpost，然后编译之，即得到图片（默认后缀.mps）。\n% file:///hello.mp\nprologues := 3;\noutputtemplate := &quot;%j-%c.mps&quot;;\noutputformat := &quot;mps&quot;;\n \nbeginfig(1);\n  draw (0,0)--(11,0)--(11,11)--(0,11)--cycle;\nendfig;\n \nbeginfig(2);\n  draw (0,0)..(11,0)..(11,11)..(0,11)..cycle;\nendfig;\nend\n几点说明：\n\nMetapost语句以分号结尾，除了最后的end!\n设置prologues:=3会在生成的图像文件.ps中嵌入字体信息，这会增加图片大小\n默认单位：PostScript Points (1/72in = 0.352777… mm)\n\n这里简单说一下源码结构，和LaTeX一样，Metapost有导言区，可以做一些设置之类的工作。如hello.mp中前三句就设置了输出文件格式，以及文件名规范等。然后作图部分主要由beginfig--endfig块控制。\nbeginfig(x);\n  draw something;\n  draw anything;\nendfig;\n括号中的x替换为数字，类似图片id. 一个源文件中可以有多个beginfig--endfig块，编译后每个块对应一张图片。\n编译hello.mp后即可得到两张图片：\n$ mpost hello.mp\nThis is MetaPost, version 2.00 (TeX Live 2018) (kpathsea version 6.3.0)\n(/usr/local/texlive/2018/texmf-dist/metapost/base/mpost.mp\n(/usr/local/texlive/2018/texmf-dist/metapost/base/plain.mp\nPreloading the plain mem file, version 1.005) ) (./hello.mp [1] [2] )\n2 output files written: hello-1.mps .. hello-2.mps\nTranscript written on tmp.log.\n\n\n    \n    \n    Fig-1\n\n\n    \n    \n    Fig-2\n\n\nMetapost按坐标画图非常简单，将坐标点一个一个连起来就行了，注意到--表示直线连接，..表示平滑的曲线连接。和众多编程语言一样，你也可以定义变量方便重复使用。\nbeginfig(3);\n  z0 = (0,0);\n  z1 = (60,40);\n  z2 = (40,90);\n  z3 = (10,70);\n  z4 = (30,50);\n  draw z0..z1..z2..z3..z4;\nendfig\n\n  \n    \n    \n  \n  Fig-3\n\nWorkflow\n使用默认输出格式会产生PostScript格式的图片，在Linux下可以用gnome中的evince查看。也可以使用epstopdf转化为PDF查看。\n\n  \n  \n  \n  Image adapted from ref1\n\nPrimitives\n变量类型\nMetapost几个常见的类型：\n\npair: (0,0) and (3,4)\npath: (0,0)—(3,4)\npen: (implicit) pen for stroking\n\n比如：\nbeginfig(0)\n  u:=1cm;\n  pair a,b; path p; pen mypen;\n  a = (0,0); b = (3u,4u);\n  p = a--b;\n  mypen = pencircle scaled 1mm;\n  pickup mypen;\n  draw p;\nendfig;\n\nAll MetaPost variable types:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTypeExamplenumeric(default, if not explicitly declared)pairpair a; a := (2in,3mm);                   booleanboolean v; v := false;                    pathpath p; p := fullcircle scaled 5mm;       penpen r; r := pencircle;                    picturepicture q; q := nullpicture;              transformtransform t; t := identity rotated 20;    colorcolor c; c := (0,0,1); (blue)cmykcolorcmykcolor k; k := (1,0.8,0,0); (some blue)stringstring s; s := &quot;Hello&quot;;                   \n弯曲控制\n我们已经知道使用..可以让Metapost在两点之间画出平滑的曲线，尽管它画的很好（默认使用贝塞尔曲线），但有时候我们往往需要控制哪里该要陡一点，哪里平缓一点。对于这种需求，Metapost同样提供了精细粒度的控制方法。\nbeginfig(4);\n  for i=0 upto 9:\n    draw (0,0){dir 45}..{dir 10a}{6cm, 0};\n  endfor\nendfig;\n\n  \n     \n    \n  \n  Fig-4\n\n可以看出，从图上起点（左边的点），对应坐标(0,0)，引出一族曲线，这些曲线在(0,0)处的左极限都是1，呈现出45度角。而在终点(6cm,0)处的入角从0度到90度变化，正如语句中描述的。\n未完待续……\n\nReference\n\nWhich Output file should I export from Metapost?\nMetapost for Beginners\nLearning METAPOST by Doing\nTutorial in MetaPost\n"},"Blogs/post/nice-softwares":{"slug":"Blogs/post/nice-softwares","filePath":"Blogs/post/nice-softwares.md","title":"小内存机器的自我救赎","links":["Blogs/post/tricks.html/"],"tags":[],"content":"在此记录一下我自己用过的非常棒的小软件。\n下载\n\naria2c: 命令行下载工具，支持下载种子、磁力等。有RPC模式，配合WebUI使用更佳。参考简介。\n\n多媒体\n\nmpv: 命令行多媒体播放器，拥有较强的扩展性和自定义的空间，另外我自己体验上来看比mplayer要流畅，mplayer在我的机子上有丢帧，而mpv无明显丢帧。\nmpd/mpc: 音乐播放，没有界面。mpd作为服务端，mpc作为客户端，占用内存非常低。\n\n文档\n\nzathura: A vim-like pdf reader. vim系快捷键，小而轻，但功能也相对较少。\n\n截图\n\nflameshot: gnome-screenshot的替代品，支持截图后标记，复制到剪贴板；平台：Linux\n\nflameshot gui: 直接打开截屏功能，更多参考flameshot -h.\n\n\npeek: 小巧易用的录屏软件，支持录制gif, mp4, webm等格式。\n\n效率\n\nxpad: 小而轻的桌面便签。\nTaskwarrior: A command-line todo manager, 不要因为它的强大而忘记使用它的初衷。\nranger: File manager in terminal, 三页分栏显示文件树，支持文件预览（需安装对应依赖），支持自定义命令，书签等。\nrofi: dmenu替代品，窗口切换，应用启动器，简约大方，纯文本构成。\n\n学习\n\nGoldenDict: 离线词典，支持在线页面查词，接有道，维基等，可以看做是Linux上的Eudic，支持多种离线字典格式，支持自定义快捷键查找剪贴板中的单词。\n"},"Blogs/post/nn-notes":{"slug":"Blogs/post/nn-notes","filePath":"Blogs/post/nn-notes.md","title":"Nueral Network Learning Notes","links":[],"tags":["cnn"],"content":"Hello here.\nCNN\nConv Layer\nConv Layer is usually decreasing the input size, i.e., the output size may less or equal than input.\n\ntake a volume as input: height x weight x depth, e.g., 32x32x3. Typically think an image having three channels: R, G, B.\na filter has the same depth as the input volume, e.g., 5x5x3 (since the filter always has a same depth as input vloume, the depth of the filter is sometimes omitted).\neach filter convolving with the input will produce an activation map, two filters will produce two, etc.\n\nThe result of the convolution at each location is just a scalar number (the result of taking a dot product between the filter and a small chunk of the image, i.e., 5\\times 5 \\times 3 = 75-dimensional dot product + bias: w^\\top x + b), which totally yields a 2D matrix (called activation map) as the filter sliding over the image. For example, 32x32x3 image convolved by 5x5x3 filter will yield a 28x28 activation map.\nConvNet is a sequence of convolution layers, interspersed with activation functions.\nLet’s find out how the spatial dimensions change (since the depth of input and filter will always match, and then shrinks to 1 in actication map). Suppose we have 7x7 input spatially, 3x3 filter, then we have 5x5 output. If applied with stride 2, then 3x3 output. What about stride 3? Oh, it doesn’t fit, you cannot apply 3x3 filter on 7x7 input with stride 3.\nOutput size: (N-F)/stride + 1 for NxN input, FxF filter.\nTake padding into account since it’s common to zero pad the border. E.g., 7x7 input, 3x3 filter, applied with stride 1, pad with 1 pixel border, what is the output? Oh, it’s 7x7 output! In general, common to see CONV layers with stride 1, filters of size FxF, and zero-padding with (F-1)/2, which will perserve size spatially.\nOutput size: (N + 2\\times padding - F) / stride + 1.\nTrain yourself, 32x32x3 input, 10 5x5 filters with stride 1, pad 2, what is the output volume size? Oh, 32x32x10 output! What is the number of parameters in this layer? Oh, (5 \\times 5 \\times 3 + 1) \\times 10 = 760, plus 1 for bias.\nTo summarize, the Conv Layer:\n\nAccepts a volume of size W_1 \\times H_1 \\times D_1\nRequires four hyperparameters:\n\nNumber of filters K,\ntheir spatial extent F,\nthe stride S,\nthe amount of zero padding P.\n\n\nProduces a volume of size W_2 \\times H_2 \\times D_2 where:\n\nW_2 = (W_1 − F + 2P)/S+1\nH_2 = (H_1−F+2P)/S+1 (i.e. width and height are computed equally by symmetry)\nD_2=K\n\n\nWith parameter sharing, it introduces F\\cdot F\\cdot D_1 weights per filter, for a total of (F\\cdot F\\cdot D_1)\\cdot K weights and K biases.\nIn the output volume, the d-th depth slice (of size W_2 \\times H_2) is the result of performing a valid convolution of the d-th filter over the input volume with a stride of S, and then offset by d-th bias.\n\nA common setting of the hyperparameters is F=3,S=1,P=1. However, there are\ncommon conventions and rules of thumb that motivate these hyperparameters.\nF is usually odd, K is usually power of 2 for computation efficiency.\nConvTranspose Layer\nConvTranspose Layer is usually increasing the input size, i.e., the output size is greater or equal than input.\nConvTranspose is also called transposed convolution, deconvolution, etc.\nFor convenience, we first summarize, the ConvTanspose layer:\n\nAccepts a volume of size W_1 \\times H_1 \\times D_1\nRequires four hyperparameters:\n\nNumber of filters K,\ntheir spatial extent F,\nthe stride S,\nthe amount of zero padding P.\n\n\nProduces a volume of size W_2 \\times H_2 \\times D_2 where:\n\nW_2 = S(W_1 − 1) + F - 2P\nH_2 = S(H_1−1) + F - 2P (i.e. width and height are computed equally by symmetry)\nD_2=K\n\n\n\nThe following isn’t that correct.\nThen what on earth does transposed convolution do? In fact, a transposed convolution has an associated convolution with F \\times F filter, 1/S stride, (F-P-1) padding, here i haven’t configured it out. Recall that, the layer requires four parameters while K does not affect the spatial size (W \\times H).\nSo if we have a square input volumn of size I \\times I \\times D, and we pass it into an ConvTranspose Layer with parameter (K, F, S, P), then the output has shape:\n\\begin{split}\n  O &amp;= \\frac{I + 2(F-P-1) - F}{1/S} + 1 =\n\\end{split}\nPooling Layer\n\nmakes the representations smaller and more manageable\noperates over each activation map independently\n\nIntuition of max pooling: select the neuron whose response is maximal.\nReferences\n\ncs231n winter 2016\ncs231n notes\nConvolution arithmetic tutorial\nconv_arithmetic\n"},"Blogs/post/python-coroutine-with-yield":{"slug":"Blogs/post/python-coroutine-with-yield","filePath":"Blogs/post/python-coroutine-with-yield.md","title":"使用 Yield 实现 Python 协程","links":["Blogs/post/yield_chain.py.html"],"tags":["python","coroutine"],"content":"考虑如下代码：\ndef async_call(it, ret_list=None):\n    try:\n        value = ret_list[0] if ret_list and len(ret_list) == 1 else ret_list\n        arg_list = it.send(value)\n    except StopIteration:\n        return\n \n    if type(arg_list) in (list, tuple):\n        imp_func, args = arg_list[0], list(arg_list[1:])\n    else:\n        imp_func, args = arg_list, []\n \n    callback = lambda *cb_args: async_call(it, cb_args)\n    imp_func(*args, callback=callback)\n \ndef make_async(func):\n    def _wrapper(*args, **kwargs):\n        async_call(func(*args, **kwargs))\n    return _wrapper\n \ndef fd(_idx, callback):\n    print(&quot;fd(%s, %s)&quot; % (_idx, callback))\n    # return &#039;EOF&#039;\n    callback(&#039;fd:%s&#039; % _idx)\n \n@make_async\ndef fb(_idx, callback):\n    print(&quot;fb(%s, %s)&quot; % (_idx, callback))\n    ret = yield fd, _idx\n    callback(&#039;fb:%s&#039; % ret)\n \ndef fc(_idx, callback):\n    print(&quot;fc(%s, %s)&quot; % (_idx, callback))\n    callback(&#039;fc:%s&#039; % _idx)\n \n@make_async\ndef fa(*args, **kwargs):\n    print(&quot;fa(%s, %s)&quot; % (args, kwargs))\n    for idx in range(2):\n        if idx % 2 == 0:\n            f = fb\n        else:\n            f = fc\n        ret = yield f, idx\n        print(&quot;%sth iteration: ret in fa is %s&quot; % (idx, ret))\n \nif __name__ == &#039;__main__&#039;:\n    fa()\n以上代码的运行结果为：\nfa((), {})\nfb(0, &lt;function async_call.&lt;locals&gt;.&lt;lambda&gt; at 0x7fb2070263b0&gt;)\nfd(0, &lt;function async_call.&lt;locals&gt;.&lt;lambda&gt; at 0x7fb207026440&gt;)\n0th iteration: ret in fa is fb:fd:0\nfc(1, &lt;function async_call.&lt;locals&gt;.&lt;lambda&gt; at 0x7fb2070264d0&gt;)\n1th iteration: ret in fa is fc:1\n\n试着分析上述输出：\n\nfa本来是个generator，在decorator的作用下（decorator首先调用了it.send(None)）被激活，fa.print句输出\nfa执行到yield，此时f=fb，于是程序跳转到fb，但fb也是个generator，没关系，同样在decorator的作用下被激活，于是fb.print句输出\nfb执行到yield，程序跳转到fd(普通函数)，于是fd.print句输出\nfd执行到callback，这个callback是啥呢，暂且相信它是lambda *cb_args: async_call(it_of_fb, cb_args)，所以callback(&#039;fd:0&#039;)展开为async_call(it_of_fb, &#039;fd:0&#039;)，然后async_call执行到it_of_fb.send(&#039;fd:0&#039;)，这就驱使generator fb从yield处（紧随其后）开始继续执行；然后控制流来到了fb中的callback(&#039;fb:fd:0&#039;)，这个callback是谁呢？暂且相信它是lambda *cb_args: async_call(it_of_fa, cb_args)，所以展开为async_call(it_of_fa, &#039;fb:fd:0&#039;)，这就驱使generator fa从yield处resume，fa.print句输出\nfa再入循环，此时idx=1, f=fc，执行到yield，控制流跳转到fc(一个普通函数)，很好，于是fc.print句输出\nfc执行到callback，很好，想必大家都知道这个callback是lambda *cb_args: async_call(it_if_fa, cb_args)，展开为async_call(it_of_fa, &#039;fc:1&#039;)，这就驱使generator fa从yield处resume，并接收到ret=&#039;fc:1&#039;，fa.print句输出\n接着开始退栈，首先generator fa迭代结束，抛出异常被async_call捕获并结束；然后别忘了我们从何而来，我们从fc.callback而来，callback执行结束，fc退栈；而我们从哪里执行到fc的呢，我们从fb中的callback通过generator的控制流乱窜到fc，现在他执行完了，也就是说fb.callback执行完了，fb抛出异常被async_call捕获并结束；我们从哪里来到fb.callback呢，从fd.callback，于是fd结束，退栈。\n\n可以看到，退栈顺序并不是按照进入顺序的逆序而来的。这是因为控制流在yield和generator.send之间反复横跳的缘故。\n如果将23行（fd中return句）注释去掉，则运行结果为：\nfa((), {})\nfb(0, &lt;function async_call.&lt;locals&gt;.&lt;lambda&gt; at 0x7fd1750b5ea0&gt;)\nfd(0, &lt;function async_call.&lt;locals&gt;.&lt;lambda&gt; at 0x7fd1750b6050&gt;)\n\n试着分析一下：\n\n同上\n同上\n同上\n控制流来到fd，但这时，fd不走callback，而是直接return了。而我们是从哪里进到fd的呢，是从fb中的yield句，其实执行yield，会将控制流返回到async_call中的it.send(value)句（紧随其后），然后走到async_call的最后一句，开始执行fd，然后fd结束，然后async_call结束，然后上一层async_call结束，…, 接着整个程序结束。fayield之后的代码根本不会执行到。因为底下人不配合它（不调用callback，进而引起上层函数调不到callback，进而引起generator无法驱动），程序看起来就像夭折了一样。\n\n读者试着思考一下，是否能够模拟程序执行流程？（上面暂时看不懂没关系，看完下文，再回头看应该会更好理解一些。）\n为了搞清楚这段代码的执行流程，我们必须先搞清楚一些概念。\nGenerator简介\n在python中，generator的通俗理解是：一个函数如果含有yield语句，则称这个函数是一个generator function，对该函数的调用生成一个generator.\nGenerator it生成之后，不会立刻执行，除非对其迭代（使用next(it)，for循环遍历等）。并且生成器每次执行到yield语句都会挂起，并将yield之后的表达式返回给调用者，直到再次迭代，会从yield语句之后继续执行。\n更多概念参考: docs.python.org/3/glossary.html#term-generator\nGenerator.send\nGenerator有一个重要的方法：generator.send(value). 它可以恢复generator的执行并且给generator function内部发送一个value. 具体参见相关文档，注意send和next的区别。\n下面给出一个例子：\n&gt;&gt;&gt; def a():\n...     i = 0\n...     while i &lt; 3:\n...             x = yield i\n...             i += 1\n...             print(&quot;after yield: x=%s, i=%s&quot; % (x, i))\n... \n&gt;&gt;&gt; it = a()\n&gt;&gt;&gt; it.send(None)\n0\n&gt;&gt;&gt; it.send(11)\nafter yield: x=11, i=1\n1\n&gt;&gt;&gt; it.send(22)\nafter yield: x=22, i=2\n2\n&gt;&gt;&gt; it.send(33)\nafter yield: x=33, i=3\nTraceback (most recent call last):\n  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;\nStopIteration\n&gt;&gt;&gt; \n官方描述it.send(None)等价于next(it)。且看上述代码，\n第一次send(None)为激活generator，此时generator执行到yield，并将i(=0)返回\n第二次send(11)，恢复generator的执行，并将11发送给generator function，赋值给x，于是打印出x=11, i=1\n第三次send(22)，恢复generator的执行，并将22发送给generator function, 赋值给x，于是打印出x=22, i=2\n第四次send(33)，恢复generator的执行，并将22发送给generator function, 赋值给x，于是打印出x=33, i=3，\n但由于此时generator已经不会再产生新值，亦即正常退出，于是send函数抛出StopIteration异常\n\n注意上述代码最后一次执行it.send(33)，可以看到，print函数成功打印出结果，此时i=3，不再进入循环，“函数正常”退出。但那仅仅是针对常规函数，对于generator，如果不再产生新值，会抛出一个StopIteration的异常。\nPEP 342提到: The send() method returns the next value yielded by the generator, or raises StopIteration if the generator exits without yielding another value.\nGenerator及其send方法是我们读懂文首代码的两个基本点，其中所有控制流跳变的地方都有他俩的身影。猛击此处获取源文件。\n利用generator和send实现的协程\nto be continued…\nReferences\n\nPython doc: yield expressions\n廖雪峰-协程\nPEP 342 – Coroutines via Enhanced Generators\n"},"Blogs/post/python-iterables":{"slug":"Blogs/post/python-iterables","filePath":"Blogs/post/python-iterables.md","title":"Python Iterables","links":[],"tags":["python"],"content":"Python的迭代器（iterator）、生成器（generator）、可迭代对象（iterable），虽是老生常谈，但我毕竟要记录一下自己的见解，因有此篇。\nIterable 和 Iterator\n为了理解generator，必须先搞清楚iterable和iterator1。\n\n\nAn iterable object is an object that implements __iter__, which is expected to return an iterator object.\nAn iterator is an object that implements __next__, which is expected to return the next element of the iterable object that returned it, and raise a StopIteration exception when no more elements are available.\n\n\n讲真，iterable和iterator的定义就是这么的朴实无华。但要彻底理解，还需费些功夫。先来看个例子：\nclass MyIterator(object):\n    def __init__(self, data):\n        self.data = data\n        self.cur = 0\n \n    def __next__(self):\n        if self.cur &lt; len(self.data):\n            self.cur += 1\n            return self.data[self.cur - 1]\n        else:\n            raise StopIteration\n \n \nclass MyIterable(object):\n    data = [4,3,2,1]\n    def __iter__(self):\n        return MyIterator(self.data)\n \nmy_iterable = MyIterable()\nfor x in my_iterable:\n    print(x)\n \n&gt;&gt;&gt; 4\n&gt;&gt;&gt; 3\n&gt;&gt;&gt; 2\n&gt;&gt;&gt; 1\n上面实现了一个iterable和iterator，iterable必须实现__iter__方法，并返回一个iterator，在上面的例子中我返回了自己实现的一个iterator。当然也可以这样写：\nclass MyIterable(object):\n    data = [4,3,2,1]\n    cur = 0\n    def __iter__(self):\n        return self\n \n    def __next__(self):\n        if self.cur &lt; len(self.data):\n            self.cur += 1\n            return self.data[self.cur - 1]\n        else:\n            raise StopIteration\n \nmy_iterable = MyIterable()\nfor x in my_iterable:\n    print(x)\n \n&gt;&gt;&gt; 4\n&gt;&gt;&gt; 3\n&gt;&gt;&gt; 2\n&gt;&gt;&gt; 1\n此时MyIterable既是iterable又是iterator。那既然能够写在一起，为什么聪明的人们要把这两个概念区分开呢？以下2给出了部分解释：\n\nIterators and iterables can be separate objects, but they don’t have to. Nothing is holding us back here. If you want, you can create a single object that is both an iterator and an iterable. You just need to implement both __iter__ and __next__.\nSo why did the wise men and women building the language decide to split these concepts? It has to do with keeping state. An iterator needs to maintain information on the position, e.g. the pointer into an internal data object like a list. In other words: it must keep track of which element to return next.\nIf the iterable itself maintains that state, you can only use it in one loop at a time. Otherwise, the other loop(s) would interfere with the state of the first loop. By returning a new iterator object, with its own state, we don’t have this problem. This comes in handy especially when you’re working with concurrency.\n\nFor 循环\nPython中的for x in y要求y为iterable，具体地，以下两段代码效果相同：\nfor x in y:\n    print(x)\n \n# &lt;==&gt;\n \nit = iter(y)\ntry:\n    a = next(it)\n    print(a)\nexcept StopIteration:\n    break\n以上遗漏一点：\n\nPython expects iterable objects in several different contexts, the most important being the for statement. In the statement for X in Y, Y must be an iterator or some object for which iter() can create an iterator. These two statements are equivalent:\nfor i in iter(obj):\n    print(i)\n \nfor i in obj:\n    print(i)\n\nNote that you can only go forward in an iterator; there’s no way to get the previous element, reset the iterator, or make a copy of it. Iterator objects can optionally provide these additional capabilities, but the iterator protocol only specifies the __next__() method. Functions may therefore consume all of the iterator’s output, and if you need to do something different with the same stream, you’ll have to create a new iterator.\nGenerator Expressions and List Comprehensions\n生成器表达式和列表推导式是Python中常用的两个语法。列表推导式生成一个列表，生成表达式生成一个iterator。看下面的例子：\ndef test2():\n    lst = [1, -2, 3, -4]\n    ge = (abs(x) for x in lst)\n    lc = [abs(x) for x in lst]\n    print(ge, type(ge))\n    print(lc, type(lc))\n    print(next(ge), iter(ge))\n    print(ge.__next__(), ge.__iter__())\n    for x in ge:\n        print(x)\n    for x in ge:\n        print(x)\n \n&gt;&gt;&gt; &lt;generator object test2.&lt;locals&gt;.&lt;genexpr&gt; at 0x7f5221c61f90&gt; &lt;class &#039;generator&#039;&gt;\n&gt;&gt;&gt; [1, 2, 3, 4] &lt;class &#039;list&#039;&gt;\n&gt;&gt;&gt; 1 &lt;generator object test2.&lt;locals&gt;.&lt;genexpr&gt; at 0x7f5221c61f90&gt;\n&gt;&gt;&gt; 2 &lt;generator object test2.&lt;locals&gt;.&lt;genexpr&gt; at 0x7f5221c61f90&gt;\n&gt;&gt;&gt; 3\n&gt;&gt;&gt; 4\n可以看到，列表推导式直接生成一个列表，而生成表达式则是返回一个iterator，并且它也是一个iterable。值得注意的是：\n\n列表推导式使用[]包围\n生成表达式使用()包围\ngenerator是iterator\niterator只能遍历一次，当元素耗尽，再次遍历直接抛出StopIteration\n\n\n可将iterator理解为只能遍历一次的iterable。\n\n特别地，以下代码等价：\n( expression for expr in sequence1 if condition1\n             for expr2 in sequence2 if condition2\n             ...\n             for exprN in sequenceN if conditionN )\n \n# &lt;==&gt;\nfor expr1 in sequence1:\n    if not (condition1):\n        continue   # Skip this element\n    for expr2 in sequence2:\n        if not (condition2):\n            continue   # Skip this element\n        ...\n        for exprN in sequenceN:\n            if not (conditionN):\n                continue   # Skip this element\n            # Output the value of the expression.\nGenerator Function\npass, to be continued…\nFootnotes\n\n\nIterator ↩\n\n\nPython iterator basics (how they work + examples) ↩\n\n\n"},"Blogs/post/python-metaclass":{"slug":"Blogs/post/python-metaclass","filePath":"Blogs/post/python-metaclass.md","title":"A point of python metaclass","links":[],"tags":["python"],"content":"Create class dynamically\nPython doc says:\n\nBy default, classes are constructed using type(). The class body is executed in a new namespace and the class name is bound locally to the result of type(name, bases, namespace).\n\nThat’s means, a class statement is equivalent to the call of type method with three arguments:\n\nname: name of the class\nbases: tuple of the parent class (for inheritance, can be empty)\nattrs: dictionary containing attributes names and values.\n\nFor example, the following classes are identical:\nclass A(object):\n    def __init__(self):\n        self.a = 1\n \ntmp = type(&#039;A&#039;, (object,), {&#039;a&#039;: 1})\nA = tmp\nas verified by the picture below：\n\nThe type function is special:\n\nWith one argument, return the type of an object. The return value is a type object and generally the same object as returned by object.__class__.\nWith three arguments, return a new type object. This is essentially a dynamic form of the class statement. The name string is the class name and becomes the __name__ attribute. The bases tuple contains the base classes and becomes the __bases__ attribute; if empty, object, the ultimate base of all classes, is added. The dict dictionary contains attribute and method definitions for the class body; it may be copied or wrapped before becoming the __dict__ attribute.\n\nIn other words, type is the factory method creating python classes.\nThe class creation process\nThe class creation process can be customized by passing the metaclass keyword argument in the class definition line, or by inheriting from an existing class that included such an argument. In the following example, both MyClass and MySubclass are instances of Meta:\nclass Meta(type):\n    pass\n \nclass MyClass(metaclass=Meta):\n    pass\n \nclass MySubclass(MyClass):\n    pass\nAny other keyword arguments that are specified in the class definition are passed through to all metaclass operations described below.\nWhen a class definition is executed, the following steps occur:\n\nMRO entries are resolved;\nthe appropriate metaclass is determined;\nthe class namespace is prepared;\nthe class body is executed;\nthe class object is created.\n\nHere comes our leading role: metaclass, the following is captured from what are metaclasses in python:\nMetaclasses are the ‘stuff’ that creates classes.\nYou define classes in order to create objects, right?\nBut we learned that Python classes are objects.\nWell, metaclasses are what create these objects. They are the classes’ classes, you can picture them this way:\nMyClass = MetaClass()\nmy_object = MyClass()\nYou’ve seen that type lets you do something like this:\nMyClass = type(&#039;MyClass&#039;, (), {})\nIt’s because the function type is in fact a metaclass. type is the metaclass Python uses to create all classes behind the scenes.\nEverything, and I mean everything, is an object in Python. That includes integers, strings, functions and classes. All of them are objects. And all of them have been created from a class:\n&gt;&gt;&gt; age = 35\n&gt;&gt;&gt; age.__class__\n&lt;type &#039;int&#039;&gt;\n&gt;&gt;&gt; name = &#039;bob&#039;\n&gt;&gt;&gt; name.__class__\n&lt;type &#039;str&#039;&gt;\n&gt;&gt;&gt; def foo(): pass\n&gt;&gt;&gt; foo.__class__\n&lt;type &#039;function&#039;&gt;\n&gt;&gt;&gt; class Bar(object): pass\n&gt;&gt;&gt; b = Bar()\n&gt;&gt;&gt; b.__class__\n&lt;class &#039;__main__.Bar&#039;&gt;\nNow, what is the __class__ of any __class__ ?\n&gt;&gt;&gt; age.__class__.__class__\n&lt;type &#039;type&#039;&gt;\n&gt;&gt;&gt; name.__class__.__class__\n&lt;type &#039;type&#039;&gt;\n&gt;&gt;&gt; foo.__class__.__class__\n&lt;type &#039;type&#039;&gt;\n&gt;&gt;&gt; b.__class__.__class__\n&lt;type &#039;type&#039;&gt;\nSo, a metaclass is just the stuff that creates class objects.\nYou can call it a ‘class factory’ if you wish.\ntype is the built-in metaclass Python uses, but of course, you can create your own metaclass.\nUse metaclass\nFirst we see an example:\nclass MyMeta(type):\n    # __new__ is the method called before __init__\n    # it&#039;s the method that creates the object and returns it\n    # while __init__ just initializes the object passed as parameter\n    # you rarely use __new__, except when you want to control how the object\n    # is created.\n    # here the created object is the class, and we want to customize it\n    # so we override __new__\n    # you can do some stuff in __init__ too if you wish\n    # some advanced use involves overriding __call__ as well.\n    def __new__(cls, cls_name:str, bases:tuple, attrs:dict, **kwargs):\n        new_attrs = {}\n        for k, v in attrs.items():\n            if not k.startswith(&#039;__&#039;):\n                key = k.upper()\n                print(&#039;modify attr: %s -&gt; %s&#039; % (k, key))\n                new_attrs[key] = v\n            else:\n                new_attrs[k] = v\n        return type.__new__(cls, cls_name, bases, new_attrs)\n \n    def __call__(self, *args, **kwds) -&gt; Any:\n        new_args = [x * x for x in args]\n        return super().__call__(*new_args, **kwds)\n \n \nclass D(object, metaclass=MyMeta, foo=1, bar=2):\n    aaa = 1\n    bbb = 2\n    def __init__(self, a, b) -&gt; None:\n        self.a = a\n        self.b = b\n \n \nif __name__ == &#039;__main__&#039;:\n    d = D(3, 4)\n    print(d)\nwe see the memory when hit the following breakpoint,\n\nFrom the picture we see:\n\nthe class name ‘D’ is passed as parameter cls_name of MyMeta.__new__,\nthe class variables of D is passed as parameter attrs of MyMeta.__new__,\nthe keyword arguments of D — foo and bar are passed as keyword arguments of MyMeta.__new__.\n\nThe next breakpoint:\n\ngives\n\nthe self variable passed to MyMeta.__call__ is just the class D,\nthe D(3, 4) pass 3, 4 to parameter args of MyMeta.__call__.\n\nThe last breakpoint gives the memory of instance d,\n\n\nthe class D has class attributes ‘AAA’ and ‘BBB’, which are converted to uppercase in MyMeta.__new__,\nthe instance d has instance attributes ‘a=9’ and ‘b=16’, which are processed in MyMeta.__call__,\nconsole outputs the log of uppercase conversion.\n\nLast word: i highly recommend you to read the document of obj.__new__ and obj.__init__, and to be continued…\nReferences\n\nWhat are metaclasses in python\nPython documents\nClass customizations\n"},"Blogs/post/shell-intro":{"slug":"Blogs/post/shell-intro","filePath":"Blogs/post/shell-intro.md","title":"Brief Introduction to Shell Script","links":["Blogs/post/"],"tags":["shell"],"content":"This article is mainly refered to “The Linux Command Line”1. I just take\nsome most important things out of the book.\nExpansion\nEach time you type a command line and press the Enter key, bash\nperforms several processes upon the text before it carries out your command.\nJust look an example:\n[me@linuxbox ~]$ echo *\nDesktop Documents ls-output.txt Music Pictures Public Templates Videos\nWhy not display an asterisk? That’s expansion! * expands to all files in\ncurrent directory.\nPathname expansion\n[me@linuxbox ~]$ ls\nDesktop ls-output.txt Pictures Templates\nDocuments Music Public Videos\n \n[me@linuxbox ~]$ echo D*\nDesktop Documents\n \n[me@linuxbox ~]$ echo *s\nDocuments Pictures Templates Videos\n \n[me@linuxbox ~]$ echo [[:upper:]]*\nDesktop Documents Music Pictures Public Templates Videos\n \n[me@linuxbox ~]$ echo /usr/*/share\n/usr/kerberos/share /usr/local/share\nTilde expansion\nAs you know, ~ has a special meaning of the home directory of current user.\n[me@linuxbox ~]$ echo ~\n/home/me\n \n[me@linuxbox ~]$ echo ~foo\n/home/foo\nArithmetic expansion\nThe shell allows arithmetic to be performed by expansion. This allows us to\nuse the shell prompt as a calculator:\n[me@linuxbox ~]$ echo $((2 + 2))\n4\n \n[me@linuxbox ~]$ echo with $((5%2)) left over.\nwith 1 left over.\nNote: Arithmetic expansion supports only integers (whole numbers, no\ndecimals).\nBrace expansion\n[me@linuxbox ~]$ echo Front-{A,B,C}-Back\nFront-A-Back Front-B-Back Front-C-Back\nPatterns to be brace expanded may contain a leading portion called a\npreamble and a trailing portion called a postscript. The brace expression\nitself may contain either a comma-separated list of strings or a range of\nintegers or single characters. The pattern may not contain embedded\nwhitespace.  Here is an example using a range of integers:\n[me@linuxbox ~]$ echo Number_{1..5}\nNumber_1 Number_2 Number_3 Number_4 Number_5\n \n[me@linuxbox ~]$ echo {Z..A}\nZ Y X W V U T S R Q P O N M L K J I H G F E D C B A\n \n[me@linuxbox ~]$ echo a{A{1,2},B{3,4}}b\naA1b aA2b aB3b aB4b\nCommand substitution\nCommand substitution allows us to use the output of a command as an\nexpansion:\n[me@linuxbox ~]$ echo $(ls)\nDesktop Documents ls-output.txt Music Pictures Public Templates Videos\n \n[me@linuxbox ~]$ ls -l $(which cp)\n-rwxr-xr-x 1 root root 71516 2012-12-05 08:58 /bin/cp\nThere is an alternative syntax for command substitution in older shell\nprograms that is also supported in bash . It uses back quotes instead\nof the dollar sign and parentheses:\n[me@linuxbox ~]$ ls -l `which cp`\n-rwxr-xr-x 1 root root 71516 2012-12-05 08:58 /bin/cp\nQuoting\nUsage of single or double quotes in shell commands is confusing for me,\nat least. Hey, take a look:\n[me@linuxbox ~]$ echo are you     ok\nare you ok\n \n[me@linuxbox ~]$ echo &#039;are you     ok&#039;\nare you     ok\n \n[me@linuxbox ~]$ echo &quot;are you     ok&quot;\nare you     ok\n \n[me@linuxbox ~]$ echo The total is $100.00\nThe total is .00\n \n[me@linuxbox ~]$ echo &#039;The total is $100.00&#039;\nThe total is $100.00\n \n[me@linuxbox ~]$ echo &quot;The total is $100.00&quot;\nThe total is .00\nIsn’t that confusing? Fortunately, the shell provides a mechanism called\nquoting to selectively suppress unwanted expansions.\nDouble quotes\nIf you place text inside double quotes, all the special characters used\nby the shell lose their special meaning and are treated as ordinary\ncharacters. The exceptions are $ (dollar sign), \\ (backslash),\nand ` (back tick).\nBy default, word splitting looks for the presence of spaces, tabs, and\nnewlines (linefeed characters) and treats them as delimiters between\nwords. This means that unquoted spaces, tabs, and newlines are not\nconsidered to be part of the text. They serve only as separators.\nThe fact that newlines are considered delimiters by the word splitting\nmechanism causes an interesting, albeit subtle, effect on command\nsubstitution. Consider the following:\n[me@linuxbox ~]$ echo $(cal)\nFebruary 2012 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29\n \n[me@linuxbox ~]$ echo &quot;$(cal)&quot;\n   February 2012\nSu Mo Tu We Th Fr Sa\n             1 2 3 4\n 5  6  7  8  9 10 11\n12 13 14 15 16 17 18\n19 20 21 22 23 24 25\n26 27 28 29\nIn the first instance, the unquoted command substitution resulted in\na command line containing 38 arguments; in the second, the result was a\ncommand line with 1 argument that includes the embedded spaces and\nnewlines.\nSingle quotes\nIf we need to suppress all expansions, we use single quotes. Here is\na comparison of unquoted, double quotes, and single quotes:\n[me@linuxbox ~]$ echo text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER\ntext /home/me/ls-output.txt a b foo 4 me\n[me@linuxbox ~]$ echo &quot;text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER&quot;\ntext ~/*.txt {a,b} foo 4 me\n[me@linuxbox ~]$ echo &#039;text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER&#039;\ntext ~/*.txt {a,b} $(echo foo) $((2+2)) $USER\nAs we can see, with each succeeding level of quoting, more and more\nexpansions are suppressed.\nVariables and assignments\n\nthe shell does not care about the type of data assigned to a variable; it treats them all as strings.\nin an assignment, there must be no spaces between the variable name, the equal sign, and the value.\n\na=z                 # Assign the string &quot;z&quot; to variable a.\nb=&quot;a string&quot;        # Embedded spaces must be within quotes.\nc=&quot;a string and $b&quot; # Other expansions such as variables can be expanded into the assignment.\nd=$(ls -l foo.txt)  # Results of a command.\ne=$((5 * 7))        # Arithmetic expansion.\nf=&quot;\\t\\ta string\\n&quot;  # Escape sequences such as tabs and newlines.\n”Here documents”\nA here document is an additional form of I/O redirection in which we\nembed a body of text into our script and feed it into the standard input\nof a command. It works like this:\ncommand &lt;&lt; token\ntext...\ntoken\nwhere command is the name of a command that accepts standard input and\ntoken is a string used to indicate the end of the embedded text. For\nexample, you\n$ cat &lt;&lt; _EOF_\nheredoc&gt; are you\nheredoc&gt; ok?\nheredoc&gt; Yes i am.\nheredoc&gt; And you?\nheredoc&gt; _EOF_\nare you\nok?\nYes i am.\nAnd you?\nNamely, you just use a custom EOF indicator of the input to that command.\nSo what’s the advantage of using a here document? It’s mostly the same as\necho , except that, by default, single and double quotes within here\ndocuments lose their special meaning to the shell. Here is a\ncommand-line example:\n[me@linuxbox ~]$ foo=&quot;some text&quot;\n[me@linuxbox ~]$ cat &lt;&lt; _EOF_\n&gt; $foo\n&gt; &quot;$foo&quot;\n&gt; &#039;$foo&#039;\n&gt; \\$foo\n&gt; _EOF_\nsome text\n&quot;some text&quot;\n&#039;some text&#039;\n$foo\nAs we can see, the shell pays no attention to the quotation marks. It\ntreats them as ordinary characters. This allows us to embed quotes freely within a here document.\nIf we change the redirection operator from &lt;&lt; to &lt;&lt;- , the shell will\nignore leading tab characters in the here document. This allows a here\ndocument to be indented, which can improve readability:\n$ cat &lt;&lt;- E_o_F\nheredocd&gt; no indent\nheredocd&gt;    indent\nheredocd&gt;         hiahia\nheredocd&gt;         E_o_F\nheredocd&gt; E_o_F\nno indent\n   indent\n        hiahia\n        E_o_F\nFlow control\nUsing if\nThe syntax of if-statement is\nif commands; then\n  commands\n[elif commands; then\n  commands...]\n[else\n  commands]\nfi\nwhere commands is a list of commands. This may be a little confusing at\nfirst glance, “if” should judge a condition rather than a series of\ncommands. This leads to the concept of exit status.\nCommands (including the scripts and shell functions we write) issue a\nvalue to the system when they terminate, called an exit status. This\nvalue, which is an integer in the range of 0 to 255, indicates the\nsuccess or failure of the command’s execution. By convention, a value\nof 0 indicates success, and any other value indicates failure. The shell\nprovides a parameter that we can use to examine the exit status. Here\nwe see it in action:\n[me@linuxbox ~]$ ls -d /usr/bin\n/usr/bin\n[me@linuxbox ~]$ echo $?\n0\n[me@linuxbox ~]$ ls -d /bin/usr\nls: cannot access /bin/usr: No such file or directory\n[me@linuxbox ~]$ echo $?\n2\nThe shell provides two extremely simple built-in commands that do\nnothing except terminate with either a 0 or 1 exit status. The true\ncommand always executes successfully, and the false command always\nexecutes unsuccessfully:\n[me@linuxbox ~]$ true\n[me@linuxbox ~]$ echo $?\n0\n[me@linuxbox ~]$ false\n[me@linuxbox ~]$ echo $?\n1\nUsing test\nBy far, the command used most frequently with if is test. The test\ncommand performs a variety of checks and comparisons. It has two\nequivalent forms:\ntest expression\n# or\n[ expression ]\nwhere “expression” is an expression that is evaluated as either true or\nfalse. The test command returns an exit status of 0 when the expression\nis true and a status of 1 when the expression is false.\nFile expressions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExpressionIs true if…file1 -nt file2file1 is newer than file2.file1 -ot file2file1 is older than file2.-d filefile exists and is a directory.-e filefile exists.-L filefile exists and is a symbolic link.-r filefile exists and is readable (has readable permission for the effective user).-s filefile exists and has a length greater than zero.-w filefile exists and is writable (has writable permission for the effective user).-x filefile exists and is executable (has execute/search permission for the effective user).\nString expressions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExpressionIs true if…stringstring is not null-n stringthe length of string is greater than zero-z stringthe length of string is zerostring1 == string2string1 and string2 are equal.string1 != string2string1 and string2 are not equal.string1 &gt; string2string1 sorts after string2.string1 &lt; string2string1 sorts before string2.\nNote: the &gt; and &lt; expression must be quoted (or escaped with a backslash)\nwhen used with test, oterwise they will be interpreted as the shell\nredirection opreators.\nInteger expressions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExpressionIs true if…integer1 -eq integer2integer1 is equal to integer2integer1 -ne integer2integer1 is not equal to integer2integer1 -le integer2integer1 is less than or equal to integer2integer1 -lt integer2integer1 is less than integer2integer1 -ge integer2integer1 is greater than or equal to integer2integer1 -gt integer2integer1 is greater than integer2\nModern test\nRecent versions of bash include a compound command that acts as an\nenhanced replacement for test . It uses the following syntax:\n[[ expression ]]\nwhere expression is an expression that evaluates to either a true or false\nresult. The  command is very similar to test (it supports all of its\nexpressions) but adds an important new string expression:\nstring =~ regex\nwhich returns true if string is matched by the extended regular expression\nregex.\n(( ))-Designed for integers\n(( )) is used to perform arithmetic truth tests. An arithmetic truth test\nresults in true if the result of the arithmetic evaluation is non-zero.\n[me@linuxbox ~]$ if ((1)); then echo &quot;It is true.&quot;; fi\nIt is true.\n[me@linuxbox ~]$ if ((0)); then echo &quot;It is true.&quot;; fi\n[me@linuxbox ~]$]\nShell function\nShell functions must be declared before using it. There are two ways to\ndefine a shell function:\nfunction name {\n  commands\n  return\n}\n \nname () {\n  commands\n  return\n}\nUse local variables in shell functions\nLocal variables are accessible only within the shell function\nin which they are defined, and they cease to exist once the shell function\nterminates.\n#!/bin/bash\n \n# local-vars: script to demonstrate local variables\n \nfoo=0   # global\n \nfunc1()\n{\n  local foo=1   # local\n  echo &quot;func1 foo = $foo&quot;\n}\n \nfunc2()\n{\n  local foo=2   # local\n  echo &quot;func1 foo = $foo&quot;\n}\n \necho &quot;global foo = $foo&quot;\nfunc1\necho &quot;global foo = $foo&quot;\nfunc2\necho &quot;global foo = $foo&quot;\n$ ./local-vars\nglobal foo = 0\nfunc1 foo = 1\nglobal foo = 0\nfunc1 foo = 2\nglobal foo = 0\nWe see that the assignment of values to the local variable foo within\nboth shell functions has no effect on the value of foo defined outside the\nfunctions.\nTO BE CONTINUED…\nFootnotes\n\n\n“The Linux Command Line, A Complete Introduction”, William E. Shotts, Jr. ↩\n\n\n"},"Blogs/post/tex-sty-basic":{"slug":"Blogs/post/tex-sty-basic","filePath":"Blogs/post/tex-sty-basic.md","title":"一个really simple的LaTeX宏包","links":[],"tags":["排版","latex"],"content":"众所周知，LaTeX是一个高效易用的排版软件，基本上只要找到合适的模板，剩下的就只剩码字了。比起MS Word，简直不知道高到哪里去。就拿最近写论文的事来说，我先用TeX码好字，然后要投的那个刊需要用Word提交。转格式转了我一下午带一晚上，太痛苦了。深刻的体会到什么叫自以为是，MS Word自作聪明地给你调格式。当你敲下回车之后，天知道它又会自动帮你做些什么？！\n好了，闲话少叙。这次主要是记录一下在使用LaTeX排版中文的时候，觉得每次都要定义字体很麻烦。于是干脆写成一个宏包的形式。之后的文档中如果需要排中文，直接导入这个包，就可以直接使用啦。说是宏包，实际上里面只包含自定义字体，惭愧惭愧，我并不是TeX专家。\n一个TeX宏包大概长成下面这个样子：\n% This package provides a zh_CN font customization for convinience.\n% yychi (guyueshui002@gmail.com)\n% 2019-09-25 10:10\n \n\\NeedsTeXFormat{LaTeX2e}[1994/06/01]\n\\ProvidesPackage{zhfont}[General zh_CN font setting for tex.]\n \n\\ifx\\zhfontpath\\undefined\n  \\newcommand{\\zhfontpath}{/path/to/font}\n\\else\n  \\message{\\string\\zhfontpath\\space is defined by some others.}\n\\fi\n \n\\RequirePackage{xeCJK}\n\\setCJKmainfont[Path=\\zhfontpath, BoldFont=方正小标宋_GBK.ttf, ItalicFont=方正仿宋_GBK.ttf]{方正书宋_GBK.ttf}\n\\setCJKsansfont[Path=\\zhfontpath]{方正黑体_GBK.ttf}\n\\setCJKmonofont[Path=\\zhfontpath]{方正中等线_GBK.ttf}\n \n 使用ctex系document，这些字体已被定义，所以做个case\n\\ifx\\songti\\undefined\n  \\newcommand*{\\songti}{\\CJKfamily{fzxbs}}   % 宋体\n\\fi\n\\ifx\\heiti\\undefined\n  \\newcommand*{\\heiti}{\\CJKfamily{fzhei}}    % 黑体\n\\fi\n\\ifx\\kaiti\\undefined\n  \\newcommand*{\\kaiti}{\\CJKfamily{fzkai}}    % 楷体\n\\fi\n\\ifx\\fangsong\\undefined\n  \\newcommand*{\\fangsong}{\\CJKfamily{fzfs}}  % 仿宋\n\\fi\n \n\\endinput\n% vim:ft=tex\n通过例子来学习，不失为一个好方法。上面的就是我为自己自定义的字体配置的宏包，还包含了一定的控制流呢。鬼知道我查这些关键字查了多久。要想设置中文并成功排版出来，必须使用xeCJK红包。里面包含的三条主要设定及其意义如下：\n\\setCJKmainfont[Path=\\zhfontpath,\n                BoldFont=方正小标宋_GBK.ttf,\n                ItalicFont=方正仿宋_GBK.ttf]\n                {方正书宋_GBK.ttf}                     % 设置中文主字体\n\\setCJKsansfont[Path=\\zhfontpath]{方正黑体_GBK.ttf}    % 设置中文无衬线字体\n\\setCJKmonofont[Path=\\zhfontpath]{方正中等线_GBK.ttf}  % 设置中文等宽字体\n上面三条命令就设定好了中文排版主字体，无衬线以及等宽字体。注意如果是已安装的字体，则不需要指定Path和文件名后缀。比如我列一下我已经安装的中文字体：\n$ fc-list :lang=zh\n/usr/share/fonts/wenquanyi/wqy-zenhei/wqy-zenhei.ttc: 文泉驿等宽正黑,WenQuanYi Zen Hei Mono,文泉驛等寬正黑:style=Regular\n/usr/share/fonts/wenquanyi/wqy-microhei/wqy-microhei.ttc: 文泉驿微米黑,WenQuanYi Micro Hei,文泉驛微米黑:style=Regular\n/usr/share/fonts/wenquanyi/wqy-microhei/wqy-microhei.ttc: 文泉驿等宽微米黑,WenQuanYi Micro Hei Mono,文泉驛等寬微米黑:style=Regular\n/usr/share/fonts/wenquanyi/wqy-zenhei/wqy-zenhei.ttc: 文泉驿正黑,WenQuanYi Zen Hei,文泉驛正黑:style=Regular\n则相应的字体设定为：\n\\setCJKmainfont[BoldFont=somefont,ItalicFont=somefont]{WenQuanYi Micro Hei}\n\\setCJKsansfont{WenQuanYi Zen Hei}\n\\setCJKmonofont{WenQuanYi Zen Hei Mono}\n后面就是定义一些常用中文字体：宋体、黑体、楷体、仿宋等。注意在使用ctex系文档时，自定义的名字可能已被定义，比如使用\\documentclass{ctextart}，\\songti命令已被定义，如果使用了我们自定义的宏包zhfont，则会报错命令重复定义。此时可以用\\renewcommand强制重新定义，也可以使用ctex默认的。总之，我这里加了条件主要是为了学一下TeX里面的控制流。\n宏包选项\n今天我们来谈谈如何给宏包传递选项，众所周知，形如\\usepackage[option1,option2]{xx}的意思是给宏包xx传递了option1, option2参数，那么宏包内部是如何处理这些选项的呢？趁着这次自定义字体，我们来看看。\n首先我建议过一遍clsguide.pdf，如果你的电脑上安装完整的tex-live（确切来说是安装了tex的documents），你可以使用texdoc clsguide来打开该文档。由于时间原因我决定先放结果，再稍作解释。\n% This package provides a zh_CN font customization for convinience.\n% yychi (guyueshui002@gmail.com)\n% 2019-09-25 10:10\n \n\\NeedsTeXFormat{LaTeX2e}[1994/06/01]\n\\ProvidesPackage{zhfont}[General zh_CN font setting for tex.]\n\\DeclareOption{typography}{\\newcommand{\\tp}{}}\n\\DeclareOption*{%\n  \\PackageWarning{zhfont}{Unknown option ‘\\CurrentOption’}%\n}\n% IMPORTANT!!!, all declareoption should before this,\n% see: es.overleaf.com/learn/latex/Writing_your_own_class\n\\ProcessOptions\\relax\n \n\\ifx\\zhfontpath\\undefined\n  \\newcommand{\\zhfontpath}{/home/yychi/Documents/FontsCollection/zh_cn/}\n\\else\n  \\message{\\string\\zhfontpath\\space is defined by some others.}\n\\fi\n \n\\RequirePackage{xeCJK}\n\\ifx\\tp\\undefined\n  \\setCJKmainfont[\n        Path = \\zhfontpath,\n        BoldFont = 方正小标宋_GBK.ttf,\n        ItalicFont = 方正仿宋_GBK.ttf\n  ]{方正书宋_GBK.ttf}\n  \\setCJKsansfont[Path=\\zhfontpath]{方正黑体_GBK.ttf}\n  \\setCJKmonofont[Path=\\zhfontpath]{方正中等线_GBK.ttf}\n\\else\n  \\setCJKmainfont[\n      Path = \\zhfontpath zhuzi_old_mincho/,\n      BoldFont = FZFWZhuZiAOldMinchoB.TTF,\n      ItalicFont = FZFWZhuZGDLMCJW.TTF,\n    ]{FZFWZhuZiAOldMinchoR.TTF}\n  \\setmainfont{EB Garamond}\n  %\\setmonofont{Consolas}\n\\fi\n \n% 下同\n此中，\\Declareoption{opt_name}{expression}，表示宏包提供选项opt_name，如果你在\\usepackage的时候传递了参数opt_name，那么expression将被执行。而\\DeclareOption*{expression}表示如果你传递了宏包中未提供的选项，那么expression将被执行。这里我为宏包zhfont提供了选项typography。如果再使用该宏包时传递了该选项，那么zhfont内部会定义一条命令\\tp，后面通过判断\\tp有没有被定义来选择不同的字体族，就达到了一个选项，切换字体的效果。\n具体来说，如果使用\\usepackage[typography]{zhfont}，将使用”FZFWZhuZiAOldMinchoR.TTF”这一套字体排版，而如果没有传递该参数，则使用方正书宋排版。好了，时间有限，这里仅做一个快速的记录，以便之后参考。未完待续……\nReference\n\ntexfaq.org/FAQ-isdef\nstackoverflow.com/questions/1211888/is-there-any-way-i-can-define-a-variable-in-latex\ntex.stackexchange.com/questions/265809/if-elseif-and-else-conditionals-in-the-preamble\n"},"Blogs/post/touchpad-horiz-scroll":{"slug":"Blogs/post/touchpad-horiz-scroll","filePath":"Blogs/post/touchpad-horiz-scroll.md","title":"Linux笔记本触摸板水平滚动问题","links":[],"tags":[],"content":"自打使用linux系统以来，触摸板这块的体验一只是个痛点：只支持基本的点击，双指垂直滚动。很久以来我就一直想要触摸板水平滚动的功能。今天终于实现了！\nSynaptics\n其实很久以前就照抄过一份xf86-input-synaptics驱动程序的触摸板配置：\n# file: /etc/X11/xorg.conf.d/70-synaptics.conf\nSection &quot;InputClass&quot;\n\tIdentifier &quot;touchpad&quot;\n\tDriver\t&quot;synaptics&quot;\n\tMatchIsTouchpad &quot;on&quot;\n\t\tOption &quot;TapButton1&quot; &quot;1&quot;\n\t\tOption &quot;TapButton2&quot; &quot;3&quot;\n\t\tOption &quot;TapButton3&quot; &quot;2&quot;\n\t\tOption &quot;VertEdgeScroll&quot; &quot;on&quot;\n\t\tOption &quot;VertTwoFingerScroll&quot; &quot;on&quot;\n\t\tOption &quot;HorizonEdgeScroll&quot; &quot;on&quot;\n\t\tOption &quot;HorizonTwoFingerScroll&quot; &quot;on&quot;\n\t\tOption &quot;EmulateTwoFingerMinZ&quot; &quot;40&quot;\n\t\tOption &quot;EmulateTwoFingerMinW&quot; &quot;8&quot;\n\t\tOption &quot;FingerLow&quot; &quot;30&quot;\n\t\tOption &quot;FingerHigh&quot; &quot;50&quot;\n\t\tOption &quot;VertScrollDelta&quot; &quot;-111&quot;\n\t\tOption &quot;HorizScrollDelta&quot; &quot;-111&quot;\nEndSection\n但很奇怪，一直以来水平滚动一直没生效。其实想来也是乌龙，是我抄错了：\n# 正确的应该是Horiz而非Horizon\nOption &quot;HorizEdgeScroll&quot; &quot;on&quot;\nOption &quot;HorizTwoFingerScroll&quot; &quot;on&quot;\n其实只要改正并重启一下，事情就完美解决了。可惜我一直没发现，还尝试研究为啥水平滚动不生效呢，他文档明明这么写了，难道是诓我？\nsynclient是用于实时更改synaptics驱动参数的命令行工具，使用\nsynclient HorizTwoFingerScroll=1\n即可开启水平滚动。事情本应到此结束，但是我惊讶的发现synaptics驱动已经停止维护，archwiki上已经推荐大家使用libinput了。\nLibinput\nCf. wiki.archlinux.org/title/Libinput\n参考archwiki直接把触摸板输入驱动换成libinput，尤其值得注意，如果/etc/X11/xorg.conf.d中需要移除（最好先备份）之前的synaptic driver的配置文件，比如我的:\nrm /etc/X11/xorg.conf.d/70-synaptics.conf\n删除之后像这样：\nyychi@/etc/X11/xorg.conf.d&gt; ls -al\n总用量 12\ndrwxr-xr-x 2 root root 4096  3月 26 00:23 ./\ndrwxr-xr-x 4 root root 4096  1月  3 20:53 ../\n-rw-r--r-- 1 root root  337  3月 26 00:23 00-keyboard.conf\nlrwxrwxrwx 1 root root   43  3月 25 23:23 40-libinput.conf -&gt; /usr/share/X11/xorg.conf.d/40-libinput.conf\n看下配置文件：\ncat 40-libinput.conf\nSection &quot;InputClass&quot;\n        Identifier &quot;touchpad&quot;\n        MatchIsTouchpad &quot;on&quot;\n        Driver &quot;libinput&quot;\n        Option &quot;AccelerationProfile&quot; &quot;2&quot;\n        Option &quot;Sensitivity&quot; &quot;0.1&quot;\n        Option &quot;Tapping&quot; &quot;on&quot;\n        Option &quot;ClickMethod&quot; &quot;clickfinger&quot;\n        Option &quot;TappingButtonMap&quot; &quot;lrm&quot;\n        Option &quot;NaturalScrolling&quot; &quot;on&quot;\nEndSection\n特别注意\n注意到文件夹中还有一个文件00-keyboard.conf，由于我们换了驱动，而libinput是所有输入的驱动，包括键盘，所以必须适当更改该文件，否则重启进来之后你会发现键盘失效！\nychi@/etc/X11/xorg.conf.d&gt; cat 00-keyboard.conf\n# Written by systemd-localed(8), read by systemd-localed and Xorg. It&#039;s\n# probably wise not to edit this file manually. Use localectl(1) to\n# instruct systemd-localed to update it.\nSection &quot;InputClass&quot;\n        Identifier &quot;system-keyboard&quot;\n        MatchIsKeyboard &quot;on&quot;\n        Driver &quot;libinput&quot;\t# 这行必须指定driver为libinput，否则重启后键盘无法输入\n        Option &quot;XkbLayout&quot; &quot;cn&quot;\nEndSection\n配置完成后用xinput看看：\nyychi@/etc/X11/xorg.conf.d&gt; xinput\n⎡ Virtual core pointer                    \tid=2\t[master pointer  (3)]\n⎜   ↳ Virtual core XTEST pointer              \tid=4\t[slave  pointer  (2)]\n⎜   ↳ ELAN2301:00 04F3:306B Touchpad          \tid=11\t[slave  pointer  (2)]\n⎣ Virtual core keyboard                   \tid=3\t[master keyboard (2)]\n    ↳ Virtual core XTEST keyboard             \tid=5\t[slave  keyboard (3)]\n    ↳ Power Button                            \tid=6\t[slave  keyboard (3)]\n    ↳ Video Bus                               \tid=7\t[slave  keyboard (3)]\n    ↳ Video Bus                               \tid=8\t[slave  keyboard (3)]\n    ↳ Sleep Button                            \tid=9\t[slave  keyboard (3)]\n    ↳ XiaoMi USB 2.0 Webcam: XiaoMi U         \tid=10\t[slave  keyboard (3)]\n    ↳ AT Translated Set 2 keyboard            \tid=12\t[slave  keyboard (3)]\n    ↳ Wireless hotkeys                        \tid=13\t[slave  keyboard (3)]\nyychi@/etc/X11/xorg.conf.d&gt; xinput list-props 11\t# 由上可知id=11为触摸板\nDevice &#039;ELAN2301:00 04F3:306B Touchpad&#039;:\n\tDevice Enabled (189):\t1\n\tCoordinate Transformation Matrix (191):\t1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000\n\tlibinput Tapping Enabled (327):\t1\n\tlibinput Tapping Enabled Default (328):\t0\n\tlibinput Tapping Drag Enabled (329):\t1\n\tlibinput Tapping Drag Enabled Default (330):\t1\n\tlibinput Tapping Drag Lock Enabled (331):\t0\n\tlibinput Tapping Drag Lock Enabled Default (332):\t0\n\tlibinput Tapping Button Mapping Enabled (333):\t1, 0\n\tlibinput Tapping Button Mapping Default (334):\t1, 0\n\tlibinput Natural Scrolling Enabled (335):\t1\n\tlibinput Natural Scrolling Enabled Default (336):\t0\n\tlibinput Disable While Typing Enabled (337):\t1\n\tlibinput Disable While Typing Enabled Default (338):\t1\n\tlibinput Scroll Methods Available (339):\t1, 1, 0\n\tlibinput Scroll Method Enabled (340):\t1, 0, 0\n\tlibinput Scroll Method Enabled Default (341):\t1, 0, 0\n\tlibinput Click Methods Available (342):\t1, 1\n\tlibinput Click Method Enabled (343):\t0, 1\n\tlibinput Click Method Enabled Default (344):\t1, 0\n\tlibinput Middle Emulation Enabled (345):\t0\n\tlibinput Middle Emulation Enabled Default (346):\t0\n\tlibinput Accel Speed (347):\t0.000000\n\tlibinput Accel Speed Default (348):\t0.000000\n\tlibinput Accel Profiles Available (349):\t1, 1\n\tlibinput Accel Profile Enabled (350):\t1, 0\n\tlibinput Accel Profile Enabled Default (351):\t1, 0\n\tlibinput Left Handed Enabled (352):\t0\n\tlibinput Left Handed Enabled Default (353):\t0\n\tlibinput Send Events Modes Available (312):\t1, 1\n\tlibinput Send Events Mode Enabled (313):\t0, 0\n\tlibinput Send Events Mode Enabled Default (314):\t0, 0\n\tDevice Node (315):\t&quot;/dev/input/event6&quot;\n\tDevice Product ID (316):\t1267, 12395\n\tlibinput Drag Lock Buttons (354):\t&lt;no items&gt;\n\tlibinput Horizontal Scroll Enabled (355):\t1\n\tlibinput Scrolling Pixel Distance (356):\t15\n\tlibinput Scrolling Pixel Distance Default (357):\t15\n\tlibinput High Resolution Wheel Scroll Enabled (358):\t1\n发现驱动已经成功更换为libinput，并且\n\tlibinput Horizontal Scroll Enabled (355):\t1\n表明已成功开启水平滚动。\nLibinput-gestures\nlibinput-gestures是一个脚本工具，它可以接收libinput的event并作出相应的action，进而达到手势操作的目地。具体可参考3.\nReferences\n\nArchWiki: Touchpad Synaptics\nArchWiki: Libinput\n对 Linux 下触控板按键、加速和手势的优化（libinput）\nLinux 下 MacBook 触摸板设置\n"},"Blogs/post/what-is-escape-character":{"slug":"Blogs/post/what-is-escape-character","filePath":"Blogs/post/what-is-escape-character.md","title":"转义字符到底是什么","links":[],"tags":["转义"],"content":"转义字符到底是啥？\n实不相瞒我就是因为不知道才写下这篇文章，不，准确的说是这篇笔记orz，既然是笔记，无所谓抄不抄了。每次说到转义字符，多少有点模糊，所以不如记下这篇笔记，以后忘了直接翻出来看看，复习起来要快一些。\n\n\n注：以下大段转载自C语言中文网，原文链接在参考中给出，如有侵权，请联系我删除。\n\n什么是转义\n字符集（Character Set）为每个字符分配了唯一的编号，我们不妨将它称为编码值。在C语言中，一个字符除了可以用它的实体（也就是真正的字符）表示，还可以用编码值表示。这种使用编码值来间接地表示字符的方式称为转义字符（Escape Character）。\n转义字符以\\或者\\x开头，以\\开头表示后跟八进制形式的编码值，以\\x开头表示后跟十六进制形式的编码值。对于转义字符来说，只能使用八进制或者十六进制。\n先贴张Ascii码表：\n\n从码表可以得到字符1、2、3、a、b、c对应的编码值：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n进制’1&#039;&#039;2&#039;&#039;3&#039;&#039;a&#039;&#039;b&#039;&#039;c’十进制495051979899八进制061062063014101420143十六进制0x310x320x330x610x620x63\n下面的例子演示了转义字符的用法：\nchar a = &#039;\\61&#039;;  //字符1\nchar b = &#039;\\141&#039;;  //字符a\nchar c = &#039;\\x31&#039;;  //字符1\nchar d = &#039;\\x61&#039;;  //字符a\nchar *str1 = &quot;\\x31\\x32\\x33\\x61\\x62\\x63&quot;;  //字符串&quot;123abc&quot;\nchar *str2 = &quot;\\61\\62\\63\\141\\142\\143&quot;;  //字符串&quot;123abc&quot;\nchar *str3 = &quot;The string is: \\61\\62\\63\\x61\\x62\\x63&quot;  //混用八进制和十六进制形式\n转义字符既可以用于单个字符，也可以用于字符串，并且一个字符串中可以同时使用八进制形式和十六进制形式。\n一个完整的例子：\n#include &lt;stdio.h&gt;\nint main(){\n    puts(&quot;\\x68\\164\\164\\x70://c.biancheng.\\x6e\\145\\x74&quot;);\n    return 0;\n}\n运行结果：c.biancheng.net\n转义字符的初衷是用于 ASCII 编码，所以它的取值范围有限：\n\n八进制形式的转义字符最多后跟三个数字，也即\\ddd，最大取值是\\177，也就是十进制的127；\n十六进制形式的转义字符最多后跟两个数字，也即\\xdd，最大取值是\\7f，也是十进制的127。\n\n超出范围的转义字符的行为是未定义的，有的编译器会将编码值直接输出，有的编译器会报错。\n常用控制字符的别名\n对于 ASCII 编码，0~31（十进制）范围内的字符为控制字符，它们都是看不见的，不能在显示器上显示，甚至无法从键盘输入，只能用转义字符的形式来表示。不过，直接使用 ASCII 码记忆不方便，也不容易理解，所以，针对常用的控制字符，C语言又定义了简写方式，完整的列表如下：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n转义字符意义ASCII码值（十进制）\\a响铃(BEL)007\\b退格(BS) ，将当前位置移到前一列008\\f换页(FF)，将当前位置移到下页开头012\\n换行(LF) ，将当前位置移到下一行开头010\\r回车(CR) ，将当前位置移到本行开头013\\t水平制表(HT)009\\v垂直制表(VT)011\\&#039;单引号039\\&quot;双引号034\\\\反斜杠092\n\\n和\\t是最常用的两个转义字符：\n\n\\n用来换行，让文本从下一行的开头输出；\n\\t用来占位，一般相当于四个空格，或者 tab 键的功能。\n\n单引号、双引号、反斜杠是特殊的字符，不能直接表示，要表示这些字符本身，需要用转义的形式，即在前面加反斜杠（backslash \\）：\n\n单引号是字符类型的开头和结尾，要使用\\&#039;表示，也即char single_quote = &#039;\\&#039;&#039;；\n双引号是字符串的开头和结尾，要使用\\&quot;表示，也即char double_quote = &#039;\\&quot;&#039;；\n反斜杠是转义字符的开头，要使用\\\\表示，也即char backslash = &#039;\\\\&#039;。\n\n转义字符示例：\n#include &lt;stdio.h&gt;\nint main(){\n    puts(&quot;C\\tC++\\tJava\\n\\&quot;C\\&quot; first appeared!&quot;);\n    return 0;\n}\n运行结果：\nC    C++    Java\n&quot;C&quot; first appeared!\n\nReference\n\nC语言转义字符\n"},"Blogs/post/一些推导":{"slug":"Blogs/post/一些推导","filePath":"Blogs/post/一些推导.md","title":"常用结论的证明记录","links":[],"tags":["math"],"content":"高斯分布的微分熵\nX \\sim \\mathcal{N}(\\mu, \\sigma^2)~，\\displaystyle f(x)=\\frac{1}{\\sqrt{2\\pi\\sigma^2}}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}，其微分熵推导过程如下：\n\\begin{split}\nh(X) &amp;= \\int_{-\\infty}^{\\infty}\n\\frac{-1}{\\sqrt{2\\pi\\sigma^2}}\\exp\\left(-\\frac{(x-\\mu)^2}{2\\sigma^2}\\right) \\cdot\n\\ln \\left[\n\\frac{1}{\\sqrt{2\\pi\\sigma^2}}\\exp\\left(-\\frac{(x-\\mu)^2}{2\\sigma^2}\\right)\n\\right] dx \\newline\n&amp;= \\frac{-1}{\\sqrt{2\\pi\\sigma^2}} \\int_{-\\infty}^{\\infty}\n\\exp\\left(-\\frac{(x-\\mu)^2}{2\\sigma^2}\\right)\n\\cdot\n\\left(\n\\ln(2\\pi\\sigma^2)^{-1/2} - \\frac{(x-\\mu)^2}{2\\sigma^2}\n\\right) dx \\newline\n&amp;= \\frac{1}{2}\\ln(2\\pi\\sigma^2) \\int_{-\\infty}^{\\infty}\n\\frac{1}{\\sqrt{2\\pi\\sigma^2}}\\exp\\left(-\\frac{(x-\\mu)^2}{2\\sigma^2}\\right) dx \\newline\n&amp;\\quad + \\int_{-\\infty}^{\\infty}\n\\frac{(x-\\mu)^2}{2\\sigma^2} \\cdot\n\\frac{1}{\\sqrt{2\\pi\\sigma^2}}\\exp\\left(-\\frac{(x-\\mu)^2}{2\\sigma^2}\\right) dx \\newline\n&amp;= \\frac{1}{2}\\ln(2\\pi\\sigma^2) + \\frac{1}{2\\sigma^2}E(X-\\mu)^2 \\newline\n&amp;= \\frac{1}{2}\\ln(2\\pi\\sigma^2) + \\frac{1}{2} = \\frac{1}{2}\\ln(2\\pi e\\sigma^2) \\qquad\\text{(nats)}\n\\end{split}\n\n又因为 H_b(X) = \\log_ba \\cdot H_a(X)，于是取 b=e, ~a=2\n\\implies \\frac{1 \\text{ nat}}{x \\text{ bits}} = \\ln2 \\implies x = \\frac{1}{\\ln2} = \\frac{\\log e}{\\log2} = \\log e \\text{ bits}\n所以\n\\frac{1}{2}\\ln(2\\pi e\\sigma^2) \\text{ nats} =\n\\frac{1}{2} \\cdot \\frac{\\log(2\\pi e\\sigma^2)}{\\log e} \\cdot \\log e \\text{ bits} =\n\\frac{1}{2}\\log(2\\pi e\\sigma^2) \\text{ bits}\n概率\nBounds on tail probabilities\nMarkov’s inequality: For any r.v. X and constant a &gt; 0,\nP(|X| \\ge a) \\le \\frac{E|X|}{a}.\nLet Y = \\frac{|X|}{a}. We need to show that P(Y\\ge 1) \\le E(Y). Note that\nI(Y \\ge 1) \\le Y,\nsince if I(Y \\ge 1) = 0 then Y \\ge 0, and if I(Y \\ge 1) = 1 then Y \\ge 1 (because the indicator says so). Taking the expectation of both sides, we have Markov’s inequality.\nChebyshev’s inequality: Let X have mean \\mu and variance \\sigma^2. Then for any a &gt; 0,\nP(|X-\\mu| \\ge a) \\le \\frac{\\sigma^2}{a^2}.\nBy Markov’s inequality,\nP(|X-\\mu|\\ge a) = P((X-\\mu)^2 \\ge a^2) \\le \\frac{E(X-\\mu)^2}{a^2} = \\frac{\\sigma^2}{a^2}.\nChernoff inequality: For any r.v. X and constants a &gt; 0 and t&gt;0,\nP(X\\ge a) \\le \\frac{E(e^{tX})}{e^{ta}}.\nThe transformation g with g(x) = e^{tx} is invertible and strictly increasing. So by Markov’s inequality, we have\nP(X\\ge a) = P(e^{tX} \\ge e^{ta}) \\le \\frac{E(e^{tX})}{e^{ta}}.\nLaw of large numbers\nAssume we have i.i.d. X_1, X_2, X_3, \\dots  with finite mean \\mu and finite variance \\sigma^2. For all positive integers n, let\n\\bar{X}_n = \\frac{X_1 + \\cdots + X_n}{n}\nbe the sample mean of X_1 through X_n. The sample mean is itself an r.v., with mean \\mu and variance \\sigma^2/n:\n\\begin{split}\nE(\\bar{X}_n) &amp;= \\frac{1}{n} E\\left(\\sum_{i=1}^n X_i\\right) = \\frac{1}{n}\\sum_{i=1}^n E(X_i) = \\mu, \\newline\n\\text{Var}(\\bar{X}_n) &amp;= \\frac{1}{n^2} \\text{Var}\\left(\\sum_{i=1}^n X_i\\right) = \\frac{1}{n^2}\\sum_{i=1}^n \\text{Var}(X_i) = \\frac{\\sigma^2}{n}.\n\\end{split}\nStrong law of large numbers The sample mean \\bar{X}_n converges to the true mean \\mu pointwise as n \\to \\infty, with probability 1. In other words,\nP(\\lim_{n\\to\\infty} \\bar{X}_n = \\mu) = 1, \\text{ or }\n\\bar{X}_n \\overset{a.s.}{\\longrightarrow} \\mu.\nWeak law of large numbers For all \\epsilon &gt;0, P(|\\bar{X}_n-\\mu|&gt;\\epsilon) \\to 0 as n\\to\\infty. (This is called convergence in probability.) In other words,\n\\lim_{n\\to\\infty}P(\\bar{X}_n = \\mu) = 1.\nFix \\epsilon &gt;0, by Chebyshev’s inequality,\nP(|\\bar{X}_n-\\mu|&gt;\\epsilon) \\le \\frac{\\sigma^2}{n\\epsilon^2}.\nAs n\\to\\infty, the right-hand side goes to 0, ans so must the left-hand side.\nReferences\n\nBlitzstein, Joseph K, and Hwang, Jessica. “Introduction to probability.”\n"},"Blogs/post/临江仙·友":{"slug":"Blogs/post/临江仙·友","filePath":"Blogs/post/临江仙·友.md","title":"临江仙·友","links":[],"tags":["诗词曲赋"],"content":"别后音书难寄，梦醒佳期曾寻？去年今日却来时，指点斜阳丽，谈笑细雨霏。\n残风枯草落桂，玉影浮萍无依。闲病一来漫如丝。秋深明月照，夜寂懒人归。"},"Blogs/post/临江仙·造境":{"slug":"Blogs/post/临江仙·造境","filePath":"Blogs/post/临江仙·造境.md","title":"临江仙·造境","links":[],"tags":["诗词曲赋"],"content":"\n硬生生的矫揉造作，满脑子乱想出来的境界。\n\n寂寂远洋村落，皑皑天水漫行。岸下游鱼翻藻荇。波心二两月，湖面十分明。\n矮草促织乱入，寒鸦林外时鸣。无食何不餐落英。心罗千万物，眼浸一天星。"},"Blogs/post/二十四":{"slug":"Blogs/post/二十四","filePath":"Blogs/post/二十四.md","title":"二十四","links":[],"tags":["诗词曲赋"],"content":"\n写于二十四岁之际，匆匆人间已经走过两纪，观之苦辣酸甜，皆归于平淡。\n\n去日寥寥终不谏，\n阴晴变换亦难圆。\n无尤无怨无执念，\n来纪来年来易之。\n丁酉腊月廿四"},"Blogs/post/使用Tar备份Archlinux":{"slug":"Blogs/post/使用Tar备份Archlinux","filePath":"Blogs/post/使用Tar备份Archlinux.md","title":"使用 Tar 备份 Archlinux","links":[],"tags":["备份","tar"],"content":"Linux 需要备份吗？本身 Linux 系统的稳定性就是一流，文件系统也不易产生碎片，只要不是硬盘突然崩掉了，你可以有 100 种方法来修复系统的各种问题而不用重装系统。但是恰好我不是多么熟练的 Linux 使用者，每次出问题也是自己在网上边查边解决，有时候也会遇到那种查了几天也没能解决的问题，所以重装 Linux 这样的情景也会时常发生。那么，如果事先做了备份，这时候就能起到很大的作用了。\n\nTar 备份\n创建exclude列表，排除不需要备份的文件。一个样例：\n#vi /excl\n/proc/*\n/dev/*\n/sys/*\n/tmp/*\n/mnt/*\n/media/*\n/run/*\n/var/lock/*\n/var/run/*\n/var/lib/pacman/*\n/var/cache/pacman/pkg/*\n/lost+found\n\n\n准备一个liveCD，也就是安装arch的u盘。\n插入u盘，进入bios，设置u盘为优先启动。\n进入u盘系统，挂载好原系统的分区。一个样例：\n\nmount /dev/sda2 /mnt\nmkdir /mnt/{boot,home}\nmount /dev/sda1 /mnt/boot\nmount /dev/sda3 /mnt/home\n挂载之后就可以执行chroot进入要备份的系统了。\narch-chroot /mnt /usr/bin/bash\n进去之后，执行\ntar cvpjf backup20160910.tar.bz2 --exclude-from=/excl /\n\n\n这里excl是一开始创建的过滤列表，若它不在tar命令的执行路径内，则应将路径写完整。\n这里建议tar的执行路径不包含在需要打包的路径内，即tar的执行路径最好放在excl列表中的某个文件夹内，只是为了防止递归备份。\n最后，当然要保证磁盘空间充足。\n\n\n这样，整个系统就被打包好了。在tar的执行路径下，应该可以看到备份文件了。\nTar 还原\n备份好的包可以用来还原，迁移系统。\n首先，插u盘进入liveCD。规划好分区，格式化啥的，参见archwiki的Beginner’s Guide. 同样的，挂载好分区。一个样例：\nmount /dev/sda2 /mnt\nmkdir /mnt/{boot,home}\nmount /dev/sda1 /mnt/boot\nmount /dev/sda3 /mnt/home\n当然，需要挂在备份包的存储分区。一个样例：\nmkdir /backup\nmount /dev/sda4 /backup\n其中，备份包的存储位置是sda4，这里插一句，大家是怎么分辨sdax对应哪块空间的？反正我是根据大小啦=。=\n创建临时目录/backup作为sda4的挂载点。最后执行：\ncd /mnt\ntar xvpjf /backup/backup20160910.tar.bz2\n将备份包解压到对应的位置。然后生成fstab：\ngenfstab -U -p /mnt &gt;&gt; /mnt/etc/fstab\n执行完成后建议检查一下/etc/fstab的正确性。接着进入恢复好的系统：\narch-chroot /mnt /bin/bash\n重新配置启动引导：\ngrub-mkconfig -o /boot/grub/grub.cfg\n这样，备份包就恢复好了。\n退出chroot，卸载目录，重启，应该可以进入系统了，还是熟悉的面孔。\nexit\numount -R /mnt\nreboot\n后话\n咦呀，我是第一次写博客，而且是博客园这样大的平台，写到这里还是惊魂未定0v0。我也有自知之明，一开始申请写博客权限的时候也写明了：借园子这样的好地方，边学习，边记录。事实上，我也是刚刚接触linux，今年6月份端午的时候。折腾了三个月，一直在折腾，因为它总是冒出莫名其妙的问题，有的解决了，有的没能解决。事后观之，在折腾的过程中，虽说没学到啥实质性的技术，但至少了解了一些处理问题的框架模式，自己也能动手解决一些小问题了，对自己还是很有帮助的。\n事实上，本文写的事情uqi已经折腾了三四次了。一开始打算装着玩，linux这边分的空间太少了。期间加过一两次，加上这次的大改，重新划了分区表。每次操作都重新找教程，于是这次自己把它写下来，方便以后查看，O(∩_∩)O哈哈~\n好了，就这样，我第一次写博客，希望看官手下留情啊，任何意见我都会听的。谢谢～"},"Blogs/post/假想敌":{"slug":"Blogs/post/假想敌","filePath":"Blogs/post/假想敌.md","title":"假想敌","links":[],"tags":[],"content":"\n有时候我们需要一个假想敌，来抵制一天的堕落。\n\n：今天也是满负罪恶感的一天呢？\n—嗯，其实我还蛮会自我减压的。\n：这已经称得上是放纵了呢！\n—不不不，我的神经有紧绷过吗？\n：那你准备何时紧绷。\n—明天吧，不过今天真是满负罪恶感的一天呢！\n"},"Blogs/post/关于饭局那些事儿":{"slug":"Blogs/post/关于饭局那些事儿","filePath":"Blogs/post/关于饭局那些事儿.md","title":"关于饭局那些事儿","links":[],"tags":["碎碎念"],"content":"\n看到班级聚会上有人被灌吐了，实在看不下去！\n\n其一，为我好我很感激，说以后在社会上总有应酬不得不喝酒，所以即使不能喝还是得喝。我始终信奉我爸的一句话：人家能喝你管他呢，你不能喝就别喝！\n其二，己所不欲，勿施于人。何为不欲？我不想喝，你喝，你劝我喝。你不想让我不喝，是为不欲，所以即便为我好，也要看我接不接受吧。你们说的我都知道，也已经做好了觉悟。我的棱角也已经被现实磨得差不多了，如果在连这点坚持也要像现实屈服的话，还不如死了算了！人生在世都不能按照自己的意志行事，还活着干嘛！\n其三，我看到了，我都看到了！聚会的地方每桌都有人吐得不行，走路飘摇，“任人宰割”。年轻人卖青春？！不懂自持，肆意无度，为一己之快灌人酒，然后看别人呕吐很高兴吗，快意吗？不错，喝酒本是乐事，但你们想过呕吐的人的感受没有，好，即便他心理快乐，生理上总不能说很愉悦吧？！然后出门以后，城里灯红酒绿，醉酒的人不危险？！\n其四，现代人把酒喝成什么样了？！就知道灌灌灌，喝到不行还要喝！喝到要死还要喝，明明自己不能喝，别人一灌他就喝，明明自己再也不能喝了，别人再道出几句利害，说出两句风马牛不相及的话，他还喝？！请允许我说他作死！古人武将喝酒是为挥洒肝胆，上阵杀敌；文人喝酒，是为投怀雅兴，寄寓风骚。“绿蚁新醅酒，红泥小火炉。晚来天欲雪，能饮一杯无？”“肯与邻翁相对饮，隔篱呼取尽馀杯。”“独持一杯酒，南亭送残春。”“彼此相看头雪白，一杯可合重推辞？”酒文化本是如此美好，却被今人异化成这样。真是好的不继承，坏的更加剧！\n最后，再郑重声明：烟酒不沾！\n好吧就这样，不服别说话。因为争辩没意义。"},"Blogs/post/初尝-C-类设计":{"slug":"Blogs/post/初尝-C-类设计","filePath":"Blogs/post/初尝-C-类设计.md","title":"初尝 C++ 类设计","links":[],"tags":["cpp"],"content":"最近在准备笔试，于是在各种网站上刷题嘛。期间做了百度某年的一道编程题。\n\n小B最近对电子表格产生了浓厚的兴趣，她觉得电子表格很神奇，功能远比她想象的强大。她正在研究的是单元格的坐标编号，她发现表格单元一般是按列编号的，第1列编号为A，第2列为B，以此类推，第26列为Z。之后是两位字符编号的，第27列编号为AA，第28列为AB，第52列编号为AZ。之后则是三位、四位、五位……字母编号的，规则类似。\n表格单元所在的行则是按数值从1开始编号的，表格单元名称则是其列编号和行编号的组合，如单元格BB22代表的单元格为54列中第22行的单元格。\n小B感兴趣的是，编号系统有时也可以采用RxCy的规则，其中x和y为数值，表示单元格位于第x行的有第y列。上述例子中的单元格采用这种编码体系时的名称为R22C54。\n小B希望快速实现两种表示之间的转换，请你帮忙设计程序将一种方式表示的坐标转换为另一种方式。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n输入输出输入的第一行为一个正整数T，表示有T组测试数据（1&lt;=T&lt;=10^5）。随后的T行中，每行为一组测试数据，为一种形式表示的单元格坐标。保证所有的坐标都是正确的，且所有行列坐标值均不超过10^6对每组测试数据，单独输出一行，为单元格坐标的另一种表示形式。2  R23C55  BC23BC23  R23C55\n\n写这道题目的时候，正好复习了C++的类，于是居然鬼使神差的想设计一个类来实现它。C++的核心思想是面向对象，而此处的单元格正好有显著的对象特征。一个单元格，应该有座标，以及其中的内容。这是很自然的，当初看C++ Primer的时候，书中也是以书本销量作为引入，介绍并阐述类的设计。\nDefinitions\n闲话少说，现在就来看看如何实现这个类。\n// Unit/Unit.h\n \nclass Unit {\nprivate:\n    using pos = unsigned int;\n    pos rowIdx;\n    pos colIdx;\n \npublic:\n    // constructors\n    Unit(pos _r, pos _c) : rowIdx(_r), colIdx(_c) { }\n    // constructor2\n    Unit(string);\n};\n先看这么多，我希望每个单元个有两个属性，一个行索引rowIdx一个列索引colIdx. 而且我定义了两个构造函数，一个是直接将行列索引传入，另一个则是通过读取一个字符串，来解析出其中的行列索引的值。这里有一个问题，因为不同类型的字符串解析的方式不一样，所以需要一个指示变量来指明传入的字符串到底是哪个类型：BC23还是R23C55？除此之外，我还需要一个可以转换不同类型表示的函数，给了我表示类型1，我可以直接调用一个函数，输出表示类型2. 需求先大致到这里，来改进一下之前的类。\n// Unit/Unit.h\n \n#ifndef _UNIT_H_\n#define _UNIT_H_\n \n#include&lt;string&gt;\n \nclass Unit {\nprivate:\n    using pos = unsigned int; // type alias\n    pos rowIdx;\n    pos colIdx;\n    bool isRC; // is the type `R23C55`?\n    void getIdx_RC(std::string); // build index for type &#039;R23C55&#039;\n    void getIdx_NRC(std::string); // for type &#039;BC23&#039;\n \npublic:\n    // constructor1\n    Unit(pos _r, pos _c) : rowIdx(_r), colIdx(_c) { }\n    // constructor2\n    Unit(std::string);\n \n    // selectors\n    pos getRow() { return rowIdx; }\n    pos getCol() { return colIdx; }\n \n    // modifiers\n    void setRow(pos _r) { rowIdx = _r; }\n    void setCol(pos _c) { colIdx = _c; }\n \n    // utilties\n    void printer(void);\n    void convertor(void);\n};\n#endif\n这里先不要纠结定义了很多不知道要干嘛的函数，往下看类的实现，你会慢慢明白为什么需要它们。\nImplementions\n类的头文件中只定义了类，除少数内联函数外，大多数函数仍未实现。按照模块化的哲学，新开一个文件写类的实现。\n构造函数的实现\n// Unit/Unit.hpp\n \n#include &quot;Unit.h&quot;\n \n// implement constructor2\nUnit::Unit(string _s) {\n    // wishful thinking \n    isRC = typeInfer(_s);\n    if (isRC) {\n    /*\n     * wishful thinking: suppose i have the function\n     * that helps me do this job\n     */\n        getIdx_RC(_s);\n    } else {\n    // again wishful thinking\n        getIdx_NRC(_s);\n    }\n}\n好了，现在我们实现了第二个构造函数，它接受一个string对象，从中解析出行列索引的值，然后初始化rowIdx和colIdx.\n但是，我们想当然的调用了一些我们还没有实现的函数。这里要特别注意一点：在写程序的时候，这种想法很有用！以下思想来自我学习SICP一段时间以后的自我体会：程序往往会包含很多的函数，为什么？因为有时候一个稍微复杂的问题，并不是一个函数就能解决的，所以需要多个函数相互协调，相互调用才能共同完成或是解决一项工作。如果你费尽心思把它们都写在一个函数里，可能你觉得很好，但是一旦程序报错，你将无从下手，很难定位到错误发生在哪里。这也是程序设计讲究模块化的理由。将复杂的功能抽象成一个一个的互不干涉的模块（子程序），在每一个小模块里尽可能的将代码写好，使得它只完成并且高效准确地完成这一项任务。那么当所有模块相互协同起来，将会使难以想象的高效，且不容易出错，即便是出错了，也能很快定位到错误发生的地点，便于调试。\n这样做的好处还有一个，就是你在写程序的时候变得更加轻松。为什么？因为我不用考虑所有的细节，只是调用了一些函数，而实现这些函数很可能不是我们要干的活。Oh, that’s cool! George will do for me. 你甚至可以去喝杯咖啡。但是现在，让我们短暂的充当以下 George 的角色。就拿Unit类的设计来说，我现在想要实现第二个构造函数，根据题目的意思，我可能接受两个代表不同表示方法的string，我要将它们解析成行列索引。让我们回头看看这个函数的实现，它先判断输入的是那个类型，然后分情况做不同的事（调用不同的函数）。这里我用到了3个wishful thinking：\n\n我希望有一个叫typeInfer()的函数，我给它一个字符串，它告诉我这属于哪个类型的表示方法。\n如果是RxCy型，我希望有一个函数getIdx_RC()能够处理这种类型的输入，解析出行列索引。\n如果是BC23型，我希望有一个函数getIdx_NRC()能够处理这种类型的输入，解析出行列索引。\n\n这样一来，我们不容易犯错。为什么？因为这个构造函数的逻辑足够简单，仅仅是分两个情况做不同的事。做的事也很简单：仅仅是调用一个函数！如果你能保证所调用的函数不犯错，那么整个过程也不会出错。既简单，又robust！\n还有我个人认为的好处就是，写程序变得简单了。我到每一步的时候，需要什么，想象一下，假设它已经有了，我该怎么写，怎么去调用它。这样你就对为什么要有这个函数，以及这个函数要干什么，心知肚明了。然后上层建设好之后，我再去考虑如何实现那些想象！现在，我们来看看，之前想当然的几个函数如何实现。\n// Unit/Unit.hpp\n \n#include &quot;Unit.h&quot;\n#include &lt;string&gt;\n \n/*\n * Predefined things...\n */\n \nbool typeInfer(std::string _s) { // infer the representation type\n    if (_s[0] == &#039;R&#039; &amp;&amp; std::isdigit(_s[1]))\n        return true;\n    else\n        return false;\n}\n \nvoid Unit::getIdx_RC(std::string _s) {\n    /*\n     * build the row/col index for\n     * type &#039;R23C55&#039;\n     */\n    _s.erase(0, 1); // remove first &#039;R&#039;\n    \n    // find where &#039;C&#039; is\n    std::string::size_type c_pos = 0;\n    for (; c_pos != _s.size(); ++c_pos) {\n        if (_s[c_pos] == &#039;C&#039;) break;\n    }\n    auto s1 = _s.substr(0, 0 + c_pos); // s1 = &quot;23&quot;\n    auto s2 = _s.substr(c_pos + 1, _s.size()); // s2 = &quot;55&quot;\n    // set index\n    rowIdx = std::stoi(s1);\n    colIdx = std::stoi(s2);\n}\n \nvoid Unit::getIdx_NRC(std::string _s) {\n    /*\n     * build the row/col index for\n     * type &#039;BC23&#039;\n     */\n \n    // find the first num\n    std::string::size_type n_pos = 0;\n    for (; n_pos != _s.size(); ++n_pos) {\n        if (std::isdigit(_s[n_pos]))\n            break;\n    }\n \n    auto s1 = _s.substr(0, n_pos); // s1 should be &quot;BC&quot;\n    auto s2 = _s.substr(n_pos, _s.size()); // s2 should be &quot;23&quot;\n    rowIdx = std::stoi(s2);\n    colIdx = letter2pos(s1);\n}\n\nNote: 注意到getIdx_RC()和getIdx_NRC()需要访问类内私有变量，所以应该声明成类的成员函数。\n\n好了，看了上面的实现，我又想当然的引入了几个函数。但是通过上下文，你可以很明显的看出来我引入这个函数实干嘛用的。正是因为这个时候我需要有一个函数帮我去干这个事情，而我又不想把这些复杂的工作都写到一个函数里面（因为容易出错，且很难调试）。所以我引入了它们：\n\nletter2pos()接受一个字符串，返回解析出来的数值索引。\n\n好吧，居然只引入了一个(╬ Ò ‸ Ó)，再来看看它的实现。\n// Unit/Unit.hpp\n \n/*\n * Predefined things...\n */\n \n// return the corresponding num for a given string\nint letter2pos(const std::string&amp; _s) {\n    auto len = _s.size();\n    int res = 0;\n    for (; len != 0; --len) {\n        res = res*26 + alph2num(_s[_s.size() - len]);\n        // std::cout &lt;&lt; &quot;res: &quot; &lt;&lt; res &lt;&lt; std::endl;\n    }\n    return res;\n}\n \n// return the corresponding string for a given num\nstd::string pos2letter(int _p) {\n    if (_p &lt;= 26){\n        char c[1] = {num2alph(_p)};\n        std::string s(c);\n        return s;\n    }\n \n    std::string res;\n    int r = 0;\n    while (_p &gt; 26) {\n        r = _p%26;\n        res += num2alph(r);\n        _p /= 26;\n    }\n    res += num2alph(_p);\n    std::reverse(res.begin(), res.end());\n    // cout &lt;&lt; &quot;res: &quot; &lt;&lt; res &lt;&lt; endl; \n    return res;\n}\n哈哈，我又想象了几个不存在的函数。它们的作用很容易通过上下文得知。letter2pos()和pos2letter()是一对相反的函数，它们的作用是完成BC&lt;-&gt;55的映射。至于alph2num()和num2alph()，其实也是一对相反的函数，用于检索26个字母对应的数值。\n// Unit/Unit.hpp\n \n// global map for quick search\nchar MAP[26] = {&#039;A&#039;,&#039;B&#039;,&#039;C&#039;,&#039;D&#039;,&#039;E&#039;,&#039;F&#039;,&#039;G&#039;,\n                &#039;H&#039;,&#039;I&#039;,&#039;J&#039;,&#039;K&#039;,&#039;L&#039;,&#039;M&#039;,&#039;N&#039;,\n                &#039;O&#039;,&#039;P&#039;,&#039;Q&#039;,&#039;R&#039;,&#039;S&#039;,&#039;T&#039;,\n                &#039;U&#039;,&#039;V&#039;,&#039;W&#039;,&#039;X&#039;,&#039;Y&#039;,&#039;Z&#039;};\n \n// return a num for the given char\nint alph2num(char _c) {\n    int idx = 0;\n    for (; idx != 26; ++idx) {\n        if (MAP[idx] == _c)\n            return idx + 1;\n    }\n    std::cerr &lt;&lt; _c &lt;&lt; &quot;Not found!&quot; &lt;&lt; std::endl;\n    return 0;\n}\n \n// return a char for the given num\nchar num2alph(int _i) { return MAP[_i - 1]; }\n转换函数的实现\n基于上面的工作，转换函数的实现就显得格外清晰简单。所谓转换函数，就是当我输入的是类型1的字符串，它输出转换之后的类型2的字符串，由此达到一个转换单元格表示方法的效果。\n// Unit/Unit.hpp\n \n/*\n * Predefined things...\n */\n \nvoid Unit::convertor() {\n    if (isRC) {\n        std::cout &lt;&lt; pos2letter(colIdx)\n            + std::to_string(rowIdx) &lt;&lt; std::endl;\n    } else {\n        std::cout &lt;&lt; &quot;R&quot;\n            + std::to_string(rowIdx)\n            + &quot;C&quot;\n            + std::to_string(colIdx) &lt;&lt; std::endl;\n    }\n}\n \nvoid Unit::printer() {\n    std::cout &lt;&lt; &quot;row index: &quot; &lt;&lt; rowIdx\n        &lt;&lt; &quot;\\ncol index: &quot; &lt;&lt; colIdx &lt;&lt; std::endl;\n}\n最后附加一个printer()方便打印信息。至此，整个类的设计大概就完了。值得注意的是，最后的convertor()之所以能够如此简单地写出来，是因为我们合理将一些工作模块化，这样带来的好处就是可以重复利用，易于维护。\n总结\n我之前写代码，总是不注意模块化，不注意抽象化。能一个函数完成的事为什么要写两个函数？然而，最后只能自食其果。一旦报错，一步步地定位错误，从下往上调试，陷入苦海。也有的时候，因为函数过于复杂，把自己绕糊涂，陷入一个圈子里想不通，弄不懂，出不来。这些结果都以失败告终！而且会打击自信心，感觉别人写代码是写代码，我写代码就纯粹是写bug啊！\n好在前段时间看了点SICP，B站上有视频的，我自己也在对着书看，真的是非常好的课程。循着书中传递的思想，慢慢就这么写着，发现有的问题可以写出来了，得益于代码结构的改变，调试错误也比以前稍微轻松一些。到这次写这道编程题，要是在考试中这么写，我肯定来不及的。但是我在课余花了不少时间构思，终于用面向对象的思想将它初步实现。虽然这个类设计的很简单，也有很多瑕疵：\n\n异常输入的处理\n类结构的优化以及完备性检查\n代码细节的优化\n\n但是和以前半途而废相比，起码完成了类的实现，虽然很粗糙。谨以此文记录一下！\n附赠：SICP的学习资源\n\nB站视频\n在线电子书\n习题答案\np2pu sicp solutions\n\n感谢SICP视频翻译工作者，感谢B站up主的搬运，感谢开源社区！"},"Blogs/post/卜算子·重阳":{"slug":"Blogs/post/卜算子·重阳","filePath":"Blogs/post/卜算子·重阳.md","title":"卜算子·重阳","links":[],"tags":["诗词曲赋"],"content":"浩浩江汉天，寂寂雁行促。信拈梧桐一叶愁，泪起相思雨。\n九九又相逢，患难身何处？却把双眉抵作山，淡看秋云暮。"},"Blogs/post/古别":{"slug":"Blogs/post/古别","filePath":"Blogs/post/古别.md","title":"古别","links":[],"tags":["诗词曲赋"],"content":"几日度离魂，午后闲萧索。\n起身斜照间，指染门前土。\n道是无情人，偏作有情甫。\n原是离别多，何必离别苦。\n"},"Blogs/post/声音的消亡":{"slug":"Blogs/post/声音的消亡","filePath":"Blogs/post/声音的消亡.md","title":"声音的消亡","links":[],"tags":["碎碎念"],"content":"近日整理以前的文章，发现一个事实：我越来越不会说话，越来越不会表达，越来越没有自己的思想。\n以前的我每隔几天都会发表空间说说，即使大部分属于“少年不识愁滋味，为赋新词强说愁”。但好歹能时常发表自己的观点、见解和感悟。我现在看起自己以前写过的东西，不论正确与否，起码可以通过写的文字窥见当时的自己，了解当时的想法，经过时空的转换，这些想法现在品起来十分有味道、并且非常有乐趣。\n“那么三年以后的我呢？”\n我现在并不像以前那样频繁的写随笔，发感悟。三年后的我能品到我现在的心境吗？恐怕不能。时间会冲刷一切，生物都是不断更新的个体。我压根不知道以后会怎样：长胖了还是长高了？开心了还是抑郁了？三年后的我又会是什么样的心境？\n我常常在回忆我是如何从唠叨的空间爱好者，变成现在沉默的机器。我当初这么活跃又是为什么？我想，有很大一部分是时期的原因。当时正处于青春期，想法比较多也是正常的，思维齿轮一刻不停，偶尔碰出火花是理所当然。还有一方面，我想经营一个“才子”的人设，所以时常会在空间里写诗歌。那时候也确实比较喜欢诗词，尝读大小李杜，山水田园，婉约豪放，小山纳兰等等，每每被其中描写的意境所打动。一读完，脑子里就有场景，美，实在是美！“我能不能写出这样美丽的意境呢？”我当时这么想着，但是对于格律一窍不通，只了解简单的平仄相对。所以我写的压根算不上诗词，这一点我十分清楚。所以我从不标榜“今天我又写了一首诗”，“昨天新写了一首词”。只是厚脸皮的套用词牌，自由快乐的写着。即便如此，我写的文字，我自我感觉，还是有那么一点点价值的，并非全部，有的也有非常好的意境。\n我当时写诗词的状态，就是看到某个事物，有了一个想法，脑子里忽然冒出一句。然后从这一句扩展，联想，直到将整篇完成。大多数时候，我都是闭眼畅想，精骛八极，心游万仞。有时候在被窝里憋着想，想到睡着，第二天一看：呀，怎么没想出来就睡着了！\n另外“才子”的人设其实是臭美，真实的想法是想吸引异性。这么好的事我为什么不干呢？但事与愿违，那些年我压根没有成功，我总指望着异性主动来找我，羞于主动找异性。是的，我还没有认清时代变了哇！（难怪单身这么久）\n另一方面，那个时候我非常喜欢道家学说，差点没成道长。现在看来可能是中二病：就是什么都看透；什么都无所谓；什么我来这红尘走一遭；什么归隐山林等等。所以遇到事情，总是能用道家的学说来分析一遍，解释一遍，还希望有人能懂我，产生共鸣，希望推己及人，把别人也拉入我道门。那个时候果真有很多小年轻来找我咨询问题：和男朋友分了咋办？不想念书了咋办？受打击了咋办？厌世了咋办……我都一一给予解答，说教的头头是道。在他们眼中，我可能就是人生导师吧哈哈！\n后来，遇到一些好友是在忍受不了了，就评论说我矫情。那个时候“矫情”这个词刚流行起来，恰好被我撞上了&lt;(=┘￣Д￣)┘╧═╧&gt;. 我的理论告诉我忽视这些“无知的人”，但是我的境界还没有到达到理论的高度，所以心中难免有些介怀。再到和我的人生导师交流，他也说他好久不发说说了，发说说的都是无聊的人，有这个时间不如去做点有意义的事。他说的话没有问题，但是我当时听岔了，没有get到他的本意。所以一味的照做了，有意识地减少发说说的频率，也不再写那些酸不琉球的话了。我压根没注意到我的个性正在被扼杀！\n后来随着年龄增长，逐渐走出了青春期。遇到事情，想发表看法的时候，脑海中就有一个声音告诉自己：说了又如何？有人会听吗？有人会和我想的一样吗？我说的是对的吗？我了解事情的原委吗？我该说吗……\n我，变得踟蹰不前了。\n遇到事情，不止三思，而是“六思”了。瞻前顾后，使我无法前进。久而久之，我不再有那么多看法。不写东西的时间，也没有用来做什么有意义的事。现在看来，是赔了夫人又折兵。啥好处没捞着，还弄丢一个。\n所以我现在打算捡回来，为了让未来的我了解现在。不记录是不行的， 记录是当下最好的，也是唯一的选择。未来的我只能通过现在的记录去观测这个时空的我，所以我必须尽可能的留下生活痕迹！"},"Blogs/post/天空":{"slug":"Blogs/post/天空","filePath":"Blogs/post/天空.md","title":"天空","links":[],"tags":["诗词曲赋","现代诗"],"content":"俯视着关于你的一切\n像死水一样寂静\n而你是云，是风\n你是向晚高飞的蝙蝠\n未曾与他们苟同\n你没有追寻光明\n在寂静的向晚\n在清新的早晨\n在蝉鸣的午后\n毫不动摇的揣想，不得其果\n你是一部戏剧\n而我也会偶尔迷惘"},"Blogs/post/年少的自大":{"slug":"Blogs/post/年少的自大","filePath":"Blogs/post/年少的自大.md","title":"年少的自大","links":[],"tags":["碎碎念"],"content":"\n前言：现在的我不认同当时的我，当时的我似乎以为世界以我为中心，真的是too young too simple, sometimes naive.\n\n好，这次我就说的明明白白：对于你们五一各种回家各种玩各种嗨各种秀，我是很羡慕。甚至嫉妒。我也想出去玩，可是我只是讨厌人多的地方，我只是想和两三个好朋友一起，可是，好朋友都在哪呢？我没有好朋友了。没有了吗？在武汉的好朋友有他们自己更要好的朋友，以前的好朋友都一直失联。我努力维系的关系，努力经营的感情，努力关注的人，都没有给我回应。给我的竟是一种热脸贴冷屁股的感觉。或许他们有新的知己，把我给淡忘了，可我却拿着记忆反复温习，生怕会忘！\n我就不想出去玩一玩吗？没到过的地方，我也想亲身一下；没看过的风景，我也想亲自去看一看；没体验过的事情，我也想亲自去体验的。奈何总是没人陪，所以我宅在宿舍作息失调。我只想要几个好朋友而已，或许我再也得不到了。这个大学给我的感觉，虽然人脉圈子大，不过真正要好的没有几个，与别人维系的仅仅是一种互相利用的关系，有事可以帮个忙什么的再好不过了。所以对于我不想结识，不想纠缠的人，我不会抱着功利心态去与之交往。\n说到这里我又想到，有些个左右逢源，能说会道的人，遇到谁都希望做个好朋友。我也曾问过他们，他们确实有时候说的话是违心的，可是为了收获人脉，他们照说不误！有些人志向远大，积极参与各种活动锻炼自己，提高自己，抓住去演讲的任何机会，锻炼自己的口才。他们认为好的口才可以为他们带来很多好处，可以使他们更轻松地在社会立足。确实他们是很有能力，是很能干，这也没什么不好。我想说的只是各人所追求的不一样罢了。你追求人脉，追求社会集体性，追求利用人际关系帮助自己。而我不追求这个，我追求内心的宁静，我追求世界的平淡，自然的朴素。有人说我的这种想法未免太天真，迟早要被社会同化。好吧，其实我也不能确定。毕竟生活在社会中，不按社会的规则办事是很麻烦的。\n最后我想用大石鼓的话作结：悠悠天地，奈何独立苍茫！好朋友，你留给我的只是无限的寂寞！！！\n\n后记：当时的好友评论说的都挺在理的，仿佛那时候就我最幼稚。\n\n摘录几个好友评论：\n\n@PYB: 社会的压力迫使人们带着面具生活，可是，都情非得已。\n\n\n@GZH: 人应该学会与寂寞相处\n\n\n@TY: 两年后你在回头来看这番话，就会觉得自己当年太那啥～～～\n\n\n@MX: 每个人都有自己独特的生活方式，有些时候不妨换个角度，换种心态看待问题……或许，那些你羡慕着的人也正羡慕着你……社会如此，很多事没表面这么简单……再转送一句我姐送我的话:学会谦卑，因为社会上没人欠你什么（PS:老纸回来了……）\n\n\n@YL: 玩之前先和朋友说好去哪玩好不好，如果没人答应，就回老家找亲朋好友玩玩，至少他们不会拒绝的，想开一点，这个社会也许就是这样，没什么大不了的。\n\n\n@FJ: 达则兼济天下，穷则独善其身。君子之交淡若水。他日相聚，酒一壶，叙旧花前月下……越浮躁，越是需要宁静……中国缺少大师，不乏商人政客……\n"},"Blogs/post/幽浦吟":{"slug":"Blogs/post/幽浦吟","filePath":"Blogs/post/幽浦吟.md","title":"幽浦吟","links":[],"tags":["诗词曲赋"],"content":"寂寂幽林密，凄凄夜色清。\n流深散月影，玉泽沁我心。\n长梦忽到此，愿遣青牛住。"},"Blogs/post/忆王孙":{"slug":"Blogs/post/忆王孙","filePath":"Blogs/post/忆王孙.md","title":"忆王孙·重阳","links":[],"tags":["诗词曲赋"],"content":"绿窗新见暮色沉，围炉夜话俏平生。\n又拈旧醅对故人，入更深，月华淌过小柴门。"},"Blogs/post/忆萝月·端阳":{"slug":"Blogs/post/忆萝月·端阳","filePath":"Blogs/post/忆萝月·端阳.md","title":"忆萝月·端阳","links":[],"tags":["诗词曲赋"],"content":"禁闱清寂，独卧无好意。拟把乡关枕边诉，花妙榆浓荫细。\n昨夜又见月明，教人何不伤情。他日湖畔信步，徒增云淡风清。"},"Blogs/post/戏小调":{"slug":"Blogs/post/戏小调","filePath":"Blogs/post/戏小调.md","title":"戏小调","links":[],"tags":["诗词曲赋"],"content":"晚风射枝断，宴罢歌舞歇。\n归卧孤衾倦揽，寒阁暗对，幽恨新结。\n不识莲心苦，尽日尝相忘。\n设入骤雪梦中，清白天地，独立苍茫。"},"Blogs/post/打春诗":{"slug":"Blogs/post/打春诗","filePath":"Blogs/post/打春诗.md","title":"打春诗","links":[],"tags":["诗词曲赋"],"content":"红日殷勤照，绿草葳蕤发。\n轻霜打薄叶，细雨湿脸颊。\n燕衔去岁诗，牛踏来年花。\n郁结二十载，难忘旧时家。\n附：立春古词\n春日春风动，\n春江春水流。\n春人饮春酒，\n春官鞭春牛。\n\n"},"Blogs/post/文本":{"slug":"Blogs/post/文本","filePath":"Blogs/post/文本.md","title":"文本","links":[],"tags":["诗词曲赋","现代诗"],"content":"在这半亩方塘\n横七竖八的站立\n倾颓，蹒跚，踟蹰\n而你是作家，是诗人\n是勤于耕作的农夫\n夕阳映照的汗水\n生命绘成的霓虹\n曾路过繁华之境\n也见过荒凉雪景\n看过滚烫生命\n叹过涂炭生灵\n你的才思迸发\n而我只是干涩的文本\n你的感情不绝\n而我也吝啬一个句号"},"Blogs/post/旅客":{"slug":"Blogs/post/旅客","filePath":"Blogs/post/旅客.md","title":"旅客","links":[],"tags":["诗词曲赋","现代诗"],"content":"\n当年上学，父亲骑着电瓶车送我到车站，我站在车上往后看……\n\n车开了\n你看我\n我回头\n看见你没能看见我\n的双眼\n说来旅客\n本身就是一种伤害\n大概"},"Blogs/post/月夕调":{"slug":"Blogs/post/月夕调","filePath":"Blogs/post/月夕调.md","title":"月夕调","links":[],"tags":["诗词曲赋"],"content":"念亟蟾宫殁，思尽天一涯。\n长躯何了了，戚戚何惨怛。\n泠泠秋风中，霭霭月华下。"},"Blogs/post/望日观月":{"slug":"Blogs/post/望日观月","filePath":"Blogs/post/望日观月.md","title":"望日观月","links":[],"tags":["诗词曲赋"],"content":"风逐残红海逐潮，\n北斗呈钩贪狼皎。\n百年明月一时盈，\n自此清辉夜夜销。"},"Blogs/post/杂思":{"slug":"Blogs/post/杂思","filePath":"Blogs/post/杂思.md","title":"杂思","links":[],"tags":["碎碎念"],"content":"回家的第一个早晨，想起去乡里走走。无奈各家都躲在深宫大院里，院门铁锁。问何以至此？曰：“昨儿个杨家电驴儿被盗啦，俺来则速的叫大儿子打了个院儿，小偷再也盗不了俺家货啦！当今的谁家没个铁栅栏水泥地儿的，能防人！”\n噫，怅然兮有所失，有所思：昔者四合之院，邻里互衬。数口之家，其员相悦。举手之间，有温良和风相送。畅晚之余，有妙语笙歌互答。谈天说地，议古论今，盘盘焉若蜂房，逡逡焉似水涡。而今各门高院，唯独防人者乎？其亦防心邪。其使路人相见，心起隔阂。久久相成，则串门之事少焉，人心之去远矣。是村之愈城，世便少村，其为外者。人之愈闭，人心渐远，其为内者。村人本不欲此，有作俑者，先修高院，极陈利弊，兼以诱引，使村人起修，互传甚者，是不修者以修者修，故曰，村人互丧，其罪莫大于始作俑者。而另考之，其受时势异化者甚众，然则罪乃戟于时势。而另考时势，亦复如是。故或曰神谕，或曰天命，而吾曹窃以为，其为自然也哉！乃口占一绝：\n质朴如玉任雕张，\n体性飘摇随风荡。\n无端各家高墙起，\n不闻稻草杂泥香。"},"Blogs/post/杂记":{"slug":"Blogs/post/杂记","filePath":"Blogs/post/杂记.md","title":"杂记","links":[],"tags":["碎碎念"],"content":"每当我提笔想写些什么，心里便虚荣起来。总想写出深奥，晦涩，精炼，优美的话语，让人们好加点评，其实都是故弄玄虚而已，真个应了“为赋新词强说愁”。故而入眼尽是哀景，入耳尽是悲歌，所写尽是愁滋味。而空造之言又能打动几人？最多打发看官无聊的时间而已，这是没有意义的！\n我曾经想过一个问题，悲和喜到底谁更打动人呢？譬如老师在批改作文，某作以悲动人，每个人都经历过悲痛，也都尝过悲痛的滋味，那真是不想再尝的了，故而所见此作足以涕泪交集，动了悲心，给55分吧；某作以乐动人，其所言尽中人心怀，勾起人快乐的回忆，那滋味真是非常美妙的，老师乐了，他回想起以往的乐事，动了乐心，给55分吧。看官，你道是悲乐孰更动人？？\n我好像有两面，在广众下的忧郁，在好友旁的快朗。而我如今在写这些杂东西，也是装忧郁罢了。可我为什么不装快乐呢？是我在生活中快乐够了，所以在网上得忧郁一下？而快乐，谁都不会嫌多的。那既然生活中并不是快乐腻了，为何还在人前装忧郁？是虚荣罢了！因为有人觉得忧郁是种气质，能够吸引人，所以得装；因为有认说愁更能动人，所以得强说愁；因为有人说看诗词可以提高修养，所以读诗览词，却未曾入木三分……我呵――就生活再别人的世界里罢了！所幸日久可见人心，不管怎么伪装，别人总会看见真正的我（不论好坏，至少真切）。\n看官若见我以后发什么愁话，大可以不必机会，想是又在虚荣罢了。人生难得是清醒。今日清醒一回，不知又要糊涂到几时？"},"Blogs/post/村东头":{"slug":"Blogs/post/村东头","filePath":"Blogs/post/村东头.md","title":"村东头","links":[],"tags":[],"content":"我们村东头，是个好地方。那里水天相接，那里绿草如茵，那里牛羊成群，那里风和日丽。\n小时候，我和我的小伙伴们，骑着脚踏车，在稻场上奔驰，平坦而又起伏，简单而又复杂，这独特的地形是我们最爱的赛道，虽然，我们时不时趴一跤，吃满嘴的泥巴，脚踝被擦破，脚踏车翻在一边，后轮还在飞转，但，我们会立马爬起来，不屑地掸去身上的泥巴，扶起踏板，高傲地再坐上去，继续那待续的路途。\n我们会顺着纵横的田梗，骑到小桥子口，去观看潺潺的流水，流水是那样清，那是与各个大村直连的水沟的支流，听说大水沟绵延着汇入长江，我们指点着水中的小餐鱼，左栏看罢换右栏，我们在桥上左右跑动追寻自己锁定的鱼儿，有时发现桥中的小缝，我们便贴在地上睁一只眼闭一只眼地偷窥桥下流水中的各色生物。\n沟里有各家船只，当然也有我大伯的，那都是水泥和木头的小船，用来运稻子的，长长的，有的像一弯新月，有时，大伯撑船带我到边田去收稻子，他在船头撑篙子，我在船尾看着被船劈开的流水，水纹很是漂亮，怎么说呢，规则的不规则的，都是那样的自然，我于是按捺不住，脱了衣服跳下水，双手扒住船尾，脚丫子在后面啪啪地拍打水面，听从大雁的智慧，我躲在水纹分叉之后，呀，这可比游的快多了，这叫搭顺风船，我张开嘴，任流水在我嘴里打旋，那感觉是非常美妙温柔的，这里一时想不到词语来描述。\n小船穿过一片水草，再一片苇丛，便到了他家田，就不说他家稻子如何了，单看这一带，却有些类似世外桃源的样子，虽没有山作屏障，却也有芦苇作掩饰，沟到这里似乎尽了，其实过弯那边还有个小桥子口，与外相通，岸边全是田亩，黄灿灿的稻子，芦苇在风中摇摆头脑，毛毛针也低下头来抚水嬉戏，南边有间小茅屋，估计是看鱼人的临时住所。\n回来的时候，小船已载得满满的了，船檐被压的贴近水面了，不过这更有一番趣味了，小船划出的水纹越发大且复杂了，我掰着手指头都数不过来了，我静静地看着水面，目光又被水中的鱼儿抢去，它们在绛蓝的水草间乱窜呢，我伸出手插进水里，顿时水面又多出几道纹路，忽而远处又冒出两只水鸭子，我们玩起了预测它们下一个冒出点的游戏，好不有趣，说真的，从未感觉离水面如此的近，当视线与水面在同一水平线上，听说会有奇迹般的视觉效果。\n上岸后，把稻子都运到稻场晒，稻草桔梗集中烧掉，可是难免会有稻粒残存在杆上，烧的时候就会有辟辟啪啪的声音，这就意味着稻子在大火之中熟了，这就意味着有口福了，这就是传说中的炮谷子，没加盐，没加糖，没加醋，没加油，它唯一的诱惑就是天然的米香，带着丝丝的焦味，没人控制火候，没人加入调料，它堪称浑然天成！走过路过，捡一个吃吃吧！\n我们小时候！我们村东头！\n\n"},"Blogs/post/某不正经的个人总结":{"slug":"Blogs/post/某不正经的个人总结","filePath":"Blogs/post/某不正经的个人总结.md","title":"某不正经的个人总结","links":[],"tags":[],"content":"不知何时开始，整理情绪，对我来说成了一件十分困难的事。每次想发点什么，总怕被说矫情，想想还是不发了吧。想必很多灵感都是这样被扼杀了吧。但是人总是要改变的，无论随着时间，还是随着空间。​四年还是变了不少的，比如变胖了什么的（这是主要的，饭量大我也没办法，括弧笑）。性情什么的也有变化，主要是理工男气质（猥琐？），当然也有正经的变化。改变是福是祸无从判断，但每个改变都是自己的选择，所以也应该释然。\n\n学业\n我不是谦虚，只是有自知之明。总结来说一句话：水平太洼。缘由嘛，主要是自己（也适当甩锅给环境，我比较在意周围的环境，看别人玩，我也想玩。）很多时候，在学习和娱乐之间选择了娱乐。老天是公平的，给你一生的时间，将选择权交给个人，有些人选择中途退场，有些人选择苟活一生，有些人嘛……你用来娱乐，起码收获了快乐，谁说一时的愉悦没有价值？！；用来刻苦努力，收获知识，为了什么？为生活，为实现自我价值，无论目的如何，你还是收获了知识；你做的任何选择都有意义，从来不存在无意义的事情，有的只是一个念想的差别。所以，现在的我是我一个个选择堆叠而成，不须后悔。未来未可知，正是人活着最美好的意义。\n交际\n很抱歉，我还是不擅长交际。这可真是一门大学问！大到前后矛盾，颠覆传统。我从前认为，人生话在自然，只要和自然好好相处就行了。万万没想到啊……关于这方面，好心的人们教了我很多，能教的都教了，可是我还是有点抗拒。很抱歉，当我熟练的时候你们可能会讨厌我了，虽然我本来也不招人喜欢。这也是没有办法的事情，就让我撞墙吧，多撞撞就好了。曾经也考虑过赤子之心被社会同化的问题，到底如何坚守，什么不忘初心，方得始终（噗，每次听都挺尬），说到底也只能走一步看一步了。曾经也爱胡思乱想，领悟人生道理，可是碰不到高人，没有人告诉我是否正确。越想越迷，越迷越想，快要想通的时候，额，就睡着了。人生也是这样，等到经历足够，经验丰富的时候，也是最睿智的时候，可那时候你就要狗带了。或许是老天爷的玩笑，每当人要悟得真理的时候，不是要睡着了，就是要够带了。所以啊，人的一生真的很笨啊！唯有初生婴儿与垂死老人，是最具智能的。一个纯白，一个纯黑，什么都不懂和什么都懂，到底谁更具有智慧呢？嘿嘿，是时候安利一波：无极之内，在极之外。入我道门，知我自然。\n遗憾\n基友一群，女票纳西。不好说多，说多了像思春一样了。语文！我还是很喜欢诗词歌赋的啊，我还是很喜欢书法的啊，无奈理工男没有语文？！荒废了诗词书法，唉，虽然没有认真学过，但作为业余，绝对是爱着的！\n致谢\n谢天谢地谢空气，谢室友不杀。要说我对这个学校还有一丝留恋，那绝对是留恋那一群人。一起上课吃饭，一起抄后排，一起迟到翘课，一起去图书馆搞事，一起彻夜不眠，一起谈天说地，一起打拳皇，火影，doa，三国杀开黑。还有我要吐槽最后居然一张正经班级合照都没发。发个纪念册算什么？我只想要一张合照，实体照片！还有些遗憾，没有认识的学弟学妹，到最后想送点东西都送不掉，可能是因为太宅了。还有某豪，真的感谢你！待我如亲生的一般，无论精神上还是物质上，都给了我很大的鼓舞与帮助，感谢某豪，我愿永远叫你一声大哥！\n结语\n所有的所有……哦，我还有个原则，还遵守的蛮好。有时候做事特别随性，比如地上掉了一块钱，我捡不捡：捡，一块也是钱，积少可以成多，你不捡就是不尊重钱，将来也赚不到钱；不捡，路不拾遗，夜不闭户，如是而已。再比如碰到一个蜻蜓粘在蜘蛛网上：救，上天有好生之德；不救，万物生存，自有定数，不可干预。再比如碰到要饭的：给，将心比心，我也有受人帮助的时候；不给，人有善恶，我今天就恶一回了，你恰好碰到我黑化的时候，也是劫数。诸如此类的……让我们继续，所有的所有，先说声再见！当我翻开相册时，我还会回来的…\n\n——易之\n\n2017.6.23\n"},"Blogs/post/浅谈-Logistic-回归":{"slug":"Blogs/post/浅谈-Logistic-回归","filePath":"Blogs/post/浅谈-Logistic-回归.md","title":"浅谈 Logistic 回归","links":[],"tags":["math","机器学习"],"content":"In editing…\nLogistic 回归属于分类模型！！！\n从最小二乘说起\n线性回归\n概率解释\nSigmoid 函数的引入\n如果把我比作一张白纸，在我的知识储备中，现在只有线性回归。但是要处理分类问题，我该怎么办？没办法，先考虑一个二分类问题，y \\in \\{0,1\\}，我们准备霸王硬上弓，用回归模型套上去！\ny = h_{\\theta}(x)\n至少我们希望h_{\\theta}(x) \\in (0,1)，就那么刚刚好，有一族函数，这里我们特指其中一个\ng(z) = \\frac{1}{1+e^{-z}} \\in (0,1)\n请记住它的名字，它就是大名鼎鼎的 sigmoid 函数。可以的话，请再记住它两个迷人的性质：\n\ng&#039;(t) = g(t)(1-g(t))\n1 - g(t) = g(-t)\n\nLogistic 回归\n现在，我们模型的假设是\n\\begin{split}\ny &amp;= h_{\\mathbf{\\theta}}(\\mathrm{x}) = g(\\mathbf{\\theta}^T \\mathrm{x}) \\\\\n&amp;= \\frac{1}{1+\\exp({-\\theta^T \\mathrm{x}})} = g(z)\n\\end{split}\n我们希望通过训练改变 \\theta 的值，进一步改善我们的模型。现在，我们打算换一个角度来看待这个问题，因为g(\\theta^T x) \\in (0,1)，正好可以表示一个概率，而之前我们看到，最小二乘实际上等价于，我对数据有一些假设（高斯白噪声），在这些假设下，做参数\\theta的极大似然估计 (MLE). 基于这个想法，我们假设，\n\\begin{split}\nP(y=1|x;\\theta) &amp;=  h_{\\theta}(x) \\newline\nP(y=0|x;\\theta) &amp;=  1 - h_{\\theta}(x)\n\\end{split}\n然后就那么刚刚好，回忆一下 sigmoid 函数有哪些迷人的性质，你会发现下面的式子也是对的\np(y|x;\\theta) = [h_{\\theta}(x)]^y [1-h_{\\theta}(x)]^{1-y}\n再假设 m 个样本独立同分布，我们得到似然函数\n\\begin{split}\nL(\\theta) &amp;= p(\\mathbf{y} | \\mathbf{X}; \\mathrm{\\theta}) \\\\\n&amp;= \\prod_{i=1}^m p(y_i | x_i ; \\theta)\n\\end{split}\n进一步，得到对数似然\n\\begin{split}\nl(\\theta) &amp;= \\log L(\\theta) \\\\\n&amp;=\\sum_{i=1}^m \\left[ y_i\\log h(x_i) + (1-y_i)\\log(1-h(x_i)) \\right]\n\\end{split}\n现在，我们基于 MLE 的方法，来调整参数 \\theta 的值，使得对数似然函数最大。很自然的，我们可以使用梯度上升的方法，更新规则为\n\\theta = \\theta + \\alpha \\nabla_{\\theta} l(\\theta)\n注意梯度上升是沿着正梯度方向更新。给定一个训练样本 (x,y), 其梯度为\n\\begin{split}\n\\frac{\\partial}{\\partial \\theta_j} l(\\theta)\n&amp;= \\left(\\frac{y}{g(z)} - \\frac{1-y}{1-g(z)}\n\\right)\n\\frac{\\partial g(z)}{\\partial z} \\frac{\\partial z}{\\partial \\theta_j} \\newline\n&amp;= (y-g(z)) \\frac{\\partial z}{\\partial \\theta_j} \\newline\n&amp;= (y-h_{\\theta}(x))x_j\n\\end{split}\n迭代使得似然函数最大化，完成训练。最后应该输出一个 0~1 之间的概率值。我们可以人为设定一个阈值（如 0.5），当输出概率大于 0.5，判定y=1，反之亦然。如此一来，就完成了回归到分类的转化。\n另外，上述 sigmoid 函数又叫 logistic 函数，故名。Logistic回归事实上是一个分类器！！！\n扩展为 softmax"},"Blogs/post/湖":{"slug":"Blogs/post/湖","filePath":"Blogs/post/湖.md","title":"湖","links":[],"tags":["诗词曲赋","现代诗"],"content":"静静躺在城市中央\n待云朵与岁月同流\n而你是花，是草\n是交错的公路\n期待你的驻足\n如逆流之虹\n但旅人未驻足\n列车未曾停止\n少年未曾回头\n所以你未曾到过波心，不谙水性\n你有你的文艺\n而我只是静静的一片湖"},"Blogs/post/独不见":{"slug":"Blogs/post/独不见","filePath":"Blogs/post/独不见.md","title":"独不见","links":[],"tags":["诗词曲赋"],"content":"莫以危楼栏杆凭，天南地北相思寻。\n涂山一望成千古，石尤翻阻远客行。\n朽木堪比彭祖老，情丝可争日月新。\n悲肠寥寥独不见，空将纷繁枕边吟。"},"Blogs/post/理园小桂":{"slug":"Blogs/post/理园小桂","filePath":"Blogs/post/理园小桂.md","title":"理园小桂","links":[],"tags":["诗词曲赋"],"content":"\n武理时光，大多是屌丝理工男宿舍生活。校园里开遍了石楠花，你懂得。某个恰当的时节，恰当的地点，遇到理学院的桂花香，算得上是人间天堂了。\n\n寂寞花开寂寞枝，\n一抹幽香没晓思，\n无端牵得游人住，\n不是深闺话片时。"},"Blogs/post/生查子":{"slug":"Blogs/post/生查子","filePath":"Blogs/post/生查子.md","title":"生查子·廿七纪事","links":[],"tags":["诗词曲赋"],"content":"昨日武昌水，纵横磨山北。燕雀噙新枝，怨号惊山鬼。\n幽恨度频传，闻言声亦老。谁折陌上花，一报江南好？"},"Blogs/post/画工":{"slug":"Blogs/post/画工","filePath":"Blogs/post/画工.md","title":"闻奇录·画工","links":[],"tags":["短评"],"content":"唐进士赵颜，于画工处得一软障，图一妇人甚丽。颜谓画工曰：“世无其人也，如可令生，余愿纳为妻。”画工曰：“余神画也，此亦有名，曰真真。呼其名百日，昼夜不歇，即必应之。应则以百家彩灰酒灌之，必活。”颜如其言，遂呼之百日，昼夜不止。乃应曰：“诺”。急以百家彩灰酒灌之，遂呼之活。下步言笑，饮食如常。曰：“谢君召妾，妾愿事箕帚。”终岁，生一儿，年二岁，友人曰：“此妖也，必与君为患！余有神剑，可斩之。”其夕，乃遗颜剑。剑才及颜室。真真乃泣曰：“妾南岳地仙也，无何为人画妾之形，君又呼妾之名，既不夺君愿。君今疑妾，妾不可住。”言讫，携其子，却上软障，呕出先所饮百家彩灰酒。睹其障，唯添一孩子，皆是画焉。\n叹曰：三年为妇，异心何出？世人如赵颜者，必福祸相消。运可持者，三年而已矣！然后祸报将至，其可奈何？"},"Blogs/post/相思曲":{"slug":"Blogs/post/相思曲","filePath":"Blogs/post/相思曲.md","title":"相思曲","links":[],"tags":["诗词曲赋"],"content":"\n系为思念友人作。\n\n两场相思雨，一处相思苦。\n此相系何物，所思在何处？\n依稀门前柳，朦胧沙坪路。\n曾经多少事，只被相思付。\n相思付相知，相知不与语。\n无语怎奈何，未把相思度。\n独叹岁月长，单将人心改。\n便改恁不改一双，指教人心添若堵。\n此处相思空流露，此时相知难清楚。\n又见野桥飞烟处，一轮相思垂天幕。\n归来却向人人诉：\n最恨相思无相知，一生空被相思误！"},"Blogs/post/瞎说KMP算法":{"slug":"Blogs/post/瞎说KMP算法","filePath":"Blogs/post/瞎说KMP算法.md","title":"瞎说 KMP 算法","links":[],"tags":["算法","模式匹配"],"content":"前天做百度笔试，没想到居然出往年的题！哼！更惨的是出了我也不会！我以为只是一个简简单单的字符串匹配，没想到要动用这么难懂的算法。说起来算法导论上也有，只是之前没看到那里。所以，总结一下：我本有好多次机会学习它，然而一次都没有把握。:(\n所以这次，拿出来好好研究一波，做点笔记，以备日后之用。说起来网络上关于该算法的博文一大堆，我也不说能比它们都好，每个人都有适合自己的理解，我这里就是瞎谈一番罢了。\n在开始之前，强烈建议先读Jake Boxer的文章，它从无到有，讲得浅显易懂，介绍了 how it works！我这篇文章，也是在看了好多中文博客未解之后，开始看了那个外文博文。在理解的基础上，加一点自己的描述。\n背景\n长长的博文一大堆，相信你也很珍惜时间，我就长话短说（偷懒找个借口:p）。**这个算法是干嘛的？**它解决的问题是，给定一个字符串，我们称之为主角K，然后你要在一个比它长的配角Z中找到我们的主角。翻译一下：在父串中寻找给定的子串，返回匹配索引。比如说K = king，Z = zookingmonkey，很显然，Z中有与K相同的子串，返回索引4.\n常规方法\n沿用Jake Boxer的例子，设K = abababca，Z = bacbababaabcbab. 常规的方法是从头开始比较，比如\n/* \n * `|` denotes a match\n * `x` denotes a dismatch\n */\n\n(1):\nbacbababaabcbab\nx\nabababca\n\n(2):\nbacbababaabcbab\n |x\n abababca\n\n(3):\nbacbababaabcbab\n  x\n  abababca\n\n(4):\nbacbababaabcbab\n   x\n   abababca\n\n(5):\nbacbababaabcbab\n    |||||x\n    abababca\n\n(6):\nbacbababaabcbab\n     x\n     abababca\n\n(7):\nbacbababaabcbab\n      |||x\n      abababca\n\n(8):\nbacbababaabcbab\n       x\n       abababca\n\n(9):\nbacbababaabcbab|\n               |\n        abababca\n\n---&gt; return NOT FOUND!\n\n以上就是正常思考的方法，维护一个指针p，指向第一次开始比的位置，然后依次比下去， 跟踪匹配的位数 ，如果全部匹配，返回p，如果有一个不匹配，直接右移一位，p = p+1. 接着如法炮制，从第一个字符依次比下去。设父串Z的长度为 n，子串K的长度为m，那么上述方法最坏情况下要比较m*n次，时间复杂度为O(mn).\nKMP算法要做的事情的，就是根据子串K的特征，在移位和比较的时候实现一个跳步！减少了比较次数。\n但是要根据子串K的特征，哪又是什么样的？该如何刻画呢？这就要说到下面的 partial match table 了。\nPartial Match Table\nKMP有一个很重要的表，叫做 Partial Match Table (PMT)，翻译过来叫做部分匹配表。它有多重要呢？就像理想对于你的那种重要。KMP什么时候能跳步，跳多少，都是由它决定的！\n先来看看它如何产生的吧，关于它的生成，许多博文讲得很清楚了。其中大多是用前缀集、后缀集的概念描述。设有字符串str = ababba, 它的长度length(str) = 6,\n\n前缀集：去掉字符串尾部 1-5 个字符得到的所有子串。记作 P(str) = {a, ab, aba, abab, ababb}.\n后缀集：去掉字符串头部 1-5 个字符得到的所有子串。记作 S(str) = {a, ba, bba, abba, babba}.\n\n该字符串str = ababba对应的 partial mathch value (PMV) 计算方式：\nv = \\max_{i\\in S(\\texttt{str}) \\cap P(\\texttt{str})} \\text{length}(i) := f(\\texttt{str})\n于是，给定一个字符串str，我们的f(str)就能返回它的PMV. 现在有请我们的主角K = abababca上场，我们来看看如何构建它的PMT.\n\nNote: 为了防止我自定义的术语让你感到很吃力，先给你洗个脑。\nPMT 是一个表（table）， PMV 是一个值（value）。PMT中的元素就是PMV.\nPMT 是一个表（table）， PMV 是一个值（value）。PMT中的元素就是PMV.\nPMT 是一个表（table）， PMV 是一个值（value）。PMT中的元素就是PMV.\n\n先用一句话简要说明一下：对K的前缀集的每个字符串再加上K本身，计算它们的PMV，按从短到长的顺序将它们排成一行。再用程序语言表达一下：\ndef buildPMT(K):\n    # 假设 S(K) 返回的列表按子串的长度从小到大排序\n    PMT = [f(substr) for substr in S(K)]\n    PMT.append(f(K))\n    return PMT\n那么我们计算得到的K = abababca的 partial match table 如下：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstrabababcavalue00123401index01234567\n记住这个表，它很重要！或者讲到跳转的时候再过来查看。这一部分基本上是转述了Jake Boker的话，不过表达的可能不如他。感谢Jake Boxer.\n又\n下面讲讲我理解的PMT的计算方式。因为PMV (partial match value) 是最大公共子串的长度，哪两个公共？前缀集和后缀集！那么我们比较的时候肯定要分别在两个集合中找字符串长度一致的两个串，考察它们是否相等。依次从长度为1，2，3…这么一直找下去，如果有更长的公共串，就更新PMV。\n具体来说，给我一个字符串str = ababa，我可以这样来计算它的PMV. 想象有一块木板插空该字符串，\na|baba =&gt; a, baba\nab|aba =&gt; ab, aba\naba|ba =&gt; aba, ba\nabab|a =&gt; abab, a\n\n每次插空，我都可以得到一个前缀和一个后缀。从上面的结果来看，产生的次序还有一定的对称性。那么我计算它的PMV时，直接这样比较：\n(1). a|baba &lt;=&gt; abab|a ---&gt; PMV = 1\n(2). ab|aba &lt;=&gt; aba|ba ---&gt; PMV = 3\n( ). aba|ba &lt;=&gt; ab|aba ---&gt; it returns to step (2)\n( ). abab|a &lt;=&gt; a|baba ---&gt; it returns to step (1)\n\n---&gt; return PMV = 3\n\n即每次划分之后，我直接考察它对称的划分，然后比较前缀后缀是否相等，进而更新PMV.\nPMT 怎么用\n实际上这一段也算是转述Jake Boxer的话，再次感谢！\n\nKMP算法要做的事情的，就是根据子串K的特征，在移位和比较的时候实现一个跳步！减少了比较次数。\n\n之前提到KMP的主要思想就是跳步，现在是时候来看看它是怎么个跳法了。同样的父串Z = bacbababaabcbab，子串K = abababca.\n/*\n * `|` denotes a match\n * `x` denotes a dismatch\n * `~` denotes a jump\n */\n\n(1):\nbacbababaabcbab\nx\nabababca\n\n(2):\nbacbababaabcbab\n |x\n abababca\n\n(3):\nbacbababaabcbab\n  x\n  abababca\n\n(4):\nbacbababaabcbab\n   x\n   abababca\n\n(5):\nbacbababaabcbab\n    |||||x\n    abababca\n!ATTENTION! I&#039;LL JUMP\n\n(6):\nbacbababaabcbab\n    ~~|||x\n      abababca\n!JUMP AGAIN!\n\n(7):\nbacbababaabcbab|\n      ~~       |\n        abababca\n\n---&gt; return NOT FOUND!\n\n为什么你跳得这么兴奋？为什么可以这么跳？我想应该有人和我当初一样，虽然你跳的很好，但是我一脸懵逼(＃°Д°).\n我们把来看step5到step6的跳步拎出来看看，\n(5):\nbacbababaabcbab\n    |||||x\n    abababca\n\n(5.1):\n****ababa******\n    |||||x\n    ababa***\n\n从step5到step5.1我什么也没干，只是把一些碍眼的东西替换成了*号。我们可以看到的是，step5匹配了5个字符，匹配的是K的开头向后5个字符。让我们回头看看这个子串的PMV，查表得知f(&quot;ababa&quot;)=3. 这个“3”代表着什么？它代表了子串ababa的长度为3的前缀一定等于长度为3的后缀，因为这就是PMV的物理意义啊，同志们！所以我可以跳步！直接将前缀abc挪到与后缀abc对齐！\naba|ba &lt;=&gt; ab|aba\n\n---&gt; jump:\n\nababa\n~~|||\n  ababa\n\n我不但可以跳步2，我还知道后面的3个字符比都不用比，肯定和父串match，所以我直接从第4个字符开始比。\n(5):\nbacbababaabcbab\n    |||||x\n    abababca\n\n(5.1):\n****ababa******\n    |||||x\n    ababa***\n\n(6):\nbacbababaabcbab\n    ~~|||x\n      abababca\n         |\n         start point for comparison\n\n如果将PMT存在一个数组里，数组下表从0开始的话，那么每次跳步的长度就可以用一个公式来刻画：\n\n    \n        jump_chars = PML - PMT[PML-1]\n    \n\n其中，PML 表示 partial match length，代表当前匹配长度，比如step5的匹配长度 `PML=5`.\nQ: PMT是什么？它为什么这么屌？凭什么它这么屌？它是干嘛的呢？\nA: 可以说PMT就是待匹配字符串的本体了。\n复杂度分析\n来日在填(╬ Ò ‸ Ó)\nC++实现\nReference\n\nThe Knuth-Morris-Pratt Algorithm in my own words\n"},"Blogs/post/碎碎念":{"slug":"Blogs/post/碎碎念","filePath":"Blogs/post/碎碎念.md","title":"真·碎碎念","links":[],"tags":["碎碎念"],"content":"一连几天阴雨天气让身体倍感不适。这两天终于出了太阳。日中则偏。有角度的阳光是温柔的。当烈日变成斜阳，人也就多了些欣赏的眼光。斜阳成绮大约就是这样了。需要我描述吗？它已经被眼睛写入大脑了。这日落，不得不让人想起要开学离家了。本来也是无可厚非，刚回家的时候，想起回校也是大大方方就能接受的，可迫近了这个关头，心眼倒小些了。回头望望这个暑假，也没做什么，没有打工，没有学车，没有学菜。说是没做什么，可时间总是有去向的。又是一个无可厚非。时间花在哪里，哪里就会有收获。从未有浪费这一说。所有的时间没有什么值得不值得花费，只有自己愿意不愿意罢了。你在A事件上花费了时间，取得了收获，收获了你所追求的，自己又是情愿的，那么，无论A事件是什么，这个时间不算浪费。那么我的时间呢？我只告诉你我在一个循环中，螺旋上升。人有时会迷茫，但日子还是正常过。咦？脑子一下空了。怎么感觉语无伦次。必须承认我不是写作文的料啊。脑子空了就写不出来了，写不出来了就不写了，最后让我冠冕堂皇地称之为随心而止。拜拜"},"Blogs/post/祝考研顺利":{"slug":"Blogs/post/祝考研顺利","filePath":"Blogs/post/祝考研顺利.md","title":"祝考研顺利","links":[],"tags":["诗词曲赋"],"content":"\n室友明日考研，祝他顺利吧。\n\n拂影寻花径，\n拨云探青天。\n平生何来意，\n潦潦一纸间。"},"Blogs/post/神奇的位运算":{"slug":"Blogs/post/神奇的位运算","filePath":"Blogs/post/神奇的位运算.md","title":"神奇的位运算","links":[],"tags":["位运算","trick","cpp"],"content":"In editing…\n必备知识\n首先要对原码、反码、补码有一定理解，推荐阅读此文：www.cnblogs.com/zhangziqiu/archive/2011/03/30/computercode.html\n摘要：按1 byte来算，1的机器数为0000 0001，原码、反码、补码均为 0000 0001. -1的机器数为1000 0001，原码为机器数、反码为1111 1110，补码为1111 1111.\n总结来说：最高位用作符号位，0表示正数，1表示负数。正数的原、反、补码一样。负数的反码为除符号位外按位取反，补码为反码加1.\n为什么C系语言中，int的范围为-2^{n-1} \\sim 2^{n-1} - 1，其中n为bit数。同样以1 byte来算，8bit能够表达的有符号范围如下：\n1111 1111   # -(2^7 - 1) = -127\n0111 1111   #  (2^7 - 1) =  127\n\n但从排列组合来看，8位能够表达的数字共有2^8 = 256个，而-127 \\sim 127只有255个数。还有一个数跑哪去了呢。答案是0，0有两种表示方法：\n1000 0000   # -0\n0000 0000   # +0\n\n这无疑是一种浪费，我们选择下面那个数表示0。而将上面的1000 0000（首先它表示一个负数，负数用补码表示，因此它应该是代表-128的补码）用于表示-128，如此一来，8bit的表达范围扩展到-128 \\sim 127，正好256=2^8个数。\n至于为什么用1000 0000来表示-128，此中还是有些门道，来看-127的三码：\n1111 1111   # -127原码\n1000 0000   # -127反码\n1000 0001   # -127补码\n\n如此一来-128的补码就等于-127的补码减一得：1000 0000. 关于负数为什么用补码表示，其实是为了做加法，计算机内没有减法器，只有加法器，具体参见上文。以上我只是用8bit数举例，实际计算机中int可能有32bit，以此类推。\n以下部分转载自：www.cnblogs.com/junsky/archive/2009/08/06/1540727.html\n假设有一个 int 类型的数，值为5，那么，我们知道它在计算机中表示为：\n00000000 00000000 00000000 00000101\n5转换成二制是101，不过int类型的数占用4字节（32位），所以前面填了一堆0。\n\n1 byte = 8 bits\n\n现在想知道，-5在计算机中如何表示？**在计算机中，负数以其正值的补码形式表达。**什么叫补码呢？这得从原码，反码说起。\n\n原码：一个整数，按照绝对值大小转换成的二进制数，称为原码。\n比如\n00000000 00000000 00000000 00000101 是 5 的原码。\n反码：将二进制数按位取反，所得的新二进制数称为原二进制数的反码。\n取反操作指：原为1，得0；原为0，得1。（1变0; 0变1）\n比如：将\n00000000 00000000 00000000 00000101每一位取反，得\n11111111 11111111 11111111 11111010。\n称：\n11111111 11111111 11111111 11111010 是\n00000000 00000000 00000000 00000101 的反码。\n反码是相互的，所以也可称：\n11111111 11111111 11111111 11111010 和\n00000000 00000000 00000000 00000101 互为反码。\n补码：反码加1称为补码。\n也就是说，要得到一个数的补码，先得到反码，然后将反码加上1，所得数称为补码。\n比如：\n00000000 00000000 00000000 00000101 的反码是：\n11111111 11111111 11111111 11111010。\n那么，补码为：\n11111111 11111111 11111111 11111010 + 1 =\n11111111 11111111 11111111 11111011\n\n所以，-5 在计算机中表达为：\n11111111 11111111 11111111 11111011。转换为十六进制：0xFFFFFFFB。\n再举一例，我们来看整数-1在计算机中如何表示。假设这也是一个int类型，那么：\n\n先取1的原码：\n00000000 00000000 00000000 00000001\n得反码：\n11111111 11111111 11111111 11111110\n得补码：\n11111111 11111111 11111111 11111111\n\n可见，－1在计算机里用二进制表达就是全1。16进制为：0xFFFFFF.\n\n转载部分结束，感谢原作者。为了便于阅读，我对排版稍作了改动。\n\n常见的位运算\nC/C++位运算符\n\n~：按位取反\n&lt;&lt;：左移位\n&gt;&gt;：右移位\n&amp;：按位与\n|：按位或\n^：按位异或\n\nSummary from learncpp.com\nCf. www.learncpp.com/cpp-tutorial/bit-manipulation-with-bitwise-operators-and-bit-masks/\nSummarizing how to set, clear, toggle, and query bit flags:\nTo query bit states, we use bitwise AND:\nif (flags &amp; option4) ... // if option4 is set, do something\nTo set bits (turn on), we use bitwise OR:\nflags |= option4; // turn option 4 on.\nflags |= (option4 | option5); // turn options 4 and 5 on.\nTo clear bits (turn off), we use bitwise AND with bitwise NOT:\nflags &amp;= ~option4; // turn option 4 off\nflags &amp;= ~(option4 | option5); // turn options 4 and 5 off\nTo flip bit states, we use bitwise XOR:\nflags ^= option4; // flip option4 from on to off, or vice versa\nflags ^= (option4 | option5); // flip options 4 and 5\nApplications\n除以/乘以2\nn &gt;&gt; 1: 右移一位，低位的1被忽略，floor(n/2).\nn &lt;&lt; 1: 左移一位，低位补0，n * 2.\n取相反数\n~n + 1：对n取反得到反码，加1得到补码，即对应的负数。\n(n ^ -1) + 1：-1的二进制全是1，按位异或之后得到的等价与按位取反。\n计算 n+1\n-(~n)：\n~n + 1 = -n\n-(~n + 1) = n\n-~n - 1 = n\n-~n = n+1\n\n计算 n-1\n~-n:\nn-1 = -(-n+1)\n-n+1 = -(~-n) &lt;--- n+1 = -~n\nn-1 = ~-n\n\nif(x==a) x=b; if(x==b) x=a;\nx = a ^ b ^ x：如果x=a，则相当于对b翻转两次，结果自然是b；如果x=b，那么b^b=0，0异或任何数都没有效果，故结果是a.\n判断奇偶\nn &amp; 1: 如果结果为1，则表明n的最低位为1，n为奇数；反之为偶数。\n变量互换（无需临时变量）\na ^= b ^= a ^= b:\n// the expression expands two:\n1). b ^= a ^= b; // now final_b = b ^ (a^b) = a, temp_a = (a^b)\n2). a ^= b; // now final_a = temp_a ^ final_b = (a^b) ^ a = b\n \n// as you know, xor twice does nothing!\n \n// ---------------------------------------------//\n// if you doesn&#039;t understand, read the following:\n// read from right to left\n// now we are reading `a ^= b`\na ^= b --&gt; = a ^ b // tag this tmp_a = a ^ b\n \n// we are reading `b ^= a ^= b`\nb ^= a --&gt; = b ^ (a ^ b) = a\n \n// we are reading `a ^= b ^= a ^= b`\na ^= b --&gt; = tmp_a ^ b = (a ^ b) ^ a = b\n \n// at last\nb = a\na = b\n判断是否为2的幂\nn &amp; (n-1)：如果n是2的幂，则\nn   = 0b100000...\nn-1 = 0b011111...\n// now n &amp; (n-1) = 0, we can judge if it is 0\n// to determine wether n is a power of 2.\n对2的n次方取余\nm &amp; ((1&lt;&lt;n) - 1):\n(1&lt;&lt;n)      = 0b10000... // is the nth power of 2\n(1&lt;&lt;n) - 1  = 0b01111...\nm &amp; ((1&lt;&lt;n) - 1) // keep the bits lower than n\n取n的第m低位\n(n &gt;&gt; (m-1)) &amp; 1: 右移m-1位，最低位即为原从低到高第m位\n将n的第m低位置1\nn | (1 &lt;&lt; (m-1)): 将1左移m-1位于n的第m低位对应，相或置1\n将n的第m低位置0\nn &amp; ~(1 &lt;&lt; (m-1)): 将1左移m-1位对上n的第m低位，按位取反相与\nReferences\n\n负数的二进制表示方法\n优秀程序员不得不知道的20个位运算技巧\n位运算简介及实用技巧（一）：基础篇\n"},"Blogs/post/结萝":{"slug":"Blogs/post/结萝","filePath":"Blogs/post/结萝.md","title":"结萝","links":[],"tags":["诗词曲赋"],"content":"\n结萝（后名毒影）是《仙剑奇侠传五前传》游戏中的人物，苗疆女子，邂逅厉岩（后名血手），一直苦苦追随，研究情蛊，希望以此得到厉岩的关心，其实厉岩原本就很喜欢她，只是羞于表露。\n\n结萝在绮侧，\n圆叶绵延发。\n莲心倾不倾，\n骤雨停不停。\n\n\n"},"Blogs/post/行香子寄贺双卿":{"slug":"Blogs/post/行香子寄贺双卿","filePath":"Blogs/post/行香子寄贺双卿.md","title":"行香子·寄贺双卿","links":["Blogs/雪压轩集.html"],"tags":["诗词曲赋"],"content":"\n见《雪压轩集》。\n\n丝丝柳絮，点点残雨。正春初，愁云乱舞。水田夕下，秋碧楚楚。纵月儿长，日儿短，双卿苦。\n豆蔻妙龄，玉带华年，偏风刀霜剑无诉。幽如白兰，缘命早枯。只怜卿长，叹卿短，代卿哭。"},"Blogs/post/记一次重装Linux":{"slug":"Blogs/post/记一次重装Linux","filePath":"Blogs/post/记一次重装Linux.md","title":"记一次重装 Linux","links":["Blogs/post/wenq.org.html"],"tags":[],"content":"放假回家，因故将笔记本电池弄到枯竭。结果再次开启，发现 startx 启动 gnome-session 失败。几经解决未果，只好重装！\n\n安装 Archlinux\n基本安装步骤都是按照 ArchWiki 上的 Installation Guide 以及简书上的一篇文章 虚拟机安装Archlinux的简易步骤.\n安装过程主要可以分为以下几个步骤：\n1.分区\n一般而言只需要分 3 个区：根（/），用户主目录(/home) 以及 swap 交换。贴一下我的分区图\n\n可以看到，一块磁盘 (disk) 被分成很多的分区 (partition) . 其中，稍微现代一点的电脑主板都启用了 UEFI，所以在磁盘第一个分区是 ESP 分区。这个分区中就包含了所有可启动系统的启动文件。在没有安装 Linux 之前，它里面只包含有 Windows 自带的启动文件。在安装完成 Linux 后，由于有两个可启动的系统，所以需要一个引导程序(rEFInd, Grub 等)来将选择权交给用户。\n上图中的最后三个分区即为 Linux 系统的分区。分区大小的划分事实上很讲究，我根据之前的经验，/home 分 50GB 够用了，如果不放什么大型视频和音频文件的话。swap 分区的大小一般为已安装内存的一半，比如我的系统内存 8GB，swap 就分 4GB.\n2.格式化分区\nLinux 文件系统一般是 ext4，使用如下命令格式化分区\nmkfs.ext4 /dev/nvme0n1p5\nmkfs.ext4 /dev/nvme0n1p6\nmkfs.ext4 /dev/nvme0n1p7\n3.挂载目录\n将各目录挂载到对应的分区，例如\nmount /dev/nvme0n1p5 /mnt\nmount /dev/nvme0n1p6 /mnt/home\n# boot分区其实应该单独分出来\n# 但是我们已经有了 esp 分区\n# 要和原来的 Windows 兼容\n# 只需要将该 esp 分区挂载到 /boot/efi 目录下\n# 之后安装 bootloader 时会把 Linux 的启动文件放到 esp 分区\nmount /dev/nvme0n1p1 /mnt/boot/efi\n开启 swap 分区以便之后生成 fstab 时检测\nswapon /dev/nvme0n1p7\n4.执行安装\n核心命令为：\npacstrap -i /mnt base base-devel net-tools\n其余细节参考 ArchWiki. 值得一提的是，base 组里面包含的程序包有限，所以追加了 base-devel 和网络配置工具包 net-tools.  注意执行安装命令前，对 /etc/pacman.d/mirrorlist 进行相关修改，把中国的镜像放在前面，使得下载速度更快。还有几个有用的网络工具包也一并装了 iw, wpa_supplicant, dialog.\n5.后续步骤\n后续就是 arch-chroot 到新安装系统中进行相关设置：hostname，hosts，时区，locale 等。这些在 Installation Guide 中均有提及，不再赘述。\n6.小结\n以上，一个新的 Archlinux 就安装完成了。不过这只是一个简陋的系统，还没有进行配置，只能用终端输命令的那种。后续配置参考简书那篇文章。\n这次安装，我的最大的一个收获就是学会了如何在命令行中连接 WiFi. 需要的工具有\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPackageCommandNotedialogwifi-menuWiFi 直连net-toolsifconfig查看网络状态wpa_supplicantwpa_supplicant, wpa_passphrase连接 WiFidhcpcddhcpcd动态 IP 地址获取\n获取无线接口名称\n\n好了，现在知道了，是 wlp2s0. 一般也可能是 wlan0. 然后确认该接口的状态是 up，如图所示。\n扫描可用网络\niw wlp2s0 scan\n确定你要连接的无线网络名称 (SSID)，假设是 shiki.\n生成配置文件\nwpa_passphrase shiki &gt; ~/shiki.conf\n连接 WiFi\nwpa_supplicant -B -i wlp2s0 -c ~/shiki.conf\n获取 IP 地址\ndhcpcd wlp2s0\n查看连接状态\niw wlp2s0 link\n\n另外，还有一种更加简单的方法，直接敲命令 wifi-menu 可以进行交互式 WiFi 连接，体验和图形界面一样。\n安装 Gnome\n来日在填\n系统美化\n字体\n如何在 Linux 上安装喜欢的字体呢？只需要将对应的字体文件复制到相应的字体目录，再执行几个命令就 OK 了。\n下载字体\n英文字体的话，Google Fonts 基本可以完全搞定。\n关于中文字体，目前推荐的只有两个：文泉驿，文鼎。\n例如要将下载好的 Alegreya.zip 字体安装到系统，只需要将其解压：\n\n可以看到里面的字体文件。挑几个解释一下\nAlegreya-Regular.ttf    # 常规字体\nAlegreya-Italic.ttf    # 斜体\nAlegreya-Bold.ttf    # 粗体\nAlegreya-BoldItalic.ttf    # 粗斜体\n\n一般而言，虽然一个字体包里面可能有很多字体文件，很多变体（粗体，特粗，细，特细等），我们只需要安装以上四种变体基本上就足够了。在 TeXLive 中，如果指定了字体族，那么其中的 \\emph 和 \\textbf命令会自动寻找相应的变体来排版。\n复制到指定目录\n将这四个文件复制到系统字体文件夹\n# 用户字体目录\n~/.local/share/fonts\n\n# 系统字体目录\n/usr/share/fonts\n\n为了便于管理，可以在系统字体目录下新建一个文件夹存放用户后续安装的字体，例如\nmkdir /usr/share/fonts/userfonts\n将需要安装的字体文件复制到上述文件夹，然后\n执行安装命令\nmkfontdir\nmkfontscale\n \nfc-cache -fv  #刷新系统字体缓存\n \n确认安装是否成功\nfc-list | grep userfonts\n\n如图所示，可以看到在指定目录下的字体已经安装成功！\n卸载字体\n删除相应字体文件，刷新系统字体缓存即可\n查看已安装字体\nfc-list :lang=zh # 查看支持中文的字体\nTroubleshooting\nintel集成显卡滚动屏幕出现撕裂现象\n可能有用的链接\n\nwiki.archlinux.org/title/Intel_graphics#Xorg_configuration\n\n如何查看当前加载的显卡驱动：\nlspci -v | grep -A20 VGA\n查看nvidia则grep 3D\n按照archwiki上所说，结果启动X报错，说没有intel这个module，后来发现应该xf86-video-intel这个驱动没装的原因。装了之后，再启动就没有屏幕撕裂现象了。\n\n搁置了这么久终于解决了屏幕撕裂的问题，呼！\n\n启用nvidia独显\n可能有用的链接\n\nhowto.lintel.in/install-nvidia-arch-linux/\nwiki.archlinux.org/title/NVIDIA#Xorg_configuration\n"},"Blogs/post/评仙剑":{"slug":"Blogs/post/评仙剑","filePath":"Blogs/post/评仙剑.md","title":"《仙剑奇侠传》的爱与道","links":[],"tags":["短评"],"content":"\n这么多年最爱的电视剧还是《仙剑奇侠传一》，当年因为一是兴趣，到仙剑贴吧发了这个帖子，被秒删了。我寻思我也没说啥呀，自此没玩过贴吧。\n\n姜明得道时对逍遥说：你明白吗？\n若拙得道时对青儿说：你明白吗？\n还有之后对莫一兮说：你明白吗？\n以及最后逍遥手抱婴儿对若拙说：你明白吗？\n本来一切都是注定：就像逍遥与灵儿的结局。若拙早算出事态的发展，若不加以阻止，三人之中必定有人牺牲。故将灵儿关入锁妖塔。无奈天意不可违，即便是近道之人也不能干预别人的修道之路。灵儿的痴情，逍遥的执着，让一切都按照注定发生了。即便后来逍遥意识到错，回到十年前欲改变一切，也只是弄巧成拙，故意避开仙灵岛的方向，却不知竟绕了地球一圈。结果一切都没有改变。后来逍遥抱着孩子，想必是五味杂陈的吧。再后来，他就得道了。你说这一切有必要改变吗？即便十年后让灵儿再现，灵儿已不是灵儿，逍遥也不是逍遥了吧。各自已经成道，也就没有必要再像以前那样了。不是不爱，而是明白了，不局限于爱了。仙一的主题就是爱与道这两个字了。鉴于时间太晚，先这么办吧"},"Blogs/post/谈谈-LaTeX-的自定义字体":{"slug":"Blogs/post/谈谈-LaTeX-的自定义字体","filePath":"Blogs/post/谈谈-LaTeX-的自定义字体.md","title":"快速自定义 LaTeX 排版字体","links":[],"tags":["排版","latex","字体"],"content":"字体设置\n在导言区引入fontspec包：\\usepackage{fontspec}\n使用如下命令自定义字体：\n% 西文默认字体，排版主字体\n\\setmainfont{}\n \n% 西文无称线字体\n\\setsansfont{}\n \n% 西文等宽字体\n\\setmonofont{}\n \n% 数学公式字体\n\\setmathfont{}\n \n% 中文主字体\n\\setCJKmainfont[\n    Path = fonts/zh_cn/ ,\n    BoldFont = HYQiHei-70S.ttf ,\n    ItalicFont = HYKaiTiS.ttf ,\n    SmallCapsFont = HYQiHei-70S.ttf\n    ]{HYQiHei-45S.ttf}\n\n\nNote:\n\n使用fc-list查看系统字体\n使用fc-list: lang=zh查看中文字体\n\n\n直接使用字体文件\nLaTeX可以直接使用未安装的字体文件进行排版，但要指定字体文件的位置等信息。\n\\setCJKmainfont[\n    Path = ./fonts/zh_cn/ , % specify the file location\n    Extension = .ttf , % specify the file suffix [opt]\n                       % or add them manually\n    BoldFont = HYQiHei-70S.ttf, % &#039;.ttf&#039; can be dropped if \n                                % &#039;Extension&#039; is specified\n    ItalicFont = HYKaiTiS.ttf,  % similarly\n]{HYQiHei-45S.ttf}              % set default font to 汉仪旗黑\n\n\n从上面两张图可以看出，中文字体不像西文，是没有对应的斜体和粗体的。所以只能用其他字体替代，通过改变字体的方式达到伪斜体，伪粗体的效果。\n设置字体别名\n\\setCJKfamilyfont{zhsong}{HYZhongSongS}\n\\setCJKfamilyfont{zhhei}{WenQuanYi Micro Hei}\n%\\setCJKfamilyfont{zhfs}{Adobe Fangsong Std}\n%\\setCJKfamilyfont{zhkai}{Adobe Kaiti Std}\n%\\setCJKfamilyfont{zhli}{LiSu}\n%\\setCJKfamilyfont{zhyou}{YouYuan}\n \n\\newcommand*{\\songti}{\\CJKfamily{zhsong}}   % 宋体\n\\newcommand*{\\heiti}{\\CJKfamily{zhhei}}     % 黑体\n%\\newcommand*{\\kaishu}{\\CJKfamily{zhkai}}   % 楷书\n%\\newcommand*{\\fangsong}{\\CJKfamily{zhfs}}  % 仿宋\n%\\newcommand*{\\lishu}{\\CJKfamily{zhli}}     % 隶书\n%\\newcommand*{\\youyuan}{\\CJKfamily{zhyou}}  % 幼圆\n以上为对应的字体设定了我们较为习惯的别名，使用方式如下：\n{\\zhsong 这段文字使用宋体字。}\n{\\zhhei 这段使用黑体。}\nLaTeX 字体样式相关命令\n字体大小\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCOMMANDSIZE\\tiny5pt\\scriptsize7pt\\footnotesize8pt\\small9pt\\normalsize10pt\\large12pt\\Large14pt\\LARGE18pt\\huge20pt\\Huge24pt\n字体样式\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCOMMANDSTYLE\\textbf粗体\\textit斜体\\textslslanted斜体\\textsc小体大写文本\\underline下划线\\texttt打字机字族，调用\\setmonofont{}所设置的字体\\textsf无称线字族，调用\\setsansfont{}所设置的字体\\textrm罗马字族，调用m\\setmainfont{}所设置的字体\n扩展包\nulem 宏包\n在导言区引入：\\usepackage{ulem}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCOMMANDSTYLE\\uline下划线\\uuline双下划线\\uwave波浪线\\sout删除线\\xout斜删除线\n基础排版\n行距\n\n首先，行距就是相邻两行文字之间的距离。在下面的图片中，两个下划线之间的长度就叫行距。行距的调节一般使用倍数，比如两倍行距。而“单倍行距”又根据字体、字号、软件的不同而改变（不同软件中有不同的定义，没有一个通用的值）。在 LaTeX 里面也有这些概念，在你定义字号的时候，“单倍行距”也随之确定。更改时，我们更改的是“单倍行距”的倍数。\n\n在导言区使用\\linespread{2.0}可设置2倍行距。\n缩进\n\n\\noindent：取消当前段的首行缩进\n\\indent：强制首行缩进\n\n对齐\n% oneline\n\\leftline{左对齐}\n\\centerline{居中对齐}\n\\rightline{右对齐}\n \n% multiline\n\\flushleft{左对齐}\n\\center{居中对齐}\n\\flushright{右对齐}\n \n% or\n\\begin{flushright/center/flushleft}\n    some text...\n\\end{flushright/center/flushleft}\n页面版式\n页面版式包括页眉页脚，以下两个命令可以设置页面版式：\n\n\\pagestyle：设置当前页及后续页版式\n\\thispagestyle：设置当前页的版式\n\n可选版式包括\n\nempty：无页眉页脚\nplain：无页眉，页脚为居中页码\nheadings：页眉为章节标题，无页脚\nmyheadings：自定义页眉，无页脚\n\n使用\\thispagestyle{empty}可将当前页的页眉页脚关闭。\nReferences\n\nLaTeX系列笔记(5)-行距\n"},"Blogs/post/谈谈《报任安书》":{"slug":"Blogs/post/谈谈《报任安书》","filePath":"Blogs/post/谈谈《报任安书》.md","title":"《报任安书》","links":[],"tags":[],"content":"太史公牛马走司马迁，再拜言。\n　　少卿足下：曩者辱赐书，教以慎于接物，推贤进士为务，意气勤勤恳恳。若望仆不相师，而用流俗人之言，仆非敢如此也。仆虽罢驽，亦尝侧闻长者之遗风矣。顾自以为身残处秽，动而见尤，欲益反损，是以独郁悒而无谁语。谚曰：“谁为为之？孰令听之？”盖钟子期死，伯牙终身不复鼓琴。何则？士为知己者用，女为说己者容。若仆大质已亏缺矣，虽材怀随和，行若由夷，终不可以为荣，适足以发笑而自点耳。\n\n　　书辞宜答，会东从上来，又迫贱事，相见日浅，卒卒无须臾之间，得竭指意。今少卿抱不测之罪，涉旬月，迫季冬，仆又薄从上雍，恐卒然不可为讳，是仆终已不得舒愤懑以晓左右，则长逝者魂魄私恨无穷。请略陈固陋。阙然久不报，幸勿为过。\n　　仆闻之：修身者，智之符也；爱施者，仁之端也；取予者，义之表也；耻辱者，勇之决也；立名者，行之极也。士有此五者，然后可以托于世，列于君子之林矣。故祸莫憯于欲利，悲莫痛于伤心，行莫丑于辱先，诟莫大于宫刑。刑余之人，无所比数，非一世也，所从来远矣。昔卫灵公与雍渠同载，孔子适陈；商鞅因景监见，赵良寒心；同子参乘，袁丝变色：自古而耻之！夫以中材之人，事有关于宦竖，莫不伤气，而况于慷慨之士乎！如今朝廷虽乏人，奈何令刀锯之余，荐天下之豪俊哉！仆赖先人绪业，得待罪辇毂下，二十余年矣。所以自惟：上之，不能纳忠效信，有奇策材力之誉，自结明主；次之，又不能拾遗补阙，招贤进能，显岩穴之士；外之，不能备行伍，攻城野战，有斩将搴旗之功；下之，不能积日累劳，取尊官厚禄，以为宗族交游光宠。四者无一遂，苟合取容，无所短长之效，可见于此矣。乡者，仆亦尝厕下大夫之列，陪外廷末议。不以此时引维纲，尽思虑，今已亏形为扫除之隶，在阘茸之中，乃欲仰首伸眉，论列是非，不亦轻朝廷、羞当世之士邪？嗟乎！嗟乎！如仆尚何言哉！尚何言哉！\n　　且事本末未易明也。仆少负不羁之才，长无乡曲之誉，主上幸以先人之故，使得奉薄伎，出入周卫之中。仆以为戴盆何以望天，故绝宾客之知，忘室家之业，日夜思竭其不肖之材力，务一心营职，以求亲媚于主上。而事乃有大谬不然者！\n　　夫仆与李陵俱居门下，素非能相善也。趣舍异路，未尝衔杯酒，接殷勤之余欢。然仆观其为人，自守奇士，事亲孝，与士信，临财廉，取予义，分别有让，恭俭下人，常思奋不顾身，以徇国家之急。其素所蓄积也，仆以为有国士之风。夫人臣出万死不顾一生之计，赴公家之难，斯已奇矣。今举事一不当，而全躯保妻子之臣随而媒孽其短，仆诚私心痛之。且李陵提步卒不满五千，深践戎马之地，足历王庭，垂饵虎口，横挑强胡，仰亿万之师，与单于连战十有余日，所杀过当。虏救死扶伤不给，旃裘之君长咸震怖，乃悉征其左、右贤王，举引弓之民，一国共攻而围之。转斗千里，矢尽道穷，救兵不至，士卒死伤如积。然陵一呼劳军，士无不起，躬自流涕，沬血饮泣，更张空弮，冒白刃，北首争死敌者。陵未没时，使有来报，汉公卿王侯皆奉觞上寿。后数日，陵败书闻，主上为之食不甘味，听朝不怡。大臣忧惧，不知所出。仆窃不自料其卑贱，见主上惨凄怛悼，诚欲效其款款之愚，以为李陵素与士大夫绝甘分少，能得人之死力，虽古之名将，不能过也。身虽陷败，彼观其意，且欲得其当而报于汉。事已无可奈何，其所摧败，功亦足以暴于天下矣。仆怀欲陈之，而未有路，适会召问，即以此指，推言陵之功，欲以广主上之意，塞睚眦之辞。未能尽明，明主不晓，以为仆沮贰师，而为李陵游说，遂下于理。拳拳之忠，终不能自列。因为诬上，卒从吏议。家贫，货赂不足以自赎，交游莫救，左右亲近不为一言。身非木石，独与法吏为伍，深幽囹圄之中，谁可告愬者！此真少卿所亲见，仆行事岂不然乎？李陵既生降，隤其家声，而仆又佴之蚕室，重为天下观笑。悲夫！悲夫！事未易一二为俗人言也。\n　　仆之先非有剖符丹书之功，文史星历，近乎卜祝之间，固主上所戏弄，倡优所畜，流俗之所轻也。假令仆伏法受诛，若九牛亡一毛，与蝼蚁何以异？而世又不与能死节者比，特以为智穷罪极，不能自免，卒就死耳。何也？素所自树立使然也。人固有一死，或重于泰山，或轻于鸿毛，用之所趋异也。太上不辱先，其次不辱身，其次不辱理色，其次不辱辞令，其次诎体受辱，其次易服受辱，其次关木索、被箠楚受辱，其次剔毛发、婴金铁受辱，其次毁肌肤、断肢体受辱，最下腐刑极矣！传曰“刑不上大夫。”此言士节不可不勉厉也。猛虎在深山，百兽震恐，及在槛阱之中，摇尾而求食，积威约之渐也。故士有画地为牢，势不可入；削木为吏，议不可对，定计于鲜也。今交手足，受木索，暴肌肤，受榜箠，幽于圜墙之中。当此之时，见狱吏则头抢地，视徒隶则心惕息。何者？积威约之势也。及以至是，言不辱者，所谓强颜耳，曷足贵乎！且西伯，伯也，拘于羑里；李斯，相也，具于五刑；淮阴，王也，受械于陈；彭越、张敖，南面称孤，系狱抵罪；绛侯诛诸吕，权倾五伯，囚于请室；魏其，大将也，衣赭衣，关三木；季布为朱家钳奴；灌夫受辱于居室。此人皆身至王侯将相，声闻邻国，及罪至罔加，不能引决自裁，在尘埃之中。古今一体，安在其不辱也？由此言之，勇怯，势也；强弱，形也。审矣，何足怪乎？夫人不能早自裁绳墨之外，以稍陵迟，至于鞭箠之间，乃欲引节，斯不亦远乎！古人所以重施刑于大夫者，殆为此也。\n　　夫人情莫不贪生恶死，念父母，顾妻子，至激于义理者不然，乃有所不得已也。今仆不幸，早失父母，无兄弟之亲，独身孤立，少卿视仆于妻子何如哉？且勇者不必死节，怯夫慕义，何处不勉焉！仆虽怯懦，欲苟活，亦颇识去就之分矣，何至自沉溺缧绁之辱哉！且夫臧获婢妾，犹能引决，况仆之不得已乎？所以隐忍苟活，幽于粪土之中而不辞者，恨私心有所不尽，鄙陋没世，而文采不表于后也。\n　　古者富贵而名摩灭，不可胜记，唯倜傥非常之人称焉。盖文王拘而演《周易》；仲尼厄而作《春秋》；屈原放逐，乃赋《离骚》；左丘失明，厥有《国语》；孙子膑脚，《兵法》修列；不韦迁蜀，世传《吕览》；韩非囚秦，《说难》《孤愤》；《诗》三百篇，大底圣贤发愤之所为作也。此人皆意有所郁结，不得通其道，故述往事、思来者。乃如左丘无目，孙子断足，终不可用，退而论书策，以舒其愤，思垂空文以自见。\n　　仆窃不逊，近自托于无能之辞，网罗天下放失旧闻，略考其行事，综其终始，稽其成败兴坏之纪，上计轩辕，下至于兹，为十表，本纪十二，书八章，世家三十，列传七十，凡百三十篇。亦欲以究天人之际，通古今之变，成一家之言。草创未就，会遭此祸，惜其不成，是以就极刑而无愠色。仆诚以著此书，藏之名山，传之其人，通邑大都，则仆偿前辱之责，虽万被戮，岂有悔哉！然此可为智者道，难为俗人言也！\n　　且负下未易居，下流多谤议。仆以口语遇遭此祸，重为乡党所笑，以污辱先人，亦何面目复上父母之丘墓乎？虽累百世，垢弥甚耳！是以肠一日而九回，居则忽忽若有所亡，出则不知其所往。每念斯耻，汗未尝不发背沾衣也！身直为闺阁之臣，宁得自引深藏于岩穴邪？故且从俗浮沉，与时俯仰，以通其狂惑。今少卿乃教以推贤进士，无乃与仆私心剌谬乎？今虽欲自雕琢，曼辞以自饰，无益，于俗不信，适足取辱耳。要之，死日然后是非乃定。书不能悉意，故略陈固陋。谨再拜。"},"Blogs/post/赠有情人":{"slug":"Blogs/post/赠有情人","filePath":"Blogs/post/赠有情人.md","title":"赠有情人","links":[],"tags":["诗词曲赋"],"content":"\n今序：那个时候我还单身，在图书馆自习，一对情侣坐在我前边，甚烦，扰人学习，作此相赠。\n\n原序：某不动，见来人，胶粘状，遂寄言。\n劳燕相与飞。\n日月相伴明。\n参商相见欢。\n与君相偕老。"},"Blogs/post/踏莎行":{"slug":"Blogs/post/踏莎行","filePath":"Blogs/post/踏莎行.md","title":"踏莎行·元日","links":[],"tags":["诗词曲赋"],"content":"苹芜青青，波光栩栩，东君重临鸳鸯浦。葬花院落弄新晴，断魂台上兼风雨。\n蟾宫戚戚，江畔独步，摊破月华平分取。何如前路楚山孤，海角天涯同逆旅。"},"Blogs/post/踏莎行·为五前作":{"slug":"Blogs/post/踏莎行·为五前作","filePath":"Blogs/post/踏莎行·为五前作.md","title":"踏莎行·为五前作","links":[],"tags":["诗词曲赋"],"content":"\n放假在家过了一遍《仙剑奇侠传五前传》，不得不说仙剑的结局还是一贯的神，一贯的悲。有时候会将看故事的人拉入其中无法自拔，真个黯然神伤，佩服佩服！\n\n连棹司云，还饮风雪。分明流年暗自越。犹记瑶池那夜星，细照花娇一颊怯。\n从未忍别，最堪伤别。香消也将玉魂偕。此去风敛云归后，唯将画屏时时揭。"},"Blogs/post/道破元日":{"slug":"Blogs/post/道破元日","filePath":"Blogs/post/道破元日.md","title":"道破元日","links":[],"tags":["诗词曲赋"],"content":"繁华事散月空明，\n春风无意草自青。\n天道有常人难测，\n朗朗乾坤一语平。"},"Blogs/post/遣怀":{"slug":"Blogs/post/遣怀","filePath":"Blogs/post/遣怀.md","title":"遣怀・并序","links":[],"tags":["诗词曲赋"],"content":"\n今冬返数日，串村之后，与老者话聊，竟不见其中人许。细问之下，原是身逝黄土。时天气晴寒，鸡蜷狗缩，又东北风呼啸，坐家中远观旧物，因忆旧人：十余年前，同道者众。夏气夺人，游于小池。水中游戏，瓜田取瓜。上则就近而坐，谈天论地，斗牌弄珠。比及冬寒日重，年关将至，则朋访友门，互张灯彩，欢情酣处，取鞭炮戏耍。人生之快，何能胜哉？而时过经年，朋走友散，各行其是，心性互异，此非一日之功。况人事更替，打击非凡。何能怨哉？今二老去其一，则日后暖不得同享，寒不能同衾，病不能相伴，食不得同堂。哀哉！百年孤独，半生劳碌，老有何求？正是尝尽人间辛酸苦，方知幸福是当初。白丝攀在青丝上，始信岁月神鬼工。乙未年冬于被中。\n\n\n昔年邻小欢乐处，而今只见旧池台。\n鸦雀枯枝夕阳颤，泥路荒田足迹歪。\n风刀霜剑楼未倒，寂境孤心人已衰。\n多情寄予庭前柳，冬雪葬尽抒春怀。"},"Blogs/post/阿莉埃蒂":{"slug":"Blogs/post/阿莉埃蒂","filePath":"Blogs/post/阿莉埃蒂.md","title":"阿莉埃蒂","links":[],"tags":[],"content":"\n看完《借东西的小人阿莉埃蒂》，对于结尾十分有感触。阿莉埃蒂一家人能否找到新的家呢？\n\n穿行在静谧的花丛\n蚂蚱蹦跳，蛐蛐乱叫\n活跃在空荡的房子\n翻过碗橱，踏上灯杆\n借东西的路漫长\n时而欢喜，时而忧伤\n栗发沐着暖风，好想凝望天空\n面前是另一个世界\n彩蝶翩翩起舞\n好想为你送一束鲜花\n我并非厌倦\n那个小小的世界\n只是想知道，更多\n更多关于你的事情\n欢喜和忧伤，总是交织在一起\n在太阳下，在花丛里\n想与你度过每一天\n带着这个愿望\n在我的世界里\n走我自己的路\n\n"},"Blogs/post/雪之野":{"slug":"Blogs/post/雪之野","filePath":"Blogs/post/雪之野.md","title":"雪之野","links":[],"tags":["诗词曲赋","现代诗"],"content":"\n看过《言叶之庭》，特别喜欢雪野百香里。\n\n一直以来\n找不到合适的词语\n不知道用什么情感\n——描述你\n久而久之\n连一切的起因也忘了\n好像你的存在\n就是这世界全部的秘密\n我和我不知道的某段文字\n也只能记录些许\n南方雁归，北方雪飞\n愿你和这个包围着你的世界\n——幸福如题"},"Blogs/post/雪压轩集":{"slug":"Blogs/post/雪压轩集","filePath":"Blogs/post/雪压轩集.md","title":"雪压轩集","links":[],"tags":[],"content":"1. 【浣溪沙】\n\n暖雨无晴漏几丝，牧童斜插嫩花枝。小田新麦上场时。\n汲水种瓜偏怒早，忍烟炊黍又嗔迟。日长酸透软腰肢。\n\n据传，这首词是用粉写在一张芍药叶片上的。词的上片意象很美，你看，初夏的阵雨飘飞在山谷田野，已上场的新麦散发着阵破清香，头上插花的牧童悠然自得地骑在牛背上。可是，在这样一个丰收的季节里，词人却没有丝毫的喜悦。她干完了农活，又要回家做饭，忙得腰酸背疼， 仍不免受到挑剔与责骂。怒早、嗔迟，真是左右为难。夫悍姑恶，一切都看不顺眼。双卿是那么的无助，身体、精神上备受煎熬，心中的苦闷、忧愤、伤痛无以排遣，无处表达，唯有借助手中的笔，将满腔的幽怨倾诉于纸上，形成一首首滴血含泪的诗篇。诗词是她唯一的听众，唯一的寄托，也是生命中唯一的闪光点，夜晚独自一人，内心的思绪如泉涌流于笔端，内心的痛苦也如泉水延绵流长，“此恨绵绵无绝期”，于是忍痛含悲，写下了这阕《浣溪沙》。\n\n2. 【望江南】\n\n春不见，寻过野桥西。染梦淡红欺粉蝶，锁愁浓绿骗黄鹂，幽恨莫重提。\n人不见，相见是还非？拜月有香空惹袖，惜花无泪可沾衣，山远夕阳低。\n\n这是女词人伤春怀旧之作。全词笼罩在凄冷欲绝的感情基调中，透露出满腔的幽恨。词人也有过美好的过去，有过情窦初开的青春年华，她还似乎曾有过美好而甜蜜的爱情，有过自己的心上人，然而吃人的封建婚姻制度，无情地拆散了有情人。上片“春不见”，暗指自己美好的青春韶华在自然的周而复始中一去不返，感叹往事不堪回首。下片“人不见”，所爱的人再难相见，即使相见，恐怕也因时过境迁而今昔非比了。正如苏东坡所云“纵使相逢应未识，尘满面，鬓如霜”啊。当日焚香拜月温馨的一幕浮现眼前，却已成过眼云烟。看着曾娇艳的花朵也已渐渐凋落，感叹逝者如斯，美好事物的不常在，却无泪沾衣，泪流尽了，心也碎了。往事已随花逝去，只留下淡淡的影子，眼前漂泊尽前事，恍若梦中。不幸的命运，正像眼前远山残照一样，令人黯然销魂。\n全词表情细腻婉转，凄恻动人，不雕饰，凭自己感受，似从心底流出。\n3. 【湿罗衣】\n\n世间难吐只幽情，泪珠咽尽还生。手捻残花，无言倚屏。 镜里相看自惊，瘦亭亭。春容不是，秋容不是，可是双卿！\n\n问世间情为何物？直叫人生死相许。而最痛苦的还是有情不能诉，有苦无处说。痛苦的泪珠，独自吞进肚里，可是，刚刚咽下，泪水又盈满眼眶了。伤悲难止，欲哭无声。人如残花，只有无言倚屏啊。顾影自怜，花容憔悴，自己也认不出自己了。词中，双卿用寻常的语言表现所见、所闻、所想，亲身经历，真实感受，透出一种别样的风采。\n4. 【玉京秋】 自题《种瓜小影》\n\n眉半敛，春红已全褪，旧愁还欠。画中瘦影，羞人难闪。新病三分未醒，淡胭脂，空费轻染。凉生夜，月华如水，素娥无玷。\n翠袖啼痕堪验。海棠边，曾沾万点。怪近来，寻常梳裹，酸咸都厌。粉汗凝香蘸碧水，罗帕时揩冰簟。有谁念。原是花神暂贬？\n\n这首《玉京秋》是应段玉函之请而作。段玉函找画家张石林为双卿画了画像，是双卿种瓜图，请双卿自题一首词于其上，便是此词。\n5. 【二郎神】菊花\n\n丝丝脆柳，袅破淡烟依旧。向落日秋山影里，还喜花枝未瘦。苦雨重阳挨过了，亏耐到小春时候。知今夜，蘸微霜，蝶去自垂首。\n生受，新寒浸骨，病来还又。可是我双卿薄幸，撇你黄昏静后。月冷阑干人不寐，镇几夜，未松金扣。枉辜却、开向贫家，愁处欲浇无酒。\n\n清代陈廷焯撰《白雨斋词话》评曰：“此类皆忠厚缠绵，幽冷欲绝。而措语则既非温、韦，亦不类周、秦、姜、史，是仙是鬼，莫能名其境矣。”\n6. 【孤鸾】病中\n\n午寒偏准，早疟意初来，碧衫添衬。宿髻慵梳，乱裹帕罗齐鬓。忙中素裙未浣，褶痕边，断丝双损。玉腕近看如茧，可香腮还嫩。\n算一生凄楚也拚忍。便化粉成灰，嫁时先忖。锦思花情，敢被爨烟薰尽。东菑却嫌饷缓。冷潮回，热潮谁问？归去将棉晒取，又晚炊相近。\n\n双卿体质素弱，在娘家很少干重体力活，到周家后受尽折磨，患上了严重的疟疾，婆婆丈夫不但不治，而且丝毫不体贴她，重活脏活全要她承担。因为疟疾忽冷忽热经常发作，双卿被折磨得面黄肌瘦，憔悴不堪。有一次她提着竹篮去给田地干活的丈夫送饭，路上突然疟疾发作，倒在地上不停的寒战，好不容易挨了过去，她又跌跌撞撞向自家的田头走去。周大旺干活干得有些饿了，左等右等不见妻子送饭来，窝下了一肚子火。终于看见了妻子的身影，又是一副要死不活的子，顿时来了火气，顺手摸起身边的锄头便向双卿砸来。贺双卿大吃一惊，连忙丢下饭篮就往回跑去，脚下轻轻飘飘，头却昏昏沉沉。一路摔倒了好多次，才勉强摸进了家门。“算一生凄楚也拚忍。便化粉成灰，嫁时先忖。”这是词人在心底悲愤的控诉，可是，既然命中如此，双卿又有什么办法呢？“冷潮回，热潮谁问？”这是词人无助的叹息。在《孤鸾（病中）》中，她以巧妙地比喻和生动的细节描写，既通俗自然又十分含蓄地表达了自己的悲惨命运，引起人们对弱女子的无限同情和对悍夫恶姑的异常憎恨。\n7. 【惜黄花慢】孤雁\n\n碧尽遥天，但暮霞散绮，碎剪红鲜。听时愁近，望时怕远，孤鸿一个，去向谁边？素霜已冷芦花渚，更休倩、鸥鹭相怜。暗自眠，凤凰纵好，宁是姻缘！\n凄凉劝你无言。趁一沙半水，且度流年。稻梁初尽，网罗正苦，梦魂易警，几处寒烟。断肠可似婵娟意，寸心里，多少缠绵！夜未闲，倦飞误宿平田。\n\n一日黄昏，将近晚炊时，病中的双卿携着畚箕从打谷场上归来，听见一只孤雁在远方的芦苇丛中无助的哀鸣，她西立而望，呆立半天，联想起自己凄凉的身世，不由潸然泪下。正好给她婆婆看见了，在背后大声呵斥，双卿素来胆小易惊，且久病体虚，被吓得畚箕落地，后来她越发心神不宁，从此又染上了易受惊吓的毛病，情动于中，数日后和泪写成这首词。\n词托咏孤雁，寄意遥深，情悲声苦，凄婉欲绝，实乃自抒身世之感。词中孤雁漂泊无依，分明是女词人自己一生孤苦凄凉的形象概括。作者以怜悯之心关怀着孤雁，似乎可以体会到它的孤独、它的无助，“暮霞散绮”，一只大雁孤独地飞翔于广袤的天际之中，“听时愁近，望时怕远；孤鸿一个，去向谁边？”作者以一颗细腻敏感而善良多情的心设想着孤雁的感受，对孤雁关怀备至，一往情深。作者怕听愁声，又同情孤雁飞得太远。而这孤雁离开最喜欢芦芦花渚，原来是素霜已冷，又不愿成双成对的鸥鹭相怜，虽然凤凰这同伴还不错，却也不可能结成姻缘，此地多留无益。\n尤其下片殷勤寄语，无一不是发自肺腑，仿佛与一位“同是天涯沦落人”的知己共诉衷肠。篇中句句写孤雁，句句不离人。落墨虽在雁，意旨却在人，人雁相通，浑然一体。结语“夜未闲，倦飞误宿平田”，正是女词人明珠暗投，误落田家不幸命运的真实写照。哀哉孤雁，悲哉双卿！下片是先由作者观望孤雁，现在田里也没有野食，猎人又伺机而动，还不如随边便找个“一沙半水”先栖息下来。不过，这孤雁自有它的伤心之处，终究夜半误宿了荒野的平田，饥寒已是无法避免的了。\n如陈廷焯所言：“此词悲怨而忠厚，读竟令人泣数行下。”\n8. 【凤凰台上忆吹箫】残灯\n\n已暗忘吹，欲明谁剔？向侬无焰如萤。听土阶寒雨，滴破三更。独自恹恹耿耿，难断处、也忒多情。香膏尽，芳心未冷，且伴双卿。\n星星。渐微不动，还望你淹煎，有个花生！胜野塘风乱，摇曳渔灯。辛苦秋蛾散后，人已病、病减何曾？相看久，朦胧成睡，睡去空惊。\n\n这是有一次，因劝谏丈夫，反给丈夫禁闭在厨房里，只有一盏半明不灭的残灯作着她，引起了她的幽怨，写下了这心弦的哀音，人是凄凉，景是凄凉，事是凄凉，词是凄凉，读来让人一掬同情之泪，让人唏嘘不止。\n作者通过对残灯的观察、描绘，创造出凄凉的氛围。夜晚，万籁寂无声，暮色中一盏残灯摇曳闪烁微弱的灯光，孤独凄冷，“独自恹恹耿耿”的残灯，如同灯下柔弱孤寂的作者，“香膏尽，芳心未冷，且伴双卿”，无人陪伴的夜晚，有了残灯的相随，亦可聊以自慰。只是，他们的命运是那么的相似，一个是即将熄灭的残灯，一个是被折磨、被伤害的双卿。看灯，也是在看自己，哀悼残灯的命运，也是在感叹自身的不幸，词中虽没有直言控诉压迫她的恶势力，然而字里行间，都浸透着一个封建社会中受尽侮辱、欺凌的女子的血和泪。\n双卿是善良的，她的感情是细腻的，常常借咏物来抒发自己的感慨。善于运用孤独、衰残、暗淡、凄冷的意象，来抒写绝望的情怀，实为自己不幸的遭遇和悲凉的心境的写照。\n9. 【薄幸】咏疟\n\n依依孤影，浑似梦、凭谁唤醒！受多少、蝶嗔蜂怒，有药难医花症。最忙时，那得功夫，凄凉自整红炉等。总诉尽浓愁，滴干清泪，冤煞娥眉不省。\n去过酉、来先午，偏放却、更深宵永。正千回万转，欲眠仍起，断鸿叫破残阳冷。晚山如镜，小柴扉烟锁，佳人翠袖恹恹病。春归望早，只恐东风未肯。\n\n一天，贺双卿清扫了屋里屋外，洗完一大盆衣服，又喂完鸡猪，刚想坐下来稍事歇息，婆婆又在院子里催她舂谷了，双卿从不敢违抗婆婆的指令，赶紧走到院子里开始舂谷。舂谷的石杵又大又重，她舂了一会儿，已累得汗流浃背，气喘吁吁，只好抱着杵休息片刻。正在这时，周大旺从地里回来。一进门见妻子无力地站在石臼边，抱着石杵一动也不动，便以为是她偷懒怠工，问也不问，就一把把她推倒在石臼旁。石杵正压在了她的腰上，双卿痛得好半天都爬不起来，痛苦屈辱的眼泪还不敢当着丈夫的面流出来。好不容易挣扎着舂完谷，又到了做午饭的时间，双卿来不及喘口气，又去厨房煮粥。粥锅坐在灶上，她则坐在灶坑前添柴烧火。浓烟一熏，加上过度的疲劳，头晕的老毛病又犯了，她只好闭上眼靠在灶台上。就在这工夫，锅里煮着的粥开了，溢出锅沿，弄得灶台上一片狼藉，还有几点热粥溅到贺双卿的脖子上，把她烫醒，睁眼一看，不由得低低地惊叫了一声。婆婆闻声探进头来一看，不禁火冒三丈，又是一顿吼骂。贺双卿早已听惯了她的呵叱，只是埋头清理灶台。杨氏一见媳妇那种对她要理不理的样子，更加气不打一处来。冲上前一把抓住双卿的耳环，用力一扯，把她的耳垂撕裂开来，鲜血流满了肩头。双卿仍然不敢反抗，却默默地咬牙忍住疼痛，擦干鲜血后，照常乖乖地把饭食送给婆婆和丈夫，婆婆和丈夫看都不看她一眼，坐下就大吃大嚼起来。双卿的泪水这才敢默默地流了下来。于是写下这首哀伤欲绝的《薄幸（咏疟）》。作者把自己比作花，把压制她的人比作蝶和蜂。“有药难医花症”，是因为“受多少、蝶嗔蜂怒”。终日无端的“嗔”和“怒”，即使有药可以医治好她的身体上的疾病，也难以医治她心灵上的伤痛。这首词写得很巧妙，借写自己的病，来写封建势力对自己的压迫，含蓄地表达了自己对封建势力的憎恨与控诉。\n10. 【一剪梅】\n\n寒热如潮势未平，病起无言，自扫前庭。琼花魂断碧天愁，推下凄凉，一个双卿。\n夜冷荒鸡懒不鸣，拟雪猜霜，怕雨贪晴。最闲时候妾偏忙，才喜双卿，又怒双卿。\n\n11. 【摸鱼儿】谢邻女韩西馈食\n\n喜初晴，晚霞西现，寒山烟外青浅。苔纹干处容香履，尖印紫泥犹软。人语乱，忙去倚、柴扉空负深深愿。相思一线，向新月搓圆；穿愁贯恨，珠泪总成串。\n黄昏后，残热犹怜细喘。小窗风射如箭。春红秋白无情艳，一朵似侬难选。重见远，听说道，伤心已受殷勤饯。斜阳刺眼，休更望天涯，天涯只是，几片冷云展。\n\n她的邻居韩西是她女伴，不识字，却爱双卿的作品，这样的女伴，几乎已是双卿婚后生活的唯一精神寄托，可是不久，韩西就嫁人了。一次，韩西回娘家小住后即将返回婆家，父母为之送行，韩西邀请双卿参加，可双卿疟疾犯了，不能前往，韩西就前去探望，并送去食物。饥寒交迫的双卿非常感动，于是和泪写下了这首《摸鱼儿（谢邻女韩西馈食）》。\n据《西青散记》记载：“邻女韩西，新嫁而归，性颇慧，见双卿独舂汲，恒助之。疟时，坐于床为双卿泣。不识字，然爱双卿书。乞双卿写心经，且教之诵。是时将返其夫家，父母得饯之。召双卿，疟弗能往，韩西亦诸食。乃分其所食自裹之遗双卿。双卿泣为此词，以淡墨细书芦叶。”\n12. 【凤凰台上忆吹箫】赠邻女韩西\n\n寸寸微云，丝丝残照，有无明灭难消。正断魂魂断，闪闪摇摇。望望山山水水，人去去，隐隐迢迢。从今后，酸酸楚楚，只似今宵。\n青遥，问天不应，看小小双卿，袅袅无聊。更见谁谁见，谁痛花娇？谁望欢欢喜喜，偷素粉，写写描描？谁还管，生生世世，夜夜朝朝？\n\n这首词是为别女友韩西而作，细腻地表现了她内心抑郁的情绪，再现与女友分别使她堕入深渊的情景。巧用叠字抒情写意，堪与词作大家李清照的“寻寻觅觅，冷冷清清，凄凄惨惨戚戚”之句媲美，将双卿后半生的酸楚尽相倾诉。“偷素粉、写写描描。谁还管，生生世世，夜夜朝朝。”这首词，情境哀凄，词义悲苦。用双字二十余叠，丝毫不露牵强痕迹。末尾三句，“谁还管，生生世世，夜夜朝朝”更是余怨无穷，紧紧扣人心弦，令人动容。\n双卿的词，没有华丽词藻，大多采用生活语言，善于将自己的情感融于自然景物中，揭示生活悲剧中所蕴藏的美质，创造出具有高度美学意义的境界。她还善于掌握声调韵律错综复杂的不同节奏，以适应自己思想感情有起伏变化。如《凤凰台上忆吹箫》通篇语言质朴，且巧用叠字，造成回环咏叹的艺术效果，缠绵悱恻，旋律优美，可谓情苦词哀，已达极致，加上连用叠字二十余韵，真可与李易安的《声声慢》相媲美，确是双卿自述境况的凄绝的哀歌。\n清代陈廷焯在《白雨斋词话》评曰：“ 其情哀，其词苦。用双字至二十余叠，亦可谓广大神通矣。易安见之，亦当避席。”\n13. 【春从天上来】梅花\n\n自笑恹恹，费半晌春忙，去省花尖。玉容憔悴，知为谁添？病来分与花嫌。正腊衣催洗，春波冷，素腕愁沾。硬东风、枉寒香一度，新月纤纤。\n多情满天坠粉，偏只累双卿，梦里空拈。与蝶招魂，替莺拭泪，夜深偷诵《楞严》。有伤春佳句，酸和苦，生死俱甜。祝花年，向观音稽首,掣遍灵签。\n\n处境悲苦，遇人不淑，在这种种折磨下，双卿也只能自我寻求些安慰了，通过读佛经，参拜观音，以求脱离苦海。\n14. 【春从天上来】饷耕\n\n紫陌春情，漫额裹春纱，自饷春耕。小梅春瘦，细草春明。春田步步春生。记那年春好，向春燕、说破春情。到于今，想春笺春泪，都化春冰。\n怜春痛春春几？被一片春烟，锁住春莺。赠与春侬，递将春你，是侬是你春灵。筭春头春尾，也难筭、春梦春醒。甚春魔，做一场春梦，春误双卿！\n\n据说她舅舅是当地的塾师，一说她舅舅是帮塾师打柴、担水的杂役，但无论如何，这都给好学的双卿提供了一个求学的便利条件。每当塾师授课时，双卿就倚于窗下，悉心聆听，铭记在心。三年过去了，双卿学会了读书、写字、吟诗、作文，父母亲认为姑娘家大了，不能再到处乱跑了，便不再让双卿去学馆听课。此时的双卿，已经善诗能文了，可是，双卿虽有卓越的才华，却一直没有引起家人的注意。\n闺中闲暇，双卿即吟诗填词，练字作画。买不起书，她便用自做的精巧的女红，向商贩们换些诗词书籍来读。在诗书的熏陶下，双卿如一枝红杏在农家小院含苞怒放。然而令人叹惋不止的是，双卿18岁时，父亲去世，由叔父作主，以三石谷子的聘礼，被嫁到金坛绡山村周家，从此，双卿便踏上了一条万劫不复的血泪之路。\n“清代第一女词人”贺双卿\n双卿的丈夫叫周大旺，比双卿大十几岁，是个没有一点文化的佃户樵民，粗俗不堪，生性粗暴，而且嗜赌成性；婆婆杨氏更是刁泼蛮恶，不讲情理。婚后，丈夫和婆婆把双卿当成牛马役使，家中清扫、煮饭、喂鸡、养猪、舂谷之类繁重的劳作都落到双卿的头上。婆婆还经常故意找双卿的茬，稍不顺眼非打即骂。双卿原本身体孱弱，在娘家就很少做这些重活，婚后却要样样从头学起，家里田里两头都要忙，哪里吃得消呢？但慑于婆婆和丈夫的淫威，她只有忍气吞声，独自把苦涩的泪水咽进肚里。在身体与精神的双重折磨下，双卿嫁到周家后不久便患上了严重的疟疾。劳动的艰苦，疾病的煎熬，婚姻的不幸，精神的折磨，心灵的凄楚，种种愁情苦况，一齐折磨着双卿，在这个冷似冰窖令人窒息的家庭中，双卿又无处倾诉，唯凭诗词倾诉衷肠。双卿的诗作，抒发的基本上是对个人生活不幸的感叹，浸透着浓郁的压抑情绪和伤感的情调，同时，她个人的悲剧，也折射出当时社会的阴影，使人们看到了封建时代下层社会妇女的苦难，听见了她们痛苦的悲吟，深为她们的才华被埋没而悲哀和不平。\n丈夫和婆婆的欺凌，日日消损着清代第一女词人的花颜玉容，却磨不尽她的锦思花情。从娘家带来的纸用尽了，双卿便在芦叶、竹叶、桂叶和破布残片上写；笔磨秃了，她就用炭棒和白粉代替。婆婆多次淫威大发，将双卿的笔折断，诗稿烧毁，可无论如何也阻挡不了双卿写诗的激情。双卿不在乎留下什么传世之作，甚至有意不想让诗作留存于世，她写诗、作词的唯一目的，只是想用它来宣泄悲郁、点染生活，为自己枯萎的生命添一抹亮丽的色彩。不幸的遭际，使双卿常常想起婚前的美好时光，虽然清苦，可拥有人世间最宝贵的亲情，内心是温暖而平静的，美好的时光如流水般逝去，再也无法倒流，双卿唯有靠这点点回忆来慰藉着饱经创伤的心灵。\n既然无法反抗，也就只有加倍地恭顺了，或许这样可以一点减少痛苦。据清代史震林（1692~1778年）《西青散记》记载，双卿到婆家后不长时间，便久病不愈，在临终前的日子里，“事舅姑愈谨，邻里称其孝。夫性益暴，善承其喜怒，弗敢稍忤。”（卷四第46页）就这样，大约于雍正末年或乾隆初年，一代才貌双全的农家女词人，最终在肉体与精神的双重折磨下，花颜凋落，含恨离开人世，留下一段千古遗憾，让后人叹惋不已！\n易之言\n易之见此人此事，为《行香子·寄贺双卿》。其词曰：\n丝丝柳絮，点点残雨。正春初，愁云乱舞。水田夕下，秋碧楚楚。纵月儿长，日儿短，双卿苦。\n豆蔻妙龄，玉带华年，偏风刀霜剑无诉。幽如白兰，缘命早枯。只怜卿长，叹卿短，代卿哭。"},"Blogs/post/露降":{"slug":"Blogs/post/露降","filePath":"Blogs/post/露降.md","title":"露降","links":[],"tags":["诗词曲赋"],"content":"秋容频惊鬓凋残，\n秋风误把相思传。\n人未眠，夜阑珊，\n天涯何处是团栾。"},"Blogs/post/题五一心事":{"slug":"Blogs/post/题五一心事","filePath":"Blogs/post/题五一心事.md","title":"题五一心事","links":[],"tags":["诗词曲赋"],"content":"\n上大学的第一个五一，室友们纷纷出去玩乐，独留我在宿舍，身在异乡，聊感寂寞。\n\n婉转星辰昨夜媚，参商不见动相离。\n飞云不顾弦声切，野桥静待落花枝。\n偏偏风雨袭人处，寂寂瑶花苦到思。\n总向伊人难对月，只盼莲心散成绮。"},"Blogs/post/题水阙":{"slug":"Blogs/post/题水阙","filePath":"Blogs/post/题水阙.md","title":"题水阙","links":[],"tags":["诗词曲赋"],"content":"疾风枯叶两相搏，一叹秋光万念空。\n瑟瑟孤霜兰亭瘦，层层幽岚花影重。\n欲投鱼雁心难递，将拟音书愿不衷。\n暂借明月作明镜，照见愁容当笑容。"},"Blogs/post/鬼话":{"slug":"Blogs/post/鬼话","filePath":"Blogs/post/鬼话.md","title":"鬼话","links":[],"tags":["碎碎念"],"content":"看官，请随我来。\n你说这大气好不奇妙。我们都知道大气对我们是有压力的，我们为什么感受不到，因为我们体内也有大气压着。哦，那么我们的肚皮不是要承受两份压力吗，那怎么受得了？哦，肚皮是有厚度的，可不能忽略，为什么压不扁呢？大概组成肚皮的层层细胞间也是有大气的，那既然细胞外有大气，那细胞里也要有的，不然不是把细胞压炸了？那细胞壁呢？它是有厚度的，可不能忽略。它是不是像肚皮一样也是由众多微不可见的东西组成的呢？我们之所以知道肚皮、细胞，那是人家告诉的。若是人家没说，我们会这样想，这是由众多的那组成的，那是由众多的这组成的，这样它们都失去了名字，就没什么区别。如果细胞壁想肚皮一样是由众多的某某组成，那这众多的某某又会诞生出下一个系统，如此生生不息，众多的系统都未命名的话，那么排列就无需先后。从中任意挑一个出来既是老祖宗，又是重孙子。就像数轴一样，任意数都可向两侧无限延伸。小而又小是什么？大而又大是什么？照刚才所说，都未命名的话，其实极小与极大是没区别的。一株小草也可以与一颗恒星相提并论。万物都是平等的系统，恒星包含了无限的微粒，小草也是。何为大，何为小，何为物，何为我，都没什么意思。无极之内，在极之外。世界本就是模糊朦胧混沌的，婴儿的大脑是最高的境界。看官可能会说，婴儿可不知道这些，更没有思考过这些。其实这就像一开始的陌路，和最终相忘江湖的两个人，表面上没有任何区别，但其中确有种种微妙。老庄说的至人无己，至人的大脑大概是和婴儿一样的，至人确有了质的飞越。从无中来，再到无中去，这便是一生的修行！老人和婴儿便是一个系统的出入口，其始亦是终。"},"Blogs/post/鹧鸪天·夜游":{"slug":"Blogs/post/鹧鸪天·夜游","filePath":"Blogs/post/鹧鸪天·夜游.md","title":"鹧鸪天·夜游","links":[],"tags":["诗词曲赋"],"content":"\n放假在家，夜深不能眠，因闭目养神，神游屋外。\n\n夏清碎雨三更天，倦卧竹席待月眠。墨云戏水声婉转，流萤映波步蹁跹。\n山连绵，水绵延，细筛夜色几分恬？皎光一道凌窗入，浮生半梦碧游仙。"},"Blogs/我与-Gnome-的爱与恨":{"slug":"Blogs/我与-Gnome-的爱与恨","filePath":"Blogs/我与 Gnome 的爱与恨.md","title":"我与 Gnome 的爱与恨","links":[],"tags":[],"content":"我与 Gnome 的爱与恨\n放假回家，因故将笔记本电池弄到枯竭。结果再次开启，发现 startx 启动 gnome-session 失败。几经解决未果，只好重装！\n安装 Archlinux\n基本安装步骤都是按照 ArchWiki 上的 Installation Guide 以及简书上的一篇文章 虚拟机安装Archlinux的简易步骤.\n安装过程主要可以分为以下几个步骤：\n1.分区\n一般而言只需要分 3 个区：根（/），用户主目录(/home) 以及 swap 交换。贴一下我的分区图\n\n可以看到，一块磁盘 (disk) 被分成很多的分区 (partition) . 其中，稍微现代一点的电脑主板都启用了 UEFI，所以在磁盘第一个分区是 ESP 分区。这个分区中就包含了所有可启动系统的启动文件。在没有安装 Linux 之前，它里面只包含有 Windows 自带的启动文件。在安装完成 Linux 后，由于有两个可启动的系统，所以需要一个引导程序(rEFInd, Grub 等)来将选择权交给用户。\n上图中的最后三个分区即为 Linux 系统的分区。分区大小的划分事实上很讲究，我根据之前的经验，/home 分 50GB 够用了，如果不放什么大型视频和音频文件的话。swap 分区的大小一般为已安装内存的一半，比如我的系统内存 8GB，swap 就分 4GB.\n2.格式化分区\nLinux 文件系统一般是 ext4，使用如下命令格式化分区\nmkfs.ext4 /dev/nvme0n1p5\nmkfs.ext4 /dev/nvme0n1p6\nmkfs.ext4 /dev/nvme0n1p7\n3.挂载目录\n将各目录挂载到对应的分区，例如\nmount /dev/nvme0n1p5 /mnt\nmount /dev/nvme0n1p6 /mnt/home\n# boot分区其实应该单独分出来\n# 但是我们已经有了 esp 分区\n# 要和原来的 Windows 兼容\n# 只需要将该 esp 分区挂载到 /boot/efi 目录下\n# 之后安装 bootloader 时会把 Linux 的启动文件放到 esp 分区\nmount /dev/nvme0n1p1 /mnt/boot/efi\n开启 swap 分区以便之后生成 fstab 时检测\nswapon /dev/nvme0n1p7\n4.执行安装\n核心命令为：\npacstrap -i /mnt base base-devel net-tools\n\n其余细节参考 ArchWiki. 值得一提的是，base 组里面包含的程序包有限，所以追加了 base-devel 和网络配置工具包 net-tools.  注意执行安装命令前，对 /etc/pacman.d/mirrorlist 进行相关修改，把中国的镜像放在前面，使得下载速度更快。还有几个有用的网络工具包也一并装了 iw, wpa_supplicant, dialog.\n5.后续步骤\n后续就是 arch-chroot 到新安装系统中进行相关设置：hostname，hosts，时区，locale 等。这些在 Installation Guide 中均有提及，不再赘述。\n6.小结\n以上，一个新的 Archlinux 就安装完成了。不过这只是一个简陋的系统，还没有进行配置，只能用终端输命令的那种。后续配置参考简书那篇文章。\n这次安装，我的最大的一个收获就是学会了如何在命令行中连接 WiFi. 需要的工具有\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPackageCommandNotedialogwifi-menuWiFi 直连net-toolsifconfig查看网络状态wpa_supplicantwpa_supplicant, wpa_passphrase连接 WiFidhcpcddhcpcd动态 IP 地址获取\n获取无线接口名称\n\n好了，现在知道了，是 wlp2s0. 一般也可能是 wlan0. 然后确认该接口的状态是 up，如图所示。\n扫描可用网络\niw wlp2s0 scan\n\n确定你要连接的无线网络名称 (SSID)，假设是 shiki.\n生成配置文件\nwpa_passphrase shiki &gt; ~/shiki.conf\n\n连接 WiFi\nwpa_supplicant -B -i wlp2s0 -c ~/shiki.conf\n\n获取 IP 地址\ndhcpcd wlp2s0\n\n查看连接状态\niw wlp2s0 link\n\n\n另外，还有一种更加简单的方法，直接敲命令 wifi-menu 可以进行交互式 WiFi 连接，体验和图形界面一样。\n安装 Gnome\n来日在填cuticeshi,xieticeshi,粗体中文cutivswf,斜体测试xpticeui.\nReference\n\n在命令行中管理 WiFi 连接\n"},"Blogs/最大熵对应的概率分布":{"slug":"Blogs/最大熵对应的概率分布","filePath":"Blogs/最大熵对应的概率分布.md","title":"最大熵对应的概率分布","links":[],"tags":["math"],"content":"最大熵对应的概率分布\n最大熵定理\n设 X \\sim p(x) 是一个连续型随机变量，其微分熵定义为\n\th(X) = - \\int p(x)\\log p(x) dx\n其中，\\log 一般取自然对数  \\ln, 单位为 奈特（nats）。\n考虑如下优化问题：\n\\begin{array}{ll}\n&amp;\\underset{p}{\\text{Maximize}} &amp; \\displaystyle h(p) = - \\int_S p(x)\\log p(x) dx \\\\\n&amp;\\text{Subject to} &amp;\\displaystyle \\int_S p(x) dx = 1 \\\\[2pt]\n&amp;~ &amp; p(x) \\ge 0 \\\\[2pt]\n&amp;~ &amp; \\displaystyle \\int_S p(x) f_i(x) dx = \\alpha_i, ~i=1,2,3,\\dots,n\n\\end{array}\n其中，集合 S 是随机变量的support，即其所有可能的取值。我们意图找到这样的概率分布 p​, 他满足所有的约束（前两条是概率公理的约束，最后一条叫做矩约束，在模型中有时会假设随机变量的矩为常数），并且能够使得熵最大。将上述优化问题写成标准形式：\n\\begin{array}{ll}\n&amp;\\underset{p}{\\text{Minimize}} &amp; \\displaystyle  \\int_S p(x)\\log p(x) dx \\\\\n&amp;\\text{Subject to} &amp;-p(x) \\le 0 \\\\[2pt]\n&amp;~ &amp;\\displaystyle \\int_S p(x) dx = 1 \\\\ \n&amp;~ &amp; \\displaystyle \\int_S p(x) f_i(x) dx = \\alpha_i, ~i=1,2,3,\\dots,n\n\\end{array}\n使用Lagrange乘数法得到其Lagrangian\nL(p,\\boldsymbol{\\lambda}) = \\int_S p\\log p ~dx - \\mu_{-1}p + \\mu_0 \\left(\\int_S p ~dx - 1\\right) + \\sum_{j=1}^n \\lambda_j \\left(\\int_S pf_j~dx - \\alpha_j\\right)\n根据KKT条件对Lagrangian求导令为0，可得最优解。\n\\begin{gathered}\n\\frac{\\partial L}{\\partial p} = \\ln p + 1 - \\mu_{-1} + \\mu_0 + \\sum_{j=1}^n \\lambda_jf_j := 0 \\\\\n\\implies p = \\exp\\left(-1 + \\mu_{-1} - \\mu_0 - \\sum_{j=1}^n \\lambda_j f_j \\right) =\\displaystyle c^* e^{-\\sum_{j=1}^n\\lambda_j^* f_j(x)} := p^*\n\\end{gathered}\n其中，我们要选择 c^*, \\boldsymbol{\\lambda}^* 使得 p(x) 满足约束。到这里我们知道，在所有满足约束的概率分布当中，p^* 是使得熵达到最大的那一个！\n\n例子\n高斯分布\n------⇒\n约束：\n\nE(X) = 0 \\implies f_1 = x\nE(X^2) = \\sigma^2 \\implies f_2 = x^2\n\n根据上面的论证，最大熵分布应具有如下形式：\np(x) = ce^{-\\lambda_1x - \\lambda_2 x^2}\n再根据 KKT 条件：\n\n\\int_{-\\infty}^{+\\infty} p(x) = 1\n\\int_{-\\infty}^{+\\infty} x p(x) = 0\n\\int x^2 p(x) = \\sigma^2\n\n由条件 (2) \\implies p(x)​ 是偶函数 \\implies \\lambda_1 = 0​, 原条件变成\n\n\\int_{-\\infty}^{+\\infty} ce^{-\\lambda_2x^2} = 1\n\\int x^2 ce^{-\\lambda_2x^2} = \\sigma^2\n\n\\implies c = \\frac{1}{\\sqrt{2\\pi\\sigma^2}}, ~\\lambda_2 = \\frac{1}{2\\sigma^2} \\implies p(x) = \\frac{1}{\\sqrt{2\\pi\\sigma^2}} e^{-\\frac{x^2}{2\\sigma^2}} \\sim N(0, ~\\sigma^2)\n指数分布\n-------⇒\n约束：\n\nX \\ge 0\nE(X) = \\frac{1}{\\mu}\n\n根据上面的论证，最大熵分布应具有如下形式：\np(x) = ce^{-\\lambda_1x}\n再根据 KKT 条件：\n\n\\int_{0}^{+\\infty} ce^{-\\lambda_1x}= 1\n\\int_0^{+\\infty} x ce^{-\\lambda_1x} = \\frac{1}{\\mu}\n\n推导如下：\n\\begin{gathered}\n\\int_{0}^{+\\infty} e^{-\\lambda_1x} = \\frac{1}{c} \\implies \\lambda_1 = c \\\\\n\\int_{0}^{+\\infty}x e^{-\\lambda_1x} = \\frac{1}{c\\mu} = \\frac{1}{\\lambda_1\\mu} \\implies \\lambda_1 = \\mu\n\\end{gathered}\n\\implies p(x) = \\mu e^{-\\mu x} \\sim Exp(\\mu)\n均匀分布\n-------⇒\n约束：\n\na \\le X \\le b\n\n根据上面的论证，最大熵分布应具有如下形式：\n\\begin{gathered}\np(x) = ce^{- 0x} = c \\\\\n\\int_a^b c ~dx = 1 \\implies c = \\frac{1}{b-a} \n\\end{gathered}\n\\implies p(x) = \\frac{1}{b-a} \\sim Unif(a,~b)\n几何分布\n-------⇒\n几何分布计数直到第一次成功前所有的失败次数。P(X=k) = q^kp\n约束：\n\nX = 0,1,2,\\dots\nE(X) = \\frac{1-p}{p}\n\n根据上面的论证，最大熵分布应具有如下形式：\nP(X=k) = p_k = ce^{-\\lambda_1 k}\n再根据 KKT 条件：\n\n\\sum_{k=0}^{\\infty} p_k = 1\n\\sum_{k=0}^{\\infty} k p_k = \\frac{1-p}{p}\n\n推导如下：\n\\begin{gathered}\n\\sum_{k=0}^{\\infty} ce^{-\\lambda_1 k} = c \\sum_{k=0}^{\\infty} q^k \\quad(\\text{where }q = e^{-\\lambda_1})\\\\\n= \\frac{c}{1-q} \\implies c = 1-q \\\\\n\\sum_{k=0}^{\\infty} k ce^{-\\lambda_1 k} = c\\sum_{k=1}^{\\infty} k (e^{-\\lambda_1})^k = c\\sum_{k=1}^{\\infty}k q^k = cq \\sum kq^{k-1} \\\\\n= cq \\sum (q^k)&#039; = cq \\left(\\sum_{k=1}^{\\infty}q^k\\right)&#039; = cq \\left(\\frac{q}{1-q}\\right)&#039; \\\\\n= cq \\cdot \\frac{1}{(1-q)^2} = \\frac{q}{1-q} = \\frac{1-p}{p}\n\\end{gathered}\n\\implies e^{-\\lambda_1} = q = 1-p, ~ c =p \\implies P(X=k) = p_k = pq^k \\sim Geom(p)"},"README":{"slug":"README","filePath":"README.md","title":"README","links":[],"tags":[],"content":"learn2live\nLearn something for fun, for work, for life…\nFor Obsidian\nIf you use obsidian, you can use callout like this (see the effects in obsidian):\n\n\n                  \n                  The Point™ \n                  \n                \n\nThe point is that you own this folder just like the other folder of camping photos that you created yourself.\nIt’s supposed to be a good thing because you get both data ownership and privacy this way.\n\n\n\n\n                  \n                  Your note title \n                  \n                \n\nYour note body.\n\n\n\n\n                  \n                  A faq with folder \n                  \n                \n\nYes, you see it.\n\n\nFor more callouts, open your sandbox vault with command palette, see chapter “Formatting”.\n\n\n                  \n                  Quote\n                  \n                \n\nthis is a quote title\n\n\n\nbare markdown quote\n\nBy default, there are 12 distinct callout types, each with several aliases. Each type comes with a different background color and icon.\nTo use these default styles, replace INFO in the examples with any of these types. Any unrecognized type will default to the “note” type, unless they are customized. The type identifier is case insensitive.\n\nnote\nabstract, summary, tldr\ninfo, todo\ntip, hint, important\nsuccess, check, done\nquestion, help, faq\nwarning, caution, attention\nfailure, fail, missing\ndanger, error\nbug\nexample\nquote, cite\n\nRefer to obsidian sandbox vault for more information, search “callout” in it."},"Untitled--1":{"slug":"Untitled--1","filePath":"Untitled -1.md","title":"Untitled -1","links":[],"tags":[],"content":"write some thing, and insert a base\nfilters:\n  and:\n    - file.hasTag(&quot;cpp&quot;)\nviews:\n  - type: table\n    name: Sample Table Base\n    order:\n      - file.name\n      - date\n      - file.folder\n      - file.tags\n    sort:\n      - property: date\n        direction: ASC\n "},"Untitled":{"slug":"Untitled","filePath":"Untitled.md","title":"Untitled","links":[],"tags":[],"content":"本地链接 IPv6 地址:\tfe80::f15d:8dee:d93d:6eab%12\nIPv4 地址:\t10.30.100.73\nIPv4 DNS 服务器:\t10.30.201.41\n10.20.202.41\n10.30.201.31\n主 DNS 后缀:\tdatayes.com\n制造商:\tIntel\n描述:\tIntel(R) Ethernet Connection (13) I219-V\n驱动程序版本:\t12.19.0.16\n物理地址(MAC):\t38-14-28-56-21-7D\n\n点击展开代码示例\nprint(&quot;Hello, GitHub!&quot;)  # 折叠后可隐藏的代码\nare you ok\n\n\nclick me\ni am hidden.\n"},"__zettel/202304101713-serach-in-hugo":{"slug":"__zettel/202304101713-serach-in-hugo","filePath":"__zettel/202304101713 serach in hugo.md","title":"202304101713","links":[],"tags":["hugo","search","website","blog"],"content":"为hugo网站添加搜索功能\n几个重要参考：\n\nBuilding search into a Hugo website\nSearch for your Hugo Website\neddiewebb’s gist\n基于上面gist整理成文：Client Side Search for your Hugo Blog with Fuse.js\nlunr.js\n"},"__zettel/202304172151":{"slug":"__zettel/202304172151","filePath":"__zettel/202304172151.md","title":"202304172151","links":[],"tags":[],"content":"下次回家要带的东西\n\n 大宝sod蜜\n 🎒书包\n 洗衣机清洁剂\n"},"__zettel/202304202149volatile-specifier":{"slug":"__zettel/202304202149volatile-specifier","filePath":"__zettel/202304202149volatile-specifier.md","title":"202304202149","links":[],"tags":["cpp","specifier","volatile"],"content":"volatile修饰的变量旨在告诉编译器这个变量易失（对应缓存的术语）、易变，因此在读取变量值的时候，始终通过内存取址的方式，而不信赖缓存。\n例如：\nint i = 10;\nint a = i;\n// 以编译器不知道的方式改变i的值为32\nint b = i;\ncout &lt;&lt; b;  // 10\n这里，由于编译器的优化，编译器看到两次赋值间，i的值未发生变化。所以直接从缓存（寄存器）中拿出上次的值赋给b.\nvolatile int i = 10;\nint a = i;\n// 以编译器不知道的方式改变i的值为32\nint b = i;\ncout &lt;&lt; b;  // 32\n这里，用volatile修饰变量i，告诉编译器这个变量易失，不要相信缓存，不要从寄存器读取。所以编译器按照常规方式从内存地址读取i的值（32）赋给b.\nsee also"},"__zettel/202304230920-cmake-learn":{"slug":"__zettel/202304230920-cmake-learn","filePath":"__zettel/202304230920 cmake learn.md","title":"202304230920","links":[],"tags":["cmake"],"content":"Just see:\ncmake_minimum_required(VERSION 3.15)\n \nproject(ClickHouse LANGUAGES C CXX ASM)\nset(CMAKE_THREAD_LIBS_INIT &quot;-lpthread&quot;)\nset(CMAKE_HAVE_THREADS_LIBRARY 1)\nset(CMAKE_USE_WIN32_THREADS_INIT 0)\nset(CMAKE_USE_PTHREADS_INIT 1)\nset(THREADS_PREFER_PTHREAD_FLAG ON)\n \nset(CMAKE_INCLUDE_DIRECTORIES_BEFORE ON)\ninclude_directories(\n./contrib/libcxx/include/\n./contrib/sysroot/linux-x86_64/x86_64-linux-gnu/libc/\n./contrib/sysroot/linux-x86_64/x86_64-linux-gnu/libc/usr/include/\n./contrib/sysroot/linux-x86_64/x86_64-linux-gnu/libc/usr/include/linux/\n./contrib/sysroot/linux-x86_64/x86_64-linux-gnu/libc/usr/include/x86_64-linux-gnu/\n./contrib/sysroot/linux-x86_64-musl/include/\n./contrib/sysroot/linux-x86_64-musl/lib/gcc/x86_64-linux-musl/10/include/\n/usr/lib/gcc/x86_64-linux-gnu/10.3.1/include/\n)\n \n# If turned off: e.g. when ENABLE_FOO is ON, but FOO tool was not found, the CMake will continue.\noption(FAIL_ON_UNSUPPORTED_OPTIONS_COMBINATION\n   &quot;Stop/Fail CMake configuration if some ENABLE_XXX option is defined (either ON or OFF)\n   but is not possible to satisfy&quot; ON)\n \nif(FAIL_ON_UNSUPPORTED_OPTIONS_COMBINATION)\n    set(RECONFIGURE_MESSAGE_LEVEL FATAL_ERROR)\nelse()\n    set(RECONFIGURE_MESSAGE_LEVEL WARNING)\nendif()\n \ninclude (cmake/arch.cmake)\ninclude (cmake/target.cmake)\ninclude (cmake/tools.cmake)\ninclude (cmake/ccache.cmake)\ninclude (cmake/clang_tidy.cmake)\ninclude (cmake/git_status.cmake)\n \n# Ignore export() since we don&#039;t use it,\n# but it gets broken with a global targets via link_libraries()\nmacro (export)\nendmacro ()\n \nset(CMAKE_EXPORT_COMPILE_COMMANDS 1) # Write compile_commands.json\nset(CMAKE_LINK_DEPENDS_NO_SHARED 1) # Do not relink all depended targets on .so\nset(CMAKE_CONFIGURATION_TYPES &quot;RelWithDebInfo;Debug;Release;MinSizeRel&quot; CACHE STRING &quot;&quot; FORCE)\nset(CMAKE_DEBUG_POSTFIX &quot;d&quot; CACHE STRING &quot;Generate debug library name with a postfix.&quot;)    # To be consistent with CMakeLists from contrib libs.\n \n# Enable the ability to organize targets into hierarchies of &quot;folders&quot; for capable GUI-based IDEs.\n# For more info see cmake.org/cmake/help/latest/prop_gbl/USE_FOLDERS.html\nset_property(GLOBAL PROPERTY USE_FOLDERS ON)\n \n# Check that submodules are present\nif (NOT EXISTS &quot;${ClickHouse_SOURCE_DIR}/contrib/sysroot/README.md&quot;)\n    message (FATAL_ERROR &quot;Submodules are not initialized. Run\\n\\tgit submodule update --init&quot;)\nendif ()\n \n# Take care to add prlimit in command line before ccache, or else ccache thinks that\n# prlimit is compiler, and clang++ is its input file, and refuses to work  with\n# multiple inputs, e.g in ccache log:\n# [2021-03-31T18:06:32.655327 36900] Command line: /usr/bin/ccache prlimit --as=10000000000 --data=5000000000 --cpu=600 /usr/bin/clang++-11 - ...... std=gnu++2a -MD -MT src/CMakeFiles/dbms.dir/Storages/MergeTree/IMergeTreeDataPart.cpp.o -MF src/CMakeFiles/dbms.dir/Storages/MergeTree/IMergeTreeDataPart.cpp.o.d -o src/CMakeFiles/dbms.dir/Storages/MergeTree/IMergeTreeDataPart.cpp.o -c ../src/Storages/MergeTree/IMergeTreeDataPart.cpp\n#\n# [2021-03-31T18:06:32.656704 36900] Multiple input files: /usr/bin/clang++-11 and ../src/Storages/MergeTree/IMergeTreeDataPart.cpp\n#\n# Another way would be to use --ccache-skip option before clang++-11 to make\n# ccache ignore it.\noption(ENABLE_CHECK_HEAVY_BUILDS &quot;Don&#039;t allow C++ translation units to compile too long or to take too much memory while compiling.&quot; OFF)\nif (ENABLE_CHECK_HEAVY_BUILDS)\n    # set DATA (since RSS does not work since 2.6.x+) to 5G\n    set (RLIMIT_DATA 5000000000)\n    # set VIRT (RLIMIT_AS) to 10G (DATA*10)\n    set (RLIMIT_AS 10000000000)\n    # set CPU time limit to 1000 seconds\n    set (RLIMIT_CPU 1000)\n \n    # gcc10/gcc10/clang -fsanitize=memory is too heavy\n    if (SANITIZE STREQUAL &quot;memory&quot; OR COMPILER_GCC)\n       set (RLIMIT_DATA 10000000000) # 10G\n    endif()\n \n    set (CMAKE_CXX_COMPILER_LAUNCHER prlimit --as=${RLIMIT_AS} --data=${RLIMIT_DATA} --cpu=${RLIMIT_CPU} ${CMAKE_CXX_COMPILER_LAUNCHER})\nendif ()\n \nif (NOT CMAKE_BUILD_TYPE OR CMAKE_BUILD_TYPE STREQUAL &quot;None&quot;)\n    set (CMAKE_BUILD_TYPE &quot;RelWithDebInfo&quot;)\n    message (STATUS &quot;CMAKE_BUILD_TYPE is not set, set to default = ${CMAKE_BUILD_TYPE}&quot;)\nendif ()\nmessage (STATUS &quot;CMAKE_BUILD_TYPE: ${CMAKE_BUILD_TYPE}&quot;)\n \nstring (TOUPPER ${CMAKE_BUILD_TYPE} CMAKE_BUILD_TYPE_UC)\n \noption(USE_STATIC_LIBRARIES &quot;Disable to use shared libraries&quot; ON)\n# DEVELOPER ONLY.\n# Faster linking if turned on.\noption(SPLIT_SHARED_LIBRARIES &quot;Keep all internal libraries as separate .so files&quot; OFF)\n \nif (USE_STATIC_LIBRARIES AND SPLIT_SHARED_LIBRARIES)\n    message(FATAL_ERROR &quot;SPLIT_SHARED_LIBRARIES=1 must not be used together with USE_STATIC_LIBRARIES=1&quot;)\nendif()\n \nif (NOT USE_STATIC_LIBRARIES AND SPLIT_SHARED_LIBRARIES)\n    set(BUILD_SHARED_LIBS 1 CACHE INTERNAL &quot;&quot;)\nendif ()\n \nif (USE_STATIC_LIBRARIES)\n    list(REVERSE CMAKE_FIND_LIBRARY_SUFFIXES)\nendif ()\n \noption (ENABLE_FUZZING &quot;Fuzzy testing using libfuzzer&quot; OFF)\n \nif (ENABLE_FUZZING)\n    # Also set WITH_COVERAGE=1 for better fuzzing process\n    # By default this is disabled, because fuzzers are built in CI with the clickhouse itself.\n    # And we don&#039;t want to enable coverage for it.\n    message (STATUS &quot;Fuzzing instrumentation enabled&quot;)\n    set (FUZZER &quot;libfuzzer&quot;)\n    set (CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -nostdlib++&quot;)\n    set (ENABLE_CLICKHOUSE_ODBC_BRIDGE OFF)\n    set (ENABLE_LIBRARIES 0)\n    set (ENABLE_SSL 1)\n    set (USE_UNWIND ON)\n    set (ENABLE_EMBEDDED_COMPILER 0)\n    set (ENABLE_EXAMPLES 0)\n    set (ENABLE_UTILS 0)\n    set (ENABLE_THINLTO 0)\n    set (ENABLE_TCMALLOC 0)\n    set (ENABLE_JEMALLOC 0)\n    set (ENABLE_CHECK_HEAVY_BUILDS 1)\n    set (GLIBC_COMPATIBILITY OFF)\n \n    # For codegen_select_fuzzer\n    set (ENABLE_PROTOBUF 1)\nendif()\n \n# Global libraries\n# See:\n# - default_libs.cmake\n# - sanitize.cmake\nadd_library(global-libs INTERFACE)\n \ninclude (cmake/fuzzer.cmake)\ninclude (cmake/sanitize.cmake)\n \noption(ENABLE_COLORED_BUILD &quot;Enable colors in compiler output&quot; ON)\n \nset (CMAKE_COLOR_MAKEFILE ${ENABLE_COLORED_BUILD}) # works only for the makefile generator\n \nif (ENABLE_COLORED_BUILD AND CMAKE_GENERATOR STREQUAL &quot;Ninja&quot;)\n    # Turn on colored output. github.com/ninja-build/ninja/wiki/FAQ\n    set (CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -fdiagnostics-color=always&quot;)\n    set (CMAKE_C_FLAGS &quot;${CMAKE_C_FLAGS} -fdiagnostics-color=always&quot;)\n    # ... such manually setting of flags can be removed once CMake supports a variable to\n    # activate colors in *all* build systems: gitlab.kitware.com/cmake/cmake/-/issues/15502\nendif ()\n \ninclude (cmake/check_flags.cmake)\ninclude (cmake/add_warning.cmake)\n \nif (COMPILER_CLANG)\n    # generate ranges for fast &quot;addr2line&quot; search\n    if (NOT CMAKE_BUILD_TYPE_UC STREQUAL &quot;RELEASE&quot;)\n        set(COMPILER_FLAGS &quot;${COMPILER_FLAGS} -gdwarf-aranges&quot;)\n    endif ()\n \n    if (HAS_USE_CTOR_HOMING)\n        # For more info see blog.llvm.org/posts/2021-04-05-constructor-homing-for-debug-info/\n        if (CMAKE_BUILD_TYPE_UC STREQUAL &quot;DEBUG&quot; OR CMAKE_BUILD_TYPE_UC STREQUAL &quot;RELWITHDEBINFO&quot;)\n            set (CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -Xclang -fuse-ctor-homing&quot;)\n            set (CMAKE_C_FLAGS &quot;${CMAKE_C_FLAGS} -Xclang -fuse-ctor-homing&quot;)\n        endif()\n    endif()\n \n    no_warning(enum-constexpr-conversion) # breaks Protobuf in clang-16\nendif ()\n \n# If compiler has support for -Wreserved-identifier. It is difficult to detect by clang version,\n# because there are two different branches of clang: clang and AppleClang.\n# (AppleClang is not supported by ClickHouse, but some developers have misfortune to use it).\nif (HAS_RESERVED_IDENTIFIER)\n    add_compile_definitions (HAS_RESERVED_IDENTIFIER)\nendif ()\n \n# If turned `ON`, assumes the user has either the system GTest library or the bundled one.\noption(ENABLE_TESTS &quot;Provide unit_test_dbms target with Google.Test unit tests&quot; ON)\noption(ENABLE_EXAMPLES &quot;Build all example programs in &#039;examples&#039; subdirectories&quot; OFF)\n \nif (OS_LINUX AND (ARCH_AMD64 OR ARCH_AARCH64) AND USE_STATIC_LIBRARIES AND NOT SPLIT_SHARED_LIBRARIES AND NOT USE_MUSL)\n    # Only for Linux, x86_64 or aarch64.\n    option(GLIBC_COMPATIBILITY &quot;Enable compatibility with older glibc libraries.&quot; ON)\nelseif(GLIBC_COMPATIBILITY)\n    message (${RECONFIGURE_MESSAGE_LEVEL} &quot;Glibc compatibility cannot be enabled in current configuration&quot;)\nendif ()\n \n# Make sure the final executable has symbols exported\nset (CMAKE_EXE_LINKER_FLAGS &quot;${CMAKE_EXE_LINKER_FLAGS} -rdynamic&quot;)\n \nif (OS_DARWIN)\n    # The `-all_load` flag forces loading of all symbols from all libraries,\n    # and leads to multiply-defined symbols. This flag allows force loading\n    # from a _specific_ library, which is what we need.\n    set(WHOLE_ARCHIVE -force_load)\n    # The `-noall_load` flag is the default and now obsolete.\n    set(NO_WHOLE_ARCHIVE &quot;-undefined,error&quot;) # Effectively, a no-op. Here to avoid empty &quot;-Wl, &quot; sequence to be generated in the command line.\nelse ()\n    set(WHOLE_ARCHIVE --whole-archive)\n    set(NO_WHOLE_ARCHIVE --no-whole-archive)\nendif ()\n \noption(ENABLE_CURL_BUILD &quot;Enable curl, azure, sentry build on by default except MacOS.&quot; ON)\nif (OS_DARWIN)\n    # Disable the curl, azure, senry build on MacOS\n    set (ENABLE_CURL_BUILD OFF)\nendif ()\n \n# Ignored if `lld` is used\noption(ADD_GDB_INDEX_FOR_GOLD &quot;Add .gdb-index to resulting binaries for gold linker.&quot;)\n \nif (NOT CMAKE_BUILD_TYPE_UC STREQUAL &quot;RELEASE&quot;)\n    # Can be lld or ld-lld.\n    if (LINKER_NAME MATCHES &quot;lld$&quot;)\n        set (CMAKE_EXE_LINKER_FLAGS &quot;${CMAKE_EXE_LINKER_FLAGS} -Wl,--gdb-index&quot;)\n        set (CMAKE_SHARED_LINKER_FLAGS &quot;${CMAKE_SHARED_LINKER_FLAGS} -Wl,--gdb-index&quot;)\n        message (STATUS &quot;Adding .gdb-index via --gdb-index linker option.&quot;)\n    # we use another tool for gdb-index, because gold linker removes section .debug_aranges, which used inside clickhouse stacktraces\n    # sourceware-org.1504.n7.nabble.com/gold-No-debug-aranges-section-when-linking-with-gdb-index-td540965.html#a556932\n    elseif (LINKER_NAME MATCHES &quot;gold$&quot; AND ADD_GDB_INDEX_FOR_GOLD)\n        find_program (GDB_ADD_INDEX_EXE NAMES &quot;gdb-add-index&quot; DOC &quot;Path to gdb-add-index executable&quot;)\n        if (NOT GDB_ADD_INDEX_EXE)\n            set (USE_GDB_ADD_INDEX 0)\n            message (WARNING &quot;Cannot add gdb index to binaries, because gold linker is used, but gdb-add-index executable not found.&quot;)\n        else()\n            set (USE_GDB_ADD_INDEX 1)\n            message (STATUS &quot;gdb-add-index found: ${GDB_ADD_INDEX_EXE}&quot;)\n        endif()\n    endif ()\nendif()\n \nif (CMAKE_BUILD_TYPE_UC STREQUAL &quot;RELEASE&quot;\n    OR CMAKE_BUILD_TYPE_UC STREQUAL &quot;RELWITHDEBINFO&quot;\n    OR CMAKE_BUILD_TYPE_UC STREQUAL &quot;MINSIZEREL&quot;)\n    set (OMIT_HEAVY_DEBUG_SYMBOLS_DEFAULT ON)\nelse()\n    set (OMIT_HEAVY_DEBUG_SYMBOLS_DEFAULT OFF)\nendif()\n# Provides faster linking and lower binary size.\n# Tradeoff is the inability to debug some source files with e.g. gdb\n# (empty stack frames and no local variables).&quot;\noption(OMIT_HEAVY_DEBUG_SYMBOLS\n    &quot;Do not generate debugger info for heavy modules (ClickHouse functions and dictionaries, some contrib)&quot;\n    ${OMIT_HEAVY_DEBUG_SYMBOLS_DEFAULT})\n \nif (CMAKE_BUILD_TYPE_UC STREQUAL &quot;DEBUG&quot;)\n    set(USE_DEBUG_HELPERS ON)\nendif()\noption(USE_DEBUG_HELPERS &quot;Enable debug helpers&quot; ${USE_DEBUG_HELPERS})\n \noption(BUILD_STANDALONE_KEEPER &quot;Build keeper as small standalone binary&quot; OFF)\nif (NOT BUILD_STANDALONE_KEEPER)\n    option(CREATE_KEEPER_SYMLINK &quot;Create symlink for clickhouse-keeper to main server binary&quot; ON)\nelse ()\n    option(CREATE_KEEPER_SYMLINK &quot;Create symlink for clickhouse-keeper to main server binary&quot; OFF)\nendif ()\n \n# Create BuildID when using lld. For other linkers it is created by default.\nif (LINKER_NAME MATCHES &quot;lld$&quot;)\n    # SHA1 is not cryptographically secure but it is the best what lld is offering.\n    set (CMAKE_EXE_LINKER_FLAGS &quot;${CMAKE_EXE_LINKER_FLAGS} -Wl,--build-id=sha1&quot;)\nendif ()\n \n# Add a section with the hash of the compiled machine code for integrity checks.\n# Only for official builds, because adding a section can be time consuming (rewrite of several GB).\n# And cross compiled binaries are not supported (since you cannot execute clickhouse hash-binary)\nif (CLICKHOUSE_OFFICIAL_BUILD AND (NOT CMAKE_TOOLCHAIN_FILE OR CMAKE_TOOLCHAIN_FILE MATCHES &quot;linux/toolchain-x86_64.cmake$&quot;))\n    message(STATUS &quot;Official build: A checksum hash will be added to the clickhouse executable&quot;)\n    set (USE_BINARY_HASH 1 CACHE STRING &quot;Calculate binary hash and store it in the separate section&quot;)\nelse ()\n    message(STATUS &quot;No official build: A checksum hash will not be added to the clickhouse executable&quot;)\nendif ()\n \n# Optionally split binaries and debug symbols.\noption(SPLIT_DEBUG_SYMBOLS &quot;Split binaries and debug symbols&quot; OFF)\nif (SPLIT_DEBUG_SYMBOLS)\n    message(STATUS &quot;Will split binaries and debug symbols&quot;)\n    set(SPLITTED_DEBUG_SYMBOLS_DIR &quot;stripped&quot; CACHE STRING &quot;A separate directory for stripped information&quot;)\nendif()\n \ncmake_host_system_information(RESULT AVAILABLE_PHYSICAL_MEMORY QUERY AVAILABLE_PHYSICAL_MEMORY) # Not available under freebsd\n \n \nif(NOT AVAILABLE_PHYSICAL_MEMORY OR AVAILABLE_PHYSICAL_MEMORY GREATER 8000)\n    # Less `/tmp` usage, more RAM usage.\n    option(COMPILER_PIPE &quot;-pipe compiler option&quot; ON)\nendif()\n \nif(COMPILER_PIPE)\n    set(COMPILER_FLAGS &quot;${COMPILER_FLAGS} -pipe&quot;)\nelse()\n    message(STATUS &quot;Disabling compiler -pipe option (have only ${AVAILABLE_PHYSICAL_MEMORY} mb of memory)&quot;)\nendif()\n \ninclude(cmake/cpu_features.cmake)\n \n# Asynchronous unwind tables are needed for Query Profiler.\n# They are already by default on some platforms but possibly not on all platforms.\n# Enable it explicitly.\nset (COMPILER_FLAGS &quot;${COMPILER_FLAGS} -fasynchronous-unwind-tables&quot;)\n \n# Reproducible builds.\nif (CMAKE_BUILD_TYPE_UC STREQUAL &quot;DEBUG&quot;)\n    set (ENABLE_BUILD_PATH_MAPPING_DEFAULT OFF)\nelse ()\n    set (ENABLE_BUILD_PATH_MAPPING_DEFAULT ON)\nendif ()\n \noption (ENABLE_BUILD_PATH_MAPPING &quot;Enable remapping of file source paths in debug info, predefined preprocessor macros, and __builtin_FILE(). It&#039;s used to generate reproducible builds. See reproducible-builds.org/docs/build-path&quot; ${ENABLE_BUILD_PATH_MAPPING_DEFAULT})\n \nif (ENABLE_BUILD_PATH_MAPPING)\n    set (COMPILER_FLAGS &quot;${COMPILER_FLAGS} -ffile-prefix-map=${CMAKE_SOURCE_DIR}=.&quot;)\n    set (CMAKE_ASM_FLAGS &quot;${CMAKE_ASM_FLAGS} -ffile-prefix-map=${CMAKE_SOURCE_DIR}=.&quot;)\nendif ()\n \noption (ENABLE_BUILD_PROFILING &quot;Enable profiling of build time&quot; OFF)\nif (ENABLE_BUILD_PROFILING)\n     if (COMPILER_CLANG)\n        set (COMPILER_FLAGS &quot;${COMPILER_FLAGS} -ftime-trace&quot;)\n     else ()\n        message (${RECONFIGURE_MESSAGE_LEVEL} &quot;Build profiling is only available with CLang&quot;)\n     endif ()\nendif ()\n \nset (CMAKE_CXX_STANDARD 20)\nset (CMAKE_CXX_EXTENSIONS ON) # Same as gnu++2a (ON) vs c++2a (OFF): cmake.org/cmake/help/latest/prop_tgt/CXX_EXTENSIONS.html\nset (CMAKE_CXX_STANDARD_REQUIRED ON)\n \nset (CMAKE_C_STANDARD 11)\nset (CMAKE_C_EXTENSIONS ON)\nset (CMAKE_C_STANDARD_REQUIRED ON)\n \nif (COMPILER_GCC OR COMPILER_CLANG)\n    # Enable C++14 sized global deallocation functions. It should be enabled by setting -std=c++14 but I&#039;m not sure.\n    set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -fsized-deallocation&quot;)\nendif ()\n \n# falign-functions=32 prevents from random performance regressions with the code change. Thus, providing more stable\n# benchmarks.\nif (COMPILER_GCC OR COMPILER_CLANG)\n    set(COMPILER_FLAGS &quot;${COMPILER_FLAGS} -falign-functions=32&quot;)\nendif ()\n \nif (ARCH_AMD64)\n    # align branches within a 32-Byte boundary to avoid the potential performance loss when code layout change,\n    # which makes benchmark results more stable.\n    set(BRANCHES_WITHIN_32B_BOUNDARIES &quot;-mbranches-within-32B-boundaries&quot;)\n    if (COMPILER_GCC)\n        # gcc is in assembler, need to add &quot;-Wa,&quot; prefix\n        set(BRANCHES_WITHIN_32B_BOUNDARIES &quot;-Wa,${BRANCHES_WITHIN_32B_BOUNDARIES}&quot;)\n    endif()\n \n    include(CheckCXXCompilerFlag)\n    check_cxx_compiler_flag(&quot;${BRANCHES_WITHIN_32B_BOUNDARIES}&quot; HAS_BRANCHES_WITHIN_32B_BOUNDARIES)\n    if (HAS_BRANCHES_WITHIN_32B_BOUNDARIES)\n        set(COMPILER_FLAGS &quot;${COMPILER_FLAGS} ${BRANCHES_WITHIN_32B_BOUNDARIES}&quot;)\n    endif()\nendif()\n \nif (COMPILER_GCC)\n    set (CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -fcoroutines&quot;)\nendif ()\n \n# Compiler-specific coverage flags e.g. -fcoverage-mapping for gcc\noption(WITH_COVERAGE &quot;Profile the resulting binary/binaries&quot; OFF)\n \nif (WITH_COVERAGE AND COMPILER_CLANG)\n    set(COMPILER_FLAGS &quot;${COMPILER_FLAGS} -fprofile-instr-generate -fcoverage-mapping&quot;)\n    # If we want to disable coverage for specific translation units\n    set(WITHOUT_COVERAGE &quot;-fno-profile-instr-generate -fno-coverage-mapping&quot;)\nendif()\n \nif (WITH_COVERAGE AND COMPILER_GCC)\n    set(COMPILER_FLAGS &quot;${COMPILER_FLAGS} -fprofile-arcs -ftest-coverage&quot;)\n    set(COVERAGE_OPTION &quot;-lgcov&quot;)\n    set(WITHOUT_COVERAGE &quot;-fno-profile-arcs -fno-test-coverage&quot;)\nendif()\n \nset (COMPILER_FLAGS &quot;${COMPILER_FLAGS}&quot;)\n \n# Our built-in unwinder only supports DWARF version up to 4.\nset (DEBUG_INFO_FLAGS &quot;-g -gdwarf-4&quot;)\n \nset (CMAKE_CXX_FLAGS                     &quot;${CMAKE_CXX_FLAGS} ${COMPILER_FLAGS}&quot;)\nset (CMAKE_CXX_FLAGS_RELWITHDEBINFO      &quot;${CMAKE_CXX_FLAGS_RELWITHDEBINFO} -O3 ${DEBUG_INFO_FLAGS} ${CMAKE_CXX_FLAGS_ADD}&quot;)\nset (CMAKE_CXX_FLAGS_DEBUG               &quot;${CMAKE_CXX_FLAGS_DEBUG} -O0 ${DEBUG_INFO_FLAGS} -fno-inline ${CMAKE_CXX_FLAGS_ADD}&quot;)\n \nset (CMAKE_C_FLAGS                       &quot;${CMAKE_C_FLAGS} ${COMPILER_FLAGS} ${CMAKE_C_FLAGS_ADD}&quot;)\nset (CMAKE_C_FLAGS_RELWITHDEBINFO        &quot;${CMAKE_C_FLAGS_RELWITHDEBINFO} -O3 ${DEBUG_INFO_FLAGS} ${CMAKE_C_FLAGS_ADD}&quot;)\nset (CMAKE_C_FLAGS_DEBUG                 &quot;${CMAKE_C_FLAGS_DEBUG} -O0 ${DEBUG_INFO_FLAGS} -fno-inline ${CMAKE_C_FLAGS_ADD}&quot;)\n \nset (CMAKE_ASM_FLAGS                     &quot;${CMAKE_ASM_FLAGS} ${COMPILER_FLAGS} ${CMAKE_ASM_FLAGS_ADD}&quot;)\nset (CMAKE_ASM_FLAGS_RELWITHDEBINFO      &quot;${CMAKE_ASM_FLAGS_RELWITHDEBINFO} -O3 ${DEBUG_INFO_FLAGS} ${CMAKE_ASM_FLAGS_ADD}&quot;)\nset (CMAKE_ASM_FLAGS_DEBUG               &quot;${CMAKE_ASM_FLAGS_DEBUG} -O0 ${DEBUG_INFO_FLAGS} -fno-inline ${CMAKE_ASM_FLAGS_ADD}&quot;)\n \nif (COMPILER_CLANG)\n    if (OS_DARWIN)\n        set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -stdlib=libc++&quot;)\n        set(CMAKE_EXE_LINKER_FLAGS &quot;${CMAKE_EXE_LINKER_FLAGS} -Wl,-U,_inside_main&quot;)\n    endif()\n \n    # Display absolute paths in error messages. Otherwise KDevelop fails to navigate to correct file and opens a new file instead.\n    set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -fdiagnostics-absolute-paths&quot;)\n    set(CMAKE_C_FLAGS &quot;${CMAKE_C_FLAGS} -fdiagnostics-absolute-paths&quot;)\n \n    if (NOT ENABLE_TESTS AND NOT SANITIZE)\n        # clang.llvm.org/docs/ThinLTO.html\n        # Applies to clang only.\n        # Disabled when building with tests or sanitizers.\n        option(ENABLE_THINLTO &quot;Clang-specific link time optimization&quot; ON)\n    endif()\n \n    set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -fstrict-vtable-pointers&quot;)\n \n    # Set new experimental pass manager, it&#039;s a performance, build time and binary size win.\n    # Can be removed after reviews.llvm.org/D66490 merged and released to at least two versions of clang.\n    set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -fexperimental-new-pass-manager&quot;)\n    set(CMAKE_C_FLAGS &quot;${CMAKE_C_FLAGS} -fexperimental-new-pass-manager&quot;)\n \n    # We cannot afford to use LTO when compiling unit tests, and it&#039;s not enough\n    # to only supply -fno-lto at the final linking stage. So we disable it\n    # completely.\n    if (ENABLE_THINLTO AND NOT ENABLE_TESTS AND NOT SANITIZE)\n        # Link time optimization\n        set (CMAKE_C_FLAGS_RELWITHDEBINFO &quot;${CMAKE_C_FLAGS_RELWITHDEBINFO} -flto=thin -fwhole-program-vtables&quot;)\n        set (CMAKE_CXX_FLAGS_RELWITHDEBINFO &quot;${CMAKE_CXX_FLAGS_RELWITHDEBINFO} -flto=thin -fwhole-program-vtables&quot;)\n        set (CMAKE_EXE_LINKER_FLAGS_RELWITHDEBINFO &quot;${CMAKE_EXE_LINKER_FLAGS_RELWITHDEBINFO} -flto=thin -fwhole-program-vtables&quot;)\n    elseif (ENABLE_THINLTO)\n        message (${RECONFIGURE_MESSAGE_LEVEL} &quot;Cannot enable ThinLTO&quot;)\n    endif ()\n \nelseif (ENABLE_THINLTO)\n    message (${RECONFIGURE_MESSAGE_LEVEL} &quot;ThinLTO is only available with Clang&quot;)\nendif ()\n \n# Turns on all external libs like s3, kafka, ODBC, ...\noption(ENABLE_LIBRARIES &quot;Enable all external libraries by default&quot; ON)\n \n# Increase stack size on Musl. We need big stack for our recursive-descend parser.\nif (USE_MUSL)\n    set (CMAKE_EXE_LINKER_FLAGS &quot;${CMAKE_EXE_LINKER_FLAGS} -Wl,-z,stack-size=2097152&quot;)\nendif ()\n \ninclude(cmake/dbms_glob_sources.cmake)\n \nadd_library(global-group INTERFACE)\nif (OS_LINUX OR OS_ANDROID)\n    include(cmake/linux/default_libs.cmake)\nelseif (OS_DARWIN)\n    include(cmake/darwin/default_libs.cmake)\nelseif (OS_FREEBSD)\n    include(cmake/freebsd/default_libs.cmake)\nendif ()\nlink_libraries(global-group)\n \nif (NOT (OS_LINUX OR OS_DARWIN))\n    # Using system libs can cause a lot of warnings in includes (on macro expansion).\n    option(WERROR &quot;Enable -Werror compiler option&quot; OFF)\nelse ()\n    option(WERROR &quot;Enable -Werror compiler option&quot; ON)\nendif ()\n \nif (WERROR)\n    # Don&#039;t pollute CMAKE_CXX_FLAGS with -Werror as it will break some CMake checks.\n    # Instead, adopt modern cmake usage requirement.\n    target_compile_options(global-group INTERFACE &quot;-Werror&quot;)\nendif ()\n \n# Make this extra-checks for correct library dependencies.\nif (OS_LINUX AND NOT SANITIZE)\n    target_link_options(global-group INTERFACE &quot;LINKER:--no-undefined&quot;)\nendif ()\n \n######################################\n### Add targets below this comment ###\n######################################\n \nset (CMAKE_POSTFIX_VARIABLE &quot;CMAKE_${CMAKE_BUILD_TYPE_UC}_POSTFIX&quot;)\n \nif (USE_STATIC_LIBRARIES)\n    set (CMAKE_POSITION_INDEPENDENT_CODE OFF)\n    if (OS_LINUX AND NOT ARCH_AARCH64)\n        # Slightly more efficient code can be generated\n        # It&#039;s disabled for ARM because otherwise ClickHouse cannot run on Android.\n        set (CMAKE_CXX_FLAGS_RELWITHDEBINFO &quot;${CMAKE_CXX_FLAGS_RELWITHDEBINFO} &quot;)\n        set (CMAKE_C_FLAGS_RELWITHDEBINFO &quot;${CMAKE_C_FLAGS_RELWITHDEBINFO} &quot;)\n        set (CMAKE_EXE_LINKER_FLAGS &quot;${CMAKE_EXE_LINKER_FLAGS} &quot;)\n    endif ()\nelse ()\n    set (CMAKE_POSITION_INDEPENDENT_CODE ON)\n    # This is required for clang on Arch linux, that uses PIE by default.\n    # See enable-SSP-and-PIE-by-default.patch [1].\n    #\n    #   [1]: github.com/archlinux/svntogit-packages/blob/6e681aa860e65ad46a1387081482eb875c2200f2/trunk/enable-SSP-and-PIE-by-default.patch\n    set (CMAKE_EXE_LINKER_FLAGS &quot;${CMAKE_EXE_LINKER_FLAGS} &quot;)\nendif ()\n \nif (ENABLE_TESTS)\n    message (STATUS &quot;Unit tests are enabled&quot;)\nelse()\n    message(STATUS &quot;Unit tests are disabled&quot;)\nendif ()\n \nenable_testing() # Enable for tests without binary\n \n# when installing to /usr - place configs to /etc but for /usr/local place to /usr/local/etc\nif (CMAKE_INSTALL_PREFIX STREQUAL &quot;/usr&quot;)\n    set (CLICKHOUSE_ETC_DIR &quot;/etc&quot;)\nelse ()\n    set (CLICKHOUSE_ETC_DIR &quot;${CMAKE_INSTALL_PREFIX}/etc&quot;)\nendif ()\n \nmessage (STATUS\n    &quot;Building for: ${CMAKE_SYSTEM} ${CMAKE_SYSTEM_PROCESSOR} ${CMAKE_LIBRARY_ARCHITECTURE} ;\n    USE_STATIC_LIBRARIES=${USE_STATIC_LIBRARIES}\n    SPLIT_SHARED_LIBRARIES=${SPLIT_SHARED_LIBRARIES}&quot;)\n \ninclude (GNUInstallDirs)\n \n# When testing for memory leaks with Valgrind, don&#039;t link tcmalloc or jemalloc.\n \nif (TARGET global-group)\n    install (EXPORT global DESTINATION cmake)\nendif ()\n \nadd_subdirectory (contrib EXCLUDE_FROM_ALL)\n \nif (NOT ENABLE_JEMALLOC)\n    message (WARNING &quot;Non default allocator is disabled. This is not recommended for production builds.&quot;)\nendif ()\n \nmacro (clickhouse_add_executable target)\n    # invoke built-in add_executable\n    # explicitly acquire and interpose malloc symbols by clickhouse_malloc\n    # if GLIBC_COMPATIBILITY is ON and ENABLE_THINLTO is on than provide memcpy symbol explicitly to neutrialize thinlto&#039;s libcall generation.\n    if (ARCH_AMD64 AND GLIBC_COMPATIBILITY AND ENABLE_THINLTO)\n        add_executable (${ARGV} $&lt;TARGET_OBJECTS:clickhouse_malloc&gt; $&lt;TARGET_OBJECTS:memcpy&gt;)\n    else ()\n        add_executable (${ARGV} $&lt;TARGET_OBJECTS:clickhouse_malloc&gt;)\n    endif ()\n \n    get_target_property (type ${target} TYPE)\n    if (${type} STREQUAL EXECUTABLE)\n        # disabled for TSAN and gcc since libtsan.a provides overrides too\n        if (TARGET clickhouse_new_delete)\n            # operator::new/delete for executables (MemoryTracker stuff)\n            target_link_libraries (${target} PRIVATE clickhouse_new_delete)\n        endif()\n \n        # In case of static jemalloc, because zone_register() is located in zone.c and\n        # is never used outside (it is declared as constructor) it is omitted\n        # by the linker, and so jemalloc will not be registered as system\n        # allocator under osx [1], and clickhouse will SIGSEGV.\n        #\n        #   [1]: github.com/jemalloc/jemalloc/issues/708\n        #\n        # About symbol name:\n        # - _zone_register not zone_register due to Mach-O binary format,\n        # - _je_zone_register due to JEMALLOC_PRIVATE_NAMESPACE=je_ under OS X.\n        # - but jemalloc-cmake does not run private_namespace.sh\n        #   so symbol name should be _zone_register\n        if (ENABLE_JEMALLOC AND USE_STATIC_LIBRARIES AND OS_DARWIN)\n            set_property(TARGET ${target} APPEND PROPERTY LINK_OPTIONS -u_zone_register)\n        endif()\n    endif()\nendmacro()\n \n# With cross-compiling, all targets are built for the target platform which usually different from the host\n# platform. This is problematic if a build artifact X (e.g. a file or an executable) is generated by running\n# another executable Y previously produced in the build. This is solved by compiling and running Y for/on\n# the host platform. Add target to the list:\n#    add_native_target(&lt;target&gt; ...)\nset_property (GLOBAL PROPERTY NATIVE_BUILD_TARGETS)\nfunction (add_native_target)\n    set_property (GLOBAL APPEND PROPERTY NATIVE_BUILD_TARGETS ${ARGV})\nendfunction (add_native_target)\n \nset(ConfigIncludePath ${CMAKE_CURRENT_BINARY_DIR}/includes/configs CACHE INTERNAL &quot;Path to generated configuration files.&quot;)\ninclude_directories(${ConfigIncludePath})\n \n# Add as many warnings as possible for our own code.\ninclude (cmake/warnings.cmake)\ninclude (cmake/print_flags.cmake)\n \nadd_subdirectory (base)\nadd_subdirectory (src)\nadd_subdirectory (programs)\nadd_subdirectory (tests)\nadd_subdirectory (utils)\n \ninclude (cmake/sanitize_target_link_libraries.cmake)\n \n# Build native targets if necessary\nget_property(NATIVE_BUILD_TARGETS GLOBAL PROPERTY NATIVE_BUILD_TARGETS)\nif (NATIVE_BUILD_TARGETS\n    AND NOT(\n        CMAKE_HOST_SYSTEM_NAME STREQUAL CMAKE_SYSTEM_NAME\n        AND CMAKE_HOST_SYSTEM_PROCESSOR STREQUAL CMAKE_SYSTEM_PROCESSOR\n    )\n)\n    message (STATUS &quot;Building native targets...&quot;)\n \n    set (NATIVE_BUILD_DIR &quot;${CMAKE_BINARY_DIR}/native&quot;)\n \n    execute_process(\n        COMMAND ${CMAKE_COMMAND} -E make_directory &quot;${NATIVE_BUILD_DIR}&quot;\n        COMMAND_ECHO STDOUT)\n \n    execute_process(\n        COMMAND ${CMAKE_COMMAND}\n            &quot;-DCMAKE_C_COMPILER=${CMAKE_C_COMPILER}&quot;\n            &quot;-DCMAKE_CXX_COMPILER=${CMAKE_CXX_COMPILER}&quot;\n        ${CMAKE_SOURCE_DIR}\n        WORKING_DIRECTORY &quot;${NATIVE_BUILD_DIR}&quot;\n        COMMAND_ECHO STDOUT)\n \n    execute_process(\n        COMMAND ${CMAKE_COMMAND} --build &quot;${NATIVE_BUILD_DIR}&quot; --target ${NATIVE_BUILD_TARGETS}\n        COMMAND_ECHO STDOUT)\nendif ()\n \noption(ENABLE_PBKDF2 &quot;Enable PBKDF2&quot; 0)\n \nif (ENABLE_PBKDF2)\n    add_definitions(-DENABLE_PBKDF2=1)\nendif()\n \noption(DISABLE_HTTP &quot;Disable HTTP Protocl&quot; 0)\n \nif (DISABLE_HTTP)\n    add_definitions(-DISABLE_HTTP=1)\nendif()\n \noption(DISABLE_MEMCPY &quot;Disable memcpy_jart&quot; 0)\n \nif (DISABLE_MEMCPY)\n    add_definitions(-DISABLE_MEMCPY=1)\nendif()\n我们从一个简单的CMakeLists.txt开始：\ncmake_minimum_required(VERSION 3.20)\nproject(GREDialing VERSION 0.1)\n \nmessage(STATUS &quot;CMake version: &quot; ${CMAKE_VERSION})\nif(NOT ${CMAKE_VERSION} VERSION_LESS &quot;3.2&quot;)\n    set(CMAKE_CXX_STANDARD 17)\n    set(CMAKE_CXX_STANDARD_REQUIRED ON)\nelse()\n    message(STATUS &quot;Checking compiler flags for C++11 support.&quot;)\n    # Set C++11 support flags for various compilers\n    include(CheckCXXCompilerFlag)\n    check_cxx_compiler_flag(&quot;-std=c++11&quot; COMPILER_SUPPORTS_CXX11)\n    check_cxx_compiler_flag(&quot;-std=c++0x&quot; COMPILER_SUPPORTS_CXX0X)\n    if(COMPILER_SUPPORTS_CXX11)\n        message(STATUS &quot;C++11 is supported.&quot;)\n        if(${CMAKE_SYSTEM_NAME} MATCHES &quot;Darwin&quot;)\n            set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -std=c++11 -stdlib=libc++&quot;)\n        else()\n            set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -std=c++11&quot;)\n        endif()\n    elseif(COMPILER_SUPPORTS_CXX0X)\n        message(STATUS &quot;C++0x is supported.&quot;)\n        if(${CMAKE_SYSTEM_NAME} MATCHES &quot;Darwin&quot;)\n            set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -std=c++0x -stdlib=libc++&quot;)\n        else()\n            set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -std=c++0x&quot;)\n        endif()\n    else()\n        message(STATUS &quot;The compiler ${CMAKE_CXX_COMPILER} has no C++11 support. Please use a different C++ compiler.&quot;)\n    endif()\nendif()\n \n \n \n# 禁止 C++ assert terminate 程序\n# add_definitions(-DNDEBUG)\n \n# ASIO 不使用 Boost 库\n#add_definitions(-DASIO_STANDALONE)\n \n# Spdlog 使用外部 Fmt 库\n#add_definitions(-DSPDLOG_FMT_EXTERNAL)\n \n# Jwt-cpp 使用外部 Json 库\n# ADD_DEFINITIONS(-DJWT_CPP_JSON_EXTERNAL)\n \n# add_definitions(-DGLOG_ON)\n \n# 生成编译命令文件，给 YCM/Clangd 使用\nset(CMAKE_EXPORT_COMPILE_COMMANDS ON)\n \nADD_COMPILE_OPTIONS(-g)\n \n#设置输出目录\n# set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)\n# set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)\n# set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${PROJECT_SOURCE_DIR}/bin)\n \n \n#加入包含目录\n# include_directories(${CMAKE_CURRENT_SOURCE_DIR}/service/src/main/cpp/decryptSDK/include) \ninclude_directories(decryptSDK/include) \ninclude_directories(/home/hubingbing/rapidjson/include)\ninclude_directories(/home/hubingbing/concurrentqueue)\n# include_directories(/opt/Euler_compile_env/usr/src/kernels/4.19.90-vhulk2107.1.0.h699.eulerosv2r10.aarch64/include)\n \n \n#静态库目录\n#link_directories(/usr/lib64/mysql)\n \n#logger lib \n#add_subdirectory(decryptSDK)\n \n \n# aux_source_directory(decryptSDK SRCS) #加入目录下所有源码\n# add_executable(demo ${SRCS}) #生成可执行文件\n# target_link_libraries(demo logger)  #链接logger库\n \nset(EXECUTABLE_OUTPUT_PATH &quot;${CMAKE_CURRENT_SOURCE_DIR}/build&quot;)\nmessage(STATUS &quot;binary dir is ${EXECUTABLE_OUTPUT_PATH}&quot;)\n \nset(BUILD_SCRATCH_TARGET 0)\n \nif(BUILD_SCRATCH_TARGET)\n    file(GLOB_RECURSE scratch_srcs scratch/*.cpp)\n    # message(STATUS &quot;all scratchs: ${scratch_srcs}&quot;)\n    foreach(srcfile IN LISTS scratch_srcs)\n        # Get file name without directory\n        get_filename_component(elfname ${srcfile} NAME_WE)\n        message(STATUS &quot;${elfname} .. ${srcfile}&quot;)\n        add_executable(${elfname} ${srcfile})\n        target_link_libraries(${elfname} pthread)\n    endforeach()\nendif()\n \n \n# add_executable(main ../main.cpp)\n# add_executable(server udp_server.cpp) \n# add_executable(ConfigReader ConfigReader.cpp) \n# add_executable(packet_handler packet_handler.cpp)\n \nset(BUILD_MAIN_TARGET 1)\n \nif(BUILD_MAIN_TARGET)\n    set(target main)\n \n    set(src_lst main.cpp ConfigReader.cpp packet_handler.cpp SslClient.cpp packet.cpp)\n    add_executable(${target} ${src_lst})\n \n    aux_source_directory(decryptSDK KMC_DIR)\n    target_sources(${target} PRIVATE ${KMC_DIR})\n    target_include_directories(${target} PRIVATE /home/hubingbing/cloud-frame-kmc/include/)\n    target_link_directories(${target} PRIVATE /home/hubingbing/cloud-frame-kmc/lib_so/)\n    target_link_libraries(${target} kmcjni)\n \n    target_link_libraries(${target} ssl crypto pthread)\nendif()\n# target_link_libraries(debug pthread)\n# target_link_libraries(server pthread)\n上面的cmake也不算太简单，我们再简化一下：\ncmake_minimum_required(VERSION 3.20)\nproject(GREDialing VERSION 0.1)\n \nmessage(STATUS &quot;CMake version: &quot; ${CMAKE_VERSION})\nset(CMAKE_CXX_STANDARD 17)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n \n# 生成编译命令文件，给 YCM/Clangd 使用\nset(CMAKE_EXPORT_COMPILE_COMMANDS ON)\n \n# 附加调试信息\nADD_COMPILE_OPTIONS(-g)\n \n#加入包含目录\ninclude_directories(decryptSDK/include) \ninclude_directories(/home/yychi/rapidjson/include)\ninclude_directories(/home/yychi/concurrentqueue)\n \n# 加入./decryptSDK目录下所有源码并赋到SRCS变量中\n# 后续可用$SRCS使用该变量\naux_source_directory(decryptSDK SRCS) \nadd_executable(demo ${SRCS}) #生成可执行文件\ntarget_link_libraries(demo logger)  #链接logger库\n \nset(EXECUTABLE_OUTPUT_PATH &quot;${CMAKE_CURRENT_SOURCE_DIR}/build&quot;)\nmessage(STATUS &quot;binary dir is ${EXECUTABLE_OUTPUT_PATH}&quot;)\n \nset(BUILD_SCRATCH_TARGET 0)\nif(BUILD_SCRATCH_TARGET)\n    # 递归找到./scratch目录下所有cpp文件，赋值给scratch_srcs变量\n    file(GLOB_RECURSE scratch_srcs scratch/*.cpp)\n    # message(STATUS &quot;all scratchs: ${scratch_srcs}&quot;)\n    foreach(srcfile IN LISTS scratch_srcs)\n        # Get file name without directory\n        get_filename_component(elfname ${srcfile} NAME_WE)\n        message(STATUS &quot;${elfname} .. ${srcfile}&quot;)\n        add_executable(${elfname} ${srcfile})\n        target_link_libraries(${elfname} pthread)\n    endforeach()\nendif()\n \n \nset(BUILD_MAIN_TARGET 1)\nif(BUILD_MAIN_TARGET)\n    set(target main)\n \n    set(src_lst main.cpp a.cpp b.cpp c.cpp d.cpp)\n    add_executable(${target} ${src_lst})\n \n    aux_source_directory(decryptSDK descrypt_srcs)\n    # 为target增加要编译的源文件\n    target_sources(${target} PRIVATE ${descrypt_srcs})\n    # 为target增加include目录\n    target_include_directories(${target} PRIVATE /home/yychi/cloud/include/)\n    # 为target增加动态库/静态库搜索路径\n    target_link_directories(${target} PRIVATE /home/yychi/frame/lib_so/)\n    # 为target链接库文件\n    target_link_libraries(${target} ssl crypto pthread)\nendif()\n通常的，一个CMakeLists.txt中必须包含至少一个target，target可以是动态库/静态库/可执行文件。当定义了target之后，推荐使用\n\ntarget_sources\ntarget_include_directories\ntarget_link_directories\ntarget_link_options\ntarget_link_libraries\ntarget_compile_options\ntarget_compile_definitions\ntarget_compile_features\n\n而非\n\ninclude_directories\nlink_directories\nadd_compile_options\nadd_link_options\n\n等全局函数。\n变量\nset(&lt;variable&gt; &lt;value&gt;) # set value to variable\n${variable} # take the value of variable\n\n\n                  \n                  Note\n                  \n                \n\nCMake语言不区分大小写，但是参数区分大小写。\n\n\nReferences\n\nCMake 完整使用教程 之二 从可执行文件到库\n"},"__zettel/202304231411-name-mangling":{"slug":"__zettel/202304231411-name-mangling","filePath":"__zettel/202304231411 name mangling.md","title":"202304231411","links":["__zettel/链接.html"],"tags":["cpp","name-mangling"],"content":"\nName mangling is the encoding of function and variable names into unique names so that linkers can separate common names in the language.\n\nName mangling实际上是对函数（或者变量）名称的一种编码，c++支持函数重载，而c不支持。所以c++的函数签名的编码方式肯定是和c不一样的，举个例子：\nint foo(int a);  // foo\nint foo(int a);  // foo(int)\nint foo(float a);  // foo(float)\n也可以理解为，函数原型经过编码之后得到的唯一id，暴露给linker用的。linker根据这个名字去查找、链接相应的函数地址。\n同样一段c代码，用c compiler和c++ compiler编出来的函数&amp;变量名称是不一样的。c++的通常会复杂一些，包含namespace，class，形参类型列表等。当使用c++ compiler且不想要上述mangling的时候，可以使用：\nextern &quot;C&quot; {\n\tint  foo(int a);\n\tvoid bar(int b);\n}\n来告诉编译器这些名字不要进行name mangle. 这在c调用c++方法时尤其有用。\n场景一：C调用C++\nC++头文件中提供函数声明，C的源文件中需要包含这个头文件，并使用这个函数。\n// file: cpp.h\n \n#ifdef __cplusplus\nextern &quot;C&quot; {\n#endif\n \nint foo(float);\n \n#ifdef __cplusplus\n}\n#endif\n// file: c.c\n \n#include &quot;cpp.h&quot;\n \nint main()\n{\n    int a = foo(3.14f);\n    return 0;\n}\n使用gcc编译c.c，头文件中的__cplusplus宏处于未定义状态，int foo(float)，foo的函数原型不会进行name mangling，直接就是foo. 因此cpp.h可以用于C项目中。\n使用g++编译其他cpp文件，包含cpp.h，此时__cplusplus宏处于定义状态，extern C的效果产生，即告诉g++不要给int foo(float)进行name mangling，此时编译出的符号，也可以直接用于C++项目，也可以编出lib给C项目使用。\n场景二：C++调C\nC中实现了某些函数，在某个头文件中声明了这些函数。例如\n// file: c.h\n \n#ifdef __cplusplus\nextern &quot;C&quot; {\n#endif\n \nint foo();\nchar bar(char);\n \n#ifdef __cplusplus\n}\n#endif\n这里的__cplusplus宏，在原生C项目中（gcc编译）处于未定义状态，压根不起作用。但在C++项目（g++编译）中，如果包含了这个头文件，读到了__cplusplus宏，就不会对foo和bar进行name mangling，因此，C++链接器在寻找这个符号时，能够正确找到此前用gcc生成的未进行name mangling的符号。\n\nc.h中的函数实现，必然在某个C源文件中。因此一般使用gcc编译产生lib. C++要用这个lib，要能找到这个符号，就必须按之前C语言的符号生成规则（不进行name mangling）来寻找（链接）。\n\nYou will need extern &quot;C&quot; both when calling:\n\nC from C++: tell g++ to expect unmangled symbols produced by gcc,\nC++ from C: tell g++ to generate unmangled symbols for gcc to use.\n\nSee also 链接\nReferences\n\nName mangling (C++ only)\nStability of the C++ ABI: Evolution of a Programming Language\nWhat is the effect of extern “C” in C++?\n"},"__zettel/202304231659-firefox伪装chrome-ua":{"slug":"__zettel/202304231659-firefox伪装chrome-ua","filePath":"__zettel/202304231659 firefox伪装chrome ua.md","title":"202304231659","links":[],"tags":["firefox","chrome","browser","ua","useragent"],"content":"许多网站强制建议使用chrome打开，但其实firefox能够完美渲染该页面。所以需要强制更改firefox的ua伪装chrome：\n\nfirefox输入about:config\n搜索general.useragent.override，没有则新建之，值类型为字符串\n打开chrome看下它的ua，输入about:version，或者直接使用 Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36\n复制chrome的ua到新建的值中\n\nsee: sspai.com/post/75349"},"__zettel/202304241826-RTTI-in-cpp":{"slug":"__zettel/202304241826-RTTI-in-cpp","filePath":"__zettel/202304241826 RTTI in cpp.md","title":"202304241826","links":["notes/cpp/继承.html"],"tags":["rtti","dynamic-cast","cpp","typeid"],"content":"RTTI stands for RunTime Type Identification. Commonly two ways to achieve it.\nDynamic cast\nclass Base {};\nclass Derived : public Base {};\n \nvoid foo(Base* b)\n{\n    Derived* d = dynamic_cast&lt;Derived*&gt;(b);\n    if (d != nullptr)\n    {\n        // b is actually points to a Derived object.\n    }\n}\nTypeid\ntypeid is a operator in c++, which gives the type_info struct to the given type. See more in cppreference.\nSummary\nDynamic cast needs to work in polymorphic. Once use RTTI, every type will contain a extra info struct type_info.\n\nPass the -fno-rtti to the compiler to disable this, i.e., RTTI incurs extra cost.\nSee also 继承."},"__zettel/202304281707-右值引用":{"slug":"__zettel/202304281707-右值引用","filePath":"__zettel/202304281707-右值引用.md","title":"202304281707","links":[],"tags":["cpp","rvalue","右值"],"content":"右值就是没有确切地址可供访问\n闭包：一个函数携带自身数据，就成为闭包，可以去cppinsight里看看lambda表达式的实现"},"__zettel/202305091937枚举":{"slug":"__zettel/202305091937枚举","filePath":"__zettel/202305091937枚举.md","title":"202305091937","links":[],"tags":["enum","enum_class","cpp"],"content":"C++中有两种枚举，\n\n普通枚举（enum，unscoped enum）\n枚举类（enum class, scoped enum）\n\n通常，花括号里面的名字具有scope的作用域及可见性，但对普通枚举并非如此。普通枚举中定义的枚举常量，在花括号外也可见。而枚举类则需要加上类名+域作用符来获取花括号内的名字。\nenum Color { RED = 1, GREEN, BLUE, };  \nenum class CMYK { C = -1, M = 0, Y = 2, K, };  \nenum NewColor: uint8_t { NR = 0, NG, NB };  \n  \nvoid foo()  \n{  \n    Color c = RED;  \n    CMYK cmyk = CMYK::C;  // Note: scope is need here  \n    NewColor nc = NB;  \n    cout &lt;&lt; sizeof c &lt;&lt; endl;  // 4  \n    cout &lt;&lt; sizeof(cmyk) &lt;&lt; endl;  // 4  \n    cout &lt;&lt; sizeof(NewColor) &lt;&lt; endl;  // 1  \n}\n此外，enum class不允许隐式转换为整数，意味着你需要显式转换，也就是说enum class具有更强的类型。"},"__zettel/202305160951初始化列表":{"slug":"__zettel/202305160951初始化列表","filePath":"__zettel/202305160951初始化列表.md","title":"202305160951","links":[],"tags":["cpp","initializer_list"],"content":"初始化列表是轻量级的对象，用于传参是无需使用引用，可以理解为传int这种参数，无需考虑拷贝开销。此外，初始化列表中传入的视为常量，不允许修改。"},"__zettel/202305161028内存模型":{"slug":"__zettel/202305161028内存模型","filePath":"__zettel/202305161028内存模型.md","title":"202305161028","links":["assets/cache-coherency.excalidraw","__zettel/202304202149volatile-specifier.html","assets/202305161028内存模型-202306291048.excalidraw"],"tags":["cpp","memory-model","memory-order","memory-barrier","内存序"],"content":"为什么需要内存模型\n编译器会优化代码，会在不影响正确结果的前提下，调整代码执行顺序，此外cpu也会乱序执行，提高效率。所以，你的代码跑起来未必是按照你写的顺序执行的。这在单线程环境下毫无问题，一旦进入多线程，这种乱序会带来不可预期的结果。\n因此，我们需要一种方式来（向底层：编译器）控制，告诉，声明我这段代码必须要按顺序执行。内存模型应运而生。\n此外，还有\n\n\n                  \n                  Cache coherency \n                  \n                \n\n现代cpu拥有多级cache，其中cache是有访问权限的。有些cahce中的数据只能被一个核心看到，这在多线程访问数据时就会出现很大的问题。\n\n\n例如：\ncache-coherency.excalidraw\n正常理解，无论线程1，2的执行顺序如何，最后不可能出现打印出0，0的情况。但是在这种情况下，如果各自都从缓存中读数据，那就可能出现0，0的情况。这也进一步引出了volatile关键字volatile wiki link。\nSequential Consistency\n顺序一致性，是一致性最严格的内存模型，他有两条要求：\n\n每个处理器的执行顺序和代码的执行顺序一致\n处理器并行执行的结果要和处理器按照某种顺序执行的结果一致\n\nMemory barrier\n即内存栅栏。为什么需要内存栅栏？\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmemory_order解释memory_order_acquire所有内存操作必须在我这个load之后memory_order_release所有内存操作必须在我这个release之前\n有两个因素会影响执行顺序：\n\n编译器优化，重排\n处理器乱序\n\nARM 和 Alpha 更为松散\n即使 Intel 处理器仍有乱序\n\n\n\n在c++98里，我们没有一种机制能够告诉c++编译器，我们在某个代码块不希望乱序。我们不可能阻止所有乱序，但在多线程同步场合下，我们确实需要保证顺序。\nacquire、release语义\n解决通过单个原子量进行同步的场景。\nacquire指的是，我在这里做了一个原子读操作，我要求在我后面的所有读操作不允许重排到我前面去。\nrelase说的是，我这儿做了个原子写操作，我要求在我前面的写操作不允许重排到我后面去。\n这两个配合使用可以做到两个线程间的同步！假设线程A store an atmoic variable using memory_order_release，线程B load the same atomic variable using memory_order_acquire.\n根据acquire和release的语义，线程A中所有发生在atomic store之前的内存写（包括非原子的和松弛原子【memory_order_relaxed】的），在线程B中将变得可见。也就是说，当线程B atmoic load之后且load到的值确实是线程A写入的那个值，则B能够保证看到everything thread A wrote to memory.\n这个同步仅仅存在于load with acuqire, store with release, on the same atomic variable的任意两个线程之间。其他线程不保证。\nMutual exclusion locks, such as std::mutex or atomic spinlock, are an example of release-acquire synchronization: when the lock is released by thread A and acquired by thread B, everything that took place in the critical section (before the release) in the context of thread A has to be visible to thread B (after the acquire) which is executing the same critical section.\n202305161028内存模型-202306291048.excalidraw\n内存屏障：内核文档"},"__zettel/202305170944callout-user-guide":{"slug":"__zettel/202305170944callout-user-guide","filePath":"__zettel/202305170944callout-user-guide.md","title":"202305170944","links":["__zettel/Internal-link.html"],"tags":["obsidian","callout","user-guide"],"content":"\nThis article comes from obsidian sandbox vault. Command palette → open sandbox vault → Formatting.Callout\n\nAs of v0.14.0, Obsidian supports callout blocks, sometimes called “admonitions”. Callout blocks are written as a blockquote, inspired by the “alert” syntax from Microsoft Docs.\nCallouts are also be supported natively on Obsidian Publish.\n\n\n                  \n                  NOTE\n                  \n                \n\nFor compatibility reasons, if you’re also using the Admonitions plugin, you should update it to at least v8.0.0 to avoid problems with the new callout system.\n\n\nUse the following syntax to denote a callout block: &gt; [!INFO].\n&gt; [!INFO]\n&gt; \n&gt; Here&#039;s a callout block.\n&gt; It supports **markdown** and [[Internal link|wikilinks]].\nIt will show up like this:\n\n\n                  \n                  INFO\n                  \n                \n\nHere’s a callout block.\nIt supports markdown and wikilinks.\n\n\nTypes\nBy default, there are 12 distinct callout types, each with several aliases. Each type comes with a different background color and icon.\nTo use these default styles, replace INFO in the examples with any of these types. Any unrecognized type will default to the “note” type, unless they are customized. The type identifier is case insensitive.\n\nnote\nabstract, summary, tldr\ninfo, todo\ntip, hint, important\nsuccess, check, done\nquestion, help, faq\nwarning, caution, attention\nfailure, fail, missing\ndanger, error\nbug\nexample\nquote, cite\n\nTitle and body\nYou can define the title of the callout block, and you can also have a callout without body content.\n&gt; [!TIP] Callouts can have custom titles, which also supports **markdown**!\n&gt; \nFolding\nAdditionally, you can create a folding callout by adding + (default expanded) or - (default collapsed) after the block.\n&gt; [!FAQ]- Are callouts foldable?\n&gt; \n&gt; Yes! In a foldable callout, the contents are hidden until it is expanded.\nWill show up as:\n\n\n                  \n                  Are callouts foldable? \n                  \n                \n\nYes! In a foldable callout, the contents are hidden until it is expanded.\n\n\nCustomizations\nSnippets and plugins can define custom callouts, too, or overwrite the default options. Callout types and icons are defined in CSS, where the color is an r, g, b tuple and the icon is the icon ID from any internally supported icon (like lucide-info). Alternatively, you can specify an SVG icon as a string.\n.callout[data-callout=&quot;my-callout-type&quot;] {\n    --callout-color: 0, 0, 0;\n    --callout-icon: icon-id;\n    --callout-icon: &#039;&lt;svg&gt;...custom svg...&lt;/svg&gt;&#039;;\n}"},"__zettel/202305171430GOPROXY配置":{"slug":"__zettel/202305171430GOPROXY配置","filePath":"__zettel/202305171430GOPROXY配置.md","title":"202305171430","links":[],"tags":["hw","go","goproxy"],"content":"公司内部由于网络问题，无法安装go module，需要配置公司的镜像goproxy：\nLinux 下：\nexport GO111MODULE=on  \nexport GOPROXY=mirrors.tools.huawei.com/goproxy/  \nexport GONOSUMDB=&quot;*&quot;\nwindows下：\ngo env -w GO111MODULE=on\ngo env -w GOPROXY=mirrors.tools.huawei.com/goproxy/  \ngo env -w GONOSUMDB=*\n参考：3ms.huawei.com/hi/group/3742219/wiki_5822954.html\ncodehub认证问题\n安装来自codehub的依赖时，如果这个依赖又有其他依赖，可能会报如下错误：\ngo: codehub-y.huawei.com/CloudSOP/GoF2@v1.7.16 requires  \ncodehub-y.huawei.com/gopkgs/gorm-zenith-driver@v0.0.8: reading codehub-y.huawei.com/gopkgs/gorm-zenith-driver/go.mod at revision v0.0.8: git ls-remote -q origin in D:\\Go_WorkSpace\\pkg\\mod\\cache\\vcs\\5f1393b29db4fa94e8d88adef5264fe0c0f46f32a82bb90c7bd1d969ec6eb3a9: exit status 128:  \nLogon failed, use ctrl+c to cancel basic credential prompt.  \nLogon failed, use ctrl+c to cancel basic credential prompt.  \nfatal: could not read Username for &#039;codehub-dg-y.huawei.com&#039;: terminal prompts disabled  \nConfirm the import path was entered correctly.  \nIf this is a private repository, see golang.org/doc/faq#git_https for additional information.\n\n解决方法参考：3ms.huawei.com/km/blogs/details/12050719"},"__zettel/202305191500tcpdump抓包":{"slug":"__zettel/202305191500tcpdump抓包","filePath":"__zettel/202305191500tcpdump抓包.md","title":"202305191500","links":[],"tags":["tcpdump","抓包"],"content":"tcpdump -i any port 30002 and host 10.136.242.200 -X  # 接口不限，指定端口和ip，进行抓包\ntcpdump -i any port 27371 and host 125.7.6.51 -w aa.cap  # 将抓包输出写入到aa.cap文件\ntcpdump -i vEth0  # 指定接口为vEth0抓包\n \nfile aa.cap\naa.cap: pcap capture file, microsecond ts (little-endian) - version 2.4 (Ethernet, capture length 262144)"},"__zettel/202305222026mermaid-tutorial":{"slug":"__zettel/202305222026mermaid-tutorial","filePath":"__zettel/202305222026mermaid-tutorial.md","title":"202305222026","links":[],"tags":["mermaid","graph","draw","画图","作图"],"content":"Pie\npie\n    title 今天晚上吃什么？\n    &quot;火锅&quot; : 8\n    &quot;外卖&quot; : 60\n    &quot;自己煮&quot; : 8\n    &quot;海底捞&quot; : 9\n    &quot;海鲜&quot; : 5\n    &quot;烧烤&quot; : 5\n    &quot;不吃&quot; : 5\n\npie\n    title 时间分布\n    &quot;GRE拨测&quot; : 35\n    &quot;NCE需求&quot; : 15\n    &quot;NCE/SPU问题单&quot; : 12\n    &quot;集采LLT支撑&quot; : 10\n    &quot;SA-UI安装/后台组件编译&quot; : 7\n    &quot;NCE/SPU网课学习&quot; : 6\n    &quot;SIG前后台补丁制作/安装&quot; : 5\n    &quot;可信考试&quot; : 5\n    &quot;三营/MINI培训&quot; : 4\n\nFlow chart\ngraph LR  \nA[矩形] -.-&gt;B(圆角矩形) --&gt; C{菱形} ==&gt; D((圆形))   \nE([体育场形])--实线文本--&gt; F[[子程序形]]==粗实线文本==&gt;G[(圆柱形)]-.虚线文本.-&gt;H{{六角形}}  \nI[/平行四边形/]-.-J[\\反向平行四边形\\]---K[/梯形\\]===L[\\反向梯形/]\n\ngraph RL\n\n        User((用户))--1.用户登录--&gt;Login(登录)\n        Login --2.查询--&gt;SERVER[服务器]\n subgraph 查询数据库\n        SERVER--3.查询数据--&gt;DB[(数据库)]\n        DB--4.返回结果--&gt;SERVER\n end\n        SERVER--5.校验数据--&gt;Condition{判断}\n        Condition --&gt;|校验成功| OK[登录成功]\n        Condition --&gt;|校验失败| ERR[登录失败]\n        OK--&gt;SYS[进入系统]\n\n        ERR --&gt;|返回登录页面,重新登录| Login\n\nSequence diagram\nsequenceDiagram\nAlice-&gt;&gt;+John: Hello John, how are you?\nAlice-&gt;&gt;+John: John, can you hear me?\nJohn--&gt;&gt;-Alice: Hi Alice, I can hear you!\nJohn--&gt;&gt;-Alice: I feel great!\n\nsequenceDiagram\n    autonumber\n    participant Z as 张三\n    participant L as 李四\n    participant W as 王五\n\n    Note over Z,W: 张三,李四,王五, 小时候是最好的玩伴,现在80年过去了...\n    Z-&gt;&gt;W: 老王最近还好吗？\n    Note left of Z: 除了老张,当过兵,身体比较好之外,其他两人都不太行了\n    loop 健康检查\n        W-&gt;&gt;W: 与疾病战斗\n    end\n    Note right of W: 合理进食   看医生  打点滴...\n    W--&gt;&gt;Z: 还行,老了走不动了 !!\n    L-&gt;&gt;Z: 老张,你呢怎样了\n    alt 健康#9829;\n    Z--&gt;&gt;L: 很好!\n    else 去世\n    Z--&gt;&gt;L: 对不起,老张已经走了!!!\nend\n\nGantt\ngantt  \n  \ndateFormat YYYY-MM-DD  \ntitle 开发计划  \n  \nsection 需求文档  \n\t登录注册:done,login,2021-06-25,2021-06-28  \n\t添加好友与分组:add, 2021-06-29,3d  \n\t单聊 :active ,chat, 2021-07-01,2d  \n\t群聊 :groupChat,after chat,5d  \n\t朋友圈 :crit,5d  \n\t其他:3d  \nsection 开发  \n\t开发登录注册:done,d-login,2021-06-25,24h  \n\t开发添加好友与分组:active,d-add,after d-login,5d  \n\t开发单聊与群聊:crit,d-chat,after d-add,7d  \n\t开发朋友圈:d-friend,after d-chat,7d  \n\t  \nsection 测试  \n\t测试用例与玩耍:active,test,2021-06-25,10d  \n\t开始测试部分接口:crit,start-test,after test,11d\n\nClass diagram\nclassDiagram  \n  \nclass Serializable{  \n&lt;&lt;interface&gt;&gt;  \n}  \nclass Throwable{  \n&lt;&lt;class&gt;&gt;  \n String detailMessage;  \n Object backtrace;  \n Throwable();  \n}  \n  \nclass Exception{  \n&lt;&lt;class&gt;&gt;  \nException()  \nException(String message)  \n}  \nclass IOException{  \n\t&lt;&lt;class&gt;&gt;  \n}  \n  \nclass SocketException{  \n\t  \n}  \n  \nclass RuntimeException{  \n&lt;&lt;class&gt;&gt;  \n}  \n  \nclass IndexOutOfBoundsException{  \n\t  \n}  \n  \nclass ArithmeticException{  \n\t  \n}  \n  \nSerializable &lt;|.. Throwable:序列化接口  \nThrowable *--Exception  \nException &lt;-- RuntimeException:运行时异常  \nException &lt;-- IOException:io流相关异常  \nIOException o-- SocketException  \nRuntimeException o-- IndexOutOfBoundsException  \nRuntimeException o-- ArithmeticException\n\nState diagram\nstateDiagram-v2  \n  \n    [*] --&gt; 静止  \n    静止 --&gt; [*]  \n    静止 --&gt; 走  \n    走 --&gt; 静止  \n    走 --&gt; 跑  \n    跑 --&gt; 走:跑可以停下来就静止，也可以慢下来：走  \n    跑 --&gt; [*]  \n  \n  \n    state if_state &lt;&lt;choice&gt;&gt;  \n    [*] --&gt; IsPositive  \n    IsPositive --&gt; if_state  \n    if_state --&gt; False: if n &lt; 0  \n    if_state --&gt; True : if n &gt;= 0  \n  \n  \n    state fork_state &lt;&lt;fork&gt;&gt;  \n      [*] --&gt; fork_state  \n      fork_state --&gt; State2  \n      fork_state --&gt; State3  \n  \n      state join_state &lt;&lt;join&gt;&gt;  \n      State2 --&gt; join_state  \n      State3 --&gt; join_state  \n      join_state --&gt; State4  \n      State4 --&gt; [*]  \n  \n    [*] --&gt; First  \n    First --&gt; Second  \n    First --&gt; Third  \n  \n    state First {  \n        [*] --&gt; fir  \n        fir --&gt; [*]  \n    }  \n    state Second {  \n        [*] --&gt; sec  \n        sec --&gt; [*]  \n    }  \n    state Third {  \n        [*] --&gt; thi  \n        thi --&gt; [*]  \n    }\n\nclassDiagram\n\nclass RefCounted {\n    &lt;&lt;interface&gt;&gt;\n}\n\nclass IOManager {\n    &lt;&lt;interface&gt;&gt;\n    +SetWorkersProxy(IOManager*)\n    +Shutdown()\n    +RegisterMessage(uint8_t, uint16_t, uint16_t)\n    +AsyncPublish(MDLMessage*)\n    +SyncPublish(MDLMessage*)\n    +AsyncResponse(Publisher*, RefCounted*, MDLMessage*)\n    +AsyncRebuildResponse(Publisher*, RefCounted*, MDLMessage*)\n    +CreateAutoSubscriber(MessageHandlerBase*, bool)\n}\n\nclass ASIOThread {\n    #OnAccept(ASIOListenerPtr, ASIOSocketPtr)\n    #OnConnect(ASIOSocketPtr, error_code)\n    #OnOpen(ASIOSocketPtr) \n    #OnClose(ASIOSocketPtr, error_code)\n    #OnRead(ASIOSocketPtr)\n    #OnWritten(ASIOSocketPtr)\n    #OnTimer()\n    #OnThreadInitialize(char*)\n}\n\nclass IOManagerImpl {\n    -m_ClientSockets: vector~SubscriberImplPtr~\n    -m_Publishers: map~int,PublisherImplBasePtr~\n    -work_threads_: vector~_WorkThreadItem*~\n    -thread_pool_: shared_ptr~thread_pool~\n    +Open(bool, int, int)\n    +Close()\n    +Post(int, RefCountedPtr)\n    +RegisterSubscriber(SubscriberImplPtr)\n    +UnRegisterSubscriber(SubscriberImplPtr)\n    +SetRequestHandler(RequestHandler*)\n    +GetCodecManager()\n    +GetSubscriberIOStat()\n    +GetPublisherIOStat()\n}\n\nRefCounted &lt;|-- IOManager\nIOManager &lt;|-- IOManagerImpl\nASIOThread &lt;|-- IOManagerImpl\n\nReferences\n\nMermaid doc\nrstyro.github.io/blog/2021/06/28/Markdown%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%AF%AD%E6%B3%95%E7%A4%BA%E4%BE%8B/\nwww.drawio.com/blog/mermaid-diagrams\n"},"__zettel/202305271514sudo安全问题":{"slug":"__zettel/202305271514sudo安全问题","filePath":"__zettel/202305271514sudo安全问题.md","title":"202305271514","links":[],"tags":["hw","sudo","安全"],"content":"sudo安全排查涉及的两个要求：\n\n脚本文件不允许被修改\n文件只能被属主用户执行\n脚本的输入参数需要校验，否则容易被用户拼接注入攻击 ⇒ 可以硬编码写死的直接在脚本里写死，否则一定做校验\n\n高权限用户执行低权限用户的脚本，对于低权限用户来说，就是越权。而这往往难以排查，因为脚本里可能调另一个脚本，或者调其他可执行文件（例如python）而他们的权限"},"__zettel/202305310919GO语言基础":{"slug":"__zettel/202305310919GO语言基础","filePath":"__zettel/202305310919GO语言基础.md","title":"202305310919","links":[],"tags":["go"],"content":"m := map[string]int {&quot;a&quot;:1, &quot;b&quot;:2}\n其实是make的语法糖，它等价于\nvar m map[string]int = make(map[string]int, 2)\nm = {&quot;a&quot;:1, &quot;b&quot;:2}\n内建函数 make 用来为 slice，map 或 chan 类型分配内存和初始化一个对象(注意：只能用在这三种类型上)，跟 new 类似，第一个参数也是一个类型而不是一个值，跟 new 不同的是，make 返回类型的引用而不是指针，而返回值也依赖于具体传入的类型。\n\nmake 的作用是初始化内置的数据结构，也就是我们在前面提到的切片、哈希表和 Channel\nnew 的作用是根据传入的类型分配一片内存空间并返回指向这片内存空间的指针\n\nChannel\nfunc f1(c chan int, x int) // 无向channel\nfunc f2(c chan&lt;- int, x int)  // 只写channel，函数内只能向channel写数据，不能读，send-only channel\nfunc f3(c &lt;-chan int, x int)  // 只读channel，receive-only channel\nUnbuffered channel\n一个基于无缓存Channels的发送操作将导致发送者goroutine阻塞，直到另一个goroutine在相同的Channels上执行接收操作，当发送的值通过Channels成功传输之后，两个goroutine可以继续执行后面的语句。反之，如果接收操作先发生，那么接收者goroutine也将阻塞，直到有另一个goroutine在相同的Channels上执行发送操作。\nGoroutine\n\n\n                  \n                  Hint\n                  \n                \n\nmain函数也是一个goroutine，称之为主goroutine.\n\n\n不管一个channel是否被关闭，当它没有被引用时将会被Go语言的垃圾自动回收器回收。（不要将关闭一个打开文件的操作和关闭一个channel操作混淆。对于每个打开的文件，都需要在不使用的时候调用对应的Close方法来关闭文件。）\nselect\nC 语言的 select 系统调用可以同时监听多个文件描述符的可读或者可写的状态，Go 语言中的 select 也能够让 Goroutine 同时等待多个 Channel 可读或者可写，在多个文件或者 Channel状态改变之前，select 会一直阻塞当前线程或者 Goroutine。\nselect 是与 switch 相似的控制结构，与 switch 不同的是，select 中虽然也有多个 case，但是这些 case 中的表达式必须都是 Channel 的收发操作。\n在通常情况下，select 语句会阻塞当前 Goroutine 并等待多个 Channel 中的一个达到可以收发的状态。但是如果 select 控制结构中包含 default 语句，那么这个 select 语句在执行时会遇到以下两种情况：\n\n当存在可以收发的 Channel 时，直接处理该 Channel 对应的 case；\n当不存在可以收发的 Channel 时，执行 default 中的语句；\n\n\n\n                  \n                  runtime.LockOSThread 的意义 \n                  \n                \n\nWith the Go threading model, calls to C code, assembler code, or blocking system calls occur in the same thread as the calling Go code, which is managed by the Go runtime scheduler.\nThe os.LockOSThread() mechanism is mostly useful when Go has to interface with some foreign library (a C library for instance). It guarantees that several successive calls to this library will be done in the same thread.\nThis is interesting in several situations:\n\na number of graphic libraries (OS X Cocoa, OpenGL, SDL, …) require all the calls to be done on a specific thread (or the main thread in some cases).\nsome foreign libraries are based on thread local storage (TLS) facilities. They store some context in a data structure attached to the thread. Or some functions of the API provide results whose memory lifecycle is attached to the thread. This concept is used in both Windows and Unix-like systems. A typical example is the errno global variable commonly used in C libraries to store error codes. On systems supporting multi-threading, errno is generally defined as a thread-local variable.\nmore generally, some foreign libraries may use a thread identifier to index/manage internal resources.\n\n\n"},"__zettel/202306062013SSL-vs-TLS":{"slug":"__zettel/202306062013SSL-vs-TLS","filePath":"__zettel/202306062013SSL-vs-TLS.md","title":"202306062013","links":[],"tags":["ssl","tls","terminology","term","术语"],"content":"SSL (Secure Sockets Layer) 【安全套接字层】和 TLS (Transport Layer Security) 【传输层安全】都是通信协议，用于加密服务器、应用程序、用户和系统之间的数据。这两种协议都会对通过网络连接的双方进行身份验证，以便他们能安全交换数据。\nTaher Elgamal 领导了 SSL 的开发，并于 1995 年公开发布了 SSL 2.0。SSL 旨在确保万维网上的通信安全。在 SSL 经历多次迭代后，Tim Dierks 和 Christopher Allen 于 1999 年创建了 TLS 1.0，作为 SSL 3.0 的后继者。 \n术语\nTLS 是 SSL 的直接后继者，所有版本的 SSL 目前均已弃用。但是，使用术语 SSL 来描述 TLS 连接的情况很常见。在大多数情况下，术语 SSL 和 SSL/TLS 都是指 TLS 协议和 TLS 证书。\n用途\nTLS 是一种支持加密和身份验证的安全通信协议，SSL 在被弃用之前也是如此。TLS 和 SSL 都使用数字证书来简化握手过程并在浏览器和 Web 服务器之间建立加密通信。\nHTTPS 中的用法\nHTTP 是一种协议或一组通信规则，用于通过任何网络进行客户端-服务器通信。HTTPS 是在不安全的 HTTP 连接上建立安全 SSL/TLS 协议的做法。\n在与网站连接之前，您的浏览器会使用 TLS 来检查网站的 TLS 或 SSL 证书。TLS 和 SSL 证书表明服务器符合当前的安全标准。您可以在浏览器地址栏中找到有关证书的证据。真实且加密的连接将显示 https://，而不是 http://。附加的 s 代表 secure（安全）。\nRefrences\n\nSSL 与 TLS 之间有何区别？\n"},"__zettel/202306071056对称加密和非对称加密":{"slug":"__zettel/202306071056对称加密和非对称加密","filePath":"__zettel/202306071056对称加密和非对称加密.md","title":"202306071056","links":["assets/对称加密-202306071102.excalidraw"],"tags":["加密","安全","密钥"],"content":"明文通信的弊端\n\n冒充\n窃听\n篡改\n\nflowchart LR\n    id1(A)-- 我是A今晚7点小树林见 --&gt;id2(B)\n    style id1 fill:#f9f,stroke:#333,stroke-width:4px\n    style id2 fill:#bbf,stroke:#f66,stroke-width:2px,color:#fff,stroke-dasharray: 5 5\n\n冒充：\nflowchart LR\n    id3(C)-- 我是A今晚7点小树林见 --&gt;id2(B)\n    style id3 fill:#49a,stroke:#333,stroke-width:4px\n    style id2 fill:#bbf,stroke:#f66,stroke-width:2px,color:#fff,stroke-dasharray: 5 5\n\n窃听：\nflowchart LR\n    TXT(我是A今晚7点小树林见)\n    id1(A) --- TXT --&gt;id2(B)\n    TXT --窃听--&gt; id3(C)\n    style id1 fill:#f9f,stroke:#333,stroke-width:4px\n    style id2 fill:#bbf,stroke:#f66,stroke-width:2px,color:#fff,stroke-dasharray: 5 5\n    style id3 fill:#49a,stroke:#333,stroke-width:4px\n    style TXT stroke-width:0\n\n篡改：\nflowchart LR\n    TXT(我是A今晚7点小树林见)\n    id1(A) --- TXT --&gt; id2(B)\n    id3 --我是A今晚9点点小湖边见--&gt; TXT\n    TXT --截获--&gt; id3(C)\n\n    style id1 fill:#f9f,stroke:#333,stroke-width:4px\n    style id2 fill:#bbf,stroke:#f66,stroke-width:2px,color:#fff,stroke-dasharray: 5 5\n    style id3 fill:#49a,stroke:#333,stroke-width:4px\n    style TXT stroke-width:0\n\n\n\n对称密钥：指通信的双方使用同一个密钥进行加解密。\n非对称密钥：成对出现，一个称为公钥，可对外公开。一个称为私钥，仅自己持有。\n\n对称加密\n对称加密-202306071102.excalidraw\n常见对称加密算法：\n\nDES\nAES\n\n消息认证码的通信机制：\n非对称加密\n密钥交换/协商\n这个过程是很重要的，尤其是对与对称加密算法而言。对称加密要想work，必须使得通信的双方具备同一个密钥，且不能被第三方知晓。要做到这一点，有两条路子：\n\n提前（可能是很久之前，具备预见性）在通信的双方使用安全的方法部署好同一个密钥，供后续通信使用；\n通信前使用安全的方法确定密钥（密钥交换/协商）。\n\n第一种方式显然不太科学，缺乏灵活性和预见性。第二种方式有个依赖：如何才能安全地交换密钥信息呢？\n基于加密通道传输密钥\n这种就是使用非对称加密算法，发送方使用接收方公钥加密密钥（这是用于后续通信的密钥），然后直接发给接收方，接收方使用私钥解密，这样双方都有了同一个密钥。\n基于通信双方共享的密钥\n比如PSK算法，双方预先部署若干个共享的密钥，通过密钥编号（明文传输）协商使用哪个密钥。这是一种比较朴素的加密通信，相当少双方持有同一个密码本，然后发送“密文”（密钥编号），双方查询密码本确定明文（后续通信要用的密钥）。其实密钥编号可被中间人获取，但他不知道编号的意义。\nsee also DH 算法。\n\nwww.peterjxl.com/JavaSE/encrypt-dh/\nblog.51cto.com/u_13291771/2798365\n\n\n\n"},"__zettel/202306081412GRE拨测切CPP方案":{"slug":"__zettel/202306081412GRE拨测切CPP方案","filePath":"__zettel/202306081412GRE拨测切CPP方案.md","title":"202306081412","links":[],"tags":["hw","work","gre"],"content":"\nbackToServiceQueue: 有无并发读写；读与读之间；写于写之间，读写之间；放的数据格式\n最后需要考虑：\nostoolcli -module legacy -action exec -type script -contents ”{“appName”: “PacketForwardAgent”,“scriptName”: “bootstrap.sh”,“params”: [“gre_dialing”,“start”]}” &gt; {_APP_LOG_DIR}/startOrStopLog.tmp;cat {_APP_LOG_DIR}/startOrStopLog.tmp &gt;&gt; {_APP_LOG_DIR}/gredialingagent/startOrStopLog.sh.log;cat {_APP_LOG_DIR}/startOrStopLog.tmp |python -c “import sys,json;print(json.load(sys.stdin)[0].get(“returnCode”))“;rm -f ${_APP_LOG_DIR}/startOrStopLog.tmp)\n当前go进程是提权拉起，考虑下是否能用普通权限\n要点：\n\n发包不（特别）在意延时\n收包很在意延时，因为收包要打上尽量准确的收包时间戳，如此才能统计准确的用时\n\n因此，这里收到回包之后，直接放池子里，打上准确时间戳。然后起两个协程向处理回包，向java进程上报。\n条件变量常用来解决线程相互唤醒的问题（适用与生产者-消费者模型），使用条件变量需要注意一些点：\n\nisocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconc-wait\n\n配置文件监控\n\nReading and writing from/to a file at the same time is a bad idea.\n\n一个进程读，一个进程写是会有问题的。因此，要保证java进程写完之后再去读。原方法是用一个循环（with sleep）不断调用 os.Stat 方法获取文件的 modtime，据此决定要不要重新读取配置文件。\n参考链接：meik2333.com/posts/linux-many-proc-write-file/\ncpp中可以使用 stat (2) 系统调用来获取文件元数据，包括最后修改时间。参考链接：blog.csdn.net/weixin_38239856/article/details/77543055\n\n\n                  \n                  Note\n                  \n                \n\n事实上，java进程写过一遍配置之后，不会再更改。因此只有go进程读到写入的那份配置即可。后续更改无需关心。\n\n\n其他方案参考：\n\nbbs.chinaunix.net/archiver/tid-1248308.html\natomic_queue: github.com/max0x7ba/atomic_queue\n\n无锁队列实现参考：\n\ngithub.com/facebook/folly/blob/main/folly/ProducerConsumerQueue.h\ngithub.com/facebook/folly/blob/main/folly/AtomicHashMap.h\nmoodycamel.com/blog/2013/a-fast-lock-free-queue-for-c++.htm\ngithub.com/max0x7ba/atomic_queue/\n\n发包过程\n\n建立tls连接，此处参考dpdkko部分建链的方式：大致是机器上存着密文，使用sdk提供的方法解出明文，在进行tls连接\n接收拨测任务的消息\n构造拨测报文 → 写入发包队列\n发包线程读取发包队列，执行发包操作\n\n收包过程\n\n收包线程读取回包 → 写入收包队列\n主线程读取收包队列进行处理\n\n可选三方库\n\nasio (stand alone, header only)\nfmt: A modern formatting library，c++格式化输出\n\n主线程的职责：\n\n创建发包/收包线程\n与java进程建链（是否可以交给发包线程），建链之后是否保持连接，还是下次再建？\n给java进程回包\n\n发包进程的职责：\n\n频繁/单次向java进程建立连接？\n\nTypicality\ncf. www.cnblogs.com/MaxLij/p/14584187.html\n/// server.cpp\n \n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;arpa/inet.h&gt;\n#include &lt;sys/socket.h&gt;\n#include &lt;netinet/in.h&gt;\n \nint main(){\n    //创建套接字\n    int serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n  \t// AF_INET :   表示使用 IPv4 地址\t\t可选参数\n    // SOCK_STREAM 表示使用面向连接的数据传输方式，\n    // IPPROTO_TCP 表示使用 TCP 协议\n \n    //将套接字和IP、端口绑定\n    struct sockaddr_in serv_addr;\n    memset(&amp;serv_addr, 0, sizeof(serv_addr));  //每个字节都用0填充\n    serv_addr.sin_family = AF_INET;  //使用IPv4地址\n    serv_addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);  //具体的IP地址\n    serv_addr.sin_port = htons(1234);  //端口\n    bind(serv_sock, (struct sockaddr*)&amp;serv_addr, sizeof(serv_addr));\n \n    //进入监听状态，等待用户发起请求\n    listen(serv_sock, 20);\n \n    //接收客户端请求\n    struct sockaddr_in clnt_addr;\n    socklen_t clnt_addr_size = sizeof(clnt_addr);\n    int clnt_sock = accept(serv_sock, (struct sockaddr*)&amp;clnt_addr, &amp;clnt_addr_size);  // block until connected\n \n    //向客户端发送数据\n    char str[] = &quot;Hello World!&quot;;\n    write(clnt_sock, str, sizeof(str));\n   \n    //关闭套接字\n    close(clnt_sock);\n    close(serv_sock);\n \n    return 0;\n}\n/// client.cpp\n \n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;arpa/inet.h&gt;\n#include &lt;sys/socket.h&gt;\n \nint main(){\n    //创建套接字\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n \n    //向服务器（特定的IP和端口）发起请求\n    struct sockaddr_in serv_addr;\n    memset(&amp;serv_addr, 0, sizeof(serv_addr));  //每个字节都用0填充\n    serv_addr.sin_family = AF_INET;  //使用IPv4地址\n    serv_addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);  //具体的IP地址\n    serv_addr.sin_port = htons(1234);  //端口\n    connect(sock, (struct sockaddr*)&amp;serv_addr, sizeof(serv_addr));\n   \n    //读取服务器传回的数据\n    char buffer[40];\n    read(sock, buffer, sizeof(buffer)-1);\n   \n    printf(&quot;Message form server: %s\\n&quot;, buffer);\n   \n    //关闭套接字\n    close(sock);\n \n    return 0;\n}\nusing asio;\n//\n// client.cpp\n// ~~~~~~~~~~\n//\n// Copyright (c) 2003-2023 Christopher M. Kohlhoff (chris at kohlhoff dot com)\n//\n// Distributed under the Boost Software License, Version 1.0. (See accompanying\n// file LICENSE_1_0.txt or copy at www.boost.org/LICENSE_1_0.txt)\n//\n \n#include &lt;iostream&gt;\n#include &lt;boost/array.hpp&gt;\n#include &lt;asio.hpp&gt;\n \nusing asio::ip::tcp;\n \nint main(int argc, char* argv[])\n{\n  try\n  {\n    if (argc != 2)\n    {\n      std::cerr &lt;&lt; &quot;Usage: client &lt;host&gt;&quot; &lt;&lt; std::endl;\n      return 1;\n    }\n    asio::io_context io_context;\n \n    tcp::resolver resolver(io_context);\n    tcp::resolver::results_type endpoints =\n      resolver.resolve(argv[1], &quot;daytime&quot;);\n \n    tcp::socket socket(io_context);\n    asio::connect(socket, endpoints);\n \n    for (;;)\n    {\n      boost::array&lt;char, 128&gt; buf;\n      asio::error_code error;\n      size_t len = socket.read_some(asio::buffer(buf), error);\n \n      if (error == asio::error::eof)\n        break; // Connection closed cleanly by peer.\n      else if (error)\n        throw asio::system_error(error); // Some other error.\n \n      std::cout.write(buf.data(), len);\n    }\n  }\n  catch (std::exception&amp; e)\n  {\n    std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;\n  }\n  return 0;\n}\n//\n// server.cpp\n// ~~~~~~~~~~\n//\n// Copyright (c) 2003-2023 Christopher M. Kohlhoff (chris at kohlhoff dot com)\n//\n// Distributed under the Boost Software License, Version 1.0. (See accompanying\n// file LICENSE_1_0.txt or copy at www.boost.org/LICENSE_1_0.txt)\n//\n \n#include &lt;ctime&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;asio.hpp&gt;\n \nusing asio::ip::tcp;\n \nstd::string make_daytime_string()\n{\n  using namespace std; // For time_t, time and ctime;\n  time_t now = time(0);\n  return ctime(&amp;now);\n}\n \nint main()\n{\n  try\n  {\n    asio::io_context io_context;\n    tcp::acceptor acceptor(io_context, tcp::endpoint(tcp::v4(), 13));\n    for (;;)\n    {\n      tcp::socket socket(io_context);\n      acceptor.accept(socket);\n      std::string message = make_daytime_string();\n      asio::error_code ignored_error;\n      asio::write(socket, asio::buffer(message), ignored_error);\n    }\n  }\n  catch (std::exception&amp; e)\n  {\n    std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;\n  }\n  return 0;\n}\n工作量输出\n\n讲一下为什么从golang切成c++，问题的背景（golang使用了很多不合规的三方件）\n分析了梳理了拨测业务的流程，了解了拨测业务的背景\n设计了c++拨测的流程，业务框架\n开发实现中，自研了日志模块、通信队列，避免引入了spdlog、concurrentqueue两个三方件\n\n这样，这个工作才显丰满。"},"__zettel/202306262103cmake-template":{"slug":"__zettel/202306262103cmake-template","filePath":"__zettel/202306262103cmake-template.md","title":"202306262103","links":["__zettel/202304230920-cmake-learn.html"],"tags":["cmake"],"content":"cmake_minimum_required(VERSION 3.20)\nproject(GREDialing VERSION 0.1)\n \nmessage(STATUS &quot;CMake version: &quot; ${CMAKE_VERSION})\nif(NOT ${CMAKE_VERSION} VERSION_LESS &quot;3.2&quot;)\n    set(CMAKE_CXX_STANDARD 17)\n    set(CMAKE_CXX_STANDARD_REQUIRED ON)\nelse()\n    message(STATUS &quot;Checking compiler flags for C++11 support.&quot;)\n    # Set C++11 support flags for various compilers\n    include(CheckCXXCompilerFlag)\n    check_cxx_compiler_flag(&quot;-std=c++11&quot; COMPILER_SUPPORTS_CXX11)\n    check_cxx_compiler_flag(&quot;-std=c++0x&quot; COMPILER_SUPPORTS_CXX0X)\n    if(COMPILER_SUPPORTS_CXX11)\n        message(STATUS &quot;C++11 is supported.&quot;)\n        if(${CMAKE_SYSTEM_NAME} MATCHES &quot;Darwin&quot;)\n            set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -std=c++11 -stdlib=libc++&quot;)\n        else()\n            set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -std=c++11&quot;)\n        endif()\n    elseif(COMPILER_SUPPORTS_CXX0X)\n        message(STATUS &quot;C++0x is supported.&quot;)\n        if(${CMAKE_SYSTEM_NAME} MATCHES &quot;Darwin&quot;)\n            set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -std=c++0x -stdlib=libc++&quot;)\n        else()\n            set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -std=c++0x&quot;)\n        endif()\n    else()\n        message(STATUS &quot;The compiler ${CMAKE_CXX_COMPILER} has no C++11 support. Please use a different C++ compiler.&quot;)\n    endif()\nendif()\n \n \n \n# 禁止 C++ assert terminate 程序\n# add_definitions(-DNDEBUG)\n \n# ASIO 不使用 Boost 库\n#add_definitions(-DASIO_STANDALONE)\n \n# Spdlog 使用外部 Fmt 库\n#add_definitions(-DSPDLOG_FMT_EXTERNAL)\n \n# Jwt-cpp 使用外部 Json 库\n# ADD_DEFINITIONS(-DJWT_CPP_JSON_EXTERNAL)\n \n# add_definitions(-DGLOG_ON)\n \n# 生成编译命令文件，给 YCM/Clangd 使用\nset(CMAKE_EXPORT_COMPILE_COMMANDS ON)\n \nADD_COMPILE_OPTIONS(-g)\n \n#设置输出目录\n# set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)\n# set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)\n# set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${PROJECT_SOURCE_DIR}/bin)\n \n \n#加入包含目录\n# include_directories(${CMAKE_CURRENT_SOURCE_DIR}/service/src/main/cpp/decryptSDK/include) \ninclude_directories(decryptSDK/include) \ninclude_directories(/home/hubingbing/rapidjson/include)\ninclude_directories(/home/hubingbing/concurrentqueue)\n# include_directories(/opt/Euler_compile_env/usr/src/kernels/4.19.90-vhulk2107.1.0.h699.eulerosv2r10.aarch64/include)\n \n \n#静态库目录\n#link_directories(/usr/lib64/mysql)\n \n#logger lib \n#add_subdirectory(decryptSDK)\n \n \n# aux_source_directory(decryptSDK SRCS) #加入目录下所有源码\n# add_executable(demo ${SRCS}) #生成可执行文件\n# target_link_libraries(demo logger)  #链接logger库\n \nset(EXECUTABLE_OUTPUT_PATH &quot;${CMAKE_CURRENT_SOURCE_DIR}/build&quot;)\nmessage(STATUS &quot;binary dir is ${EXECUTABLE_OUTPUT_PATH}&quot;)\n \nset(BUILD_SCRATCH_TARGET 0)\n \nif(BUILD_SCRATCH_TARGET)\n    file(GLOB_RECURSE scratch_srcs scratch/*.cpp)\n    # message(STATUS &quot;all scratchs: ${scratch_srcs}&quot;)\n    foreach(srcfile IN LISTS scratch_srcs)\n        # Get file name without directory\n        get_filename_component(elfname ${srcfile} NAME_WE)\n        message(STATUS &quot;${elfname} .. ${srcfile}&quot;)\n        add_executable(${elfname} ${srcfile})\n        target_link_libraries(${elfname} pthread)\n    endforeach()\nendif()\n \n \n# add_executable(main ../main.cpp)\n# add_executable(server udp_server.cpp) \n# add_executable(ConfigReader ConfigReader.cpp) \n# add_executable(packet_handler packet_handler.cpp)\n \nset(BUILD_MAIN_TARGET 1)\n \nif(BUILD_MAIN_TARGET)\n    set(target main)\n \n    set(src_lst main.cpp ConfigReader.cpp packet_handler.cpp SslClient.cpp packet.cpp)\n    add_executable(${target} ${src_lst})\n \n    aux_source_directory(decryptSDK KMC_DIR)\n    target_sources(${target} PRIVATE ${KMC_DIR})\n    target_include_directories(${target} PRIVATE /home/hubingbing/cloud-frame-kmc/include/)\n    target_link_directories(${target} PRIVATE /home/hubingbing/cloud-frame-kmc/lib_so/)\n    target_link_libraries(${target} kmcjni)\n \n    target_link_libraries(${target} ssl crypto pthread)\nendif()\n# target_link_libraries(debug pthread)\n# target_link_libraries(server pthread)\nnew:\ncmake_minimum_required(VERSION 3.20)\nproject(GREDialing VERSION 0.1)\n \nmessage(STATUS &quot;CMake version: &quot; ${CMAKE_VERSION})\nif(NOT ${CMAKE_VERSION} VERSION_LESS &quot;3.2&quot;)\n    set(CMAKE_CXX_STANDARD 17)\n    set(CMAKE_CXX_STANDARD_REQUIRED ON)\nelse()\n    message(STATUS &quot;Checking compiler flags for C++11 support.&quot;)\n    # Set C++11 support flags for various compilers\n    include(CheckCXXCompilerFlag)\n    check_cxx_compiler_flag(&quot;-std=c++11&quot; COMPILER_SUPPORTS_CXX11)\n    check_cxx_compiler_flag(&quot;-std=c++0x&quot; COMPILER_SUPPORTS_CXX0X)\n    if(COMPILER_SUPPORTS_CXX11)\n        message(STATUS &quot;C++11 is supported.&quot;)\n        if(${CMAKE_SYSTEM_NAME} MATCHES &quot;Darwin&quot;)\n            set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -std=c++11 -stdlib=libc++&quot;)\n        else()\n            set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -std=c++11&quot;)\n        endif()\n    elseif(COMPILER_SUPPORTS_CXX0X)\n        message(STATUS &quot;C++0x is supported.&quot;)\n        if(${CMAKE_SYSTEM_NAME} MATCHES &quot;Darwin&quot;)\n            set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -std=c++0x -stdlib=libc++&quot;)\n        else()\n            set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -std=c++0x&quot;)\n        endif()\n    else()\n        message(STATUS &quot;The compiler ${CMAKE_CXX_COMPILER} has no C++11 support. Please use a different C++ compiler.&quot;)\n    endif()\nendif()\n \n \n \n# 禁止 C++ assert terminate 程序\n# add_definitions(-DNDEBUG)\n \n# ASIO 不使用 Boost 库\n#add_definitions(-DASIO_STANDALONE)\n \n# Spdlog 使用外部 Fmt 库\n#add_definitions(-DSPDLOG_FMT_EXTERNAL)\n \n# Jwt-cpp 使用外部 Json 库\n# ADD_DEFINITIONS(-DJWT_CPP_JSON_EXTERNAL)\n \n# add_definitions(-DGLOG_ON)\n \n# 生成编译命令文件，给 YCM/Clangd 使用\nset(CMAKE_EXPORT_COMPILE_COMMANDS ON)\n \nADD_COMPILE_OPTIONS(-g)\n \n#设置输出目录\n# set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)\n# set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)\n# set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${PROJECT_SOURCE_DIR}/bin)\n \n \n#加入包含目录\n# include_directories(${CMAKE_CURRENT_SOURCE_DIR}/service/src/main/cpp/decryptSDK/include) \n# include_directories(decryptSDK/include)\n# include_directories(/home/hubingbing/concurrentqueue)\ninclude_directories(json/include)  # for baize json\n \n \n#静态库目录\n#link_directories(/usr/lib64/mysql)\n \n#logger lib \n#add_subdirectory(decryptSDK)\n# add_subdirectory(json)\n \naux_source_directory(json/src BAIZE_JSON_SRC)\n# aux_source_directory(decryptSDK SRCS) #加入目录下所有源码\n# add_executable(demo ${SRCS}) #生成可执行文件\n# target_link_libraries(demo logger)  #链接logger库\n \nset(EXECUTABLE_OUTPUT_PATH &quot;${CMAKE_CURRENT_SOURCE_DIR}/build&quot;)\nmessage(STATUS &quot;binary dir is ${EXECUTABLE_OUTPUT_PATH}&quot;)\n \nset(BUILD_SCRATCH_TARGET 1)\nif(BUILD_SCRATCH_TARGET)\n    file(GLOB_RECURSE scratch_srcs scratch/*.cpp)\n    # message(STATUS &quot;all scratchs: ${scratch_srcs}&quot;)\n    foreach(srcfile IN LISTS scratch_srcs)\n        # Get file name without directory\n        get_filename_component(elfname ${srcfile} NAME_WE)\n        message(STATUS &quot;${elfname} .. ${srcfile}&quot;)\n        if (${elfname} STREQUAL &quot;test_logger&quot;)\n            add_executable(${elfname} ${srcfile} SimpleLogger.cpp)\n        elseif(${elfname} STREQUAL &quot;cqueue_test&quot;)\n            add_executable(${elfname} ${srcfile} helper.cpp SimpleLogger.cpp packet_handler.cpp ConfigReader.cpp packet.cpp ${BAIZE_JSON_SRC})\n            target_link_libraries(${elfname} securec)\n        elseif(${elfname} STREQUAL &quot;baizejson&quot;)\n            add_executable(${elfname} ${srcfile} ${BAIZE_JSON_SRC})\n            target_link_libraries(${elfname} securec)\n        else()\n            add_executable(${elfname} ${srcfile})\n        endif()\n        target_link_libraries(${elfname} pthread)\n    endforeach()\nendif()\n \n \n# add_executable(main ../main.cpp)\n# add_executable(server udp_server.cpp) \n# add_executable(ConfigReader ConfigReader.cpp) \n# add_executable(packet_handler packet_handler.cpp)\n \nset(LIBKMC_PATH decryptSDK)\nset(KMC_LINK_OPTION &quot;STATIC&quot;)\nset(BUILD_MAIN_TARGET 1)\nif(BUILD_MAIN_TARGET)\n    set(target gredialingagent)  # 可执行文件名\n    if(${CMAKE_BUILD_TYPE} MATCHES &quot;RELEASE&quot;)\n        message(STATUS &quot;build with release, add compile options to remove debug info...&quot;)\n        # 安全编译选项：3ms.huawei.com/hi/group/2028271/wiki_6704184.html\n        set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -fstack-protector-strong -Wl,-z,relro,-z,now,-z,noexecstack -s -fPIE -pie&quot;)\n    endif()\n    set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} \\\n        -Wall -Wextra -Weffc++ -Wconversion -Wsign-conversion \\\n        -Wtrampolines -Wdate-time -Wfloat-equal -Wswitch-default \\\n        -Wshadow -Wno-return-local-addr -Wcast-qual -Wcast-align -Wvla -Wunused \\\n        -Wundef -Wnon-virtual-dtor -Woverloaded-virtual -pedantic-errors -Wsizeof-array-argument \\\n    &quot;)\n    # message(STATUS &quot;compile options are ${CMAKE_CXX_FLAGS}&quot;)\n \n    aux_source_directory(./ src_lst)\n    # message(STATUS &quot;source list of ${target}: ${src_lst}&quot;)\n    add_executable(${target} ${src_lst})\n    target_sources(${target} PRIVATE ${BAIZE_JSON_SRC})\n \n \n    if(${KMC_LINK_OPTION} STREQUAL &quot;STATIC&quot;)\n        add_subdirectory(decryptSDK)  # 编译kmc静态库\n        target_link_directories(${target} PRIVATE ${LIBKMC_PATH}/lib/)\n        # target_link_libraries(${target} decrypt libkmcext.a libkmc.a libsecurec.a libsdp.a libssl.a libcrypto.a dl)\n        target_link_libraries(${target} decrypt kmcext kmc securec sdp ssl crypto dl)\n    else()\n        aux_source_directory(decryptSDK KMC_DIR)\n        target_sources(${target} PRIVATE ${KMC_DIR})\n        target_include_directories(${target} PRIVATE ${LIBKMC_PATH}/include/)\n        target_link_directories(${target} PRIVATE /home/hubingbing/cloud-frame-kmc/lib_so/)\n        target_link_libraries(${target} kmcjni)\n    endif()\n \n    # find_library(KMC_STATIC_LIB kmc sdp /home/hubingbing/cloud-frame-kmc/lib_a/)\n    # message(STATUS &quot;finded lib: ${KMC_STATIC_LIB}&quot;)\n \n    target_link_libraries(${target} pthread)\nendif()\n# target_link_libraries(debug pthread)\n# target_link_libraries(server pthread)\nsee also 202304230920 cmake learn"},"__zettel/202306270923memcpy":{"slug":"__zettel/202306270923memcpy","filePath":"__zettel/202306270923memcpy.md","title":"202306270923","links":[],"tags":[],"content":"memcpy拷贝字符串数组时，不会自动拷贝null-terminator，除非指定的size包含它。\n完美转发：c.biancheng.net/view/7868.html\nC++11 标准中规定，通常情况下右值引用形式的参数只能接收右值，不能接收左值。但对于函数模板中使用右值引用语法定义的参数来说，它不再遵守这一规定，既可以接收右值，也可以接收左值（此时的右值引用又被称为“万能引用”）。\ntemplate &lt;typename T&gt;\nclass A {\n    // 注意这里并非完美转发，因为T是类模板参数，而非函数模板参数\n    void foo(T&amp;&amp;);  // 只能接收右值引用\n \n    template &lt;typename U&gt;\n    void bar(U&amp;&amp;);  // 这里就是完美转发，可以接受左值/右值引用\n};"},"__zettel/202306272227类型转换":{"slug":"__zettel/202306272227类型转换","filePath":"__zettel/202306272227类型转换.md","title":"202306272227","links":["notes/cpp/cpp-learn.html"],"tags":["cpp","cast"],"content":"dynamic_cast 只能用于继承体系下的转换，一般用于将基类转换为子类，需要考虑是不是设计有问题？\nconst_cast用于去除对象的const/volatile属性，一般用于适应接口，且明确接口不会修改对象。\nreinterpret_cast 重新表达，告诉编译器将这段内存解释为指定的数据类型。因为我们知道，类型只是告诉编译器如何解释一段内存，内存还是那个内存，数据还是那份数据，在二进制上，它们没有任何区别。类型只是辅助解释！参见A view of memory and fundamental data types in cpp. 不安全，尽量少用。但用得保证能用对。\nstatic_cast 最常用。"},"__zettel/202306272237整数运算":{"slug":"__zettel/202306272237整数运算","filePath":"__zettel/202306272237整数运算.md","title":"202306272237","links":[],"tags":["cpp"],"content":"常见整数运算的问题\n\n有符号整数运算时出现溢出（undefined behavior）\n无符号整数运算时出现回绕（其实也是溢出）\n整数类型转换导致符号错误\n按位操作有符号整数导致符号错误\n\n整数运算不当带来的风险\n\n运算产生异常\n死循环（将整数运算作为循环判断条件）\n内存分配错误（将整数运算结果作为内存分配大小的参数）\n内存复制、指针偏移、数组索引等出现越界\n\n建议\n对于外部输入（不可控）的整数，需要做相应的边界检查！\n\n如果参与运算的整数来自外部或者整数的绝对值偏大，需要考虑运算后是否出现溢出\n特别关注整数被用在指针偏移、数组索引、内存拷贝长度、内存分配大小、循环判断条件等场景\n\n\n\n这里尤其注意，低于 int 类型的无符号整数做位运算时，会进行整型提升！"},"__zettel/202306281018循环队列参考":{"slug":"__zettel/202306281018循环队列参考","filePath":"__zettel/202306281018循环队列参考.md","title":"202306281018","links":[],"tags":["循环队列","cpp"],"content":"下列材料可供实现并发循环队列时参考：\n\ngithub.com/facebook/folly/blob/main/folly/ProducerConsumerQueue.h\nmoodycamel.com/blog/2013/a-fast-lock-free-queue-for-c++.htm\npreshing.com/20120625/memory-ordering-at-compile-time/\ngithub.com/cameron314/readerwriterqueue\n"},"__zettel/202306281021资源管理":{"slug":"__zettel/202306281021资源管理","filePath":"__zettel/202306281021资源管理.md","title":"202306281021","links":["__zettel/202306272237整数运算.html","tags/RAII.html"],"tags":["cpp","resource-manage","RAII"],"content":"资源访问校验\n当外部数据参与数组索引、内存申请大小、内存复制长度、指针偏移等操作，必须对数据大小进行严格校验，否则可能发生严重问题。\nsee also 202306272237整数运算\n在传递数组时，同时传递数组长度\n数组在函数传参时会退化为指针，导致数组长度信息丢失，容易造成数组索引合法性检查错误，引发越界读写问题。\nvoid test()\n{\n    char array[10];\n    init_array(array);\n}\n \nvoid init_array(char arr[])\n{\n    // 【错误】这里计算的是 char* 指针的大小\n    for (size_t i = 0; i &lt; sizeof(arr); ++i) ...\n}\n建议：\n\n如果函数只接受固定长度的数组作为参数，可以定义参数类型为数组引用或std::array\n如果函数要兼容C接口，那么应该把长度作为另外一个参数也传递进去\n\nvoid init_array(char arr[], size_t len);  // ok\n \nvoid init_arr(char arr[])  // error, arr deduced to char*\n{\n    cout &lt;&lt; &quot;nake arr&quot; &lt;&lt; sizeof(arr) &lt;&lt; endl;\n}\n \nvoid init_arr_ref(char (&amp;arr_ref)[10]) // ok, pass by ref\n{\n    cout &lt;&lt; &quot;arr ref&quot; &lt;&lt; sizeof(arr_ref) &lt;&lt; endl;\n}\n \ntemplate&lt;typename T, size_t N&gt;\nvoid init_arr_temp(T (&amp;arr_temp)[N])  // ok, template instantiate to init_arr_temp&lt;char, 10UL&gt;(char (&amp;arr_temp)[10])\n{\n    cout &lt;&lt; &quot;arr temp&quot; &lt;&lt; sizeof(arr_temp) &lt;&lt; endl;\n}\nRAII管理资源的声明周期\nRAII\n资源的获取和释放是成对操作（例如new/delete，fopen/fclose，lock/unlock等）恰好能对应c++语言对称的构造函数和析构函数。利用c++对象的生命周期来管理资源的声明周期，是一种常见的策略。\n不要访问超出生命周期的对象\n禁止将局部变量的地址返回到其作用域以外，\nstring_view get_data()\n{\n    const char s[] = &quot;hello world&quot;;\n    return s;  // 【错误】，会间接将s的地址返回到其作用域外\n}\n当lambda会逃逸处函数外面时，禁止按引用捕获局部变量，\nvoid foo()\n{\n    int local_var = 0;\n    ...\n    // 【错误】，lambda不确定何时、在何地（线程）执行，而local_val的生命周期在此处即将结束\n    thread_pool.QueueWork([&amp;] { process(local_val); });\n}"},"__zettel/202306281126异常处理":{"slug":"__zettel/202306281126异常处理","filePath":"__zettel/202306281126异常处理.md","title":"202306281126","links":["notes/cpp/多态.html"],"tags":["cpp","exception","异常处理"],"content":"异常仅用于处理错误\n不要滥用异常。\n不要盲目catch，不能处理的异常应继续向上传播\n避免在不宜抛异常的地方抛出异常\n构造异常的操作本身不应抛出异常，\n// // 如果exp本身抛出异常，这一句实际抛出的就是exp抛出的异常，而非程序员原本想抛出的异常，confusing\nthrow exp;\n下面特定的函数不宜抛异常：\n\n全局变量和线程局部变量的构造函数：全局变量构造时，main函数还没有执行，无法捕获这个异常\n析构函数\ndelete操作符\n移动构造函数\n移动赋值操作符\nswap函数\n\n4、5、6会被标准库调用，而其调用时不期望异常抛出。在这些地方抛异常将无法处理、或破坏标准库的某些性质。\n异常的抛出与捕获\n\n只使用std::exception的派生类实例作为异常对象，不要使用基本类型\n抛异常时，抛对象本身而非指针，否则会造成回收责任不明确，简而言之new的异常对象谁负责delete？\n以左值引用的形式捕获异常，如果按值捕获异常的基类，会导致对象被切片。因为只有引用和指针有动态绑定，按值传递会导致类型转换（派生类向基类隐式转换），导致对象被切片。\ntry-catch语句有多个catch子句时，catch的顺序应该是先捕获派生类，后捕获基类\n"},"__zettel/202306301718类成员是否可以是类本身的类型":{"slug":"__zettel/202306301718类成员是否可以是类本身的类型","filePath":"__zettel/202306301718类成员是否可以是类本身的类型.md","title":"202306301718","links":[],"tags":["cpp","class"],"content":"类内成员如果要定义为本身类型的话，只能通过指针或者静态变量定义。原因参考： www.zhihu.com/question/341035289/answer/1047747826"},"__zettel/202307031654GIT-rebase撤销":{"slug":"__zettel/202307031654GIT-rebase撤销","filePath":"__zettel/202307031654GIT-rebase撤销.md","title":"202307031654","links":[],"tags":[],"content":"juejin.cn/s/git%20%E6%92%A4%E9%94%80rebase\n更改指定commit的msg：docs.github.com/zh/pull-requests/committing-changes-to-your-project/creating-and-editing-commits/changing-a-commit-message"},"__zettel/202307051438CPP调试-coredump":{"slug":"__zettel/202307051438CPP调试-coredump","filePath":"__zettel/202307051438CPP调试-coredump.md","title":"202307051438","links":[],"tags":["cpp","debug","coredump","gdb"],"content":"Segmentation fault\n中文叫做段错误，非常令人头疼的问题，默认没有任何提示信息。可能导致段错误的原因有：\n参考：www.cnblogs.com/kuliuheng/p/11698378.html\n\n解除引用一个包含非法值\n解除引用一个空指针(常常由函数返回，并未经检查就使用)\n在未得到正确的权限时进行访问。例如，试图往一个只读的文本段储存值就会引发段错误。\n用完了栈或者堆空间(虚拟内存虽然巨大，但也有可能使用殆尽)\n\n生成coredump文件\n# 查看当前coredump文件大小限制\n$ ulimit -c\n \n# 如果为0，则需要解除限制，注意只对当前shell进程生效\n$ ulimit -c unlimited\n \n# 生成coredump文件的命名格式\n$ cat /proc/sys/kernel/core_pattern\n|/usr/share/apport/apport %p %s %c %P\n \n# 更改文coredump文件命名规则\n$ sudo vi /etc/sysctl.conf\nkernel.core_pattern=/var/crash/%E.%p.%t.%s\n$ sudo sysctl -p\n我们设置 core dump 目录为/var/crash，core dump 的命名方式为%E.%p.%t.%s，它们的含义：\n\n%E：程序文件的完整路径（路径中的/会被!替代）\n%p：进程 ID\n%t：进程崩溃的时间戳\n%s：哪个信号让进程崩溃\n\n在获取coredump文件后，执行gdb进行调试\n$ gdb &lt;file&gt; &lt;file.coredump&gt;\n(gdb) backtrace # 打印调用栈\n使用coredumpctl info可查找coredump文件位置。\nSignal handler\n产生段错误时一般会触发一个SIGSEGV信号，我们可以添加该信号的处理函数，在程序退出之前记录一些信息。我们甚至可以使用backtrace(3)函数来保存当前栈内容。\n#include &lt;csignal&gt;\n#include &lt;execinfo.h&gt;\n \n#define SIZE 100\nvoid dump(int signo)\n{\n        fprintf(stderr,&quot;catch Segmentation fault!!!\\n&quot;);\n         FILE *fh;\n        if(!(fh = fopen(&quot;/tmp/dbg_msg.log&quot;, &quot;w+&quot;)))\n            exit(0);\n        void *buffer[100];\n        int nptrs;\n        nptrs = backtrace(buffer,SIZE);\n        backtrace_symbols_fd(buffer, nptrs, fileno(fh));\n        fflush(fh);\n        exit(-1);\n}\n \nmain (void)\n{\n        signal(SIGSEGV, &amp;dump);\n        *((int*)NULL) = 0;\n \n        return 0;\n}\nReferences\n\nsenlinzhan.github.io/2017/12/31/coredump/\n段错误(Segmentation fault)产生的原因以及调试方法\nwww.cnblogs.com/linux-37ge/p/12781176.html\nwww.cnblogs.com/kuliuheng/p/11698378.html\n"},"__zettel/202307121011开源协议解读":{"slug":"__zettel/202307121011开源协议解读","filePath":"__zettel/202307121011开源协议解读.md","title":"202307121011","links":[],"tags":["oss","开源"],"content":"\n    \n        \n            \n            \n            \n            \n            \n            \n        \n        \n            \n                \n                    开源大类\n                \n                \n                    常见许可证类型\n                \n                \n                    典型软件\n                \n                \n                    触发代码开源义务前提条件\n                \n                \n                    开源要求和范围\n                \n                \n                    规避开源方式\n                \n            \n            \n                \n                    BSD类\n                \n                \n                    Apache/BSD/MIT等\n                \n                \n                    Tomcat\n                    OpenSSL\n                \n                \n                    无\n                \n                \n                    无\n                \n                \n                    不涉及\n                \n            \n            \n                \n                    MPL类\n                \n                \n                    MPL/EPL等\n                \n                \n                    FireFox\n                    Eclipse\n                \n                \n                    产品集成使用该软件，并对外分发或销售。\n                    产品对该软件进行了修改。\n                \n                \n                    若无修改，则无需开源。\n                    若对其进行了修改，需将修改的部分开源。\n                \n                \n                    使用时不做任何修改\n                \n            \n            \n                \n                    GPL类\n                \n                \n                    LGPL\n                \n                \n                    Hibernate\n                    glibc\n                \n                \n                    产品集成使用该软件，并对外分发或销售。\n                \n                \n                    软件本身须开源。具有传染性，与其静态链接部分的代码也必须以LGPL许可开源；动态链接则不被传染。\n                \n                \n                    动态链接使用，仅开源其软件本身即可，产品代码可免受传染。\n                \n            \n            \n                \n                    GPL\n                \n                \n                    Busybox\n                    linux kernel\n                \n                \n                    产品集成使用该软件，并对外分发或销售。\n                \n                \n                    软件本身须开源。具有传染性，与其有链接关系的代码都必须以GPL许可对外开源，即与该软件在同一进程中运行的代码都必须开源\n                \n                \n                    进程隔离，独立于产品进程运行，仅开源其软件本身即可，产品代码可免受传染\n                \n            \n            \n                \n                    AGPL\n                \n                \n                    Berkeley_DB\n                \n                \n                    产品集成使用该软件。\n                \n                \n                    在GPL上增加了一条限制：即便不对外分发，只要在网络服务器上使用AGPL软件提供网络服务，就需要履行相关开源义务。\n                    例如： Berkeley_DB，即使没有“分发”动作，通过WEB形式为用户提供服务，也要履行对外开源义务。\n                \n                \n                    同GPL\n                \n            \n            \n                \n                    SSPL\n                \n                \n                    MongoDB\n                \n                \n                    产品将该软件做为服务或利用该软件的能力向公司外的第三方提供服务。\n                \n                \n                    软件本身须开源。具有传染性，使用开源软件相关的服务组件也要开源。相对AGPL，任何试图将开源软件作为服务加以利用的组件，都必须开放用于提供此类服务的软件的源代码。\n                \n                \n                    谨慎使用！对于使用SSPL协议软件，向第三方提供服务会导致软件包整体开源。只能向公司内部人员开放。\n                \n            \n        \n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n常见许可证类型触发代码开源义务前提条件开源要求和范围BSD类，如：Apache/BSD/MIT等无无MPL类，如：MPL/EPL/CDDL等-  产品集成使用该软件，并对外分发或销售-  产品对该软件进行了修改- 若无修改，则无需开源- 若对其进行了修改，需将修改的部分开源LGPLl  产品集成使用该软件，并对外分发或销售l  软件本身须开源l  具有传染性，与其静态链接部分的代码也必须以LGPL许可开源；动态链接则不被传染。l  若对其进行修改，若修改后增加的功能实现依赖于产品软件的数据或功能，则产品代码也会被传染。l  开源的代码要能够通过编译l  若为面向个人或家庭消费者的设备类产品，如手机、平板、电视机顶盒等，V3版本还要允许用户能够将编译出的二进制文件安装回产品设备GPLl  产品集成使用该软件，并对外分发或销售l  软件本身须开源。l  具有传染性，与其有链接关系的代码都必须以GPL许可对外开源，即与该软件在同一进程中运行的代码都必须开源l  开源的代码要能够通过编译l  若为面向个人或家庭消费者的设备类产品，如手机、平板、电视机顶盒等，V3版本还要允许用户能够将编译出的二进制文件安装回产品设备AGPLl  产品集成使用该软件，对外分发、销售，或是通过web对外提供服务l  同GPL"},"__zettel/202307261811vscode开发cpp配置":{"slug":"__zettel/202307261811vscode开发cpp配置","filePath":"__zettel/202307261811vscode开发cpp配置.md","title":"202307261811","links":[],"tags":[],"content":"首先安装必要插件，\n\nms-vscode-remote.remote-ssh：远程开发必备插件，可以使用ssh连接打开远端目录作为workspace\nllvm-vs-code-extensions.vscode-clangd：提供c++ code intelligence功能，安装完此插件后，需要禁用或移除微软本身提供的c++插件（如已安装）\nvadimcn.vscode-lldb：提供调试功能\n\n\n如遇网络问题，可从vsixhub手动下载安装插件。\n\n列一下我的插件列表：\n本地：\n$ code --list-extensions\nhuizhou.githd\njeff-hykin.better-cpp-syntax\nmhutchie.git-graph\nms-vscode-remote.remote-ssh\nms-vscode-remote.remote-ssh-edit\nms-vscode-remote.remote-wsl\nms-vscode.remote-explorer\npeaceshi.syntax-highlight\nvscodevim.vim\n远端：\n$ code --list-extensions\nExtensions installed on SSH: arm虚拟机(x.x.x.x):\nhuizhou.githd\nllvm-vs-code-extensions.vscode-clangd\nmhutchie.git-graph\ntwxs.cmake\nvadimcn.vscode-lldb\n远程开发配置\n在vscode中，按下ctrl+shift+p打开命令面板，键入如下命令：\n\n打开本地ssh_config文件，编辑连接信息：\n\n之后就可以在vscode中，连接这台机器，打开远端目录。\n\nTIPS：为了避免每次都输入ssh登录密码，可以配置ssh免密登录。\n\nclangd配置\n远程机器需要安装clangd软件包，如果没有，需要安装一个。如果安装不了，可以手动编译。内网llvm仓库地址：codehub-y.huawei.com/Performance_Abyss/LTEL2Tools/llvm-project/\n然后在远程机器的vscode全局配置里面配上clangd可执行文件的路径：\n// file:///home/hubingbing/.vscode-server/data/Machine/settings.json\n{\n    &quot;clangd.path&quot;: &quot;/home/hubingbing/llvm-project/build/bin/clangd&quot;,\n    &quot;clangd.arguments&quot;: [\n        // 在后台自动分析文件（基于 complie_commands)\n        &quot;--background-index&quot;,\n        // 标记 compelie_commands.json 文件的目录位置\n        // 关于 complie_commands.json 如何生成可见我上一篇文章的末尾\n        // zhuanlan.zhihu.com/p/84876003\n        // &quot;--compile-commands-dir=build&quot;,\n        // 同时开启的任务数量\n        &quot;-j=12&quot;,\n        // 告诉 clangd 用那个 clang 进行编译，路径参考 which clang++的路径\n        &quot;--query-driver=/usr/bin/g++&quot;,\n        // clang-tidy 功能\n        &quot;--clang-tidy&quot;,\n        &quot;--clang-tidy-checks=performance-*,bugprone-*&quot;,\n        // 全局补全（会自动补充头文件）\n        &quot;--all-scopes-completion&quot;,\n        // 更详细的补全内容\n        &quot;--completion-style=detailed&quot;,\n        // 补充头文件的形式\n        &quot;--header-insertion=iwyu&quot;,\n        // pch 优化的位置\n        &quot;--pch-storage=disk&quot;,\n    ],\n}\n配置完成后，打开一个cpp文件，\n\n状态栏中的clangd有输出，表示配置成功。至此可以在vscode中享受clangd带来的intelligence功能，\n\n调试\n安装好codelldb插件后，选择一个cpp文件，按F5，vscode会自动提示你创建一个调试任务（如果之前没配过）。简单配置成下面的样子即可，\n// file:///.vscode/launch.json\n{\n    // Use IntelliSense to learn about possible attributes.\n    // Hover to view descriptions of existing attributes.\n    // For more information, visit: go.microsoft.com/fwlink/\n    // for variables see: code.visualstudio.com/docs/editor/variables-reference\n    &quot;version&quot;: &quot;0.2.0&quot;,\n    &quot;configurations&quot;: [\n        {\n            &quot;type&quot;: &quot;lldb&quot;,\n            &quot;request&quot;: &quot;launch&quot;,\n            &quot;name&quot;: &quot;Debug&quot;,\n            &quot;args&quot;: [],\n            &quot;cwd&quot;: &quot;${workspaceFolder}/service/src/main/cpp&quot;,\n            &quot;program&quot;: &quot;service/src/main/cpp/build/${fileBasenameNoExtension}&quot;,\n        },\n        {\n            // see: github.com/vadimcn/codelldb/blob/master/MANUAL.md#connecting-to-lldb-server-agent\n            // and github.com/vadimcn/codelldb/discussions/779\n            &quot;type&quot;: &quot;lldb&quot;,\n            &quot;request&quot;: &quot;launch&quot;,\n            &quot;name&quot;: &quot;RemoteLaunch&quot;,\n            &quot;args&quot;: [],\n            &quot;program&quot;: &quot;service/src/main/cpp/build/${fileBasenameNoExtension}&quot;,\n            &quot;initCommands&quot;: [\n                &quot;platform select remote-linux&quot;,\n                // &quot;platform connect connect://127.0.0.1:12306&quot;,\n                &quot;platform connect connect://10.136.193.188:12306&quot;,\n            ],\n            &quot;expressions&quot;: &quot;native&quot;,\n        }\n    ]\n}\n这样，即可在本地调试程序，\n\n远程调试\n此外，lldb还支持远程调试，将lldb-server及相关文件拷贝到目标机器：\n\n在远程机器上执行lldb-server起监听，然后在本机配置远程调试任务（上述launch.json中的第二个就是用于远程调试）。然后，当你执行这个调试任务，其实就是将可执行文件拷贝到远程机器上执行，并启用调试功能。\n\n此外远程调试还有一个bonus，可以root权限进行调试！只需使用root权限执行lldb-server即可。\n\n参考：\n\ngithub.com/vadimcn/codelldb/discussions/779\ngithub.com/vadimcn/codelldb/blob/master/MANUAL.md#connecting-to-lldb-server-agent\n\n例如：\nint sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);\n如果不用root权限执行，会返回errno 1, EPERM，即permission denied. 为了能够正常创建socket并debug，必须使用root身份运行debugger.\n\n可以看到socket创建成功了，且服务后台也有debug connect/disconnect的消息。\n\nReferences\n\nwindowsmacos-vscode-c-llvm-clang-clangd-lldb.readthedocs.io/configure.html\n"},"__zettel/202308011934C++惯用法":{"slug":"__zettel/202308011934C++惯用法","filePath":"__zettel/202308011934C++惯用法.md","title":"202308011934","links":[],"tags":["cpp"],"content":"使用lambda表达式消除多重初始化路径\nObj obj;\nswitch (init_mode) {\ncase mode1:\n    obj = Obj(...);\n    break;\ncase mode2:\n    obj = Obj(...);\n    break;\n...\n}\n上述代码要求：\n\nObj类型支持默认初始化\nObj类型支持赋值\n如果要获得较好的性能，Obj类型需要移动友好\n\n可用如下lambda表达式消减：\nauto obj = [&amp;] {\n    switch (init_mode) {\n    case mode1:\n        return Obj(...);\n        break;\n    case mode2:\n        return Obj(...);\n        break;\n    ...\n    }\n}();"},"__zettel/202308012018lambda表达式":{"slug":"__zettel/202308012018lambda表达式","filePath":"__zettel/202308012018lambda表达式.md","title":"202308012018","links":[],"tags":["cpp","labmda"],"content":"考虑如下代码：\n#include &lt;iostream&gt;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n#include &lt;thread&gt;\n \nusing namespace std;\n \nint get_count()\n{\n    static int count = 0;\n    return ++count;\n}\n \nclass task\n{\npublic:\n    task(int data) : data_(data) {}\n    auto lazy_launch()\n    {\n        return [*this, count = get_count()]() mutable { // 这里使用*this按值捕获，如果直接捕获this，会有问题\n            ostringstream oss;\n            oss &lt;&lt; &quot;Done work &quot; &lt;&lt; data_ &lt;&lt; &quot; (No. &quot; &lt;&lt; count\n                &lt;&lt; &quot;) in thread &quot; &lt;&lt; this_thread::get_id() &lt;&lt; &#039;\\n&#039;;\n            msg_ = oss.str();\n            calculate();\n        };\n    }\n \n    void calculate()\n    {\n        this_thread::sleep_for(100ms);\n        cout &lt;&lt; msg_;\n    }\n \nprivate:\n    int data_;\n    string msg_;\n};\n \nint main()\n{\n    task t(37);\n    thread t1{t.lazy_launch()};\n    thread t2{t.lazy_launch()};\n    t1.join();\n    t2.join();\n    return 0;\n}\n运行结果：\nhubingbing@siaphisprm02259 ~/PacketForwardAgent/service/src/main/cpp/build&gt; ./01_lambda_capture                      20:22\nDone work 37 (No. 1) in thread 281473391817152\nDone work 37 (No. 2) in thread 281473383424448\nhubingbing@siaphisprm02259 ~/PacketForwardAgent/service/src/main/cpp/build&gt; ./01_lambda_capture                      20:22\nDone work 37 (No. 1) in thread 281473675637184\nDone work 37 (No. 2) in thread 281473667244480\nhubingbing@siaphisprm02259 ~/PacketForwardAgent/service/src/main/cpp/build&gt; ./01_lambda_capture                      20:22\nDone work 37 (No. 1) in thread 281473119936960\nDone work 37 (No. 2) in thread 281473111544256\nhubingbing@siaphisprm02259 ~/PacketForwardAgent/service/src/main/cpp/build&gt; ./01_lambda_capture                      20:22\nDone work 37 (No. 2) in thread 281473806221760\nDone work 37 (No. 1) in thread 281473814614464\nhubingbing@siaphisprm02259 ~/PacketForwardAgent/service/src/main/cpp/build&gt; ./01_lambda_capture                      20:22\nDone work 37 (No. 2) in thread 281473281548736\nDone work 37 (No. 1) in thread 281473289941440\n\nfine, ok.\n如果把注释处改为按this指针捕获，则运行结果为：\nhubingbing@siaphisprm02259 ~/PacketForwardAgent/service/src/main/cpp/build&gt; ./01_lambda_capture                      20:23\nDone work 37 (No. 2) in thread 281473417372096\nDone work 37 (No. 2) in thread 281473417372096\nhubingbing@siaphisprm02259 ~/PacketForwardAgent/service/src/main/cpp/build&gt; ./01_lambda_capture                      20:23\nDone work 37 (No. 1) in thread 281473528775104\nDone work 37 (No. 1) in thread 281473528775104\nhubingbing@siaphisprm02259 ~/PacketForwardAgent/service/src/main/cpp/build&gt; ./01_lambda_capture                      20:23\nDone work 37 (No. 2) in thread 281473521451456\nDone work 37 (No. 2) in thread 281473521451456\nhubingbing@siaphisprm02259 ~/PacketForwardAgent/service/src/main/cpp/build&gt; ./01_lambda_capture                      20:23\nDone work 37 (No. 1) in thread 281473544192448\nDone work 37 (No. 1) in thread 281473544192448\n\n很奇怪有没有？\n如果按指针捕获，lambda表达式中对成员msg_的修改是同一处，后跑的线程会覆盖先跑的线程，所以打印出来都是一句。而按*this捕获，lambda表达式中已经对task做了拷贝，两个线程写的msg_不是同一个，因此可以正常输出。"},"__zettel/202308181549SFINAE":{"slug":"__zettel/202308181549SFINAE","filePath":"__zettel/202308181549SFINAE.md","title":"202308181549","links":[],"tags":["cpp","sfinae"],"content":"问题背景\n想要实现一个append(C&amp; contianer, T* ptr, size_t size)函数，作用是拷贝size个数组ptr中的元素到容器container中。为了防止container扩容引发的性能开销，希望如果container有reserve成员，先调用reserve分配好内存，如果没有就算了。\ntemplate &lt;typename C, typename T&gt;\nvoid append(C&amp; container, T* ptr, size_t size)\n{\n    container.reserve(container.size() + size); // 有reserve的版本\n    for (size_t i = 0; i &lt; size; ++i) {\n        container.push_back(ptr[i]);\n    }\n}\n \ntemplate &lt;typename C, typename T&gt;\nvoid append(C&amp; container, T* ptr, size_t size)\n{\n    // 无reserve的版本\n    for (size_t i = 0; i &lt; size; ++i) {\n        container.push_back(ptr[i]);\n    }\n}\n我们能不能像python一样，\ntemplate &lt;typename C, typename T&gt;\nvoid append(C&amp; container, T* ptr, size_t size)\n{\n    if (has_reserve&lt;C&gt;::value) { // 实现一个trait，判断C有没有reserve成员\n        container.reserve(container.size() + size); // #1\n    }\n    for (size_t i = 0; i &lt; size; ++i) {\n        container.push_back(ptr[i]);\n    }\n}\n很遗憾不行，因为当类型C没有reserve成员时，#1处直接编译错误。\n解决方案\n#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;list&gt;\n#include &lt;type_traits&gt;\n \nusing namespace std;\n \n \ntemplate &lt;typename T, typename = void_t&lt;&gt;&gt;\nstruct has_reserve : false_type {};\n \ntemplate &lt;typename T&gt;\nstruct has_reserve&lt;T, void_t&lt;decltype(declval&lt;T&amp;&gt;().reserve(1U))&gt;&gt; : true_type {};\n \ntemplate &lt;typename C, typename T&gt;\nvoid append(C&amp; container, T* ptr, size_t size)\n{\n    if constexpr (has_reserve&lt;C&gt;::value) { // #2\n        container.reserve(container.size() + size);\n    }\n    for (size_t i = 0; i &lt; size; ++i) {\n        container.push_back(ptr[i]);\n    }\n}\n \ntemplate &lt;typename T&gt;\nvoid print(const T&amp; container)\n{\n    cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; &quot;: &quot;;\n    for (auto it = container.begin(); it != container.end(); ++it) {\n        cout &lt;&lt; *it &lt;&lt; &#039; &#039;;\n    }\n    cout &lt;&lt; endl;\n}\n \n \nint main()\n{\n    cout &lt;&lt; has_reserve&lt;vector&lt;int&gt;&gt;::value &lt;&lt; endl;\n    cout &lt;&lt; has_reserve&lt;list&lt;int&gt;&gt;::value &lt;&lt; endl;\n    int a[] = {1,2,3,4,5};\n    list&lt;int&gt; lst;\n    vector&lt;int&gt; vec;\n    // append(lst, data(a), std::size(a));\n    // append(vec, data(a), std::size(a));\n    append(lst, a, 5);\n    append(vec, a, 5);\n \n    print(lst); // void print(const T&amp;) [with T = std::__cxx11::list&lt;int&gt;]: 1 2 3 4 5\n    print(vec); // void print(const T&amp;) [with T = std::vector&lt;int&gt;]: 1 2 3 4 5\n \n    return 0;\n}\n这里#2处使用了if constexpr功能，由c++17引入（被吴咏炜称为c++17最喜爱的特性）。他的作用是，直接在编译期判断条件，判过了，if下面的语句才会被编译，否则直接跳过。"},"__zettel/202308261504make基础":{"slug":"__zettel/202308261504make基础","filePath":"__zettel/202308261504make基础.md","title":"202308261504","links":[],"tags":["make"],"content":"makefile的规则\n一个makefile可以有很多个rules，一个rule长这样：\ntarget ... : prerequisites ...\n    recipe\n    ...\n    ...\n\ntarget：可以是一个object file（目标文件），也可以是一个可执行文件，还可以是一个标签（label）。\nprerequisites：生成该target所依赖的文件和/或target。\nrecipe：该target要执行的命令（任意的shell命令）。\n\n一个rule包含三个部分\n\n一个或多个targets\n0个或多个dependencies\n0个或多个commands（recipe）\n\n这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说:\nprerequisites中如果有一个以上的文件比target文件要新的话，recipe所定义的命令就会被执行。\n\n这就是makefile的规则，也就是makefile中最核心的内容。\n重要参数：\n\n-n : dry run\n-f : 指定makefile\n-s : silent/quiet，静默模式，不显示任何输出\n\n规则说明：\n\nrecipe中的命令默认使用/bin/sh解释shell命令\n输入make target意味着\n\n确定所有的依赖都是最新的\n如果target比任何一个dependency旧，则重新构建target\n\n\n输入make默认构建Makefile中的第一个target\nPhony target（伪目标）：伪目标的名字并不表示真的要生成这样一个文件，伪目标仅包含recipe和target，不包含任何dependency\n\n命令的开头\n\nrecipe中的命令一定要以一个Tab键作为开头，不能用空格代替\nrecipe中的命令若以-开头，表示如果命令执行出错，继续执行下一条命令\nrecipe中的命令若以@开头，表示命令本身不会输出，但命令的输出（如有）会输出\n\n命令的执行\nmake会一条一条执行recipe中的命令，需要注意的是，如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令。比如你的第一条命令是cd命令，你希望第二条命令得在cd之后的基础上运行，那么你就不能把这两条命令写在两行上，而应该把这两条命令写在一行上，用分号分隔。如：\n#1\nexec:\n    cd /home/hchen\n    pwd\n \n#2\nexec:\n    cd /home/hchen; pwd\n当我们执行 make exec 时，第一个例子中的cd没有作用，pwd会打印出当前的Makefile目录，而第二个例子中，cd就起作用了，pwd会打印出“/home/hchen”。\n嵌套执行make\n在一些大的工程中，我们会把我们不同模块或是不同功能的源文件放在不同的目录中，我们可以在每个目录中都书写一个该目录的Makefile，这有利于让我们的Makefile变得更加地简洁，而不至于把所有的东西全部写在一个Makefile中，这样会很难维护我们的Makefile，这个技术对于我们模块编译和分段编译有着非常大的好处。\n例如，我们有一个子目录叫subdir，这个目录下有个Makefile文件，来指明了这个目录下文件的编译规则。那么我们总控的Makefile可以这样书写：\nsubsystem:\n    cd subdir &amp;&amp; $(MAKE)\n其等价于：\nsubsystem:\n    $(MAKE) -C subdir\n定义$(MAKE)宏变量的意思是，也许我们的make需要一些参数，所以定义成一个变量比较利于维护。这两个例子的意思都是先进入“subdir”目录，然后执行make命令。\n我们把这个Makefile叫做“总控Makefile”，总控Makefile的变量可以传递到下级的Makefile中（如果你显示的声明），但是不会覆盖下层的Makefile中所定义的变量，除非指定了 -e 参数。\n定义命令包\n如果Makefile中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以 define 开始，以 endef 结束，如:\ndefine run-yacc\n    yacc $(firstword $^)\n    mv y.tab.c $@\nendef\n这里，“run-yacc”是这个命令包的名字，其不要和Makefile中的变量重名。在 define 和 endef 中的两行就是命令序列。这个命令包中的第一个命令是运行Yacc程序，因为Yacc程序总是生成“y.tab.c”的文件，所以第二行的命令就是把这个文件改改名字。还是把这个命令包放到一个示例中来看看吧。\nfoo.c : foo.y\n    $(run-yacc)\n我们可以看见，要使用这个命令包，我们就好像使用变量一样。在这个命令包的使用中，命令包“run-yacc”中的 $^ 就是 foo.y ， $@ 就是 foo.c （有关这种以 $ 开头的特殊变量，我们会在后面介绍），make在执行命令包时，命令包中的每个命令会被依次独立执行。\n使用变量\n在Makefile中的定义的变量，就像是C/C++语言中的宏一样，他代表了一个文本字串，在Makefile中执行的时候其会自动原模原样地展开在所使用的地方。其与C/C++所不同的是，你可以在Makefile中改变其值。在Makefile中，变量可以使用在“目标”，“依赖目标”， “命令”或是Makefile的其它部分中。\n命名规则：变量的命名字可以包含字符、数字，下划线（可以是数字开头），但不应该含有 : 、 # 、 = 或是空字符（空格、回车等）。变量是大小写敏感的，“foo”、“Foo”和“FOO”是三个不同的变量名。传统的Makefile的变量名是全大写的命名方式，但我推荐使用大小写搭配的变量名，如：MakeFlags。这样可以避免和系统的变量冲突，而发生意外的事情。\n有一些变量是很奇怪字串，如 $&lt; 、 $@ 等，这些是自动化变量，我会在后面介绍。\n\nmacro @ evaluates to the name of the current target.\n可用make -p打印内部宏\n\n变量在声明时需要给予初值，而在使用时，需要给在变量名前加上 $ 符号，但最好用小括号 () 或是大括号 {} 把变量给包括起来。如果你要使用真实的 $ 字符，那么你需要用 $$ 来表示。\n变量可以使用在许多地方，如规则中的“目标”、“依赖”、“命令”以及新的变量中。先看一个例子：\nobjects = program.o foo.o utils.o\nprogram : $(objects)\n    cc -o program $(objects)\n \n$(objects) : defs.h\n变量会在使用它的地方精确地展开，就像C/C++中的宏一样，例如：\nfoo = c\nprog.o : prog.$(foo)\n    $(foo)$(foo) -$(foo) prog.$(foo)\n展开后得到：\nprog.o : prog.c\n    cc -c prog.c\n当然，千万不要在你的Makefile中这样干，这里只是举个例子来表明Makefile中的变量在使用处展开的真实样子。可见其就是一个“替代”的原理。\n另外，给变量加上括号完全是为了更加安全地使用这个变量，在上面的例子中，如果你不想给变量加上括号，那也可以，但我还是强烈建议你给变量加上括号。\n与C/C++不同，为变量赋值时，右侧变量可以是后面定义的变量：\nfoo = $(bar)\nbar = $(ugh)\nugh = Huh?\n \nall:\n    echo $(foo)\n我们执行“make all”将会打出变量 $(foo) 的值是 Huh? （ $(foo) 的值是 $(bar) ， $(bar) 的值是 $(ugh) ， $(ugh) 的值是 Huh? ）可见，变量是可以使用后面的变量来定义的。\n还有另一种使用变量的方式（推荐）：\nx := foo\ny := $(x) bar\nx := later\n其等价于：\ny := foo bar\nx := later\n值得一提的是，这种方法，前面的变量不能使用后面的变量，只能使用前面已定义好了的变量。如果是这样：\ny := $(x) bar\nx := foo\n那么，y的值是“bar”，而不是“foo bar”。\n总结一下：\n\n=操作符允许先使用变量，后为变量赋值，但容易引发递归定义的问题\n:=操作符遵循常规变量先定义后使用的原则，推荐使用\n\n行尾注释的副作用\nnullstring :=\nspace := $(nullstring) # essential for one space\ndir := /foo/bar         # dir for xxx\nall:\n        @echo &quot;$(space),$(dir),$(nullstring),hehe&quot;\n$ make -n\necho &quot; ,/foo/bar                ,,hehe&quot;\n$ make\n ,/foo/bar              ,,hehe\n注意其中的空格，由此可见，行尾注释之前的空格也会被附加到变量值中。如果行尾没有注释，space变量将没有空格，dir变量也将恢复正常，没有后面的空格。用“#”注释符来表示变量定义的终止。这样，我们可以定义出其值是一个空格的变量。\n?= 操作符\nFOO ?= bar\n其含义是，如果FOO没有被定义过，那么变量FOO的值就是“bar”，如果FOO先前被定义过，那么这条语将什么也不做，其等价于：\nifeq ($(origin FOO), undefined)\n    FOO = bar\nendif\n+= 操作符\n我们可以使用 += 操作符给变量追加值，如：\nobjects = main.o foo.o bar.o utils.o\nobjects += another.o\n于是，我们的 $(objects) 值变成：“main.o foo.o bar.o utils.o another.o”（another.o被追加进去了）。它等价于下面的写法：\nobjects = main.o foo.o bar.o utils.o\nobjects := $(objects) another.o\n很明显，+= 更简洁。\n如果变量之前没有定义过，那么， += 会自动变成 = ，如果前面有变量定义，那么 += 会继承于前次操作的赋值符。如果前一次的是 := ，那么 += 会以 := 作为其赋值符。\n仍然，小心使用=和+=时引发的递归定义：\nv = $(value)\nvalue += $v\nall:\n        @echo &quot;value is $(value)&quot;\n$ make\nMakefile:6: *** Recursive variable &#039;value&#039; references itself (eventually).  Stop.\n目标变量\n前面我们所讲的在Makefile中定义的变量都是“全局变量”，在整个文件，我们都可以访问这些变量1。当然，我也同样可以为某个目标设置局部变量，这种变量被称为“Target-specific Variable”，它可以和“全局变量”同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。而不会影响规则链以外的全局变量的值。\n其语法是：\n&lt;target ...&gt; : &lt;variable-assignment&gt;;\n&lt;target ...&gt; : overide &lt;variable-assignment&gt;\n&lt;variable-assignment&gt;;可以是前面讲过的各种赋值表达式，如 = 、 := 、 += 或是 ?= 。第二个语法是针对于make命令行带入的变量，或是系统环境变量。\n这个特性非常的有用，当我们设置了这样一个变量，这个变量会作用到由这个目标所引发的所有的规则中去。如：\nprog : CFLAGS = -g\nprog : prog.o foo.o bar.o\n    $(CC) $(CFLAGS) prog.o foo.o bar.o\n \nprog.o : prog.c\n    $(CC) $(CFLAGS) prog.c\n \nfoo.o : foo.c\n    $(CC) $(CFLAGS) foo.c\n \nbar.o : bar.c\n    $(CC) $(CFLAGS) bar.c\n在这个示例中，不管全局的 $(CFLAGS) 的值是什么，在prog目标，以及其所引发的所有规则中（prog.o foo.o bar.o的规则）， $(CFLAGS) 的值都是 -g.\n高级用法\n拼接：\nfirst_second = Hello\na = first\nb = second\nall = $($a_$b)\n这里的 $a_$b 组成了“first_second”，于是， $(all) 的值就是“Hello”。当然，“把变量的值再当成变量”这种技术，同样可以用在操作符的左边:\ndir = foo\n$(dir)_sources := $(wildcard $(dir)/*.c)\ndefine $(dir)_print\n    lpr $($(dir)_sources)\nendef\n这个例子中定义了三个变量：“dir”，“foo_sources”和“foo_print”。\nReference\n\n跟我一起写Makefile - 陈皓\nA Short Introduction to Makefile\n羽夏 MakeFile 简明教程\n\nFootnotes\n\n\n当然，“自动化变量”除外，如 $&lt; 等这种类量的自动化变量就属于“规则型变量”，这种变量的值依赖于规则的目标和依赖目标的定义。 ↩\n\n\n"},"__zettel/202309080931code-smells":{"slug":"__zettel/202309080931code-smells","filePath":"__zettel/202309080931code-smells.md","title":"202309080931","links":[],"tags":["code-smell","refactor"],"content":"\n滥用OO\n被拒绝的遗赠\nRefused Bequest\n是什么\n子类不需要父类的数据、方法\n有什么问题\n滥用继承，会造成理解困难，不必要的耦合\n场景\n子类只用父类部分方法\n搞一个兄弟类，把不用的都放进去\nPush Down Method\nPush Down Field\n子类用了父类的实现，但接口不一样\n可能这个时候要用代理，而不是继承\nReplace Inheritance with Delegation\n异曲同工的类\nAlternative Classes with Different Interfaces\n是什么\n两个函数做一样的事，却有不同的签名\n所以主要是接口不同，跟类的关系不大\n有什么问题\n缺乏抽象，引发不必要的复杂度\n场景\n两个函数做的事一样，签名不同\n通过命名的修改来凸显问题\nRename Method\n通过不停地把行为内置，让两边协议一样\nMove Method\n最后可能提取到父类里\nExtract Superclass\n临时字段\nTemporary Field\n是什么\n为了特定情况建立的字段\n有什么问题\n跟其他字段生命周期不一样容易造成bug\n场景\n用一个或几个field当临时变量\n应该创建一个新类\nExtract Class\n然后传参\n为null设置一个field\nIntroduce Null Object\n一个复杂算法，要用很多变量，但是作者不想传太多变量，所以把他们都搞成了field，这些变量只对这个算法有意义\n提取新对象\nExtract Class\n新版被去掉的坏味道\n不完美的类库\nIncomplete Library Class\n手法\nIntroduce Local Extension\nIntroduce Foreign Method\nMove Method\n场景\n类库有些API不提供，或API不好用\nswitch惊悚现身\nswitch statements\n是什么\n分支判断很多，而且到处出现\n不仅仅是switch关键字\n有什么问题\n因为四处出现，每改一个分支就要改好多地方\n遗漏而出bug\n即便只有一个地方，太长的分支列表也会有问题\n改一个新的，不小心动到了旧代码\n就算没动到新代码，也会扩散变化，无法证明整个列表中其他分支没有被改变，要做全量回归\n场景\n一个明显需要多态的场景\n需要一连串的手法来实现一个多态替换掉它\n先把整个分支列表移到一个新函数里\nExtract Method\n再移到你计划制造多态的新类里\nMove Method\n然后决定是否需要用继承体系替换掉\n如果是，选择哪一种继承体系，如下：\n一组State/Strategy\nReplace Type Code with State/Strategy\n一些子类\nReplace Type Code with Subclasses\n最后用继承体系替换掉\n多态类的创建场景\n用enum或抽象工厂或loC容器\n手法同上\n有时候调用端其实是只在此自己要什么的，没必要隐藏\n你可以把分支里的行为抽取成具体的函数\n调用段只要直接调用具体的函数就可以\nReplace Parameter with Explicit Methods\n有时候只是判个空\n可以让调用端传入一个NullObject对象\nIntroduce Null Object\n膨胀剂\n神秘的命名\n新版新加的\n可以对应magic number\n过长的参数列表\nlong parameter list\n是什么\n就是形参太多了\n有什么问题\n不容易理解\n你从接口上看不出为啥需要这些数据\n不容易定义出函数的职责\n造成职责不单一，各种耦合\n接口会经常变动\n场景\n几个参数明显属于一个整体\n手法：组合成一个类\nIntroduce Parameter Object\nPreserve Whole Object\n参数里有对象和对象的属性\n手法：那就不要传属性，直接读对象\nReplace Parameter with Method\n有时候自己的属性可以被对方读属性读到\n就直接传自己，手法同上\nPreserve Whole Object\nReplace Parameter with Method\n例外场景\n你不需要被调对象和其他某个对象（比如自己）产生依赖（纯函数流行后，这个可能越发的多了）\n这个时候，传属性是对的\n过长的函数\nlong method\n是什么\n一个函数的函数体内代码行数过长\n一个函数建议在20行以内\n有什么问题\n程序越长越难理解，自然容易出bug\n场景\n一个函数内有很多段逻辑，函数本身职责不单一，每段代码彼此可以通过数据传递隔离（绝大多数）\n分割成小函数，并起一个合理的名字\nExtract Method\n如果函数内临时变量太多，或函数本身的参数太多。提取函数会制造大量的参数，搞不好就有long param list坏味道\n可以用函数替代临时变量\nReplace Temp with Query\n这样可以在其他函数里直接调用这个新函数，省去传参\n可以用对象来封装参数\nIntroduce Parameter Object\n有时你从一个对象里去除几个数据传给函数A，这个时候，你就直接传这个对象，在函数A里面取\nPreserve Whole Object\n如果以上手法还不能拯救你，就可以祭出大杀器，用函数对象代替函数\nReplace Method with Method Object\n不要滥用\n毕竟OO不是FP\n不知道哪段代码，该被提取\n寻找注释\n哪怕只有一行代码，既然值得注释，就值得提取\n发现循环\n整个提取\nExtract Method\n新时代可以用lambda替换\n发现条件表达式\n把表达式提取成函数\nDecompose Conditional\n数据泥团\nData Dump\n是什么\n数据项总是扎堆出现，扎堆小时，说明他们是一个类\n有什么问题\n丢失的概念\n往往这里有个概念，但是我们在需求传递中丢失了，造成不内聚\n场景\n有几个数据项，总是同时被某一个或几个函数使用\n有几个数据项，总是同时被一个或几个代码块使用\n手法是一样的\n先把数据项抽取成对象\nIntroduce Parameter Object\n直接传对象\nPreserve Whole Object\n过大的类\nLarge Class\n是什么\n单个类做了太多的事情\n类的行数很长，field也很多\n有什么问题\n这也是百病之源\n理解困难\n职责不单一，代码容易耦合\n场景\n有些时候，这些变量适合放在子类里\n那就抽取一个子类\nExtract Subclass\n仅仅是行数太长\n也是需要提取一个新类\nExtract Class\nExtract Subclass\n可能是职责不单一，根据客户端的使用情况不同，先提取接口，然后在动刀\nExtract Interface\n这个大类是GUI的类\n有可能需要把业务逻辑和显示逻辑分离\n哪怕你需要duplicate一套数据，两边同步\nDuplicate Observed Data\n如果在服务端，不要对View层的TO过于吝啬\nController可以有自己专属的一组ViewObject\n基本类型偏执\nPrimitive Obsession\n是什么\n该用结构类型来抽取概念的时候，没用，非要用基本类型\n有什么问题\n不内聚\n逻辑泄漏的到处都是\n场景\n不愿意为了小任务建立小对象\n比如\nmoney\n用浮点数是由风险的\ncontact\nZipCode\nRange\nURL\n类型码\n手法\nReplace Data Value with Object\nReplace Type Code with Subclass\nReplace Type Code with State/Strategy\nExtract Class\nIntroduce Parameter\n数组中的不同下标代表不同含义\n举例\n[“张三”,18,“男”]\n手法\nReplace Array with Object\n可有可无\n夸夸其谈的未来性\nSpeculative Generality\n是什么\n过度设计的产物\n认为我们未来会用到，但其实谁知道呢\n有什么问题\n理解困难\n维护困难\n看到一个精巧的设计，人们会本能的害怕，这个东西是不是有谁在用，于是一旦开放的接口只会越来越大，没有人敢删\n场景\n为一个简单的场景做了复杂的设计\n分解成下面具体的场景，然后逐个干掉\n抽象类没啥用（接口类似）\n那就直接用具体类就好了\nCollapse Hierarchy\n不必要的委托（A通过B访问C）\n那就直接依赖被委托的类（A直接访问C）\nInline Class\n函数的参数没啥用\n删掉没人用的参数\nRemove Parameter\n函数名听着太抽象\n重命名\nRename Method\n类和函数只有测试用例用，且这些测试用例业务上并不存在\n直接删除就好了\n这些没啥用，是说在当前需求中没用，\n都是为了某个想象出来的需求做的设计\n重复代码\nDuplicated Code\n是什么\n在一个以上的地点看到同样的程序结构\n有什么问题\n重复代码是万恶之源，会衍生出其他绝大多数的坏味道\n最常见的是一旦变化了，到处修改，漏改一个就是bug\n场景\n同一个类的两个函数含有相同的表达式\n把重复的部分提取出一个函数\nExtract Method\n两个互为兄弟的子类中看到相同的表达式\n先\nExtract Method\n再\nPull Up Method\n前两种情况下，两部分的代码相似却不相同\n首先提取相同部分\nExtract Method\n然后制造模板方法，把差异的部分交给子类实现\nForm Template Method\n有时候，代码确实不同，但其实在做同一件事，只是用了两种算法\n用比较清楚的一种替代掉另一种\nSubstitute Algorithm\n两个毫不相关的类里出现重复\n先提炼到一个类里去\nExtract Class\n然后在另一个类里使用\n注意：要决定这个函数在哪合适\n可能在A\n可能在B\n也能在第三个类\n冗余类\nLazy Class\n是什么\n不必要存在的类，不管是过度设计还是已经过时了\n有什么问题\n增加理解复杂度，已经没用的东西要尽早清理\n场景\n没用的类\n其实方法没人用了，也改干掉\n把类的代码内联回调用端\nInline Class\n没用的子类\n把子类和父类合成一个类，直接用\nCollapse Hierarchy\n莫名其妙的接口\n删除接口，直接用具体实现\nCollapse Hierarchy\n过多的注释\nComments\n是什么\n因为代码很糟糕，不得不写注释\n不是什么\n不写注释\n有什么问题\n掩盖坏味道\n场景\n需要注释一段代码干了什么\nExtract Method\n需要注释一个函数干了什么\nRename Method\n需要注释说明使用规格\nIntroduce Assertion\n纯数据类\nData Class\n是什么\n只有数据，没有方法\n有什么问题\n可能是错误的抽象\n场景\n一堆public field\n没什么好说的，封装起来\nEncapsulate Field\nEncapsulate Collection\n只有setter和getter\n把使用这些数据的函数慢慢挪到类里\nRemove Setting Method\nMove Method\nExtract Method\nHide Method\n例外\n起步阶段，你可能不知道有啥未来的方法，\n那就先用纯数据类，等业务出现的时候再重构\n难以修改\n平行的继承体系\nParallel Inheritance Hierarchies\n是什么\n这种情况下，假设有两个类，没给A增加一个子类，就要给B增加一个子类\n有什么问题\n还是因为不内聚，而容易出bug\n场景\n一个体系的前缀和另一个体系的前缀一模一样\n先引用\n再\nMove Method\nMove Field\n虽然类一样，但不继承，还是不要过早下判断\n分层架构下Domain层和View层、持久化层虽然会有类似对象，但是不继承\n最主要的是，他们往往是为了处理不同的变化\n比如一个是业务变化，一个是存储变化\n霰弹式修改\nShotgun Surgery\n是什么\n一种原因改变多个类\n优秀的设计是，同一种变化应该只改一个类\n最多因为这个类的修改，而逻辑上合理扩散到相关的类\n有什么问题\n很难找到\n也容易遗忘\n忘一个就是一个bug\n场景\n来一个需求，变一处逻辑，要四处修改\n把需要修改的代码放到一个类里，如果这个类不存在，就创造一个\n手法\nMove Method\nMove Field\nInline Class\n缺点\n会造成发散式变化\n比起霰弹式修改，还是好一点\n但不是说就不管了\n你可以先集中在一处，然后再慢慢重构\n发散式变化\nDivergent Change\n是什么\n多个原因改变一个类\n优秀的设计是，同一个类应该只响应一种变化\n不是什么\n一种变化，不是一个变化\n多个变化可能属于一种变化，比如业务逻辑修改，数据库替换，这是两种变化\n上下文也很重要，这就要结合DDD讲了\n有什么问题\n违反单一职责，这种类很容易代码耦合，不容易变\n也不容易理解\n一个业务实体类因为缓存变一变，因为数据库变一变，因为业务逻辑变一变，最后你看这代码想看出业务逻辑到底是啥就比较费劲\n场景\n一个技术需求和一个业务需求都要改同一个类\n不同上下文的业务，都要改同一个类\n库存\n产品\n识别变化原因\n然后Extract Class\n耦合\n依恋情结\nFeature Envy\n是什么\n一个函数对另一个类的数据感兴趣的程度远超过自己所在的类\n有什么问题\n不够内聚\n逻辑分散\n场景\n就是函数放错地方了，它用到的数据基本全在另一个类里，自己类里的数据反而可能只用一两个\nMove Method\n一段代码，用到的数据全在另一个类里\n先提取函数\nExtract Method\n再挪到另一个类里去\nMove Method\n例外\nvisitor\nstrategy\n这是为发散式变化付出的代价\n过度耦合的消息连\nMessage Chains\n是什么\na调b，b调c，c调d\n只是为了拿个数据\n有什么问题\n客户端过度了解被调用端结构\n被调用端改变，客户端不得不修改\n场景\n要通过一长串的访问拿到最终对象\n识别\n看看最终对象到底拿来做啥\n这个方法是否属于客户端\n是否可以直接把逻辑放到消息链里\n或其中一个对象上\n手法\nHide Delegate\nExtract Method\nMove Method\n中间人\nMiddle Man\n是什么\n对于委托的滥用\n有什么问题\n莫名其妙的出现了一个委托，每次查找问题的时候会很困扰，从而难以定位bug\n场景\n一个类大多数的逻辑都委托给了另一个类\n举例\n当客户端需要指导两个概念\nPerson\nDepartment\n却只能通过Person拿到Department\n改为\n既能访问Person，也能访问Department\n还能通过两者互取对方\n手法\nReplace Delegation with Inheritance\nInline Method\nRemove Middle Man\n狎昵关系\nInappropriate Intimacy\n是什么\n一个类对另一个类的了解太多了\n不管是private的field\n还是函数内在逻辑\n包括私有函数\n以至于自己的逻辑完全建立在对方的逻辑假设之上，从而变得两边隔空耦合\n有什么问题\n耦合，难以变动\n场景\n当两个类设计太深，变一个就得改另一个的时候\n先通过搬移Method和Field看能不能隔离变化\nMove Method\nMove Field\n如果存在双向关联，看看是不是要转为单项关联\nChange Bidirectional Association to Unidirectional\n看看是不是能提取出一个公共的类，双方都依赖它\nExtract Class\n或者这个公共的类，来替它们两个通信\nHide Delegate\n子类不再适合做子类的时候\n除了上述手法，有一个专题手法\nReplace Inheritance with Delegation\nReplace Parameter with Explicit Methods\n手法是一样的\n先把数据项抽取成对象\nIntroduce Parameter Object\n直接传对象\nPreserve Whole Object\n这些没啥用，是说在当前需求中没用，\n都是为了某个想象出来的需求做的设计\n识别变化原因\n然后Extract Class\n这是为发散式变化付出的代价"},"__zettel/202310162020UML基础":{"slug":"__zettel/202310162020UML基础","filePath":"__zettel/202310162020UML基础.md","title":"202310162020","links":[],"tags":["uml"],"content":"UML图分类：\n\n\n9种UML（Unified Modeling Language）模型图：\n\n用例图（Use-Case Diagram），静态图\n类图（Class Diagram），静态图\n对象图（Object Diagram），静态图\n状态图（State Diagram），动态图\n活动图（Activity Diagram），动态图\n顺序图（Sequence Diagram），动态图\n合作图（Communication Diagram），动态图\n组件图（Component Diagram），静态图\n部署图（Deployment Diagram），静态图\n\n6种关系：\n\n实现（Realization）\n依赖（Dependency）\n泛化（Generalization）\n关联（Association）\n聚合（Aggregation）\n组合（Composition）\n\n关系强弱顺序：泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖\n---\ntitle: 各关系图例\n---\nclassDiagram\n\nclassA --|&gt; classB : Inheritance(Generalization)\nclassC --* classD : Composition\nclassE --o classF : Aggregation\nclassG --&gt; classH : Association\nclassI ..&gt; classJ : Dependency\nclassK ..|&gt; classL : Realization\n\n\n\n                  \n                  TIP\n                  \n                \n\n类图关系连线的箭头，指向内容和范围较小的类。\n\n"},"__zettel/202310232023":{"slug":"__zettel/202310232023","filePath":"__zettel/202310232023.md","title":"202310232023","links":[],"tags":["链接","编译","linkage"],"content":"// a.c\nint a = 3;\n \n// b.c\n#include &lt;stdio.h&gt;\nint a;\nint main()\n{\n    printf(&quot;a=%d\\n&quot;, a);\n    return 0;\n}\ngcc a.c b.c -c\n[hubingbing@pekphis193995 test_linkage2]$ readelf -s a.o\n\nSymbol table &#039;.symtab&#039; contains 9 entries:\n   Num:    Value          Size Type    Bind   Vis      Ndx Name\n     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND \n     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS a.c\n     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 \n     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    2 \n     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 \n     5: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    2 $d\n     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 \n     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 \n     8: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    2 a\n[hubingbing@pekphis193995 test_linkage2]$ readelf -s b.o\n\nSymbol table &#039;.symtab&#039; contains 15 entries:\n   Num:    Value          Size Type    Bind   Vis      Ndx Name\n     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND \n     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS b.c\n     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 \n     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 \n     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 \n     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 \n     6: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    5 $d\n     7: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    1 $x\n     8: 0000000000000000     0 SECTION LOCAL  DEFAULT    7 \n     9: 0000000000000014     0 NOTYPE  LOCAL  DEFAULT    8 $d\n    10: 0000000000000000     0 SECTION LOCAL  DEFAULT    8 \n    11: 0000000000000000     0 SECTION LOCAL  DEFAULT    6 \n    12: 0000000000000004     4 OBJECT  GLOBAL DEFAULT  COM a\n    13: 0000000000000000    44 FUNC    GLOBAL DEFAULT    1 main\n    14: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND printf\n\n[hubingbing@pekphis193995 test_linkage2]$ g++ a.c b.c -c\n[hubingbing@pekphis193995 test_linkage2]$ readelf -s a.o\n\nSymbol table &#039;.symtab&#039; contains 9 entries:\n   Num:    Value          Size Type    Bind   Vis      Ndx Name\n     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND \n     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS a.c\n     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 \n     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    2 \n     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 \n     5: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    2 $d\n     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 \n     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 \n     8: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    2 a\n[hubingbing@pekphis193995 test_linkage2]$ readelf -s b.o\n\nSymbol table &#039;.symtab&#039; contains 16 entries:\n   Num:    Value          Size Type    Bind   Vis      Ndx Name\n     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND \n     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS b.c\n     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 \n     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 \n     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 \n     5: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    4 $d\n     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 \n     7: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    5 $d\n     8: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    1 $x\n     9: 0000000000000000     0 SECTION LOCAL  DEFAULT    7 \n    10: 0000000000000014     0 NOTYPE  LOCAL  DEFAULT    8 $d\n    11: 0000000000000000     0 SECTION LOCAL  DEFAULT    8 \n    12: 0000000000000000     0 SECTION LOCAL  DEFAULT    6 \n    13: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    4 a\n    14: 0000000000000000    44 FUNC    GLOBAL DEFAULT    1 main\n    15: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND printf\n[hubingbing@pekphis193995 test_linkage2]$ \n\n特别注意，g++编译出来的b.o，a是在第4段，视作定义而非声明。而gcc编译出来的b.o，a在common段，视为声明，不分配空间。\n所以上述代码gcc能编过并链接成功，而g++链接会报错。\n// a.c\nint x;\nvoid func() {\n    x = 20;\n}\n \n// b.c\n#include &quot;stdio.h&quot;\n \nshort x = 10;\nshort y = 10;\nextern void func();\n \nint main()\n{\n    printf(&quot;before call func: x = %d, y = %d\\n&quot;, x, y);\n    func();\n    printf(&quot;after call func: x = %d, y = %d\\n&quot;, x, y);\n    printf(&quot;sizeof(x)=%lu, sizeof(y)=%lu\\n&quot;, sizeof(x), sizeof(y));\n    return 0;\n}\n[hubingbing@pekphis193995 test_linkage]$ gcc a.c b.c\n/usr/bin/ld: warning: alignment 2 of symbol `x&#039; in /tmp/ccoKSrLO.o is smaller than 4 in /tmp/cc8Qpcod.o\n/usr/bin/ld: warning: size of symbol `x&#039; changed from 4 in /tmp/cc8Qpcod.o to 2 in /tmp/ccoKSrLO.o\n[hubingbing@pekphis193995 test_linkage]$ ./a.out \nbefore call func: x = 10, y = 10\nafter call func: x = 20, y = 0\nsizeof(x)=2, sizeof(y)=2\n"},"__zettel/202404150949vlan":{"slug":"__zettel/202404150949vlan","filePath":"__zettel/202404150949vlan.md","title":"202404150949","links":[],"tags":["vlan","vxlan"],"content":"Vlan和Vxlan\nVlan（Virtual LAN）\n为什么需要Vlan？\n在二层网络（Data Link Layer）中，交换机本身就是一个广播域。如果不划分Vlan，任意一台连接到交换机上的设备所发送的报文，将会广播给其他所有的设备。\n如果设备太多，过多的封包将会拥塞网络。\n每一个Vlan都相当于一个广播域。不同的Vlan之间想要通讯就必须要通过第三层网络（Network Layer）。\n二层交换机可以划分出很多的Vlan，但是Vlan间的通信必须要加上路由器。然而，三层交换机包含了路由功能。相当于二层交换机+路由器。\nAccess口：用于接入设备\nTrunk口：连接其他的交换机，上面可以承载多个Vlan\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n16 bits3 bits1 bit12 bitsTPIDPCPCFIVID\n因为只有12位 Vlan Identifier， 所以可用的Vlan只有4096-2 = 4094个\n4094个Vlan 对于大型云计算需要的隔离性是不够的，所以需要Vxlan\nVxlan（virtual extensible lan）\nVxlan 有24bit 标识位， 满足庞大的隔离需求。而且提供无障碍接入的网络。\n\n虚拟机动态迁移：将一个虚拟机从一个物理服务器迁移到另一物理服务器。要求IP地址，运行状态不变，只能在一个二层域迁移。\n传统架构限制了迁移的范围\n\nVxlan技术基于三层的网络结构，构建了二层的虚拟网络\n\nVxlan是一种overlay技术，overlay是基于隧道技术实现的。Vxlan把原始二层报文进行隧道协议封装之后，在承载网络中透明传输，完全无视中间网络的结构。中间的网络就像一个巨大的交换机，主机毫不关心报文在交换机中是如何传输的。\nReference\n\nzh.wikipedia.org/zh-cn/IEEE_802.1Q\n"},"__zettel/202405100938mutable-in-cpp":{"slug":"__zettel/202405100938mutable-in-cpp","filePath":"__zettel/202405100938mutable-in-cpp.md","title":"202405100938","links":[],"tags":["cpp","mutable"],"content":"C++中的mutable关键字\n一言以蔽之，在常量成员函数里面可以修改mutable修饰的成员变量。\nReferences\n\n8.8 关键字：mutable\nC++ 中的 mutable 关键字\n"},"__zettel/202406111912函数栈":{"slug":"__zettel/202406111912函数栈","filePath":"__zettel/202406111912函数栈.md","title":"202406111912","links":[],"tags":["cpp","stack"],"content":"两个重要指针：\nThe ESP (Extended Stack Pointer) holds the top stack address. 指向栈顶\nEBP (Extended Base Pointer) is used for this purpose. 指向栈帧\nAs an example in Windows/Intel, typically, when the function call takes place, data elements are stored on the stack in the following way:\n\n\nThe function parameters are pushed on the stack before the function is called.  The parameters are pushed from right to left.\n\n\nThe function return address is placed on the stack by the x86 CALL instruction, which stores the current value of the EIP register.\n\n\nThen, the frame pointer that is the previous value of the EBP register is placed on the stack.\n\n\nIf a function includes try/catch or any other exception handling construct such as SEH (Structured Exception Handling - Microsoft implementation), the compiler will include exception handling information on the stack.\n\n\nNext, the locally declared variables.\n\n\nThen the buffers are allocated for temporary data storage.\n\n\nFinally, the callee save registers such as ESI, EDI, and EBX are stored if they are used at any point during the functions execution.  For Linux/Intel, this step comes after step no. 4.\n\n\nthe stack grows downwards in memory as it gets bigger，栈向低内存地址增长，栈越大，栈顶地址越小。\nReference\n\nwww.tenouk.com/Bufferoverflowc/Bufferoverflow2a.html\n"},"__zettel/202406111956_dataview使用参考":{"slug":"__zettel/202406111956_dataview使用参考","filePath":"__zettel/202406111956_dataview使用参考.md","title":"Selected List","links":[],"tags":["plugin","dataview","tutorial","教程"],"content":"list query\nlist from &quot;__zettel&quot;\nwhere contains(file.etags, &quot;cpp&quot;)\nsort file.ctime\nlimit 5\n下面这个例子可以看到文件的所有metadata，\ntable this\nwhere file=this.file\n日期操作\ntable file.cday as &quot;创建日期&quot;,file.tags from #cpp\nwhere file.cday &gt;= date(&quot;2023-12-04&quot;)\ninline query\nthis is a inline query dv= this.file.name, here is another dv=[[备忘]].file.tags\ntable dateformat(file.mday, &quot;yy/MM/dd&quot;) as &quot;Update&quot;, file.tags as &quot;Tags&quot;\nfrom !&quot;work&quot; and !&quot;__obex&quot; and !&quot;inbox&quot; and !&quot;life&quot;\nwhere containsword(file.name, &quot;excalidraw&quot;)\nReferences\n\nDataview函数集合\nDataview 基本语法学习指南\n"},"__zettel/202409242301-usb耳机无声音":{"slug":"__zettel/202409242301-usb耳机无声音","filePath":"__zettel/202409242301-usb耳机无声音.md","title":"202409242301","links":[],"tags":["pipewire","pulseaudio","linux","音频"],"content":"起因：入了个usb耳机，然后插上电脑（archlinux）无效果。电脑自带扬声器和3.5mm耳机孔都是好好工作的，然而插了usb耳机后好像没插一样。\n先看下lsusb排除下物理连接问题\nyychi@~&gt; lsusb\nBus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub\nBus 001 Device 002: ID 04f2:b5a3 Chicony Electronics Co., Ltd XiaoMi USB 2.0 Webcam\nBus 001 Device 003: ID 04f3:0c1a Elan Microelectronics Corp. ELAN:Fingerprint\nBus 001 Device 004: ID 8087:0a2b Intel Corp. Bluetooth wireless interface\nBus 001 Device 009: ID 0b0e:0313 GN Netcom Jabra EVOLVE 30 II # usb headphone\nBus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub\n接着根据以前的经验，很快定位到了card-profile的问题。是不是情景模式不对呢？最后发现和上次不一样，上次普通耳机和外置扬声器用的一张声卡。这次usb耳机用的自带声卡，所以需要切换成自带声卡，且调对情景模式。\n\n现在用pipewire替代pulse-audio，其对应的配置命令行为pactl\n\nyychi@~&gt; pactl list cards short\n45\talsa_card.pci-0000_00_1f.3\talsa # 自带声卡\n576\talsa_card.usb-GN_Audio_A_S_Jabra_EVOLVE_30_II_0005EDED3F4A09-00\talsa # usb耳机声卡\n \npactl set-card-profile alsa_card.usb-GN_Audio_A_S_Jabra_EVOLVE_30_II_0005EDED3F4A09-00 pro-audio  # 设置正确的情景模式\n# 切换声卡，即设置默认输入输出\npactl set-default-sink alsa_output.usb-GN_Audio_A_S_Jabra_EVOLVE_30_II_0005EDED3F4A09-00.pro-output-0 # 设置默认输出\npactl set-default-source alsa_input.usb-GN_Audio_A_S_Jabra_EVOLVE_30_II_0005EDED3F4A09-00.pro-input-0 # 设置默认输入\n一番折腾，最终成功让usb耳机出声。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n命令含义pactl list cards [short]列出可用声卡pactl get-default-sink/source获取默认输出/输入pactl set-card-profile &lt;card-name/index&gt; &lt;card-profile&gt;给指定声卡设置情景模式"},"__zettel/202411092142-frp使用小记":{"slug":"__zettel/202411092142-frp使用小记","filePath":"__zettel/202411092142-frp使用小记.md","title":"202411092142","links":[],"tags":["frp","内网穿透","反代理"],"content":"frp官方文档：gofrp.org/zh-cn/docs/reference/server-configures/\n需要一个公网ip服务器运行frps，客户端运行frpc. 值得注意的是，运行frpc的客户端之间可以借助frps实现点对点直连（nat打洞），从而绕开frps（公网服务器）的带宽限制。\nfrps配置示例\n# file:///frps.toml\n \n#: Refer to gofrp.org/zh-cn/docs/reference/server-configures/\n#: for more information.\n \nauth.token = &quot;abc&quot; # 用于认证frpc的连接，frpc需要设置同样token才能连接\nbindPort = 7000\n# kcp 绑定的是 UDP 端口，可以和 bindPort 一样\nkcpBindPort = 7000\n# quic 绑定的是 UDP 端口，不能和 kcp 的一样\nquicBindPort = 7001\n \ntransport.tls.force = true\n \n# 默认为 127.0.0.1，如果需要公网访问，需要修改为 0.0.0.0。\nwebServer.addr = &quot;0.0.0.0&quot;\nwebServer.port = 7500\n# dashboard 用户名密码，可选，默认为空\nwebServer.user = &quot;admin&quot;\nwebServer.password = &quot;admin&quot;\nfrpc配置示例\n# file:///frpc.toml\n \n#: refer to gofrp.org/zh-cn/docs\nserverAddr = &quot;10.10.10.10&quot;\nserverPort = 7000\nauth.token = &quot;abc\n \n# 开启网页后台\n# webServer.addr = &quot;127.0.0.1&quot;\n# webServer.port = 7400\n# webServer.user = &quot;admin&quot;\n# webServer.password = &quot;admin&quot;\n \n[[proxies]]\nname = &quot;ssh-tunnel&quot;\ntype = &quot;tcp&quot;\nlocalIP = &quot;127.0.0.1&quot;\nlocalPort = 22\nremotePort = 8000\n \n \n[[proxies]]\nname = &quot;p2p_ssh&quot;\ntype = &quot;xtcp&quot;\n# 只有共享密钥 (secretKey) 与服务器端一致的用户才能访问该服务\nsecretKey = &quot;abcdefg&quot;\nlocalIP = &quot;127.0.0.1&quot;\nlocalPort = 22\n如此在外网可以通过ssh root@10.10.10.10 -p8000访问内网机器的sshd，流量经过公网服务器转发到内网机器。如果要建立点对点连接，需要在访问内网服务的机器上（下称本机）也执行frpc，作为visitor. 在这种情况下，内网机器frpc作为“服务端”，本机的frpc作为“客户端”。\nfrpc visitor配置示例\n# file:///frpc_visitor.toml\n \n#: refer to gofrp.org/zh-cn/docs\nserverAddr = &quot;10.10.10.10&quot;\nserverPort = 7000\nauth.token = &quot;abc&quot;\n \n[[visitors]]\nname = &quot;p2p_ssh_visitor&quot;\ntype = &quot;xtcp&quot;\nprotocol = &quot;kcp&quot;\nserverName = &quot;p2p_ssh&quot;\n# 只有共享密钥 (secretKey) 与服务器端一致的用户才能访问该服务\nsecretKey = &quot;abcdefg&quot;\nbindAddr = &quot;127.0.0.1&quot;\nbindPort = 3344 # 本地端口\nkeepTunnelOpen = true\n如此可以在本机使用ssh root@127.0.0.1 -p3344访问内网机器的sshd，且流量不用经过frps，绕过了公网服务器的带宽限制。"},"__zettel/202411100101firewalld使用小记":{"slug":"__zettel/202411100101firewalld使用小记","filePath":"__zettel/202411100101firewalld使用小记.md","title":"202411100101","links":[],"tags":["firewalld","防火墙","centos"],"content":"centos自带的防火墙firewalld感觉不太好用，命令行太长了，开放/删除端口的命令比较长，记不住。这里列一个简单方法，\n\n直接编辑zone里面的xml文件，例如，/etc/firewalld/zones/public.xml\n改完之后直接firewall-cmd --reload\n查看firewall-cmd --list-ports是否生效\n\nfirewalld是一个守护进程，可用systemd管理，systemctl start/stop firewalld.\nfirewall-cmd是用户交互命令，光看这个命令就很长orz\n附带一篇参考吧：juejin.cn/post/6844904116443938824"},"__zettel/202411132048数字证书":{"slug":"__zettel/202411132048数字证书","filePath":"__zettel/202411132048数字证书.md","title":"202411132048","links":[],"tags":["数字签名","数字证书","安全","非对称加密","http","https"],"content":"https比http安全在哪里？http是明文传输，如果被中间人劫持，你提交的表单（例如输入的密码）就会被窃取。而https是加密传输，即使被截取，得到的也是密文，无法直接破译。\nhttps协商要比http复杂一些，简单来说，分为几步：\n\n客户端发起http请求，服务端返回他的数字证书\n客户端（浏览器）根据自己所知道的CA机构密钥，一一验证服务端的数字证书是哪个CA颁发的（即用CA的公钥去解密数字证书，能解出来的就是该CA颁发的）\n再确认是一个可信CA颁发了服务端证书后，（上一步解密会得到服务端公钥），客户端使用对端（服务端）公钥加密消息，开始进行http连接，此时应该会带上自己（客户端）的公钥\n消息到达服务端后，这样双方就有了各自的公钥，可以互相发送加密消息\n\n数字证书是什么，解决了什么问题？\n数字证书是用来验证一个公钥所有权的密文，里面通常包含公钥持有人的公钥、基本信息（单位，名称，域名等）。数字证书一般由可信的第三方机构（CA-Certification Authorization机构）颁发。公钥所有人去CA机构申请证书，通常要缴费。而申请证书其实就是让CA用自己的私钥给公钥所有人的相关信息（他的公钥和基本信息）加密，加密后的产物就是公钥所有人的数字证书。\n数字证书就是“公钥的数字签名”！see：www.cnblogs.com/gide/p/16650487.html\n如果没有CA机制会发生什么问题？\n甲想给乙发信（加密的那种），因此他需要乙的公钥。但甲并非天生就有乙的公钥，在他获取公钥的过程中如果被第三者丙劫持，伪造一个公钥，那么甲会得到一个伪造的乙的公钥，他所有向乙发送的加密消息都会被丙知道，丙完全冒充了乙。因此，甲必须有证明“这个公钥就是乙的”的办法。为此他要求乙向CA机构申请数字证书，之后他会请求乙的数字证书。而丙无法伪造一个数字证书，使得甲误认为这是乙的证书。因为证书是由可信的CA机构颁发，已经给乙颁发了，不可能给丙再颁发一个带有同样个人信息的证书。且丙也无法绕过CA伪造证书，因为证书是由CA的私钥加密而来的。\nX.509证书\nX.509是ITU-T定义的证书格式，它包含\n\n两个 专有名称，用于唯一标识颁发证书的认证中心 (CA) 和 主体集 (向其颁发证书的个人或组织)。 专有名称包含多个可选组件:\n\n公共名称\n组织单元\n组织\n位置\n省/自治区/直辖市\n国家或地区\n\n\n数字签名。 签名由认证中心使用公用密钥加密技术创建:\n\n安全散列算法用于创建证书内容的摘要。\n摘要使用认证中心的专用密钥进行加密。\n使用 CA 的公用密钥对签名进行解密。\n制作证书内容的新摘要，并与解密的签名进行比较。 任何差异都表明证书可能已更改。 因此，数字签名向接收方保证，自证书发放以来，未对其进行任何更改。\n\n\n主体的域名。 接收方将此与证书的实际发送方进行比较。\n主体的公用密钥。\n\n\nHTTPs的安全性🔐\n一言以蔽之，HTTPS的流量是经过加密的，即便被中间人截取也无法轻易破译。HTTP的流量是明文的，裸奔！\n从超文本传输协议说起，HTTPs的\n对称加密\n数学定义\n非对称加密\n所谓非对称加密\n窃听三重奏（一）\n数字签名\n数字证书\nHTTPs的连接建立"},"__zettel/202411251922动态库链接问题":{"slug":"__zettel/202411251922动态库链接问题","filePath":"__zettel/202411251922动态库链接问题.md","title":"202411251922","links":[],"tags":["链接路径","符号表","链接","linkage"],"content":"参考修改：github.com/tbuktu/libntru/pull/47/files\n该仓库是纯C代码，构建工具是make. 但是代码直接下下来是无法编译通过的，它在poly.h中定义了多个函数指针，然后在poly.c中根据平台架构等区分给这几个函数指针不同的实现。\n例如\n// poly.h\nuint8_t (*ntru_invert)(NtruPrivPoly *a, uint16_t mod_mask, NtruIntPoly *Fq);\n// poly.c\nvoid ntru_set_optimized_impl_poly() {\n...\n    if (sizeof(void*) &gt;= 8)   /* 64-bit arch */\n        ntru_invert = ntru_invert_64;\n    else\n        ntru_invert = ntru_invert_32;\n...\n#if _LP64\n    ntru_invert = ntru_invert_64;\n#else\n    ntru_invert = ntru_invert_32;\n#endif\n这样如果多个源文件包含poly.h，必然会存在重复定义的问题，违反ODR（one-definition-rule）。而解决方法首先想到在poly.h中为符号加上extern，改定义为声明。然后这样一来，引发的效果还是符号未定义。\n$ gcc poly.c -c -o poly.o\n$ nm poly.o | grep ntru_invert\n                 U ntru_invert\n0000000000005228 T ntru_invert_32\n0000000000005bc9 T ntru_invert_64\n该项目将函数指针的初始化放在一个init函数里，要求使用者先调用init函数，可这样导致其他依赖这个库的文件编译错误，报错找不到这个符号的定义。\n而修改的方案也很简单，只需要在poly.c中再定义一次这个符号，那么该符号就变成了为初始化的全局数据（B）。\n// poly.c\n \n// 补一个定义即可\nuint8_t (*ntru_invert)(NtruPrivPoly *a, uint16_t mod_mask, NtruIntPoly *Fq);\n...\nvoid ntru_set_optimized_impl_poly() {\n...\n    if (sizeof(void*) &gt;= 8)   /* 64-bit arch */\n        ntru_invert = ntru_invert_64;\n    else\n        ntru_invert = ntru_invert_32;\n...\n#if _LP64\n    ntru_invert = ntru_invert_64;\n#else\n    ntru_invert = ntru_invert_32;\n#endif\n$ nm poly.o | grep ntru_invert\n0000000000000000 B ntru_invert\n00000000000041f0 T ntru_invert_32\n0000000000003b70 T ntru_invert_64\n这样符号至少有定义，但未初始化。其他依赖单元编译时就不会报错。\n参考PR：github.com/tbuktu/libntru/pull/47/files\n这个项目还牵扯出一个问题，就是编译出的可执行文件在运行时报错，找不到编出来的动态库：\n$ ./testham\n./testham: error while loading shared libraries: libntru.so: cannot open shared object file: No such file or directory\n$ ldd testham                                                                                           127 19:44\n        linux-vdso.so.1 (0x00007ac6eec8a000)\n        libntru.so =&gt; not found\n        libm.so.6 =&gt; /usr/lib/libm.so.6 (0x00007ac6eeb5a000)\n        libc.so.6 =&gt; /usr/lib/libc.so.6 (0x00007ac6ee969000)\n        /lib64/ld-linux-x86-64.so.2 =&gt; /usr/lib64/ld-linux-x86-64.so.2 (0x00007ac6eec8c000)\n$ ls\nchangelog    LICENSE   Makefile.bsd    Makefile.os2  Makefile.win  README.md  testham*\nlibntru.so*  Makefile  Makefile.linux  Makefile.osx  PATENTS       src/       tests/\n可见不会搜索当前目录，此时需要给链接器传额外参数，让他搜索当前目录，在makefile里加上\nCFLAGS+=-Wl,-rpath,./\n即可，参考：\n\nunix.stackexchange.com/a/479476\nserverfault.com/a/402590\n\n $ ldd testham\n        linux-vdso.so.1 (0x000079365271f000)\n        libntru.so =&gt; ./libntru.so (0x00007936526d7000)\n        libm.so.6 =&gt; /usr/lib/libm.so.6 (0x00007936525b9000)\n        libc.so.6 =&gt; /usr/lib/libc.so.6 (0x00007936523c8000)\n        /lib64/ld-linux-x86-64.so.2 =&gt; /usr/lib64/ld-linux-x86-64.so.2 (0x0000793652721000)\n$ ./testham\nRunning tests...\n  test_ntruprime_inv_int   ✓\n  test_ntruprime_inv_poly  ✓\n  test_mult_int            ✓\n  test_mult_tern           ✓\n  test_mult_prod           ✓\n  test_inv                 ✓\n  test_arr                 ✓\n  test_ntruprime_keygen    ✓\n  test_ntru_keygen         ✓\n  test_encr_decr           ✓\n  test_idxgen              ✓\n  test_bitstring           ✓\n  test_key                 ✓\n  test_hash                ✓\nAll tests passed     \nNM命令参考\n\nvoidint.github.io/post/tool/nm/\nlinuxtools-rst.readthedocs.io/zh-cn/latest/tool/nm.html\n"},"__zettel/202412111913dunst使用小记":{"slug":"__zettel/202412111913dunst使用小记","filePath":"__zettel/202412111913dunst使用小记.md","title":"202412111913","links":[],"tags":["dunst","notification-daemon","桌面通知","美化"],"content":"Dunst是一个notification-daemon，同类的软件包有很多，其中之一是extra/notification-daemon，如果没注意，你可能默认用的就是这个软件包。当安装了多个notification-daemon的时候，他们都会宣称自己提供了同个dbus service (org.freedesktop.Notifications)，导致冲突，默认会用一个，但具体规则我不清楚1。\nyychi@/usr/share/dbus-1/services&gt; grep org.freedesktop.Notifications *\norg.freedesktop.Notifications.service:Name=org.freedesktop.Notifications\norg.knopwob.dunst.service:Name=org.freedesktop.Notifications \n因此，最好保证这里只有一个提供这个service.\nnotification-daemon作为守护进程，接受客户端（libnotify包中提供的notify-send）的通知请求，按照规则显示通知。除此之外，dunst还提供dunstify（完全兼容notify-send）来发送通知以及dunstctl来配置dunst.\ndunst作为守护进程，可以配置通知的样式。从官网[showcase][1]中直接拿一个来用，简单改改即可。凑合看看，比之前默认的好看不少。猛击[这里][2]获取配置。\n\nFootnotes\n\n\n参考：wiki.archlinux.org/title/Dunst关于启动的描述和这个问题帖：bbs.archlinux.org/viewtopic.php\n[1]: dunst-project.org/showcase/\n[2]: github.com/guyueshui/dotfiles/blob/master/.config/dunst/dunstrc ↩\n\n\n"},"__zettel/202412112316linux桌面美化":{"slug":"__zettel/202412112316linux桌面美化","filePath":"__zettel/202412112316linux桌面美化.md","title":"202412112316","links":["__zettel/202412212317fcitx5更换systray-icon.html","__zettel/202412212328goldendict更换systray-icon.html"],"tags":["美化","桌面","linux"],"content":"icon-theme\npapirus-icon-theme\narc-icon-theme\narc-gtk-theme\nicon_theme位置：/usr/share/icons\ntheme位置：/usr/share/themes\n此文有截图效果：www.omgubuntu.co.uk/best-icon-themes-ubuntu\n更换示例：\n\n202412212317fcitx5更换systray-icon\n202412212328goldendict更换systray-icon\n\n如何设置\n参考：wiki.archlinux.org/title/GTK#Configuration"},"__zettel/202412112322firefox重启保留标签页":{"slug":"__zettel/202412112322firefox重启保留标签页","filePath":"__zettel/202412112322firefox重启保留标签页.md","title":"202412112322","links":[],"tags":["firefox","trick","技巧"],"content":"firefox带标签页重启\n\n地址栏输入：about:profiles\n选择正常重启\n\nfirefox直达密码管理：about:logins\n\n顺带说下chrome带标签页重启\n\n直接地址栏输入chrome://restart\n\nchrome直达密码管理：chrome://password-manager"},"__zettel/202412121707redshift使用小记":{"slug":"__zettel/202412121707redshift使用小记","filePath":"__zettel/202412121707redshift使用小记.md","title":"202412121707","links":[],"tags":["redshift","桌面","美化","护眼"],"content":"Redshift是linux桌面护眼程序，配置简单却足够使用。开启后自动根据一天中的时间设置渐变色温（色温范围在日间色温和夜间色温之间）。减少蓝光输出，稍微护眼一点吧。\n# file: .config/redshift.conf\n[redshift]\n# 手动提供位置信息\nlocation-provider=manual\n# 日间温度6000K\ntemp-day=6000\ntemp-night=4500\n \n[manual] # 手动位置信息配置，经纬度，x for secret\nlat=xxx.1\nlon=xxx.8\n命令行redshift可配合脚本使用，另有redshift-gtk供图形化界面使用。\n"},"__zettel/202412131501waydroid使用小记":{"slug":"__zettel/202412131501waydroid使用小记","filePath":"__zettel/202412131501waydroid使用小记.md","title":"202412131501","links":[],"tags":["waydroid","android","linux","container","安卓","容器"],"content":"Waydroid是一款可以在linux体内跑android的容器。不同于虚拟机，它利用容器化技术直接在Linux启动android系统，性能比虚拟机要好得多。目前仅支持Wayland session. 但通过在X session中使用一些compositor也能跑起来。\n顺便说下，waydroid数据目录：/home/yychi/.local/share/waydroid/data.\n使用指南主要参考archwiki.\n\n\n与host共享文件夹，参考此处。\n安装smartdock（一个类似桌面端的launcher）\n\nTroubleshooting\nAndroid容器内无网络\n\n\n                  \n                  Note\n                  \n                \n\nAndroid内部快捷菜单中的wifi按钮开关是假的，没有任何意义。即，无论它的状态是啥跟容器内部有无网络连接无关！\n\n\n\n确保开启iptables和dnsmasq，使用systemctl status &lt;xxx&gt;查看状态\n/usr/lib/waydroid/data/scripts/waydroid-net.sh脚本配置问题，参考这个issue\n\nArm安装包安装失败\n由于waydroid的架构和宿主（host）一致，一般是x86_64. 所以为arm架构编译的apk会安装失败。可以尝试casualsnek的脚本1。\n这里仅提两个坑点：\n\n上面的脚本指导使用python虚拟环境安装依赖包，但是他又要调用waydroid的系统脚本（依赖dbus-python），而且还要sudo权限，sudo完之后很多包会找不到，不如一开始就用系统环境用sudo安装依赖。\n大陆用户可能受网络问题困扰，终端设置ALL_PROXY不再生效，可能是request包不读这个环境变量。我的做法是，直接浏览器下载好放到指定位置，改改代码跳过校验md5，直接安装。\n\nReferences\n\nScript to start Android LineageOS with Waydroid in an X11 session\nNo internet in waydroid\n\nFootnotes\n\n\n这里参考archwiki. ↩\n\n\n"},"__zettel/202412151610pipewire-commands":{"slug":"__zettel/202412151610pipewire-commands","filePath":"__zettel/202412151610pipewire-commands.md","title":"202412151610","links":[],"tags":["av","pulseaudio","audio","linux","pipewire"],"content":"\n\n                  \n                  Disclaimer \n                  \n                \n\nAdapted from kowalcj0.github.io/2022/01/09/handy-pipewire-commands-and-tools/\n\n\nHandy Pipewire commands and tools\nPipeWire provides a nice set of CLI commands and tools to manage and monitor A/V devices on you machine. Here’s a list of those commands with some usage examples:\n\npw-cli - The PipeWire Command Line Interface.\n\nExamples:\npw-cli dump short Node - list all input/output nodes and their state.\npw-cli info 0 - inspect the state of the server.\n\nLists useful details like: clock-rate and allowed clock-rates\n\n\n\n\npw-mon dumps and monitors the state of the PipeWire daemon.\npw-metadata - Monitor, set and delete metadata on PipeWire objects.\n\npw-metadata -n settings - list the current settings.\n\n\npw-dot can dump a graph of the pipeline, check out the help for how to do this.\npw-top monitors the real-time status of the graph. This is handy to find out what clients are running and how much DSP resources they use.\npw-dump dumps the state of the PipeWire daemon in JSON format. This can be used to find out the properties and parameters of the objects in the PipeWire daemon.\npw-link - List, monitor or link input or output ports, e.g.:\n\npw-link --input\npw-link --output\n\n\n\nBTW. you can still use pactl command to control “PulseAudio” sound server, e.g.:\n\npactl info - shows details like server name &amp; version, sink &amp; source names\npactl list - list all clients, cards, their properties, loaded modules etc\npactl list short - same as above but much less verbose\n\n\nMore info:\n\ngithub.com/MusicPlayerDaemon/MPD/issues/1288\ngithub.com/MusicPlayerDaemon/MPD/issues/1263\n"},"__zettel/202412171658imv官包不支持gif":{"slug":"__zettel/202412171658imv官包不支持gif","filePath":"__zettel/202412171658imv官包不支持gif.md","title":"202412171658","links":[],"tags":["imv","image-viewer","linux","tool"],"content":"Archlinux的官方extra/imv不支持gif文件查看，\nextra/imv 4.5.0-4\n    Image viewer for Wayland and X11\n\narchlinuxcn/imv-lily 4.5.0-7 [已安装]\n    Image viewer for Wayland and X11 (with lilydjwg&#039;s patches)\n\n本身imv是支持的，前提是依赖libnsgif库，但它要求libnsgif版本&lt; 1.0.0，但当前最新版本是1.0.0，所以官包打不上这个依赖，没办法带上libnsgif，从而不支持gif查看。而且这个库从0.2.1到1.0.0有很多不兼容变更：\n\n头文件从libnsgif.h改为nsgif.h，diff\n头文件暴露的接口，结构体全部换名字，有的还给删掉了，这直接让之前用这个库的人懵了，diff1, diff2\n\n解决办法有二：\n\n自己下载imv源码，机器上将libnsgif库降级为0.2.1版本，自行编译\n使用依云改过的包archlinuxcn/imv-lily，亲测可以查看gif文件\n\nPS：可使用imv -h查看当前编译信息是否带了libnsgif支持，如下是我自己编译带了libnsgif支持的。\n./imv-x11 -h\nimv v4.5.0\nSee manual for usage information.\nThis version of imv has been compiled with the following backends:\n\nName: FreeImage\nDescription: Open source image library supporting a large number of formats\nWebsite: freeimage.sourceforge.net/\nLicense: FreeImage Public License v1.0\n\nName: libtiff\nDescription: The de-facto tiff library\nWebsite: www.libtiff.org/\nLicense: MIT\n\nName: libpng\nDescription: The official PNG reference implementation\nWebsite: www.libpng.org/pub/png/libpng.html\nLicense: The libpng license\n\nName: libjpeg-turbo\nDescription: Fast JPEG codec based on libjpeg. This software is based in part on the work of the Independent JPEG Group.\nWebsite: libjpeg-turbo.org/\nLicense: The Modified BSD License\n\nName: libRSVG\nDescription: SVG library developed by GNOME\nWebsite: wiki.gnome.org/Projects/LibRsvg\nLicense: GNU Lesser General Public License v2.1+\n\nName: libnsgif\nDescription: Tiny GIF decoding library from the NetSurf project\nWebsite: www.netsurf-browser.org/projects/libnsgif/\nLicense: MIT\n\nName: libheif\nDescription: ISO/IEC 23008-12:2017 HEIF file format decoder and encoder.\nWebsite: www.libheif.org\nLicense: GNU Lesser General Public License\n\nName: libjxl\nDescription: The official JPEGXL reference implementation\nWebsite: jpeg.org/jpegxl/\nLicense: The Modified BSD License\n\nimv&#039;s full source code is published under the terms of the MIT\nlicense, and can be found at sr.ht/~exec64/imv\n\nimv uses the inih library to parse ini files.\nSee github.com/benhoyt/inih for details.\ninih is used under the New (3-clause) BSD license.\n\nPS2：imv官方仓库：git.sr.ht/~exec64/imv"},"__zettel/202412202053simplify":{"slug":"__zettel/202412202053simplify","filePath":"__zettel/202412202053simplify.md","title":"202412202053","links":[],"tags":["笔记","方法论"],"content":"目录结构简化\n附件路径不再使用相对路径\n./assets/${filename}/xxxx\n\n直接迁移至一级目录assets，顺应简单第一原则。\n\n另外摘录一下记笔记原则：\n国外有作者将卡片盒笔记的使用原则总结得非常系统，翻译如下： \n\n原子性原则：这个词是 由 Christian Tietze 创造的，一个笔记只表述一个内容，这样笔记连接起来的指向性更加明确。\n自主原则：每个笔记都应该是独立的，自成一体，包含完整含义，这使得笔记可以独立于相邻位置的卡片进行移动、延伸、分离和串联，就算脱离原始上下文，依然能保证内容的完整性和可读性。\n始终记得链接你的笔记：无论何时添加笔记，请确保将其与内容相关的笔记链接，避免断连，正如卢曼本人所说：“每一个笔记都是引用和反向引用系统网络中的一个元素，笔记的质量就是取决于这个网络，没有被链接起来的笔记，将被 Zettelkasten 遗忘。\n解释你为什么要链接笔记：每当你通过链接连接两个笔记时，一定要简要解释你为什么要链接它们。否则，多年后当你重新查看笔记时，你可能忘记连接它们的原因。\n用你自己的话：不要复制和粘贴 。如果你遇到一个有趣的想法并想将其添加到你的 Zettelkasten 中，你必须用自己的语言表达该想法，确保多年后你还能理解。不要把你的 Zettelkasten 变成一堆复制粘贴的信息。\n保留参考文献：始终在笔记中添加参考文献，以便你知道自己的想法是从哪里获得的 。这可以防止抄袭，并使你以后可以轻松地重新访问原始来源。\n将你自己的想法添加到 Zettelkasten：如果你有自己的想法，请将它们作为笔记添加到 Zettelkasten，同时牢记原子性、自主性和链接需求的原则。\n不要担心笔记结构：不要担心将笔记放在整齐的文件夹中，或者按照先入为主的类别进行归类。正如施密特所说，在 Zettelkasten 这张笔记网中，每一个卡片都没有特权地位，也没有顶部也没有底部，让组织有机地发展。\n添加关联笔记：当你注意到看似随机的笔记之间的内在关联时，请创建关联笔记，该笔记的目的是将其它笔记链接在一起并解释它们之间的关系。\n添加大纲笔记：随着想法开始合并为主题，创建大纲笔记。大纲笔记是只包含一系列指向其他笔记的链接的笔记，将其他笔记按特定顺序排列以创建故事、叙述或论点。（主题索引）\n从不删除：不要删除旧笔记，相反，链接到一条新的笔记去解释旧笔记有什么问题。这样，你的 Zettelkasten 将反映你的思维是如何随着时间的推移而演变的，这将防止 事后偏见。此外，如果你不删除，你可能会重新审视那些可能最终证明是正确的旧想法。\n大胆添加笔记：你的 Zettelkasten 中永远不会被信息塞满，而且，你将添加那些不会立即使用的笔记。就算添加更多笔记也不会破坏你的 Zettelkasten ，或干扰其正常运行。要知道，卢曼在他的 Zettelkasten 中有 90,000 条笔记！\n\nsource: 杨奇的博客"},"__zettel/202412202251ssh问题记录":{"slug":"__zettel/202412202251ssh问题记录","filePath":"__zettel/202412202251ssh问题记录.md","title":"202412202251","links":[],"tags":["ssh","terminfo","troubleshooting","sftp"],"content":"WARNING: terminal is not fully functional\nssh连接服务器时，使用less或vim提示如下信息\nWARNING: terminal is not fully functional  \n- (press RETURN)\n\n其原因是目标机器没有你带过去的terminfo. 例如，我如果使用urxvt或者xterm，带过去的TERM环境变量可能就是目标机器已经有的，所以支持，可以很好的展示颜色，超链接等。如果我用小众一点的terminal emulator，例如kitty，带过去的TERM环境变量可能不受目标机器支持。当然，兼容性最好的是xterm. 所以要么在目标机器bashrc里面export TERM=xterm或者xterm-256color，亦或是安装相应terminal的terminfo. 例如kitty的kitty-terminfo. 此外，ncurses-term里面包含了大量terminfo，可以先装下这个。\n参考：www.linuxquestions.org/questions/ubuntu-63/terminal-is-not-fully-functional-410946/\nsftp error: Received message too long\nsftp连接服务器时，如果报这个错，基本上是因为连上ssh后有标准输出，这使sftp不知道干啥，所以报错。\nThis output confuses the sftp/scp client.  You can verify if your shell is doing this by executing:\nssh &lt;yourhost&gt; /usr/bin/true\n\nIf the above command produces any output, then you need to modify your shell initialization.\n确保连上ssh之后不会有任何输出。\n参考：unix.stackexchange.com/a/84141"},"__zettel/202412212317fcitx5更换systray-icon":{"slug":"__zettel/202412212317fcitx5更换systray-icon","filePath":"__zettel/202412212317fcitx5更换systray-icon.md","title":"202412212317","links":["__zettel/202412212328goldendict更换systray-icon.html"],"tags":["fcitx","systray","icon-theme","美化","linux"],"content":"安装了Papirus图标包（extra/papirus-icon-theme）之后，按照wiki上的教程设置icon-theme，发现fcitx5的托盘图标太暗了，看不清楚。于是想着换一个亮一点的。最后鼓捣发现把图标包设置为Papirus-Dark之后就好了，托盘图标就变亮了。PS，下图最后一个图标是替换过之后的goldendict图标。\n\n"},"__zettel/202412212328goldendict更换systray-icon":{"slug":"__zettel/202412212328goldendict更换systray-icon","filePath":"__zettel/202412212328goldendict更换systray-icon.md","title":"202412212328","links":[],"tags":["icon-theme","goldendict","美化","linux","systray"],"content":"参考：github.com/goldendict/goldendict/issues/1304#issuecomment-732902086\n下图最后一个图标就是goldendict.\n"},"__zettel/202412221603笔记方法论":{"slug":"__zettel/202412221603笔记方法论","filePath":"__zettel/202412221603笔记方法论.md","title":"202412221603","links":["__zettel/202412202053simplify.html"],"tags":["笔记","note","方法论"],"content":"目前遵循卡片法记录笔记。有心得两条：\n\n没有无用的笔记。或多或少会在某个时刻发挥作用，否则你当初干嘛要记？\n没有记错的笔记。如果有，留下他以便追踪改进的历程，知道一开始为啥错了，错在哪了。就和以前练字一样，发现一个字写不好，千万不要写一部分就重写。一定要把它写完。在整体看看是哪里没写好，才能改进。\n\n参见笔记原则6条。"},"__zettel/202412222011termux编译baidupcs":{"slug":"__zettel/202412222011termux编译baidupcs","filePath":"__zettel/202412222011termux编译baidupcs.md","title":"202412222011","links":[],"tags":["baidupcs","termux","android"],"content":"有两种方式编译android版本的baidupcs\n\ntermux直接配好go环境，直接编译\n电脑上下载androind ndk，指定编译架构后编译\n\n我最后使用第一个方案成功。第二个虽然编译成功，放到termux里面运行还是会报dns的问题。最后work的编译命令行\nGOOS=android GOARCH=arm64 CGO_ENABLE=1 go build  \n如果下载依赖过慢，设置一下GOPROXY环境变量，\n$ go env -w GOPROXY=mirrors.aliyun.com/goproxy/,direct\n$ go env | grep GOPROX\nGOPROXY=&#039;mirrors.aliyun.com/goproxy/,direct&#039;\n\n\n                  \n                  关于登录百度账号 \n                  \n                \n\n建议直接使用bduss的方式登录，\n./BaiduPCS-GO login -bduss &lt;your_bduss_string&gt;\n\n账号密码貌似登录不上。bduss获取方式为，打开浏览器，登录pan.baidu.com，查看cookie，找到bduss对应的value即可。\n\n\n参考\n\n使用方案二的参考：web.archive.org/web/20190830041727/http://www.iikira.com/2017/08/09/golang-compile-jc-2/\n报错invalid reference to runtime.rawbyteslice修改方案：github.com/qjfoidnh/BaiduPCS-Go/pull/344/files\nbaidupcs项目地址：github.com/qjfoidnh/BaiduPCS-Go\n"},"__zettel/202412242129rygel使用小记":{"slug":"__zettel/202412242129rygel使用小记","filePath":"__zettel/202412242129rygel使用小记.md","title":"202412242129","links":[],"tags":["rygel","dlna"],"content":"Rygel是一个流媒体服务器，可与支持DLNA/UPnP协议的客户端通信达到局域网文件共享、家庭媒体播放的效果。\n\n在电脑上启动（也可以user unit的方式启动，即systemctl --user start rygel.service）之后，局域网下的客户端就能搜寻到其服务，下图是xplore的DLNA访问截图：\n\n如图，可以在手机上浏览PC上的媒体（图片、视频和音乐），可以直接通过流式播放，也可以下载到本地操作。"},"__zettel/202412251940linux目录结构":{"slug":"__zettel/202412251940linux目录结构","filePath":"__zettel/202412251940linux目录结构.md","title":"202412251940","links":[],"tags":["linux","directory","目录结构"],"content":"三个目录的区别，\n\n/usr: 系统自带的包管理器（如archlinux的pacman）安装的软件包及其产物一般在此目录\n/usr/local: 自己下载源码编译安装的系统级软件包及其产物一般在此目录\n~/.local: 自己安装的用户级软件包及其产物一般在此目录\n"},"__zettel/202412262023qt添加翻译":{"slug":"__zettel/202412262023qt添加翻译","filePath":"__zettel/202412262023qt添加翻译.md","title":"202412262023","links":[],"tags":["qt","多语言"],"content":"QT Application想要支持多语言，需要添加一个项目对应的ts（translation source）文件。每支持一种语言就要添加一个ts文件。同时在cmake中指明翻译文件。\n# LinguistTools是多语言组件\nfind_package(Qt6 CREQUIRED COMPONENTS Widgets LinguistTools)\n \n# translation source (ts)\nset(TS_FILES src/i18n/QWdigetTutorial_zh_CN.ts)\n \nset(PROJECT_SOURCES\n        src/main.cpp\n        src/mainwindow.cpp\n        src/mainwindow.h\n        src/mainwindow.ui\n        ${TS_FILES}\n        textfinder.qrc\n)\n \n# translation target\nqt_create_translation(QM_FILES ${CMAKE_SOURCE_DIR} ${TS_FILES})\nadd_custom_target(translation ALL DEPENDS ${QM_FILES})\nqt_add_lrelease(QM_FILES)\n同时在代码中调用翻译文件，\n// main.cpp\n \nint main(int argc, char *argv[])\n{\n    QApplication a(argc, argv);\n \n    // add a translation\n    QTranslator translator;\n    QLocale locale = QLocale::system(); // get system locale\n    qDebug() &lt;&lt; &quot;syslocale is &quot; &lt;&lt; locale.name();\n    // replace your project name here\n    // something like &quot;QWidgetTutorial_zh_CN&quot;\n    QString basename = &quot;QWdigetTutorial_&quot; + locale.name();\n    if (translator.load(basename)) {\n        a.installTranslator(&amp;translator);\n    }\n \n    MainWindow w;\n    w.setWindowFlags(Qt::Window | Qt::WindowCloseButtonHint);\n    w.show();\n    return a.exec();\n}\n上述代码中直接使用文件名的形式QWidgetTutorial_zh_CN，实际上ts文件会被编译成qm文件使用。上面代码能读到qm文件的条件有二，\n\n可执行文件必须和翻译文件在一个目录\n执行时必须在可执行文件所在目录执行，即使满足条件1，但我像这样执行src/&lt;executable&gt;，那么src目录下的翻译文件是读不到的。也就是执行目录（并不一定是可执行文件所在的目录）下必须有翻译文件（xx.qm）。\n\n例如，linux命令行很多，随着当前目录的变化，执行/usr/bin/ls，他的执行目录也会变化不是吗。\n如何生成ts文件？\n先创建ts文件，大部分时候Qt Creator会帮你创建。空文件长这样，\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;!DOCTYPE TS&gt;\n&lt;TS version=&quot;2.1&quot; language=&quot;zh_CN&quot;&gt;\n&lt;/TS&gt;\n通过在CMakeLists.txt里面指定\nqt_create_translation(QM_FILES ${CMAKE_SOURCE_DIR} ${TS_FILES})\nadd_custom_target(translation ALL DEPENDS ${QM_FILES})\n然后\nmake translation\n\n即可往ts里面填充待翻译的文本，自动从源文件中提取，标记为“unfinished”表示还没翻译。\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;!DOCTYPE TS&gt;\n&lt;TS version=&quot;2.1&quot; language=&quot;zh_CN&quot;&gt;\n&lt;context&gt;\n    &lt;name&gt;MainWindow&lt;/name&gt;\n    &lt;message&gt;\n        &lt;location filename=&quot;../mainwindow.ui&quot; line=&quot;14&quot;/&gt;\n        &lt;source&gt;MainWindow&lt;/source&gt;\n        &lt;translation type=&quot;unfinished&quot;&gt;&lt;/translation&gt;\n    &lt;/message&gt;\n    &lt;message&gt;\n        &lt;location filename=&quot;../mainwindow.ui&quot; line=&quot;32&quot;/&gt;\n        &lt;source&gt;Keyword&lt;/source&gt;\n        &lt;translation type=&quot;unfinished&quot;&gt;&lt;/translation&gt;\n    &lt;/message&gt;\n    &lt;message&gt;\n        &lt;location filename=&quot;../mainwindow.ui&quot; line=&quot;42&quot;/&gt;\n        &lt;source&gt;Find&lt;/source&gt;\n        &lt;translation type=&quot;unfinished&quot;&gt;&lt;/translation&gt;\n    &lt;/message&gt;\n    &lt;message&gt;\n        &lt;location filename=&quot;../mainwindow.ui&quot; line=&quot;65&quot;/&gt;\n        &lt;source&gt;file&lt;/source&gt;\n        &lt;translation type=&quot;unfinished&quot;&gt;&lt;/translation&gt;\n    &lt;/message&gt;\n    &lt;message&gt;\n        &lt;location filename=&quot;../mainwindow.ui&quot; line=&quot;72&quot;/&gt;\n        &lt;source&gt;window&lt;/source&gt;\n        &lt;translation type=&quot;unfinished&quot;&gt;&lt;/translation&gt;\n    &lt;/message&gt;\n    &lt;message&gt;\n        &lt;location filename=&quot;../mainwindow.ui&quot; line=&quot;78&quot;/&gt;\n        &lt;source&gt;help&lt;/source&gt;\n        &lt;translation type=&quot;unfinished&quot;&gt;&lt;/translation&gt;\n    &lt;/message&gt;\n    &lt;message&gt;\n        &lt;location filename=&quot;../mainwindow.ui&quot; line=&quot;89&quot;/&gt;\n        &lt;source&gt;open&lt;/source&gt;\n        &lt;translation type=&quot;unfinished&quot;&gt;&lt;/translation&gt;\n    &lt;/message&gt;\n    &lt;message&gt;\n        &lt;location filename=&quot;../mainwindow.ui&quot; line=&quot;94&quot;/&gt;\n        &lt;source&gt;close&lt;/source&gt;\n        &lt;translation type=&quot;unfinished&quot;&gt;&lt;/translation&gt;\n    &lt;/message&gt;\n    &lt;message&gt;\n        &lt;location filename=&quot;../mainwindow.ui&quot; line=&quot;99&quot;/&gt;\n        &lt;source&gt;about&lt;/source&gt;\n        &lt;translation type=&quot;unfinished&quot;&gt;&lt;/translation&gt;\n    &lt;/message&gt;\n&lt;/context&gt;\n&lt;/TS&gt;\n然后通过Qt Creator自带的linguist工具添加翻译即可。\nlinguist QWdigetTutorial_zh_CN.ts\n翻译完成之后，再make translation一些即可编译出翻译好的QWdigetTutorial_zh_CN.qm文件，程序直接读取他即可达到翻译效果。"},"__zettel/202501082036suckless-windows":{"slug":"__zettel/202501082036suckless-windows","filePath":"__zettel/202501082036suckless-windows.md","title":"202501082036","links":[],"tags":["定制","windows","suckless","msys2"],"content":"Windows毛病例举，\n\n祖传蓝屏（这一点在xp尤为严重，win7以上已经少见许多）。\n静默更新。悄悄下载更新，强制更新，莫名其妙跳出来说要更新，关机时强迫更新。恶心的默认策略！\n万年难用的资源管理器，不带标签页，窗口开一堆。\n开发上来说，编译工具链体验比不上linux.\n\n虽然Windows很难用，但并不妨碍它桌面市场占用率第一的地位。在生活或者工作中，我还是无法避免地被动使用windows. 因此，我希望通过一些简单定制，让我的使用体验能好一些。\n安装MSYS2\n如果你在windows上做开发，必定会装git bash，而它提供的终端就是MINGW（Minimalist GNU for Windows）。它的主要作用是提供windows版本的gcc编译工具链。它自带了一些linux基础命令，仅仅是基础。所以MSYS2出现了，它在MINGW的基础上，提供了更多的命令，并且自带了一个著名的包管理器—Pacman. 没错就是Archlinux的包管理器。如此一来便可以在在windows上使用相同的linux命令行，而这些都是适配原生windows的，并非虚拟机或者子系统之类的。并且想要啥软件包，直接通过pacman安装也非常方便。\nMinGW、Clang、UCRT？\n安装完之后，会产生多个launcher，选择哪个呢？这里有详细的对比。其实就是工具链和运行时库的区别。一般用gcc建议选择MINGW64，用llvm建议使用CLANG64.\n一点配置\n网上的配置帖子还是比较多的，这里简单列举几个常用的。\n修改镜像\n/etc/pacman.d 文件夹里面包含几个mirrorlist，新版的MSYS2里面默认已经有中科大源。直接编辑将其提前即可。\nServer = mirrors.ustc.edu.cn/msys2/\nServer = mirrors.tuna.tsinghua.edu.cn/msys2/\n\n禁用某些源\n编辑/etc/pacman.conf，注释掉不想要的源。\n\n\n                  \n                  Attention\n                  \n                \n\nvim和zsh在mingw里面，mingw64和clang64里面都没有。\n\n\n参考：my.oschina.net/zuozhihua/blog/8757266\n继承环境变量\n如果你之前安装过git bash，现在你的电脑里面应该有两套mingw（一个git bash安装的，一个是MSYS2安装的）。Git bash里面自带vim. 而MSYS2里面可以通过包管理器安装vim. 然而重要的是windows系统程序的路径需要继承下来，这样可以方便的在mingw里面直接调用windows程序例如\n\nnotepad.exe：记事本\ncmd：命令提示符\nexplorer：文件管理器\n\n要继承windows系统环境变量，找到MSYS2的安装目录（例如，D:\\msys64）下有mingw64.ini，将里面的\nMSYS2_PATH_TYPE=inherit\n\n取消注释，再次打开mingw64即可继承系统环境变量。\n\n上面只改了MinGW64的launcher，如要改其他可如法炮制。\n\n更改默认shell\nlauncher.ini（例如mingw64.ini）里面添加环境变量\nSHELL=/usr/bin/zsh\n\n参考：superuser.com/questions/961699/change-default-shell-on-msys2\n添加到vscdoe集成终端\n设置里面加上，参考：gist.github.com/dhkatz/106891324c9624074a84d11e2691144b\n{\n    &quot;terminal.integrated.defaultProfile.windows&quot;: &quot;MSYS2 MINGW64&quot;,\n    &quot;terminal.integrated.profiles.windows&quot;:{\n        &quot;MSYS2 MINGW64&quot;: {\n            &quot;path&quot;: &quot;D:\\\\msys64\\\\usr\\\\bin\\\\bash.exe&quot;,\n            &quot;args&quot;: [&quot;--login&quot;, &quot;-i&quot;],\n            &quot;env&quot;: {\n                &quot;MSYSTEM&quot;: &quot;MINGW64&quot;,\n                &quot;CHERE_INVOKING&quot;: &quot;1&quot;,\n                &quot;MSYS2_PATH_TYPE&quot;: &quot;inherit&quot;\n            }\n        },\n        &quot;PowerShell&quot;: {\n            &quot;source&quot;: &quot;PowerShell&quot;,\n            &quot;icon&quot;: &quot;terminal-powershell&quot;\n        },\n        &quot;Command Prompt&quot;: {\n            &quot;path&quot;: [\n                &quot;${env:windir}\\\\Sysnative\\\\cmd.exe&quot;,\n                &quot;${env:windir}\\\\System32\\\\cmd.exe&quot;\n            ],\n            &quot;args&quot;: [],\n            &quot;icon&quot;: &quot;terminal-cmd&quot;\n        },\n        &quot;Git Bash&quot;: {\n            &quot;source&quot;: &quot;Git Bash&quot;\n        }\n    }\n}\n安装Everything\nEverything是一个windows文件搜索程序，搜索速度快，轻量易用，支持正则表达式。完爆windows资源管理器自带的搜索功能。直接至官网下载安装即可。\n安装QtTabBar\nQtTabBar是一款windows资源管理器扩展工具。之前说了，windows自带的文件管理器不支持标签页。这才有了QtTabBar. 值得一提的功能点：\n\n深度资源管理器标签支持，甚至控制面板都是一个标签页的事儿。\n支持用户自定义组，放置常用路径（类似于书签）。\n支持多语言，官网下载翻译包即可。\n桌面快捷操作。桌面双击即可触发浮动菜单，常用路径一键即达。\n不俗的文件预览功能。鼠标悬停即可预览目录、图片、视屏等。预览图片真的很实用！\n\n微软拼音添加小鹤双拼\n作为双拼爱好者，当初去知乎吸收了一下各种双拼方案对比，决定学小鹤，至今已经忘记它有啥优缺点了，反正用着挺好就是了。\n方案来自互联网。在CMD中直接粘贴\nreg add HKCU\\Software\\Microsoft\\InputMethod\\Settings\\CHS /v UserDefinedDoublePinyinScheme0 /t REG_SZ /d &quot;小鹤双拼*2*^*iuvdjhcwfg^xmlnpbksqszxkrltvyovt&quot; /f\n\nPS，微软大法好！在曾经的XP时代，搜狗拼音还是很好用的，如今已是臃肿不堪。后来一直在找替代，知道微软拼音横空出世。至此windows输入法无需再纠结。其界面节约，打字流畅，又支持添加小鹤双拼，已经很够用了！\n另辟蹊径之linux虚拟机\n无论是WSL还是MSYS2，启动起来都有些卡，而且换zsh之后就更卡了。目前还不清楚原因，所以才有了这种尝试。Windows下可以使用virtualbox安装一个linux虚拟机，然后开启sshd，配置好端口转发（或者虚拟网卡）即可在宿主机上ssh连接虚拟机，体验上和linux远程开发机相差无几。\n使用VirtualBox安装一个Archlinux虚拟机重点步骤：\n\n安装VirtualBox\n下载archlinux镜像（LiveCD）\n从镜像启动虚拟机，执行安装流程，这一步参考archwiki中的installation guide\n\n值得注意的是，虚拟磁盘创建分区的时候，建议直接选择MBR分区表。我一开始选择GPT分区表，多挂载一个boot分区，反复装了3次，装完启动引导重启都提示找不到可启动的设备。反正是虚拟机，也不用考虑引导多个系统，直接MBR分区表，还可以少挂载一个boot分区。\n装完之后安装一些常用软件，\n\nvim\nzsh\nopenssh\nNetworkManager\n\n\n\n                  \n                  Attention\n                  \n                \n\nLiveCD里面网络配置是开箱即用的，但这并不表示装好的系统网络配置和LiveCD一样。当你兴奋地重启进新系统之后，很可能发现里面没网。因此，一定要在安装过程中（arch-chroot）把网络管理器的包装好。\n\n\n启动进新系统之后，\nsystemctl start NetworkManager.service  # 启动网络管理器\nsystemctl enable NetworkManager.service # 设为自动启动\n配置端口转发\n系统启动之后，不必装图形界面。直接启动一个ssh sever，然后在windows上ssh连上即可。使用体验和远程Linux开发机一致。但宿主机（Host）和虚拟机（VM）的网络不一定直接相通，还须做一点配置。\n端口转发配置参考SSH连接NAT网络模式VirtualBox虚拟机。\n\n配置固定IP\n端口转发配置简单易用，但有一个小缺点。每次暴露一个端口，都需要新增一条规则。比如我转发22端口给ssh，那我sftp的23端口呢？这时候又得新增一条规则，比较麻烦。\n我们可以通过增加一张虚拟网卡，配置静态IP地址和主机网络互通。此后直接访问这个IP带端口即可访问虚拟机。配置参考Win10宿主机ssh连接VirtualBox里的archlinux虚拟机。\n需要注意一点，配置接口（interface）静态地址并使之持久化生效是网络管理器的职责。所以一定要通过网络管理器的接口设置IP地址。之前安装的NetworkManager提供nmcli命令行配置工具。详细用法参考NetworkManager - ArchWiki.\n使用示例，\nyychi@~/bin&gt; nmcli dev\nDEVICE          TYPE      STATE         CONNECTION \nwlp2s0          wifi      已连接        LovelyLife \nlo              loopback  连接（外部）  lo\n \nyychi@~/bin&gt; nmcli connection\nNAME                  UUID                                  TYPE      DEVICE \nLovelyLife            92506e38-1823-4f66-1a89-75a62ecabe74  wifi      wlp2s0 \nlo                    7e2fe31d-8ba1-1823-ad29-239857601abb  loopback  lo     \n \nyychi@~/bin&gt; nmcli connection edit LovelyLife\n \n===| nmcli 交互式连接编辑器 |===\n \n正在编辑已有的连接 &quot;802-11-wireless&quot;：&quot;LovelyLife&quot;\n \n输入 &quot;help&quot; 或 &quot;?&quot; 查看可用的命令。\n输入 &quot;print&quot; 来显示所有的连接属性。\n输入 &quot;describe [&lt;设置&gt;.&lt;属性&gt;]&quot; 来获得详细的属性描述。\n \n您可编辑下列设置：connection, 802-11-wireless (wifi), 802-11-wireless-security (wifi-sec), 802-1x, ethtool, match, ipv4, ipv6, hostname, link, tc, proxy\nnmcli&gt; set ipv4.addresses 192.168.56.100/24\nnmcli&gt; set ipv4.gateway 192.168.56.1\nnmcli&gt; save \npersistent  temporary   \nnmcli&gt; save persistent \n成功地更新了连接 &quot;MeijmTenda&quot; (ab876b5a-a02e-43c5-8d65-8da29891b0c1)。\n配置ssh别名\n在宿主机（Host）上配置，\n# FILE:~/.ssh/config\n \nHost varch\n    HostName 192.168.56.100\n    User xxxx\n此后就可以直接ssh varch了。\n小结\n至此，我在windows上安装了一些小工具、配置了一个可用的linux环境。与我个人来说，大幅提升了windows的易用性。"},"__zettel/202501092242archlinux安装指定版本包":{"slug":"__zettel/202501092242archlinux安装指定版本包","filePath":"__zettel/202501092242archlinux安装指定版本包.md","title":"202501092242","links":[],"tags":["linux","包管理","package"],"content":"首先在aur上搜索，如gcc-4.8，\naur.archlinux.org/packages/gcc48\n然后下载snapshot文件，\n\n下载完了解压，cd到解压后的目录直接makepkg即可。\n\n注意⚠️：此时可以随便改改PKGBUILD文件，想怎么折腾就怎么折腾。\n\n更简单的方法（推荐）\n使用yay（aur包管理器）直接安装，前提先在aur搜索包名\nyay -S gcc48"},"__zettel/202501211106kroki-sample":{"slug":"__zettel/202501211106kroki-sample","filePath":"__zettel/202501211106kroki-sample.md","title":"202501211106","links":[],"tags":["kroki","draw","画图","uml","digram"],"content":"先安装一下obsidian插件kroki，然后可用。\n\nblockdiag {\n  Kroki -&gt; generates -&gt; &quot;Block diagrams&quot;;\n  Kroki -&gt; is -&gt; &quot;very easy!&quot;;\n \n  Kroki [color = &quot;greenyellow&quot;];\n  &quot;Block diagrams&quot; [color = &quot;pink&quot;];\n  &quot;very easy!&quot; [color = &quot;orange&quot;];\n}\n@startmindmap\nskinparam monochrome true\n+ OS\n++ Ubuntu\n+++ Linux Mint\n+++ Kubuntu\n+++ Lubuntu\n+++ KDE Neon\n++ LMDE\n++ SolydXK\n++ SteamOS\n++ Raspbian\n-- Windows 95\n-- Windows 98\n-- Windows NT\n--- Windows 8\n--- Windows 10\n@endmindmap\n@startuml\n \ninterface RefCounted\nabstract class RefCountedImplT&lt;T&gt;\nRefCounted &lt;|.. RefCountedImplT\n \n&#039; Publisher hierarchy\nclass Publisher\nclass PublisherImpl\nclass TCPPublisher  \nclass RedisPublisher\nclass MulticastPublisher \nclass WebsocketPublisher\n \nRefCountedImplT &lt;|-- Publisher\nPublisher &lt;|-- PublisherImpl\nPublisher &lt;|-- TCPPublisher\nPublisher &lt;|-- RedisPublisher  \nPublisher &lt;|-- MulticastPublisher\nPublisher &lt;|-- WebsocketPublisher\n \n&#039; Service hierarchy  \nclass Service\nclass SHL1HandlerThread\nclass SHL2HandlerThread  \nclass SZL1HandlerThread\nclass SZL2HandlerThread\nclass HKExHandlerThread\nclass NEEQHandlerThread\nclass MessageForwardHandler\nclass ReplayHandler\nclass XSHEHandlerThread\nclass MessageConvertHandler\nclass XSHEL1Forward\nclass L2RebuildHandler\n \nRefCountedImplT &lt;|-- Service\nService &lt;|-- SHL1HandlerThread\nService &lt;|-- SHL2HandlerThread\nService &lt;|-- SZL1HandlerThread\nService &lt;|-- SZL2HandlerThread \nService &lt;|-- HKExHandlerThread\nService &lt;|-- NEEQHandlerThread\nService &lt;|-- MessageForwardHandler\nService &lt;|-- ReplayHandler\nService &lt;|-- XSHEHandlerThread\nService &lt;|-- MessageConvertHandler\nService &lt;|-- XSHEL1Forward\nService &lt;|-- L2RebuildHandler\n \n&#039; Connection hierarchy\nclass Connection\nclass TCPConnection\nclass RedisConnection\nclass WebsocketConnection\nclass MulticastConnection\n \nRefCountedImplT &lt;|-- Connection\nConnection &lt;|-- TCPConnection\nConnection &lt;|-- RedisConnection\nConnection &lt;|-- WebsocketConnection\nConnection &lt;|-- MulticastConnection\n \n&#039; IOManager hierarchy\nclass IOManager\nclass IOManagerImpl\n \nRefCountedImplT &lt;|-- IOManager\nIOManager &lt;|-- IOManagerImpl\n \n&#039; Thread hierarchy\nclass Thread\nclass ASIOThread\nclass WorkerThread\nclass TimerThread\n \nRefCountedImplT &lt;|-- Thread\nThread &lt;|-- ASIOThread\nThread &lt;|-- WorkerThread\nThread &lt;|-- TimerThread\n \n&#039; Other classes\nclass HTTPHandler\nclass MessageQueue\nclass BlockingQueue\nclass RingBuffer\nclass SubscriberManager\nclass MessageDispatcher\n \nRefCountedImplT &lt;|-- HTTPHandler\nRefCountedImplT &lt;|-- MessageQueue\nMessageQueue &lt;|-- BlockingQueue\nMessageQueue &lt;|-- RingBuffer\nRefCountedImplT &lt;|-- SubscriberManager\nRefCountedImplT &lt;|-- MessageDispatcher\n \n@enduml\n$r = 0.2in\nlinerad = 0.75*$r\nlinewid = 0.25\n \n# Start and end blocks\n#\nbox &quot;element&quot; bold fit\nline down 50% from last box.sw\ndot rad 250% color black\nX0: last.e + (0.3,0)\narrow from last dot to X0\nmove right 3.9in\nbox wid 5% ht 25% fill black\nX9: last.w - (0.3,0)\narrow from X9 to last box.w\n \n \n# The main rule that goes straight through from start to finish\n#\nbox &quot;object-definition&quot; italic fit at 11/16 way between X0 and X9\narrow to X9\narrow from X0 to last box.w\n \n# The LABEL: rule\n#\narrow right $r from X0 then down 1.25*$r then right $r\noval &quot; LABEL &quot; fit\narrow 50%\noval &quot;\\&quot;:\\&quot;&quot; fit\narrow 200%\nbox &quot;position&quot; italic fit\narrow\nline right until even with X9 - ($r,0) \\\n  then up until even with X9 then to X9\narrow from last oval.e right $r*0.5 then up $r*0.8 right $r*0.8\nline up $r*0.45 right $r*0.45 then right\n \n# The VARIABLE = rule\n#\narrow right $r from X0 then down 2.5*$r then right $r\noval &quot; VARIABLE &quot; fit\narrow 70%\nbox &quot;assignment-operator&quot; italic fit\narrow 70%\nbox &quot;expr&quot; italic fit\nline right until even with X9 - ($r,0) \\\n  then up until even with X9 then to X9\n \n# The PRINT rule\n#\narrow right $r from X0 then down 3.75*$r then right $r\noval &quot;\\&quot;print\\&quot;&quot; fit\narrow\nbox &quot;print-args&quot; italic fit\nline right until even with X9 - ($r,0) \\\n  then up until even with X9 then to X9\n@startuml\n&#039; Base Classes\ninterface RefCounted {\n  +{abstract} AddRef()\n  +{abstract} ReleaseRef()\n}\n \nabstract class RefCountedImplT&lt;T&gt; {\n  #m_RefCount: volatile int\n  +AddRef()\n  +ReleaseRef()\n}\n \n&#039; Core Infrastructure\npackage &quot;Core&quot; {\n  class IOManager\n  class IOManagerImpl\n  class Connection\n  class Publisher\n  class Service\n  class Thread\n}\n \n&#039; Network Classes\npackage &quot;Network&quot; {\n  class TCPConnection\n  class WebSocketConnection\n  class MulticastConnection\n  class RedisConnection\n}\n \n&#039; Market Data Services  \npackage &quot;MarketData&quot; {\n  class SHMarketHandler\n  class SZMarketHandler\n  class HKMarketHandler\n  class L1Handler\n  class L2Handler\n}\n \n&#039; Threading\npackage &quot;Threading&quot; {\n  class ASIOThread\n  class WorkerThread\n  class TimerThread\n}\n \n&#039; Publishers\npackage &quot;Publishers&quot; {\n  class TCPPublisher\n  class WebSocketPublisher\n  class MulticastPublisher\n  class RedisPublisher\n}\n \n&#039; Inheritance\nRefCounted &lt;|.. RefCountedImplT\nRefCountedImplT &lt;|-- IOManager\nRefCountedImplT &lt;|-- Connection\nRefCountedImplT &lt;|-- Publisher\nRefCountedImplT &lt;|-- Service\nRefCountedImplT &lt;|-- Thread\n \nIOManager &lt;|-- IOManagerImpl\n \nConnection &lt;|-- TCPConnection\nConnection &lt;|-- WebSocketConnection\nConnection &lt;|-- MulticastConnection\nConnection &lt;|-- RedisConnection\n \nThread &lt;|-- ASIOThread\nThread &lt;|-- WorkerThread\nThread &lt;|-- TimerThread\n \nPublisher &lt;|-- TCPPublisher\nPublisher &lt;|-- WebSocketPublisher\nPublisher &lt;|-- MulticastPublisher\nPublisher &lt;|-- RedisPublisher\n \nService &lt;|-- SHMarketHandler\nService &lt;|-- SZMarketHandler\nService &lt;|-- HKMarketHandler\nService &lt;|-- L1Handler\nService &lt;|-- L2Handler\n \n@enduml"},"__zettel/202501241043创建软连接的路径问题":{"slug":"__zettel/202501241043创建软连接的路径问题","filePath":"__zettel/202501241043创建软连接的路径问题.md","title":"202501241043","links":[],"tags":["linux","softlink","软连接","ln-command"],"content":"一个可能违反直觉的事实！\n例如：\ntree\n.\n├── a\n├── bar\n└── foo\n    └── fooa\n \n3 directories, 2 files\n \ncd bar\nln -sf ../foo/fooa ../foo/fooa-link\nln -sf ../foo/fooa fooa-link\nln -sf ../a ../a-link # yields broken link\nln -sf ../a a-link\nln -sf fooa ../foo/wtf-fooa\nln -sf a ../wft-a\ntree ..\n..\n├── a\n├── a-link -&gt; ../a # broken link\n├── bar\n│   ├── a-link -&gt; ../a\n│   └── fooa-link -&gt; ../foo/fooa\n├── foo\n│   ├── fooa\n│   ├── fooa-link -&gt; ../foo/fooa\n│   └── wft-fooa -&gt; fooa\n└── wft-a -&gt; a\n \n3 directories, 8 files\n由此得出，\nln -sf &lt;target&gt; &lt;link&gt;\n\n务必好好理解下面这句话，\n\n\n                  \n                  Attention\n                  \n                \n\ntarget的路径是相对于link的路径来的，如果link和target同路径，target压根不用带目录，在link中指定目录即可。"},"__zettel/202502141432tar命令的小坑":{"slug":"__zettel/202502141432tar命令的小坑","filePath":"__zettel/202502141432tar命令的小坑.md","title":"202502141432","links":[],"tags":["tar","备份"],"content":"202502141432\n先看一条tar命令\ncd $HOME\ntar -cvpaf ../home.tgz * --exclude-caches --exclude-caches-all --exclude-vcs --exclude-tag-all=&quot;skip_tar.tag&quot;\n\n一看以为是备份home目录，结果输出发现你想排除的目录压根没有排除，这是因为，—exclude选项要放在前面，改成这样就行了\ntar --exclude-caches-all --exclude-vcs --exclude-tag-all=skip_tar.tag -cvpaf ../home.tgz *\n\n然后这里还有一个坑，你以为*会包含隐藏目录？不会的，试试echo *。一般的，*在ls命令和bash展开中不会包含隐藏文件（即以.开头的文件），但是tar不care（find命令也不care），但这里写的*其实是bash展开。正确写法应该是\ntar --exclude-caches-all --exclude-vcs --exclude-tag-all=skip_tar.tag -cvpaf ../home.tgz .\n\n这样tar的目标是当前目录，而tar默认会包含隐藏文件。\nsee: unix.stackexchange.com/a/31976"},"__zettel/202502181641virtualbox虚拟机断网问题":{"slug":"__zettel/202502181641virtualbox虚拟机断网问题","filePath":"__zettel/202502181641virtualbox虚拟机断网问题.md","title":"202502181641","links":[],"tags":["route","virtualbox","网络","路由"],"content":"问题背景\n公司电脑上用virtualbox安装了archlinux虚拟机，使用自带的nat网卡默认可以访问外网。此外配置了一个host-only网卡用于和宿主机（host）互相访问。遇到一个奇怪的问题就是，自虚拟机重启一天之内，nat网卡可以正常上网（ping baidu.com通），一天后就上不了网了。\n尝试\n将宿主机网卡共享给host-only网卡，让虚拟机通过host-only网卡上网，一开始配置完好使了一段时间，第二天来又不行了，原因不明。\n最后的解决方案（伪）\n\n升级virtualbox版本\n配置路由规则，优先使用nat网卡访问外网\n\n$ ip route\ndefault via 10.0.2.2 dev enp0s3 proto dhcp src 10.0.2.15 metric 100 \ndefault via 192.168.137.1 dev enp0s8 proto static metric 234 # 主动设置\n10.0.2.0/24 dev enp0s3 proto kernel scope link src 10.0.2.15 metric 100 \n10.0.2.2 dev enp0s3 proto dhcp scope link src 10.0.2.15 metric 100 \n192.168.137.0/24 dev enp0s8 proto kernel scope link src 192.168.137.200 \n10.2.2.2是nat网卡的网关，192.168.137.1是host-only网卡的网关。将metric值设大些，流量会优先从metric值小的路由走。\n一天之后，仍然可以访问外网。不知道是升级virtualbox版本解决的还是设置路由优先级解决的。\n谨此记录，备日后用。\n真！现在的解决方案\n偶然发现，virtualbox的多个虚拟机使用nat网络的接口ip一样（默认都是10.0.2.15），稍加探索发现每个虚拟机都有一套自己的nat网络，互相独立。所以不同虚拟机的nat网关（10.0.2.2）其实不是同一个实例。随之，通过全局设定添加一个nat网关，把两个虚拟机的nat网络配置均改为新增的全局nat网关。发现两个虚拟机的ip地址有所不同，且在同一网段。且nat网关的地址变更为10.0.2.1. 更神奇的是，如果上面的断网问题发生了，不用关闭虚拟机，通过改nat网卡的配置，改完虚拟机又有网了！虽然不是根本的解决方案，至少可以不关机让它再次有网了！且看第二天会不会断网吧。\nupdate: 实践证明：没有断网！！！！！\n\n\n                  \n                  Attention\n                  \n                \n\n一定要用全局NAT网络！\n\n\n\n配置参考：blog.csdn.net/qq_51153463/article/details/123966124"},"__zettel/202502181657gdb-attach":{"slug":"__zettel/202502181657gdb-attach","filePath":"__zettel/202502181657gdb-attach.md","title":"202502181657","links":["notes/cpp/gdb基础.html","__zettel/202307051438CPP调试-coredump.html"],"tags":["gdb","debug","调试","attach"],"content":"gdb attach到正在运行的程序上进行调试，\ngdb program &lt;pid_of_program&gt;\n \n# examples\ngdb firefox 1234\ngdb -p 1234\ngdb -p `pidof firefox` # combined with pidof\n使用pidof &lt;pattern&gt;可以直接返回命令的pid，在只运行一个实例的情况下，很好用。\ngdb调试coredump\ngdb program &lt;corefile&gt;\nFrom gdb manual,\n   You can run &quot;gdb&quot; with no arguments or options; but the most usual way to start GDB is with one argument or two, specifying an executable program as the argument:\n\n           gdb program\n\n   You can also start with both an executable program and a core file specified:\n\n           gdb program core\n\n   You can, instead, specify a process ID as a second argument or use option &quot;-p&quot;, if you want to debug a running process:\n\n           gdb program 1234\n           gdb -p 1234\n\n   would attach GDB to process 1234.  With option -p you can omit the program filename.\n\n"},"__zettel/202502201432python-paramiko使用小记":{"slug":"__zettel/202502201432python-paramiko使用小记","filePath":"__zettel/202502201432python-paramiko使用小记.md","title":"202502201432","links":[],"tags":["paramiko","python","ssh"],"content":"paramiko是一个python ssh库，提供python api去执行ssh操作，包括但不限于登录远程机器（ssh），执行远程命令，sftp上传下载文件。\n# env: python3\nimport os\nimport tarfile\nimport subprocess\nimport paramiko\nimport paramiko.util\nparamiko.util.log_to_file(&quot;paramiko.log&quot;)\n \n \ndef notify(*msg, **kwargs):\n    print(&quot;--- &quot;, *msg, **kwargs)\n \ndef tar_dir(dir_path, tar_path):\n    &quot;&quot;&quot; Tar a directory `dir_path` to a tar file. &quot;&quot;&quot;\n    if tar_path.endswith(&quot;.gz&quot;) or tar_path.endswith(&quot;.tgz&quot;):\n        mode = &quot;w:gz&quot;\n    elif tar_path.endswith(&quot;.bz2&quot;):\n        mode = &quot;w:bz2&quot;\n    elif tar_path.endswith(&quot;.xz&quot;):\n        mode = &quot;w:xz&quot;\n    else:\n        mode = &quot;w&quot;\n    with tarfile.open(tar_path, mode) as tar:\n        tar.add(dir_path, arcname=os.path.basename(dir_path))\n \ndef untar_file(tar_path, target_dir):\n    with tarfile.open(tar_path, &quot;r&quot;) as tar:\n        tar.extractall(target_dir)\n \ndef test_tar():\n    tar_dir(&quot;./&quot;, &quot;/home/bingbing.hu/my.tar.gz&quot;)\n    untar_file(&quot;/home/bingbing.hu/my.tar.gz&quot;, &quot;/home/bingbing.hu/mytar_gz_extracted&quot;)\n \nclass CommandRunException(Exception):\n    pass\n \n \nclass NodeConf(object):\n    HOST = &quot;&quot;\n    PORT = 22\n    USERNAME = &quot;fuck&quot;\n    PASSWORD = &quot;you&quot;\n \nclass NewApiDevNode(NodeConf):\n    HOST = &quot;1.2.3.4&quot;\n \nclass SSHConnection(object):\n    def __init__(self, host=&quot;&quot;, password=&quot;&quot;, username=&quot;bingbing.hu&quot;, port=22) -&gt; None:\n        self.host = host\n        self.password = password\n        self.username = username\n        self.port = port\n        self._client = None      # type: paramiko.SSHClient | None\n        self._sftp_client = None # type: paramiko.SFTPClient | None\n \n    def close(self):\n        if self._client is not None:\n            self._client.close()\n        if self._sftp_client is not None:\n            self._sftp_client.close()\n        self._client = None\n        self._sftp_client = None\n \n    def re_init(self, node_cls):\n        &quot;&quot;&quot; Re-init the node with a NodeConf class. &quot;&quot;&quot;\n        self.host = node_cls.HOST\n        self.password = node_cls.PASSWORD\n        self.username = node_cls.USERNAME\n        self.port = node_cls.PORT\n        if self._client is not None:\n            self._client.close()\n            self._client = None\n        self.get_client()\n \n    def get_client(self):\n        if self._client is None:\n            self._client = ssh = paramiko.SSHClient()\n            ssh.load_system_host_keys()\n            ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n            ssh.connect(self.host, self.port, self.username, self.password)\n        return self._client\n \n    def get_sftp_client(self):\n        if self._sftp_client is None:\n            self._sftp_client = self.get_client().open_sftp()\n        return self._sftp_client\n \n    def excute(self, cmd):\n        stdin, stdout, stderr = self.get_client().exec_command(cmd)\n        return self.__handle_cmd_output(stdout, stderr, cmd)\n \n    def excute_with_sudo(self, cmd):\n        stdin, stdout, stderr = self.get_client().exec_command(&quot;sudo -S %s&quot; % cmd)\n        stdin.write(self.password + &quot;\\n&quot;)\n        stdin.flush()\n        return self.__handle_cmd_output(stdout, stderr, cmd)\n \n    @staticmethod\n    def __handle_cmd_output(stdout: paramiko.ChannelFile, stderr: paramiko.ChannelFile, cmd: str) -&gt; int:\n        status = stdout.channel.recv_exit_status()\n        if status != 0:\n            raise CommandRunException(\n                &quot;Excute &#039;%s&#039; failed with status %d.\\n\\n%s&quot;\n                % (cmd, status, stderr.read().decode()))\n        for line in stdout:\n            print(line, end=&quot;&quot;)\n        return status\n \n    def upload(self, local_path, remote_path):\n        if not os.path.exists(local_path):\n            raise FileNotFoundError(&quot;Local file %s not found.&quot; % local_path)\n        if remote_path[-1] == &#039;/&#039;: # treat remote_path as a directory\n            self.__ensure_remote_path(remote_path)\n            filename = os.path.basename(local_path)\n            remote_path += filename\n        notify(&quot;Uploading %s to %s&quot; % (local_path, remote_path))\n \n        # \\r is used to move cursor to the beginning of the line.\n        cb = lambda x, y: notify(f&quot;Uploaded {x}/{y}\\r&quot;, end=&quot;&quot;, flush=True)\n        self.get_sftp_client().put(local_path, remote_path, callback=cb)\n        print(&#039;&#039;) # used to remove the last \\r\n \n    def download(self, remote_path, local_path):\n        if remote_path[-1] == &#039;/&#039;:\n            raise ValueError(&quot;Remote path should be a file path.&quot;)\n        local_file = local_path\n        if local_path[-1] == &#039;/&#039;:\n            local_dir = local_path[:-1]\n            local_file = os.path.join(local_path, os.path.basename(remote_path))\n        else:\n            local_dir = os.path.split(local_path)[0]\n        if not os.path.exists(local_dir):\n            os.makedirs(local_dir)\n \n        sftp = self.get_sftp_client()\n        notify(&quot;Downloading %s to %s&quot; % (remote_path, local_file))\n \n        # \\r is used to move cursor to the beginning of the line.\n        cb = lambda x, y: print(f&quot;\\rDownloaded {x}/{y}&quot;, end=&quot;&quot;, flush=True)\n        sftp.get(remote_path, local_file, callback=cb)\n \n    def __ensure_remote_path(self, remote_path):\n        self.excute(f&quot;&quot;&quot;\n            if [ ! -d {remote_path} ]; then\n                mkdir -p {remote_path}\n            fi\n            &quot;&quot;&quot;)\n \ndef deploy_newapi_dev():\n    conn = SSHConnection()\n    conn.re_init(NewApiDevNode)\n \n    # code_root = os.path.expanduser(&quot;~/code/newapi&quot;)\n    # print(code_root)\n \n    args = [&quot;/datayes/api_dev/bin&quot;, &quot;api_service.tar.gz&quot;]\n    # subprocess.check_call([&quot;make&quot;, &quot;-C&quot;, *args])\n    local_file = &#039;/&#039;.join(args)\n    conn.upload(local_file, &#039;./&#039;)\n    conn.excute(f&quot;&quot;&quot;\n    mkdir ttt\n    tar -xavf {args[1]} -C ttt\n&quot;&quot;&quot;)\n    conn.close()\n \ndef test_connection():\n    conn = SSHConnection()\n    conn.re_init(NewApiDevNode)\n \n    a = conn.excute(&quot;pwd;df -h&quot;)\n    conn.excute_with_sudo(&quot;apt list --upgradable | head -n5&quot;)\n    conn.excute(&quot;&quot;&quot;\ncd /tmp\nmkdir -p test\ncd test\npwd\ntouch {a,b,c}\nls -l&quot;&quot;&quot;)\n \n    conn.upload(&quot;main.py&quot;, &quot;./areyouok/&quot;)\n    # conn.excute(&quot;./a.out&quot;)\n    # node.get_sftp_client().put(&quot;main.py&quot;, &quot;main.py&quot;)\n    conn.download(&quot;./api_etc.tar&quot;, &quot;./from_remote.tar&quot;)\n    conn.close()\n    print(NewApiDevNode.PASSWORD)\n    print(NewApiDevNode.USERNAME)\n \n \n \nif __name__ == &quot;__main__&quot;:\n    deploy_newapi_dev()\n \nclosed by github.com/guyueshui/dotfiles/tree/master/bin/paramiko\n\n更新下wrapper\nnode.py\n# encoding = utf-8\n# This file stores the information of remote nodes.\n \nclass NodeConf(object):\n    HOST = &quot;&quot;\n    PORT = 22\n    USERNAME = &quot;bingbing.hu&quot;\n    PASSWORD = &quot;datayes@123&quot;\n \n    @classmethod\n    def get_para(cls):\n        return (cls.HOST, cls.PASSWORD, cls.USERNAME, cls.PORT)\n \n    @classmethod\n    def get_para_dict(cls):\n        return {&quot;host&quot;: cls.HOST, &quot;password&quot;: cls.PASSWORD,\n                &quot;username&quot;: cls.USERNAME, &quot;port&quot;: cls.PORT }\n \nclass NewApiDevNode(NodeConf):\n    HOST = &quot;10.24.21.23&quot;\n \nclass DbStoreNode(NodeConf):\n    HOST = &quot;10.24.21.105&quot;\n \nclass MdlDevNode(NodeConf):\n    HOST = &quot;10.24.21.40&quot;\n \nclass DbAlchemyNodeStg(NodeConf):\n    HOST = &quot;10.24.21.25&quot;\n    USERNAME = &quot;xufei.li&quot;\n \nclass BarDev(NodeConf):\n    HOST = &quot;10.24.21.181&quot;\n    USERNAME = &quot;xufei.li&quot;\n \n    DEPLOY_DIR = &quot;/home/shang/mdl_bar&quot;\n \nssh_connection.py\n# encoding: utf-8\n \nfrom tool.utils import notify\nimport os\nimport time\nimport paramiko\nimport paramiko.util\nparamiko.util.log_to_file(&quot;paramiko.log&quot;)\n \n \nclass CommandRunException(Exception):\n    pass\n \n \nclass SSHConnection(object):\n    def __init__(self, host=&quot;&quot;, password=&quot;&quot;, username=&quot;bingbing.hu&quot;, port=22) -&gt; None:\n        self.host = host\n        self.password = password\n        self.username = username\n        self.port = port\n        self._client = None      # type: paramiko.SSHClient | None\n        self._sftp_client = None # type: paramiko.SFTPClient | None\n \n    def __enter__(self):\n        return self\n \n    def __exit__(self, exc_type, exc_val, exc_tb):\n        print(&quot;type: %s&quot; % exc_type)\n        print(&quot;val: %s&quot; % exc_val)\n        print(&quot;tb: %s&quot; % exc_tb)\n        self.close()\n \n    def close(self):\n        if self._client is not None:\n            self._client.close()\n        if self._sftp_client is not None:\n            self._sftp_client.close()\n        self._client = None\n        self._sftp_client = None\n \n    def re_init(self, node_cls):\n        &quot;&quot;&quot; Re-init the node with a NodeConf class. &quot;&quot;&quot;\n        self.host = node_cls.HOST\n        self.password = node_cls.PASSWORD\n        self.username = node_cls.USERNAME\n        self.port = node_cls.PORT\n        if self._client is not None:\n            self._client.close()\n            self._client = None\n        self.get_client()\n \n    def get_client(self):\n        if self._client is None:\n            self._client = ssh = paramiko.SSHClient()\n            ssh.load_system_host_keys()\n            ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n            ssh.connect(self.host, self.port, self.username, self.password)\n        return self._client\n \n    def get_sftp_client(self):\n        if self._sftp_client is None:\n            self._sftp_client = self.get_client().open_sftp()\n        return self._sftp_client\n \n    def excute(self, cmd):\n        stdin, stdout, stderr = self.get_client().exec_command(cmd)\n        return self.__handle_cmd_output(stdout, stderr, cmd)\n \n    def excute_with_sudo(self, cmd):\n        stdin, stdout, stderr = self.get_client().exec_command(&quot;sudo -S %s&quot; % cmd)\n        stdin.write(self.password + &quot;\\n&quot;)\n        stdin.flush()\n        return self.__handle_cmd_output(stdout, stderr, cmd)\n \n    def __excute_successive_cmds(self, cmd):\n        client = self.get_client()\n        chan = client.invoke_shell()\n        chan.set_combine_stderr(True)\n        stdin = chan.makefile_stdin(&quot;wb&quot;, -1)\n        stdout = chan.makefile(&quot;r&quot;, -1)\n        # chan.send(&quot;sudo -i\\n&quot;)\n        # chan.sendall(self.password + &quot;\\n&quot;)\n        # time.sleep(.5)\n        # stdin.flush()\n        stdin.write(&quot;ls -al\\n&quot;)\n        stdin.write(f&quot;&quot;&quot;\nsudo -i\n{self.password}\n&quot;&quot;&quot;)\n        time.sleep(0.5)\n#         chan.send(&quot;&quot;&quot;\n# pwd\n# echo $HOME\n# echo $USER\n# &quot;&quot;&quot;.encode())\n        # chan.sendall(&quot;pwdx 15391\\n&quot;.encode())\n        chan.send(&quot;exit\\n&quot;.encode())\n        chan.send(&quot;./a.out\\n&quot;.encode())\n        chan.send(&quot;exit\\n&quot;.encode())\n        while True:\n            if chan.recv_ready():\n                print(chan.recv(1024).decode())\n                continue\n            if chan.exit_status_ready():\n                exit_status = chan.recv_exit_status()\n                break\n            if chan.closed or chan.eof_received or not chan.active:\n                break\n            time.sleep(0.5)\n        print(&quot;exit_status:&quot;, exit_status)\n \n    @staticmethod\n    def __handle_cmd_output(stdout: paramiko.ChannelFile, stderr: paramiko.ChannelFile, cmd: str) -&gt; int:\n        for line in stdout:\n            print(line, end=&quot;&quot;)\n        status = stdout.channel.recv_exit_status()\n        if status != 0:\n            raise CommandRunException(\n                &quot;Excute &#039;%s&#039; failed with status %d.\\n\\n%s&quot;\n                % (cmd, status, stderr.read().decode()))\n        return status\n \n    def get_cmd_chain(self, timeout=0):\n        return CommandChain(self.get_client(), timeout)\n \n    def upload(self, local_path, remote_path):\n        if not os.path.exists(local_path):\n            raise FileNotFoundError(&quot;Local file %s not found.&quot; % local_path)\n        if remote_path[-1] == &#039;/&#039;: # treat remote_path as a directory\n            self.__ensure_remote_path(remote_path)\n            filename = os.path.basename(local_path)\n            remote_path += filename\n        notify(&quot;Uploading %s to %s&quot; % (local_path, remote_path))\n \n        # \\r is used to move cursor to the beginning of the line.\n        cb = lambda x, y: notify(f&quot;Uploaded {x}/{y}\\r&quot;, end=&quot;&quot;, flush=True)\n        self.get_sftp_client().put(local_path, remote_path, callback=cb)\n        print(&#039;&#039;) # used to remove the last \\r\n \n    def download(self, remote_path, local_path):\n        if remote_path[-1] == &#039;/&#039;:\n            raise ValueError(&quot;Remote path should be a file path.&quot;)\n        local_file = local_path\n        if local_path[-1] == &#039;/&#039;:\n            local_dir = local_path[:-1]\n            local_file = os.path.join(local_path, os.path.basename(remote_path))\n        else:\n            local_dir = os.path.split(local_path)[0]\n        if not os.path.exists(local_dir):\n            os.makedirs(local_dir)\n \n        sftp = self.get_sftp_client()\n        notify(&quot;Downloading %s to %s&quot; % (remote_path, local_file))\n \n        # \\r is used to move cursor to the beginning of the line.\n        cb = lambda x, y: print(f&quot;\\rDownloaded {x}/{y}&quot;, end=&quot;&quot;, flush=True)\n        sftp.get(remote_path, local_file, callback=cb)\n \n    def __ensure_remote_path(self, remote_path):\n        self.excute(f&quot;&quot;&quot;\n            if [ ! -d {remote_path} ]; then\n                mkdir -p {remote_path}\n            fi\n            &quot;&quot;&quot;)\n \n \nclass CommandChain(object):\n    def __init__(self, ssh_client: paramiko.SSHClient, timeout=0):\n        assert ssh_client is not None\n        self._client = ssh_client\n        self._chan = ssh_client.invoke_shell(self.__class__.__name__) # type: paramiko.Channel\n        time.sleep(1) # wait the channel to be ready\n        # self._chan.setblocking(0)\n        # self._chan.set_combine_stderr(True)\n        self._stdin = self._chan.makefile_stdin(&quot;wb&quot;, -1)\n        self._exit_status = 0\n        self._timeout = timeout\n \n    def over(self):\n        time.sleep(0.5) # essential, otherwise the command will be blocked\n        # while not self._chan.exit_status_ready():\n        #     self.execute(&quot;exit&quot;)\n        self.__handle_output()\n        self._stdin.close()\n        self._chan.close()\n        self._client = None\n \n    def execute(self, one_line_cmd: str):\n        one_line_cmd = one_line_cmd.rstrip(&#039;\\n&#039;) + &#039;\\n&#039;\n        self._chan.send(one_line_cmd.encode())\n        return self\n \n    def write_input(self, text: str):\n        text = text.rstrip(&#039;\\n&#039;) + &#039;\\n&#039;\n        self._stdin.write(text.encode())\n        return self\n \n    def __handle_output(self):\n        chan = self._chan\n        # If you don&#039;t set timeout, the stdout.read will block,\n        # or you can send multiple &quot;exit&quot; to remote node,\n        # this will make chan.exit_status_ready returns true.\n        if self._timeout &gt; 0:\n            chan.settimeout(5)\n        stdout = chan.makefile(&quot;r&quot;, -1)\n        try:\n            for line in stdout:\n                print(line, end=&quot;&quot;)\n        except Exception as e:\n            notify(&quot;no data in %ss, channel will be closed!&quot; % self._timeout)\n \n \ndef test_connection():\n    from tool.node import NewApiDevNode\n    conn = SSHConnection()\n    conn.re_init(NewApiDevNode)\n \n    conn.excute(&quot;pwd;df -h&quot;)\n    conn.excute_with_sudo(&quot;apt list --upgradable | head -n5&quot;)\n    conn.excute(&quot;&quot;&quot;\ncd /tmp\nmkdir -p test\ncd test\npwd\ntouch {a,b,c}\nls -l&quot;&quot;&quot;)\n \n    conn.upload(&quot;main.py&quot;, &quot;./areyouok/&quot;)\n    # conn.excute(&quot;./a.out&quot;)\n    # node.get_sftp_client().put(&quot;main.py&quot;, &quot;main.py&quot;)\n    conn.download(&quot;./api_etc.tar&quot;, &quot;./from_remote.tar&quot;)\n    conn.close()\n \n \ndef test_cmd_chain():\n    from tool.node import NewApiDevNode\n    conn = SSHConnection()\n    conn.re_init(NewApiDevNode)\n \n    conn.get_cmd_chain().execute(&quot;echo $USER&quot;)\\\n        .execute(&quot;sudo -i&quot;).write_input(conn.password)\\\n        .execute(&quot;echo $USER&quot;).execute(&quot;apt list --upgradable|head -5&quot;)\\\n        .over()\n \n \nif __name__ == &quot;__main__&quot;:\n    # test_connection()\n    test_cmd_chain()\nutils.py\n# encoding: utf-8\n \nimport os\nimport tarfile\n \ndef notify(*msg, **kwargs):\n    print(&quot;---&quot;, *msg, **kwargs)\n \ndef __tar_mode_helper(tar_path: str):\n    if tar_path.endswith(&quot;.gz&quot;) or tar_path.endswith(&quot;.tgz&quot;):\n        mode = &quot;w:gz&quot;\n    elif tar_path.endswith(&quot;.bz2&quot;):\n        mode = &quot;w:bz2&quot;\n    elif tar_path.endswith(&quot;.xz&quot;):\n        mode = &quot;w:xz&quot;\n    else:\n        mode = &quot;w&quot;\n    return mode\n \ndef tar_dir(dir_path: str, tar_path: str, **kwargs):\n    &quot;&quot;&quot; Tar a directory `dir_path` to a tar file. &quot;&quot;&quot;\n    mode = __tar_mode_helper(tar_path)\n    with tarfile.open(tar_path, mode) as tar:\n        tar.add(dir_path, arcname=os.path.basename(dir_path), **kwargs)\n \ndef tar_files(tar_path: str, *files):\n    mode = __tar_mode_helper(tar_path)\n    with tarfile.open(tar_path, mode) as tar:\n        for fn in filter(lambda x: os.path.exists(x), files):\n            tar.add(fn, arcname=os.path.basename(fn))\n \ndef untar_file(tar_path, target_dir):\n    with tarfile.open(tar_path, &quot;r&quot;) as tar:\n        tar.extractall(target_dir)\n \ndef test_tar():\n    tar_dir(&quot;./&quot;, &quot;/home/bingbing.hu/my.tar.gz&quot;)\n    untar_file(&quot;/home/bingbing.hu/my.tar.gz&quot;, &quot;/home/bingbing.hu/mytar_gz_extracted&quot;)\n \n \nif __name__ == &quot;__main__&quot;:\n    test_tar()\n示例\nfrom common import *\nimport os\nimport tarfile\n \n \nclass CompileTask1604(object):\n    &quot;&quot;&quot; Compile on ubuntu 16.04. &quot;&quot;&quot;\n    def __init__(self) -&gt; None:\n        self.conn = SSHConnection()\n        self.conn.re_init(N.NewApiDevNode)\n \n    def destroy(self):\n        if self.conn is not None:\n            self.conn.close()\n        self.conn = None\n \n    @staticmethod\n    def filter_src_files(tarinfo: tarfile.TarInfo):\n        name = tarinfo.name\n        if &#039;.git&#039; in name or &quot;.vscode&quot; in name or &quot;.cache&quot; in name:\n            return None\n        if name.startswith(&#039;.&#039;):\n            return None\n        if tarinfo.isdir():\n            if &quot;3rd&quot; in name or &quot;build&quot; in name or &quot;doc&quot; in name or &quot;obj&quot; in name or &quot;bin&quot; in name:\n                return None\n            return tarinfo\n        if tarinfo.isfile() and (\n            name.endswith(&quot;.h&quot;) or name.endswith(&quot;.cpp&quot;)\n        ):\n            return tarinfo\n        return None\n \n    def compile_mdl_src(self):\n        conn = self.conn\n \n        tar_name = &quot;mdl_src.tar.bz2&quot;\n        utils.tar_dir(MDL_SRC, tar_name, filter=self.__class__.filter_src_files)\n        conn.upload(tar_name, &quot;./code/&quot;)\n        conn.excute(f&quot;&quot;&quot;\ncd code\ntar -xavf {tar_name}\nrm -f {tar_name}\necho; echo\ncd mdl_src/build/make\nmake -j4\n&quot;&quot;&quot;)\n        os.remove(tar_name)\n \n    def compile_dbalchemy(self):\n        conn = self.conn\n \n        def _filter(tarinfo: tarfile.TarInfo):\n            name = tarinfo.name\n            if &#039;build.sh&#039; in name or &quot;makefile&quot; in name:\n                return tarinfo\n            return self.__class__.filter_src_files(tarinfo)\n \n        tar_name = &quot;dbalchemy.tar.bz2&quot;\n        utils.tar_dir(DBALCHEMY, tar_name, filter=_filter)\n        conn.upload(tar_name, &quot;./code/&quot;)\n        conn.excute(f&quot;&quot;&quot;\nset -e\ncd code\ntar -xavf {tar_name}\nrm -f {tar_name}\necho; echo\ncd dbalchemy/\nbash -e build.sh\n&quot;&quot;&quot;)\n        os.remove(tar_name)\n \n \nif __name__ == &#039;__main__&#039;:\n    task = CompileTask1604()\n    task.compile_mdl_src()\n    task.destroy()"},"__zettel/202502210928make-template":{"slug":"__zettel/202502210928make-template","filePath":"__zettel/202502210928make-template.md","title":"202502210928","links":["__zettel/202308261504make基础.html"],"tags":["make"],"content":"Here list some makefile as references.\napi_service:\n        cp -b ~/code/newapi/build/api_service .\n \n \napi_service.tar.gz: api_service so_files\n        @mkdir -p so_files\n        cp api_service so_files\n        cd so_files; tar -caf ../$@ *\n \n \nCODE_ROOT := ~/code/newapi\nLIBPATH := $(CODE_ROOT)/3rd-modules/libs\nDEPEND_SO := libodbc.so libunwind.so libtcmalloc.so libbson-1.0.so libmongoc-1.0.so libpq.so\n# PACKAGE_SO := $(addprefix so_files/,$(DEPEND_SO))\nso_files:\n        @mkdir -p so_files\n        @for so in $(DEPEND_SO); do \\\n                tmp=$$(find $(LIBPATH) -type f -name &quot;$$so*&quot; -print); \\\n                lnk=$$(basename $$tmp | sed &#039;s/\\(lib.*\\.so\\.[0-9]\\)\\(\\.[0-9]\\)\\+/\\1/&#039;); \\\n                cp $$tmp so_files/$$lnk; \\\n        done\n \n \nruntime_so_alias:\n        @for so in $(DEPEND_SO); do \\\n                tmp=$$(find $(LIBPATH) -type f -name &quot;$$so*&quot; -print); \\\n                lnk=$$(basename $$tmp | sed &#039;s/\\(lib.*\\.so\\.[0-9]\\)\\(\\.[0-9]\\)\\+/\\1/&#039;); \\\n                ln -sf $$tmp $$lnk; \\\n        done\n \nclean_so_alias:\n        @for so in $(DEPEND_SO); do \\\n                find -type l -name &quot;$$so*&quot; -exec $(RM) {} \\; ; \\\n        done\n \nclean:\n        $(RM) api_service\n        -$(RM) api_service.tar.gz\n        -$(RM) so_files\n \n.PHONY: clean clean_so_alias so_files runtime_so_alias\nsee also 202308261504make基础"},"__zettel/202502241705crtp-in-cpp":{"slug":"__zettel/202502241705crtp-in-cpp","filePath":"__zettel/202502241705crtp-in-cpp.md","title":"202502241705","links":["notes/cpp/多态.html"],"tags":["CRTP","cpp"],"content":"今天学了一个新的C++知识点，诚然life is too short to learn c++.\n先看cpprefernece上的表述，\nen.cppreference.com/w/cpp/language/crtp\n可见，通过这种奇怪的方式，可以在编译期实现多态。从而省去了虚函数的调用开销（查虚表）以及虚指针的内存开销。追求极致性能可以考虑使用这种技巧。\n简单来说，就是这样使用：\n#include &lt;cstdio&gt;\n \ntemplate &lt;class Derived&gt;\nclass Base {\npublic:\n    void interface() {\n        static_cast&lt;Derived*&gt;(this)-&gt;impl();\n    }\n};\n \nclass D1 : public Base&lt;D1&gt; {\npublic:\n    void impl() {\n        printf(&quot;hello from D1\\n&quot;);\n    }\n};\n \nclass D2 : public Base&lt;D2&gt; {\npublic:\n    void impl() {\n        printf(&quot;hello from D2\\n&quot;);\n    }\n};\n \nint\nmain(int argc, const char* argv[])\n{\n    D1 d1;\n    D2 d2;\n    d1.interface();\n    d2.interface();\n    return 0;\n}\n \n// output:\n// hello from D1\n// hello from D2\n更详细的参考：xr1s.me/2022/10/18/brief-introduction-to-crtp/\n别称：静态绑定，静态多态 \nsee also 多态"},"__zettel/202502261718firefox-chrome-禁用政策插件":{"slug":"__zettel/202502261718firefox-chrome-禁用政策插件","filePath":"__zettel/202502261718firefox-chrome-禁用政策插件.md","title":"202502261718","links":["__zettel/202412112322firefox重启保留标签页.html"],"tags":["firefox","chrome","技巧"],"content":"看到浏览器中“由贵组织管理”让人很恼怒，它装的插件一般是用来监控你的浏览记录和浏览内容的。所以，在这种情况下，你等于没穿衣服在网上冲浪。我们必须强烈抵制这种行为。\n\n\n网上的一些方法多半是删除注册表，但是公司电脑往往不给你管理员权限，因此行不通。所以我们要另辟蹊径。\nchrome禁用政策插件\n打开你的profile目录，一般为\nC:\\Users\\用户名\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\Extensions\n\n删掉这个插件文件夹（打开开发者模式可以看到插件id，在插件目录里面对应一个插件目录）\n\nfirefox禁用政策插件\nfirefox就更牛了，官方文档直接教你怎么禁用。\nsupport.mozilla.org/en-US/kb/cannot-remove-add-on-extension-or-theme\n具体来说，还是先查看插件。地址栏输入about:support，可以看到配置文件夹目录，打开它，里面有个extensions目录存放插件文件。\n\n再往下翻一翻，可以看到插件信息，\n\n可以看到插件ID，删除对应文件即可。\nsee also 202412112322firefox重启保留标签页"},"__zettel/202503071009不要直接改系统的glibc版本":{"slug":"__zettel/202503071009不要直接改系统的glibc版本","filePath":"__zettel/202503071009不要直接改系统的glibc版本.md","title":"202503071009","links":[],"tags":["glibc"],"content":"如题，不要改系统的glibc版本，否则！你的系统可能崩掉！\n踩坑经历\n因为Ubuntu20.04（GBLIC 2.31）和Ubuntu16.04（GLIBC 2.23）版本不兼容。在20.04上面编译的二进制无法在16.04上面运行。报错，\n$ lsb_release -a\nNo LSB modules are available.\nDistributor ID: Ubuntu\nDescription:    Ubuntu 16.04.2 LTS\nRelease:        16.04\nCodename:       xenial\n\n$ ./feeder_handler \n./feeder_handler: /lib/x86_64-linux-gnu/libm.so.6: version `GLIBC_2.29&#039; not found (required by ./feeder_handler)\n./feeder_handler: /lib/x86_64-linux-gnu/libm.so.6: version `GLIBC_2.29&#039; not found (required by ./libmdl_api.so)\n\n因为feeder_handler是在20.04上面编译的。你可以通过以下方法查看glibc版本，\n$ ldd --version | head -1\nldd (Ubuntu GLIBC 2.23-0ubuntu11.3) 2.23\n \n$ strings /lib/x86_64-linux-gnu/libm.so.6 | grep GLIBC\nGLIBC_2.2.5\nGLIBC_2.4\nGLIBC_2.15\nGLIBC_2.18\nGLIBC_2.23\nGLIBC_PRIVATE\n可见，系统上的glibc是2.23版本。而二进制文件需要glibc2.29版本。解决方法有二：\n\n把源码放到16.04的机器上编译\n在16.04上装一个glibc2.29，通过patchelf修改动态库指向\n\n对于频繁更新代码，编译，放到目标机器上跑的任务来说，每次都要patchelf有点过于恼人。两种方案可参考：\n\n如何安装其他版本的glibc：stackoverflow.com/a/73188338\n如何修改动态库指向新的glibc版本：stackoverflow.com/a/851229\n\n\n\n                  \n                  Attention\n                  \n                \n\n但是，千万注意，不要动系统的glibc相关文件！否则，很可能必定会把系统弄崩掉。\n\n\n我就替换了一个符号链接，将libpthread.so.0换了一个指向就引发了雪崩。\nll /lib/x86_64-linux-gnu/libpthread*\n-rwxr-xr-x 1 root root  157224 Jan 29 22:41 /lib/x86_64-linux-gnu/libpthread-2.31.so*\n-rw-r--r-- 1 root root 6590210 Jan 29 22:41 /lib/x86_64-linux-gnu/libpthread.a\nlrwxrwxrwx 1 root root      37 Jan 29 22:41 /lib/x86_64-linux-gnu/libpthread.so -&gt; /lib/x86_64-linux-gnu/libpthread.so.0*\nlrwxrwxrwx 1 root root      18 Mar  7 09:23 /lib/x86_64-linux-gnu/libpthread.so.0 -&gt; libpthread-2.31.so*\n可以看到libpthread.so.0指向正确版本的libpthread-2.31.so，如果这里改为指向一个低版本的动态库。你会发现一连串奇怪的问题接踵而来，连ls都不能正常工作。不能切用户，不能sudo，无法校验密码（输入用户名直接报鉴权失败）。重启一下立马启不动，无法正常开机。进入修复模式，直接报kernel panic. 下面欣赏一部分截图，\n\n\n\n从上面一些截图中可见端倪，系统的很多命令依赖这个动态库，而你改了不兼容的版本，导致寻址错误，找不到对应的符号，大部分程序都会崩溃。据同事说低版本指向高版本是ok的（按时高版本兼容低版本），但是who knows！万一替换了一个不兼容的版本，GG！\n修复建议\n找一个bootable的live cd，比如archliux的安装盘，进去之后挂在相应目录，把软连接指向正确的文件即可。"},"__zettel/202503092037NetworkManager更换iwd后端":{"slug":"__zettel/202503092037NetworkManager更换iwd后端","filePath":"__zettel/202503092037NetworkManager更换iwd后端.md","title":"202503092037","links":[],"tags":["networkmanager","iwd","wpa_supplicant"],"content":"此前NetworkManager一直使用wpa_supplicant作为后端，但是journalctl -f发现狂刷日志，\njournalctl -f\nFeb 28 10:23:31 baumgard wpa_supplicant[982]: wlan0: CTRL-EVENT-SIGNAL-CHANGE above=0 signal=-73 noise=9999 txrate=175600\nFeb 28 10:23:31 baumgard wpa_supplicant[982]: wlan0: CTRL-EVENT-SIGNAL-CHANGE above=0 signal=-73 noise=9999 txrate=175600\nFeb 28 10:23:32 baumgard wpa_supplicant[982]: wlan0: CTRL-EVENT-SIGNAL-CHANGE above=0 signal=-73 noise=9999 txrate=175600\nFeb 28 10:23:32 baumgard wpa_supplicant[982]: wlan0: CTRL-EVENT-SIGNAL-CHANGE above=0 signal=-70 noise=9999 txrate=175600\nFeb 28 10:23:33 baumgard wpa_supplicant[982]: wlan0: CTRL-EVENT-SIGNAL-CHANGE above=0 signal=-70 noise=9999 txrate=175600\nFeb 28 10:23:33 baumgard wpa_supplicant[982]: wlan0: CTRL-EVENT-SIGNAL-CHANGE above=0 signal=-70 noise=9999 txrate=6000\nFeb 28 10:23:34 baumgard wpa_supplicant[982]: wlan0: CTRL-EVENT-SIGNAL-CHANGE above=0 signal=-71 noise=9999 txrate=6000\nFeb 28 10:23:34 baumgard wpa_supplicant[982]: wlan0: CTRL-EVENT-SIGNAL-CHANGE above=0 signal=-70 noise=9999 txrate=175600\nFeb 28 10:23:35 baumgard wpa_supplicant[982]: wlan0: CTRL-EVENT-SIGNAL-CHANGE above=0 signal=-70 noise=9999 txrate=175600\nFeb 28 10:23:35 baumgard wpa_supplicant[982]: wlan0: CTRL-EVENT-SIGNAL-CHANGE above=0 signal=-70 noise=9999 txrate=6000\n\n而且官方LiveCD里面也已经切换到iwd，所以我们也换成iwd作为wifi后端。\n更换方法参考：forum.endeavouros.com/t/journalctl-wlan0-ctrl-event-signal-change/68475/4\nInstall iwd\nsudo pacman -S iwd\ncreate a config file for KDE network manager\nsudo vi /etc/NetworkManager/conf.d/iwd.conf\naddd this lines\n[device] wifi.backend=iwd\ndeactivate the wpa_supplicant\nsudo systemctl stop wpa_supplicant.service sudo systemctl disable wpa_supplicant.service\nactivate iwd\nsudo systemctl enable iwd.service sudo systemctl start iwd.service\nrestart network manager\nsudo systemctl restart NetworkManager\nafter that i must reconnect to my wifi with password\nnow i have a clean journal !"},"__zettel/202503191332程序的进程名和命令名":{"slug":"__zettel/202503191332程序的进程名和命令名","filePath":"__zettel/202503191332程序的进程名和命令名.md","title":"202503191332","links":[],"tags":["pgrep","pkill"],"content":"英文叫做\n\nprocess name\ncommand line\n\n在pgrep、pkill处理进程的时候，需要注意process name最多15个字符，所以有时可能匹配不到，\nroot@mdl-dev01:~# ps -elf | grep feeder\n5 S root     21004     1 62  80   0 - 567610 futex_ Mar18 ?       13:01:20 ./feeder_handler1\n1 S root     21069     1 19  80   0 - 728090 futex_ Mar18 ?       04:05:21 ./feeder_handler2\n5 S root     21220     1  1  80   0 - 287844 futex_ Mar18 ?       00:14:21 ./feeder_handler_bar\n0 S root     31789 31592  0  80   0 -  3235 pipe_w 13:34 pts/1    00:00:00 grep --color=auto feeder\nroot@mdl-dev01:~# pgrep -x feeder_handler1\n21004\nroot@mdl-dev01:~# pgrep -x feeder_handler2\n21069\nroot@mdl-dev01:~# pgrep -x feeder_handler_bar\nroot@mdl-dev01:~# \n可见feeder_handler_bar没有命中，而pgrep的manpage里面明确指出：\n\t\tThe process name used for matching is limited to the 15 characters present in the output of /proc/pid/stat.  Use the -f option to match  against  the  complete  command  line,\n       /proc/pid/cmdline.\n\n这时候需要用pgrep -f才行。\nroot@mdl-dev01:~# pgrep -f feeder_handler_bar\n21220\nroot@mdl-dev01:~# pgrep -lf feeder\n21004 feeder_handler1\n21069 feeder_handler2\n21220 feeder_handler_"},"__zettel/202504301210反向迭代器转正向迭代器":{"slug":"__zettel/202504301210反向迭代器转正向迭代器","filePath":"__zettel/202504301210反向迭代器转正向迭代器.md","title":"202504301210","links":[],"tags":["iterator","reverse_iterator"],"content":"反向迭代器有一个坑点。正向迭代器，指向的位置和解引用对应的元素是一致的；反向迭代器指向的位置和解引用对应的元素差了一个。从前往后看（正向角度），反向迭代器指向位置i，那么解引用会得到i-1位置上的元素。\ncpprefrence指出，\n\nFor a reverse iterator r constructed from an iterator i, the relationship &amp;*r == &amp;*(i - 1) is always true (as long as r is dereferenceable); thus a reverse iterator constructed from a one-past-the-end iterator dereferences to the last element in a sequence.\n\n\nThis is due to the fact that a reverse iterator has a slightly different referencing logic than a regular iterator: it points to an element, but when dereferenced, it yields a reference to the previous element.\n\n更多参考：\n\nc++ - Why does removing the first element of a list invalidate .rend()? - Stack Overflow\nc++ - Why can I not convert a reverse iterator to a forward iterator? - Stack Overflow\nc++ - Can I convert a reverse iterator to a forward iterator? - Stack Overflow\n\n反向迭代器的base成员函数，返回底层所持有的正向迭代器，我们转正向迭代器的时候尤其要注意上面的坑点，\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;iterator&gt;\n#include &lt;algorithm&gt;\n \nint main() { \n    int i[] = {1,2,3,4,5,6};\n    std::vector&lt;int&gt; v(i, i+6);\n \n    auto ri = std::find(std::rbegin(v), std::rend(v), 3);\n    std::cout &lt;&lt; *ri &lt;&lt; std::endl; // 3\n    auto fi = ri.base()-1;\n    std::cout &lt;&lt; *fi &lt;&lt; std::endl; // 3\n    fi = (++ri).base();\n    std::cout &lt;&lt; *fi &lt;&lt; std::endl; // 3\n}\n即，\n\n要么调用base之前将反向迭代器增一\n要么调用base之后将得到的正向迭代器减一\n"},"__zettel/202505090847awk判断csv的id有序性":{"slug":"__zettel/202505090847awk判断csv的id有序性","filePath":"__zettel/202505090847awk判断csv的id有序性.md","title":"202505090847","links":[],"tags":["awk","csv","文本处理"],"content":"Example 1\n#!/bin/bash\n \n# file: check_order.sh\n \nfile=&quot;$1&quot;\norder=&quot;asc&quot;         # 排序类型：asc（升序）或desc（降序）\n \nawk -F&#039;,&#039; -v order=&quot;$order&quot; &#039;\nBEGIN {\n    # 初始化哈希表，记录每个 key 的上一个 value 和当前有序状态\n    delete prev_value;\n    delete key_status;  # 状态标记：1（有序）、0（无序）\n}\n \n{\n    if (NR == 1) {\n        next;\n    }\n \n    key = $1;\n    current_val = $2;\n \n    if (NR % 1000000 == 0) {\n        print &quot;now processing &quot; key &quot;：&quot; current_val;\n    }\n \n    # 若 key 首次出现，初始化状态为有序\n    if (!(key in prev_value)) {\n        prev_value[key] = current_val;\n        key_status[key] = 1;  # 默认有序\n        next;\n    }\n \n    # 获取当前 key 的上一个 value\n    prev_val = prev_value[key];\n \n    # 数值类型判断与比较\n    if (current_val ~ /^-?[0-9]+(\\.[0-9]+)?$/ &amp;&amp; prev_val ~ /^-?[0-9]+(\\.[0-9]+)?$/) {\n        num_curr = current_val + 0;\n        num_prev = prev_val + 0;\n        if ((order == &quot;asc&quot; &amp;&amp; num_curr &lt; num_prev) || (order == &quot;desc&quot; &amp;&amp; num_curr &gt; num_prev)) {\n            print &quot;found bad seq: key=&quot; key &quot;,cur=&quot; num_curr &quot;,prev=&quot; num_prev\n            key_status[key] = 0;  # 标记为无序\n        }\n        if ((order == &quot;asc&quot; &amp;&amp; num_curr != num_prev + 1) || (order == &quot;desc&quot; &amp;&amp; num_curr + 1 != num_prev)) {\n            print &quot;found gap seq: key=&quot; key &quot;,cur=&quot; num_curr &quot;,prev=&quot; num_prev\n        }\n    } else {\n        print &quot;should not hit, cur=&quot; current_val &quot;, prev=&quot; prev_val\n        # 字符串字典序比较\n        if ((order == &quot;asc&quot; &amp;&amp; current_val &lt; prev_val) || (order == &quot;desc&quot; &amp;&amp; current_val &gt; prev_val)) {\n            key_status[key] = 0;  # 标记为无序\n        }\n    }\n \n    # 更新当前 key 的上一个 value\n    prev_value[key] = current_val;\n}\n \nEND {\n    # 输出所有 key 的有序状态\n    for (key in key_status) {\n        status = (key_status[key] == 1) ? &quot;有序&quot; : &quot;无序&quot;;\n        print key &quot;：&quot; status;\n    }\n}\n&#039; &quot;$file&quot;\n \n使用方式：\nbash check_order.sh xxx.csv\n\n在处理大文件（10G+）时特别有用。\nExample 2\ncsv中，第一列是股票代码，第二列是分钟线时间。下面这段脚本检测，对于每一个股票代码，他的分钟线时间都是逐分钟递增，检测是否存在跳变的情况。\nfunction diff_min(hhmm_1, hhmm_2) {\n    if (hhmm_1 == &quot;13:01&quot; &amp;&amp; hhmm_2 == &quot;11:30&quot;) return 1;\n    if (hhmm_1 == &quot;15:00&quot; &amp;&amp; hhmm_2 == &quot;15:00&quot;) return 1;\n \n    split(hhmm_1, arr, &quot;:&quot;)\n    a = arr[1]*60 + arr[2]\n    split(hhmm_2, arr, &quot;:&quot;)\n    b = arr[1]*60 + arr[2]\n    return a - b\n}\n \nBEGIN {\n    delete prev_min;\n    delete key_status;\n}\n \n{\n    if (NR == 1) next;\n    key = $1\n    min = substr($2, 1, 5)\n \n    if (!(key in prev_min)) {\n        prev_min[key] = min\n        key_status[key] = 1 # ok\n        next\n    }\n \n    pmin = prev_min[key]\n    if (diff_min(min, pmin) != 1) {\n        key_status[key] = pmin\n    }\n \n    prev_min[key] = min\n}\n \nEND {\n    for (key in key_status) {\n        status = (key_status[key] == 1) ? &quot;ok&quot; : key_status[key]\n        print key &quot;: &quot; status\n    }\n}\nExample 3\ncsv中，第一列为股票代码，第二列为分钟线时间。对于相同股票代码，可能有重复的分钟线。需要过滤掉重复的但保留最后一条。\n{\n    lines[NR] = $0\n    if (NR == 1) next;\n    key = $1 &quot;_&quot; $2\n \n    if (key in seen) {\n        dup_lines[seen[key]] = 1\n    }\n    seen[key] = NR\n}\n \nEND {\n    for (i = 1; i &lt;= NR; i++) {\n        line = lines[i]\n        split(line, arr, &quot;,&quot;)\n        key = arr[1] &quot;_&quot; arr[2]\n        if (!(i in dup_lines) || i == seen[key]) {\n            print line\n        }\n    }\n}\nExample 4\ncsv中，最后一列为数据序列号。check序列号逐一递增。\nBEGIN {\n    flag = 1\n}\n \n{\n    if (NR == 1) next;\n \n    cur_val = $(NF) + 0\n    if (prev_val ~ /^-?[0-9]+(\\.[0-9]+)?$/) {\n        if (cur_val != prev_val + 1) {\n            print &quot;Line &quot; NR &quot; not continuous, prev:&quot; prev_val &quot;, cur:&quot; cur_val\n            flag = 0\n            exit 2\n        }\n    }\n    prev_val = cur_val\n}\n \nEND {\n    print flag ? &quot;passed&quot; : &quot;failed&quot;\n}\ninline example\n# 打印第2列为689009且第1列匹配10:57:24的行\nawk -F, &#039;$2==689009 &amp;&amp; $1~&quot;10:57:24&quot; {print $0}&#039; mdl_4_4_0.csv\nawk -F, &#039;$2==689009 &amp;&amp; $1 ~ /10:57:24/ {print $0}&#039; mdl_4_4_0.csv\n \n# 打印第一列为920088且倒数第二列匹配10:31:0x的行，print $0 &lt;=&gt; print\nawk -F&#039;,&#039; &#039;$1==&quot;920088&quot; &amp;&amp; $(NF-1) ~ /10:31:0/ {print}&#039; mdl_14_8_0.csv\n# 反向匹配（不包含相应模式），操作符换为 &quot;!~&quot;\nawk -F&#039;,&#039; &#039;$1==&quot;920088&quot; &amp;&amp; $(NF-1) !~ /10:31:0/ {print}&#039; mdl_14_8_0.csv"},"__zettel/202505281711lambda表达式作为参数传递":{"slug":"__zettel/202505281711lambda表达式作为参数传递","filePath":"__zettel/202505281711lambda表达式作为参数传递.md","title":"202505281711","links":[],"tags":["lambda","cpp","pitfalls"],"content":"lambda不等于std::function，传参时会发生隐式转换\ncplusplus.com/forum/general/272010/"},"__zettel/202506292148texlive精简安装":{"slug":"__zettel/202506292148texlive精简安装","filePath":"__zettel/202506292148texlive精简安装.md","title":"202506292148","links":[],"tags":["tex"],"content":"参考：\n\nbithesis.bitnp.net/guide/getting-started.html#%E7%B2%BE%E7%AE%80%E5%AE%89%E8%A3%85%E5%86%85%E5%AE%B9\ngist.github.com/yihui/7ae1144e45063c4957e5c1f6f67039f4\ntug.ctan.org/info/install-latex-guide-zh-cn/install-latex-guide-zh-cn.pdf\nwww.cnblogs.com/eslzzyl/p/17358405.html\n\ntexlive可以将安装选项保存到一个texlive.profile文件中，安装程序直接读取这个文件进行安装，无需在进行交互。这次使用的是网络安装方式，而非下载iso文件，\n./install-tl --profile texlive.profile\n最后一步将可执行文件链接到系统目录可能要提权，安装完后可以执行\nsudo TEXLIVE_INSATLL_PATH/bin/tlmgr path add\ntmlgr option showall # 查看相关信息"},"__zettel/202507031535mysql基本命令":{"slug":"__zettel/202507031535mysql基本命令","filePath":"__zettel/202507031535mysql基本命令.md","title":"202507031535","links":[],"tags":[],"content":"命令行\n# connect to a mysql server\nmysql -h&lt;ip&gt; -u&lt;user&gt; -p\n \n# specify a database\nmysql&gt; use &lt;database_name&gt;\n \n# 修改列（shortnm）的数据类型\nmysql&gt; ALTER TABLE equity_delta_price MODIFY COLUMN shortnm varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL;\nsee: www.runoob.com/mysql/mysql-command-manual.html"},"__zettel/202507171527debug技巧之top":{"slug":"__zettel/202507171527debug技巧之top","filePath":"__zettel/202507171527debug技巧之top.md","title":"202507171527","links":[],"tags":["linux","管理"],"content":"虽然htop更modern，但是top毕竟是自带。\n# 查看指定程序\ntop -p`pidof &lt;program&gt;`\n \n# 按H可以展示线程，可用于查看各线程CPU占用\ntop - 15:29:49 up 954 days, 23:27,  6 users,  load average: 0.00, 0.06, 0.63\nThreads:  16 total,   0 running,  16 sleeping,   0 stopped,   0 zombie\n%Cpu(s):  0.1 us,  0.0 sy,  0.0 ni, 99.8 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\nKiB Mem : 24689460 total,  7071788 free,   181036 used, 17436636 buff/cache\nKiB Swap:        0 total,        0 free,        0 used. 23842748 avail Mem \n \n  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND\n 9867 bingbin+  20   0  615688  32832  19904 S  4.3  0.1   0:34.90 feeder_handler\n 9864 bingbin+  20   0  615688  32832  19904 S  0.3  0.1   0:00.50 SZL2ZhuBiSort\n 9854 bingbin+  20   0  615688  32832  19904 S  0.0  0.1   0:00.33 feeder_handler\n 9855 bingbin+  20   0  615688  32832  19904 S  0.0  0.1   0:00.01 feeder_handler\n 9856 bingbin+  20   0  615688  32832  19904 S  0.0  0.1   0:00.40 WorkThread1\n 9857 bingbin+  20   0  615688  32832  19904 S  0.0  0.1   0:00.00 WorkThread2\n 9858 bingbin+  20   0  615688  32832  19904 S  0.0  0.1   0:00.00 WorkThread3\n 9859 bingbin+  20   0  615688  32832  19904 S  0.0  0.1   0:00.00 WorkThread4\n 9860 bingbin+  20   0  615688  32832  19904 S  0.0  0.1   0:00.17 IOManagerImpl\n 9861 bingbin+  20   0  615688  32832  19904 S  0.0  0.1   0:00.21 HttpHandler\n 9862 bingbin+  20   0  615688  32832  19904 S  0.0  0.1   0:00.23 FileWriter\n 9863 bingbin+  20   0  615688  32832  19904 S  0.0  0.1   0:00.00 PubSortedThrd\n 9865 bingbin+  20   0  615688  32832  19904 S  0.0  0.1   0:00.42 SZL2ZhuBiSort\n 9866 bingbin+  20   0  615688  32832  19904 S  0.0  0.1   0:00.48 SZL2ZhuBiSort\n 9868 bingbin+  20   0  615688  32832  19904 S  0.0  0.1   0:00.03 feeder_handler\n 9869 bingbin+  20   0  615688  32832  19904 S  0.0  0.1   0:00.36 IOManagerImpl\n常用快捷键：\n\ne: 切换数值显示单位，m、g、t、p\nm：显示内存用量条\nM：按内存占用排序\nz：上色\nH：切换显示线程\nc: 切换显示完整命令行\nN：固定顺序，行不再跳来跳去\n"},"__zettel/202507181631sed技巧":{"slug":"__zettel/202507181631sed技巧","filePath":"__zettel/202507181631sed技巧.md","title":"202507181631","links":[],"tags":[],"content":"sed很强大，但也没那么直观易用。\n# 只打印匹配行\nsed -n &#039;/pattern/p&#039;\n \n# 启用扩展正则表达式，大小括号分组无须escape\nsed -E &#039;s/pattern/substituted/&#039;\n \n# 可以先使用下面的命令验证正则是否能匹配\nsed -nE &#039;/pattern/p&#039;\n \n# 分割符不一定非得是`/`，可以随便换，在搜索或替换的字符中包含`/`的时候，就不要用它作为分割符。\nsed &#039;s|pattern|substituted|&#039;\n \nsed -nE &#039;s/(&quot;Address&quot;.*:.*&quot;.*:)([0-9]{4,})&quot;/\\1\\2&quot;/p&#039; feeder_handler.cfg\nsed -nE &#039;/(&quot;Address&quot;.*:.*&quot;.*:)([0-9]{4,})&quot;/p&#039; feeder_handler.cfg\n可以先准备好正则表达式，利用下面的网站可以快速写出正确的正则表达式。\n正则表达式debug网站\n\nwww.debuggex.com/\nregex101.com/\n"},"__zettel/202507241701cat命令":{"slug":"__zettel/202507241701cat命令","filePath":"__zettel/202507241701cat命令.md","title":"202507241701","links":[],"tags":["linux","cmd"],"content":"# cat标准输入和一个文件到另一个文件\ncommand1 | cat - file1 &gt; file2\n \n# cat两个命令的输出\ncat &lt;(command1) &lt;(command2)\n \n# cat标准输入和一个命令的输出\ncommand1 | cat - &lt;(command2)"},"__zettel/202508151303redis集群部署":{"slug":"__zettel/202508151303redis集群部署","filePath":"__zettel/202508151303redis集群部署.md","title":"202508151303","links":[],"tags":["redis","cluster"],"content":"一般集群3主3备，需要6个redis示例。示例配置，\nport 6379\ncluster-enabled yes\ndir /etc/redis/\ncluster-config-file node.conf\ncluster-node-timeout 10000\nprotected-mode no\nrequirepass p@ssw0rd\nlogfile /etc/redis/redis-server.log\nio-threads 4\nio-threads-do-reads yes\nmasterauth p@ssw0rd\n\n然后在各个节点上启动redis示例，可以通过systemd service启动，以达到故障后自动重启的效果。启动完之后，在任意机器上通过redis-cli即可创建集群。\nredis-cli --cluster create 10.24.71.154:6380 10.24.71.165:6380 10.24.71.18:6380 10.24.71.184:6380 10.24.71.188:6380 10.24.71.189:6380 --cluster-replicas 1 -a &#039;p@ssw0rd&#039;\n\n即可自动分配槽位，主备等。\n$ cat /etc/redis/node.conf\n01e22cb1988300540363d16b88db9f300e90e09b 10.24.71.18:6379@16379 master - 0 1723628125000 3 connected 10923-16383\n4f2a252cb9e24b95543fff7e78004675bd70edeb 10.24.71.188:6379@16379 slave 7f5df9ad50649e087afc6c41a5b94479ad9b9f0a 0 1723628125090 1 connected\n7f5df9ad50649e087afc6c41a5b94479ad9b9f0a 10.24.71.154:6379@16379 master - 0 1723628124083 1 connected 0-5460\n354350dbd36e2302c9c59b768406c0662ad0f2c9 10.24.71.184:6379@16379 slave 01e22cb1988300540363d16b88db9f300e90e09b 0 1723628125191 3 connected\ncc6a11f2705eca8e2b362feebc512c5369448ee6 10.24.71.189:6379@16379 slave 0986e476de8a7097cc1c65f279651fa22a269c3b 0 1723628125000 2 connected\n0986e476de8a7097cc1c65f279651fa22a269c3b 10.24.71.165:6379@16379 myself,master - 0 1723628125000 2 connected 5461-10922\nvars currentEpoch 6 lastVoteEpoch 0\n同时，redis-cli连接任意集群节点，通过cluster nodes亦可查看，\n$ redis-cli -a &#039;p@ssw0rd&#039;\n127.0.0.1:6380&gt; CLUSTER NODES\n5e26e347983060f7703a0194925455099f9d1665 10.24.71.165:6380@16380 slave 6bda7c18e4f3ccc2a9b813e6e8990d5929dad7cb 0 1755234623000 1 connected\nca6cbd9b1a6887584e5e78d30aa5097ab438d839 10.24.71.189:6380@16380 master - 0 1755234623000 3 connected 10923-16383\na275278b451e517ce703aaf125d1e825ea00806b 10.24.71.154:6380@16380 myself,slave ca6cbd9b1a6887584e5e78d30aa5097ab438d839 0 1755234620000 3 connected\n6bda7c18e4f3ccc2a9b813e6e8990d5929dad7cb 10.24.71.184:6380@16380 master - 0 1755234624757 1 connected 0-5460\n046e0033330f0cafe25b84734e92f1c9a4d48ad7 10.24.71.188:6380@16380 master - 0 1755234621753 2 connected 5461-10922\ne88867b424ef5a10d61a59bb0d7999390d85cde3 10.24.71.18:6380@16380 slave 046e0033330f0cafe25b84734e92f1c9a4d48ad7 0 1755234623755 2 connected\n127.0.0.1:6380&gt; \n虽然集群中任意节点均可进行读写，但单点流量过高可能出现瓶颈。搭配predixy-1.0.5可以做到命令级负载均衡。"},"__zettel/202508181019redis配置io-threads":{"slug":"__zettel/202508181019redis配置io-threads","filePath":"__zettel/202508181019redis配置io-threads.md","title":"202508181019","links":[],"tags":["redis"],"content":"################################ THREADED I/O #################################\n\n# Redis is mostly single threaded, however there are certain threaded\n# operations such as UNLINK, slow I/O accesses and other things that are\n# performed on side threads.\n#\n# Now it is also possible to handle Redis clients socket reads and writes\n# in different I/O threads. Since especially writing is so slow, normally\n# Redis users use pipelining in order to speed up the Redis performances per\n# core, and spawn multiple instances in order to scale more. Using I/O\n# threads it is possible to easily speedup several times Redis without resorting\n# to pipelining nor sharding of the instance.\n#\n# By default threading is disabled, we suggest enabling it only in machines\n# that have at least 4 or more cores, leaving at least one spare core.\n# We also recommend using threaded I/O only if you actually have performance\n# problems, with Redis instances being able to use a quite big percentage of\n# CPU time, otherwise there is no point in using this feature.\n#\n# So for instance if you have a four cores boxes, try to use 3 I/O\n# threads, if you have a 8 cores, try to use 7 threads. In order to\n# enable I/O threads use the following configuration directive:\n#\n# io-threads 4\n#\n# Setting io-threads to 1 will just use the main thread as usual.\n# When I/O threads are enabled, we not only use threads for writes, that\n# is to thread the write(2) syscall and transfer the client buffers to the\n# socket, but also use threads for reads and protocol parsing.\n#\n# NOTE: If you want to test the Redis speedup using redis-benchmark, make\n# sure you also run the benchmark itself in threaded mode, using the\n# --threads option to match the number of Redis threads, otherwise you&#039;ll not\n# be able to notice the improvements.\n\nio-threads选项开启io多线程，值得注意的是，开启的io多线程中也包含主线程，所以通常4核，设为3，8核设为7，因为自带主线程也是一个io线程。"},"__zettel/202508232328garden-entry":{"slug":"__zettel/202508232328garden-entry","filePath":"__zettel/202508232328garden-entry.md","title":"Digital Garden Entry","links":[],"tags":[],"content":"This is site is powerd by obsidian digital garden plugin. And this page is a sample entry point for exploring this site, which should not be such simple though.\nThis site is mainly for self references, all pages liscensed under CC BY-NC-ND 4.0 unless explicitly claimed.\nSome selected pages,\ntable dateformat(file.mday, &quot;yy/MM/dd&quot;) as &quot;Update&quot;, file.tags as &quot;Tags&quot;\nfrom !&quot;work&quot; and !&quot;__obex&quot; and !&quot;inbox&quot; and !&quot;assets&quot; and !&quot;life&quot;\nwhere !containsword(file.name, &quot;202406111956_dataview&quot;)\nsort file.mday desc"},"__zettel/202509011620vector小坑":{"slug":"__zettel/202509011620vector小坑","filePath":"__zettel/202509011620vector小坑.md","title":"202509011620","links":[],"tags":["vector","cpp"],"content":"std::vector::emplace_back有时会调用copy ctor！大意就是，如果发生扩容，且没有定义move ctor，那么会调用copy ctor。如果提供了move ctor，优先调用move ctor。\nfrom cppreference:\n\nNotes\nSince reallocation may take place, emplace_back requires the element type to be MoveInsertable for vector.\n\nstackoverflow.com/a/40457433"},"__zettel/202509032035override关键字":{"slug":"__zettel/202509032035override关键字","filePath":"__zettel/202509032035override关键字.md","title":"202509032035","links":["notes/cpp/多态.html"],"tags":["cpp","虚函数"],"content":"析构函数与override\n\nvirtual\noverride\nfinal\n\n上面三个关键字在继承体系中起着重要作用。virtual不用多说，声明虚函数必备的关键字。override和final是C++11中引入的，二者的作用其实更多是提醒开发者自己，\n\n我正在重写一个虚函数\n我正在重写一个虚函数，并且不希望再被派生类重写这个函数\n\n当然，final也可以用来修饰类，表示这是最后一次继承，即我这个类不能再被继承了。很形象，例如\nclass A {};\nclass B : public A {};\nclass C final : pubilc B {};\nclass D : public C {}; // compile error!\n但除此之外，final和override对编译器而言，确实有助益。例如，\n\n如果你用override和final修饰一个函数，但基类没有这个函数，或者这个函数在基类没有被声明为虚函数，就会引发编译错误。当然，你可能只是手滑打错字了。但确实，编译错误帮你很快定位到这个问题。\n如果你用override和final修饰一个函数，你就不必再用virtual修饰。因为这两个修饰已经暗示这个函数是虚函数。当然，如果基类中声明已经声明了virtual，无论你用不用这些修饰词，这个函数在派生类中都是虚函数。\n\n然而，有一个很纠结的问题。在多态体系中，基类的析构函数必须是虚的。这就要问了，那对于派生类的析构函数，到底要不要声明为virtual，又或者用override或final修饰呢？这个问题很让人纠结，从下面这个issue出发，你可以看到大家的讨论\n\nC.128: Should destructors be marked “override”?\n\n用override修饰析构函数\n不过我自己的建议是，对于派生类的析构函数，总是用override修饰。如果你这么做了，你将得到如下收益：\n\n编译器确保基类的析构函数是虚的，否则编译报错。真的有人会忘记将基类析构函数声明为虚的。\n你可以直观看出，当前这个类有一个虚析构函数。\n\n同时，这也会因此困惑，\n\n析构函数可以被重写吗？你不敢确信，于是上网搜寻相关资料，发现并不能重写析构函数。过了一个月，你看到这段代码，又重演一遍上述剧情！\n\n确实，用override修饰析构函数会造成困惑！但是，它利大于弊。事实上，虚析构函数中的“虚”和普通的虚函数有着不一样的语义。对于普通成员函数，让他成为虚函数的目的是，我摆明了想在派生类中重写它，进而达到多态的效果。而析构函数的虚，是一种机制上的必须。当你用基类指针或引用使用动态绑定时，对象的销毁依赖于虚析构函数。如果基类的析构函数非虚，那么对象销毁时，只会调用基类的析构函数，这可能造成派生类的资源没有释放，进而导致内存泄漏。而如果基类的析构函数是虚的，那么会调用到派生类的析构函数，而派生类的析构函数保证会调用基类的析构函数（C++标准保证），这样一来，就能保证资源以合理的顺序释放。\n所以，用override修饰析构函数，并不是重写基类的析构函数（事实上我们也无法做到），而是在提醒编译器检查基类的虚构函数必须是虚的。\n为什么不用final修饰析构函数？\n事实上，final用来修饰函数，可以防止这个函数继续被派生类重写。但是，每个类都必须有析构函数！一旦析构函数被final修饰，那么这个类将无法再被继承。因为继承这个类，默认会带上生成析构函数，无论用不用这三个关键字修饰。然而，这个行为被基类的final阻止了，冲突了。这里，编译器认为是重写了被final修饰的函数，编译无法通过。\n为什么不用virtual修饰析构函数？\n可以，但没必要。因为如果基类析构函数已经是虚的，那么派生类析构函数自然而然也是虚的。用virtual修饰不会增加任何编译检查，因为virtual是声明虚函数的，对编译器没有任何提示作用。即便是基类没有的函数，派生类用virtual修饰的函数也会成为虚函数被进一步派生重写。"},"__zettel/202509291120deploy-github-page":{"slug":"__zettel/202509291120deploy-github-page","filePath":"__zettel/202509291120deploy-github-page.md","title":"202509291120","links":[],"tags":["github","CI","github-action"],"content":"下面的例子演示了直接从action deploy到github page的工作流，cf. github.com/DefenderOfBasic/obsidian-quartz-template/blob/main/.github/workflows/ci.yaml\nname: Build and Test\n \non:\n  push:\n    branches: [&quot;main&quot;]\n  workflow_dispatch:\n \njobs:\n  build-and-test:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          fetch-depth: 0\n \n      - name: Setup Node\n        uses: actions/setup-node@v4\n        with:\n          node-version: 20\n \n      - name: Cache dependencies\n        uses: actions/cache@v4\n        with:\n          path: ~/.npm\n          key: ${{ runner.os }}-node-${{ hashFiles(&#039;**/package-lock.json&#039;) }}\n          restore-keys: |\n            ${{ runner.os }}-node-\n \n      - run: npm install\n        working-directory: ./source\n \n      - name: chmod\n        run: chmod +x ./quartz/bootstrap-cli.mjs\n        working-directory: ./source\n \n      - name: Ensure Quartz builds\n        run: npx quartz build --bundleInfo\n        working-directory: ./source\n \n  deploy:\n    needs: build-and-test\n    permissions:\n      contents: read\n      pages: write\n      id-token: write\n    environment:\n      name: github-pages\n      url: ${{ steps.deployment.outputs.page_url }}\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          fetch-depth: 0\n \n      - name: Setup Node\n        uses: actions/setup-node@v4\n        with:\n          node-version: 20\n \n      - name: Build Quartz\n        run: |\n          npm install\n          npx quartz build\n        working-directory: ./source\n \n      - name: Copy raw HTML folder\n        run: |\n          ls -la\n          cp -r raw_html/* public/ || true\n          echo &quot;Contents of public directory:&quot;\n          ls -la public/\n        working-directory: ./source\n \n      - name: Setup GitHub Pages\n        uses: actions/configure-pages@v4\n \n      - name: Upload GitHub Pages artifact\n        uses: actions/upload-pages-artifact@v3\n        with:\n          path: ./source/public\n          retention-days: 1\n \n      - name: Deploy to GitHub Pages\n        id: deployment\n        uses: actions/deploy-pages@v4"},"__zettel/202509302140quartz发布obsidian":{"slug":"__zettel/202509302140quartz发布obsidian","filePath":"__zettel/202509302140quartz发布obsidian.md","title":"202509302140","links":[],"tags":["quartz","obsidian","publish"],"content":"问题\n我有一个obsidian仓库，私有的，因为里面有一些笔记涉及公司和个人隐私。但其余部分都是可公开的，有没有一个方案同时满足，\n\n免费\n可以控制哪些发布，哪些不发布\n原始仓库是私有的\n\n方案\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n工具名称优点缺点obsidian-digital-garden1. 一键部署到Vercel/Netlify2. 通过Frontmatter控制单笔记发布3. 无需维护GitHub CI1. 国内访问慢（Vercel已无法访问）2. 导出网站存在异常，未深究3. 部署GitHub Pages困难且定制性低obsidian-webpage-export1. 支持仓库整体导出为HTML2. 可部署到GitHub Pages1. 开发中功能不完善2. 部分笔记导出报错且提示不清晰3. 不支持单笔记发布控制quartz1. 支持Glob匹配发布控制2. 案例丰富参考性强3. 文档齐全4. UI高度可定制1. 不支持Dataview语法2. 不兼容Obsidian的Base文件\n最后选用了quartz. 看看这个网站有多美！\nQuartz需要一些内部文件来完成文件转网页的工作，通常是一些js、ts、json文件。这样以来便有两种选择，\n\n将quartz集成到obsidian仓库（私有）中，将转换好的文件publish到另一个仓库（公开）\n新建一个公开仓库放quartz，然后将obsidian仓库作为submodule引入，直接在本仓库执行构建，发布\n\n这里我选用方案2，因为方案1会污染obsidian仓库，而它本应聚焦于内容创作！而这个新建的仓库就是guyueshui/quartz，参考其中的action文件。\n# Copied from jackyzha0/quartz&#039;s ci.yaml\nname: Build vault\n \non:\n  pull_request:\n    branches:\n      - master\n  push:\n    branches:\n      - master\n    paths:\n      - &#039;.gitmodules&#039;\n      - &#039;learn2live/**&#039;\n  # receive event of submodule update\n  repository_dispatch:\n    types: [submodule_updated]\n  workflow_dispatch:\n \njobs:\n  build-and-test:\n    strategy:\n      matrix:\n        os: [ubuntu-latest]\n    runs-on: ${{ matrix.os }}\n    permissions:\n      contents: write\n      pages: write\n      id-token: write\n \n    steps:\n      - uses: actions/checkout@v5\n        with:\n          fetch-depth: 0\n          token: ${{ secrets.VAULT_PAT }}\n          submodules: &#039;recursive&#039;\n \n      - name: Update submodule to latest\n        run: |\n          git config --global user.email &quot;actions@github.com&quot;\n          git config --global user.name &quot;GitHub Actions&quot;\n          git submodule foreach --recursive &#039;git checkout main || git checkout master&#039;\n          git submodule update --remote --merge\n          git add .\n          git commit -m &quot;chore: sync submodules to HEAD&quot; || exit 0\n          git push\n \n      - name: Setup Node\n        uses: actions/setup-node@v5\n        with:\n          node-version: 22\n \n      - name: Cache dependencies\n        uses: actions/cache@v4\n        with:\n          path: ~/.npm\n          key: ${{ runner.os }}-node-${{ hashFiles(&#039;**/package-lock.json&#039;) }}\n          restore-keys: |\n            ${{ runner.os }}-node-\n \n      - run: npm ci\n \n      - name: Test\n        run: npm test\n \n      - name: Ensure Quartz builds, check bundle info\n        run: npx quartz build --bundleInfo -d learn2live\n \n      - name: Setup GitHub Pages\n        uses: actions/configure-pages@v4\n \n      - name: Upload GitHub Pages artifact\n        uses: actions/upload-pages-artifact@v3\n        with:\n          path: ./public\n          retention-days: 1\n \n      - name: Deploy to GitHub Pages\n        id: deployment\n        uses: actions/deploy-pages@v4\n而obsidian仓库（私有）仅作为submodule提供内容，同时也需要配置一个action，在仓库更新后，触发quartz仓库的构建。Actions文件如下，\nname: Trigger deployment of obsidian vault\n# see: github.com/guyueshui/quartz\n \non:\n  pull_request:\n    branches:\n      - master\n  push:\n    branches:\n      - master\n  # 允许手动触发\n  workflow_dispatch:\n \njobs:\n  build-and-test:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Post &quot;submodule_updated&quot; event\n        # 向quartz仓库推送内容更新的事件，对应quartz仓库ci中的repository_dispatch\n        run: |\n          curl -X POST \\\n            -H &quot;Authorization: token ${{ secrets.VAULT_PAT }}&quot; \\\n            -H &quot;Accept: application/vnd.github.everest-preview+json&quot; \\\n            api.github.com/repos/guyueshui/quartz/dispatches \\\n            -d &#039;{&quot;event_type&quot;:&quot;submodule_updated&quot;}&#039;\n      - run: |\n          echo &quot;Onwer: ${{ github.repository_owner }}&quot;\n          echo &quot;Repo:  ${{ github.event.repository.name }}&quot;\n  \n另外配置还有几点要注意：\n\n可以创建一个PAT（Personal Access Token）同时具备这两个仓库的读写权限，实际上obsidna仓库只需要读\nPAT创建入口：github.com/settings/personal-access-tokens\nPAT权限注意勾选workflow，因为要跨仓库触发quartz仓库的workflow\nquartz仓库设置中的Actions &gt; Workflow permissions更改为”Read and write permissions”\nsecrets.VAULT_PAT对应仓库中配置的Settings &gt; Secrets and variables &gt; Actions &gt; Repository secrets\n\n\n此时，就可以做到更新obsidian仓库，触发quartz仓库的构建操作，进而更新发布出去的网站。\nQuartz定制\n私有笔记不发布\n参考：quartz.jzhao.xyz/features/private-pages\n例如我的忽略配置如下，\nignorePatterns: [\n  &quot;private&quot;, &quot;templates&quot;, &quot;.obsidian&quot;,\n  &quot;__obex&quot;, &quot;.+&quot;, &quot;work&quot;,\n  &quot;life/亲子&quot;,\n  &quot;**/202305302345.md&quot;,\n  &quot;**/2022-07-22.md&quot;,\n  &quot;**/2022-09-06.md&quot;,\n  // &quot;assets&quot;,\n],\nasset必须要发布，不然笔记中的图片就找不到了。\nAccent color\n直接修改quartz.config.ts中的config.theme.colors字段。改颜色是个审美的活，简单点就好。\nExplorer过滤assets文件夹\n参考：quartz.jzhao.xyz/features/explorer\ndiff --git a/quartz.layout.ts b/quartz.layout.ts\nindex bd16975..042210d 100644\n--- a/quartz.layout.ts\n+++ b/quartz.layout.ts\n@@ -1,5 +1,27 @@\n import { PageLayout, SharedLayout } from &quot;./quartz/cfg&quot;\n import * as Component from &quot;./quartz/components&quot;\n+import { Options as ExplOptions } from &quot;./quartz/components/Explorer&quot;\n+\n+// add explorer customizations, cf. quartz.jzhao.xyz/features/explorer\n+export const explMapFn : ExplOptions[&quot;mapFn&quot;] =\n+(node) =&gt; {\n+  if (node.isFolder) {\n+    node.displayName = &quot;📁 &quot; + node.displayName\n+  } else {\n+    node.displayName = &quot;📄 &quot; + node.displayName\n+  }\n+}\n+\n+export const explFilterFn : ExplOptions[&quot;filterFn&quot;] =\n+(node) =&gt; {\n+  // set containing names of everything you want to filter out\n+    const omit = new Set([&quot;assets&quot;, &quot;tags&quot;, &quot;advanced&quot;])\n+ \n+    // can also use node.slug or by anything on node.data\n+    // note that node.data is only present for files that exist on disk\n+    // (e.g. implicit folder nodes that have no associated index.md)\n+    return !omit.has(node.displayName.toLowerCase())\n+}\n \n // components shared across all pages\n export const sharedPageComponents: SharedLayout = {\n@@ -38,7 +60,7 @@ export const defaultContentPageLayout: PageLayout = {\n         { Component: Component.ReaderMode() },\n       ],\n     }),\n-    Component.Explorer(),\n+    Component.Explorer({&#039;mapFn&#039;: explMapFn, &#039;filterFn&#039;: explFilterFn}),\n   ],\n   right: [\n     Component.Graph(),\n@@ -62,7 +84,7 @@ export const defaultListPageLayout: PageLayout = {\n         { Component: Component.Darkmode() },\n       ],\n     }),\n-    Component.Explorer(),\n+    Component.Explorer({&#039;mapFn&#039;: explMapFn, &#039;filterFn&#039;: explFilterFn}),\n   ],\n   right: [],\n }\n小结\n可见，quartz的定制还是非常方便的。"},"assets/202305161028内存模型-202306291048.excalidraw":{"slug":"assets/202305161028内存模型-202306291048.excalidraw","filePath":"assets/202305161028内存模型-202306291048.excalidraw.md","title":"202305161028内存模型-202306291048.excalidraw","links":[],"tags":["excalidraw"],"content":"⚠  Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠\nExcalidraw Data\nText Elements\natomic x; ^EaLfjD5E\nthread A \nthread B \n// dome\n// some\n// write\nx.store(23, memory_order_realse); \nif (x.load(memory_order_acquire) == 23) {\n// at this point, all writes in A\n// before x.store(23, memory_order_release)\n// is visible in B.\n} "},"assets/cache-coherency.excalidraw":{"slug":"assets/cache-coherency.excalidraw","filePath":"assets/cache-coherency.excalidraw.md","title":"cache-coherency.excalidraw","links":[],"tags":["excalidraw"],"content":"⚠  Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠\nExcalidraw Data\nText Elements\nCPU Core2 \nCPU Core1 \nmemory \ncache: A=0; B=2; \ncache: A=1; B=0; \nA=0; B=0;\n// thread 1\nA = 1;\nprint(B);\n// thread 2\nB = 2;\nprint(A); "},"assets/excalidraw/202305300948.excalidraw":{"slug":"assets/excalidraw/202305300948.excalidraw","filePath":"assets/excalidraw/202305300948.excalidraw.md","title":"202305300948.excalidraw","links":[],"tags":["excalidraw"],"content":"⚠  Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠\nExcalidraw Data\nText Elements\nData \nSentTime\n8 byte\n\n-8 \n-16 \n-68 \n-66 \nSerialNumber\n2 byte \ntype SendData struct {\nIP     string\nData   []byte\nNumber uint16\n} \n\nserialNumber 共有 SendData.Number 个，从 0 依次递增 \n"},"assets/excalidraw/Scripts/Downloaded/Add-Link-to-Existing-File-and-Open":{"slug":"assets/excalidraw/Scripts/Downloaded/Add-Link-to-Existing-File-and-Open","filePath":"assets/excalidraw/Scripts/Downloaded/Add Link to Existing File and Open.md","title":"Add Link to Existing File and Open","links":[],"tags":[],"content":"/*\r\n\nPrompts for a file from the vault. Adds a link to the selected element pointing to the selected file. You can control in settings to open the file in the current active pane or an adjacent pane.\n*/\n \nif(!ea.verifyMinimumPluginVersion || !ea.verifyMinimumPluginVersion(&quot;1.5.21&quot;)) {\n  new Notice(&quot;This script requires a newer version of Excalidraw. Please install the latest version.&quot;);\n  return;\n}\n \nsettings = ea.getScriptSettings();\n \nif(!settings[&quot;Open link in active pane&quot;]) {\n  settings = {\n    &quot;Open link in active pane&quot;: {\n      value: false,\n      description: &quot;Open the link in the current active pane (on) or a new pane (off).&quot;\n\t},\n    ...settings\n  };\n  ea.setScriptSettings(settings);\n}\n \nconst openInCurrentPane = settings[&quot;Open link in active pane&quot;].value;\n \nelements = ea.getViewSelectedElements();\nif(elements.length === 0) {\n  new Notice(&quot;No selected elements&quot;);\n  return;\n}\n \nconst files = app.vault.getFiles()\nconst filePaths = files.map((f)=&gt;f.path);\nfile = await utils.suggester(filePaths,files,&quot;Select a file&quot;);\n \nif(!file) return;\n \nconst link = `[[${app.metadataCache.fileToLinktext(file,ea.targetView.file.path,true)}]]`;\n \nea.style.backgroundColor = &quot;transparent&quot;;\nea.style.strokeColor = &quot;rgba(70,130,180,0.05)&quot;\nea.style.strokeWidth = 2;\nea.style.roughness = 0;\n \nif(elements.length===1 &amp;&amp; elements[0].type !== &quot;text&quot;) {\n  ea.copyViewElementsToEAforEditing(elements);\n\tea.getElements()[0].link = link;\n} else {\n  const b = ea.getBoundingBox(elements);\n  const id = ea.addEllipse(b.topX+b.width-5, b.topY, 5, 5);\n  ea.getElement(id).link = link;\n  ea.copyViewElementsToEAforEditing(elements);\n  ea.addToGroup(elements.map((e)=&gt;e.id).concat([id]));\n}\nawait ea.addElementsToView(false,true,true);\nea.selectElementsInView(ea.getElements());\n \nif(openInCurrentPane) {\n\tapp.workspace.openLinkText(file.path,ea.targetView.file.path,false);\n  return;\n}\nea.openFileInNewOrAdjacentLeaf(file);"},"assets/excalidraw/Scripts/Downloaded/Mindmap-connector":{"slug":"assets/excalidraw/Scripts/Downloaded/Mindmap-connector","filePath":"assets/excalidraw/Scripts/Downloaded/Mindmap connector.md","title":"Mindmap connector","links":[],"tags":[],"content":"/*\n\n\nThis script creates mindmap like lines(only right and down side are available). The line will starts according to the creation time of the elements. So you may need to create the header element first.\n*/\nconst elements = ea.getViewSelectedElements();\nea.copyViewElementsToEAforEditing(elements);\ngroups = ea.getMaximumGroups(elements);\n \nels=[];\nelsx=[];\nelsy=[];\nfor (i = 0, len =groups.length; i &lt; len; i++) {\n  els.push(ea.getLargestElement(groups[i]));\n  elsx.push(ea.getLargestElement(groups[i]).x);\n  elsy.push(ea.getLargestElement(groups[i]).y);\n}\n//line style setting\nea.style.strokeColor = els[0].strokeColor;\nea.style.strokeWidth = els[0].strokeWidth;\nea.style.strokeStyle = els[0].strokeStyle;\nea.style.strokeSharpness = els[0].strokeSharpness;\n//all min max x y\nlet maxy = Math.max.apply(null, elsy);\nlet indexmaxy=elsy.indexOf(maxy);\nlet miny = Math.min.apply(null, elsy);\nlet indexminy = elsy.indexOf(miny);\nlet maxx = Math.max.apply(null, elsx);\nlet indexmaxx = elsx.indexOf(maxx);\nlet minx = Math.min.apply(null, elsx);\nlet indexminx = elsx.indexOf(minx);\n//child max min x y\nlet gmaxy = Math.max.apply(null, elsy.slice(1));\nlet gindexmaxy=elsy.indexOf(gmaxy);\nlet gminy = Math.min.apply(null, elsy.slice(1));\nlet gindexminy = elsy.indexOf(gminy);\nlet gmaxx = Math.max.apply(null, elsx.slice(1));\nlet gindexmaxx = elsx.indexOf(gmaxx);\nlet gminx = Math.min.apply(null, elsx.slice(1));\nlet gindexminx = elsx.indexOf(gminx);\nlet s=0;//Set line direction down as default \nif (indexminx==0 &amp;&amp;  els[0].x + els[0].width&lt;=gminx) {\n  s=1; \n}\nelse if (indexminy == 0) {\n  s=0;\n}\nvar length_left;\nif(els[0].x + els[0].width * 2&lt;=gminx){length_left=els[0].x + els[0].width * 1.5;}\nelse {length_left=(els[0].x + els[0].width+gminx)/2;}\n \nvar length_down;\nif(els[0].y + els[0].height* 2.5&lt;=gminy){length_down=els[0].y + els[0].height * 2;}\nelse {length_down=(els[0].y + els[0].height+gminy)/2;}\nif(s) {\n  ea.addLine(\n    [[length_left,\n    maxy + els[indexmaxy].height / 2],\n    [length_left,\n    miny + els[indexminy].height / 2]]\n  );\n  for (i = 1, len = groups.length; i &lt; len; i++) {\n    ea.addLine(\n      [[els[i].x,\n      els[i].y + els[i].height/2],\n      [length_left,\n      els[i].y + els[i].height/2]]\n    );\n  }\n  ea.addArrow(\n    [[els[0].x+els[0].width,\n    els[0].y + els[0].height / 2],\n    [length_left,\n    els[0].y + els[0].height / 2]],\n    {\n      startArrowHead: &quot;none&quot;,\n      endArrowHead: &quot;dot&quot;\n    }\n  )\n}\n \nelse {\n  ea.addLine(\n    [[maxx + els[indexmaxx].width / 2,\n    length_down],\n    [minx + els[indexminx].width / 2,\n    length_down]]\n  );\n  for (i = 1, len = groups.length; i &lt; len; i++) {\n    ea.addLine(\n      [[els[i].x + els[i].width / 2,\n      els[i].y],\n      [els[i].x + els[i].width / 2,\n      length_down]]\n    );\n  }\n  ea.addArrow(\n    [[els[0].x + els[0].width / 2,\n    els[0].y + els[0].height],\n    [els[0].x + els[0].width / 2,\n    length_down]],\n    {\n      startArrowHead: &quot;none&quot;,\n      endArrowHead: &quot;dot&quot;\n    }\n  );\n}\n \nawait ea.addElementsToView(false,false,true);"},"assets/excalidraw/Scripts/Downloaded/Mindmap-format":{"slug":"assets/excalidraw/Scripts/Downloaded/Mindmap-format","filePath":"assets/excalidraw/Scripts/Downloaded/Mindmap format.md","title":"Mindmap format","links":[],"tags":[],"content":"/*\nformat the left to right mind map\n\ntree\nMind map is actually a tree, so you must have a root node. The script will determine the leftmost element of the selected element as the root element (node is excalidraw element, e.g. rectangle, diamond, ellipse, text, image, but it can’t be arrow, line, freedraw, group)\nThe element connecting node and node must be an arrow and  have the correct direction, e.g. parent node → children node\nsort\nThe order of nodes in the Y axis or vertical direction is determined by the creation time of the arrow connecting it\n\nSo if you want to readjust the order, you can delete arrows and reconnect them\nsetting\nScript provides options to adjust the style of mind map, The option is at the bottom of the option of the exalidraw plugin(e.g. Settings → Community plugins → Excalidraw → drag to bottom)\nproblem\n\nsince the start bingding and end bingding of the arrow are easily disconnected from the node, so if there are unformatted parts, please check the connection and use the script to reformat\n\n*/\n \nlet settings = ea.getScriptSettings();\n//set default values on first run\nif (!settings[&quot;MindMap Format&quot;]) {\n  settings = {\n    &quot;MindMap Format&quot;: {\n      value: &quot;Excalidraw/MindMap Format&quot;,\n      description:\n        &quot;This is prepared for the namespace of MindMap Format and does not need to be modified&quot;,\n    },\n    &quot;default gap&quot;: {\n      value: 10,\n      description: &quot;Interval size of element&quot;,\n    },\n    &quot;curve length&quot;: {\n      value: 40,\n      description: &quot;The length of the curve part in the mind map line&quot;,\n    },\n    &quot;length between element and line&quot;: {\n      value: 50,\n      description:\n        &quot;The distance between the tail of the connection and the connecting elements of the mind map&quot;,\n    },\n  };\n  ea.setScriptSettings(settings);\n}\n \n// default X coordinate of the middle point of the arc\nconst defaultDotX = Number(settings[&quot;curve length&quot;].value);\n// The default length from the middle point of the arc on the X axis\nconst defaultLengthWithCenterDot = Number(\n  settings[&quot;length between element and line&quot;].value\n);\n// Initial trimming distance of the end point on the Y axis\nconst initAdjLength = 4;\n// default gap\nconst defaultGap = Number(settings[&quot;default gap&quot;].value);\n \nconst setCenter = (parent, line) =&gt; {\n  // Focus and gap need the api calculation of excalidraw\n  // e.g. determineFocusDistance, but they are not available now\n  // so they are uniformly set to 0/1\n  line.startBinding.focus = 0;\n  line.startBinding.gap = 1;\n  line.endBinding.focus = 0;\n  line.endBinding.gap = 1;\n  line.x = parent.x + parent.width;\n  line.y = parent.y + parent.height / 2;\n};\n \n/**\n * set the middle point of curve\n * @param {any} lineEl the line element of excalidraw\n * @param {number} height height of dot on Y axis\n * @param {number} [ratio=1] ，coefficient of the initial trimming distance of the end point on the Y axis, default is 1\n */\nconst setTopCurveDotOnLine = (lineEl, height, ratio = 1) =&gt; {\n  if (lineEl.points.length &lt; 3) {\n    lineEl.points.splice(1, 0, [defaultDotX, lineEl.points[0][1] - height]);\n  } else if (lineEl.points.length === 3) {\n    lineEl.points[1] = [defaultDotX, lineEl.points[0][1] - height];\n  } else {\n    lineEl.points.splice(2, lineEl.points.length - 3);\n    lineEl.points[1] = [defaultDotX, lineEl.points[0][1] - height];\n  }\n  lineEl.points[2][0] = lineEl.points[1][0] + defaultLengthWithCenterDot;\n  // adjust the curvature of the second line segment\n  lineEl.points[2][1] = lineEl.points[1][1] - initAdjLength * ratio * 0.8;\n};\n \nconst setMidCurveDotOnLine = (lineEl) =&gt; {\n  if (lineEl.points.length &lt; 3) {\n    lineEl.points.splice(1, 0, [defaultDotX, lineEl.points[0][1]]);\n  } else if (lineEl.points.length === 3) {\n    lineEl.points[1] = [defaultDotX, lineEl.points[0][1]];\n  } else {\n    lineEl.points.splice(2, lineEl.points.length - 3);\n    lineEl.points[1] = [defaultDotX, lineEl.points[0][1]];\n  }\n  lineEl.points[2][0] = lineEl.points[1][0] + defaultLengthWithCenterDot;\n  lineEl.points[2][1] = lineEl.points[1][1];\n};\n \n/**\n * set the middle point of curve\n * @param {any} lineEl the line element of excalidraw\n * @param {number} height height of dot on Y axis\n * @param {number} [ratio=1] ，coefficient of the initial trimming distance of the end point on the Y axis, default is 1\n */\nconst setBottomCurveDotOnLine = (lineEl, height, ratio = 1) =&gt; {\n  if (lineEl.points.length &lt; 3) {\n    lineEl.points.splice(1, 0, [defaultDotX, lineEl.points[0][1] + height]);\n  } else if (lineEl.points.length === 3) {\n    lineEl.points[1] = [defaultDotX, lineEl.points[0][1] + height];\n  } else {\n    lineEl.points.splice(2, lineEl.points.length - 3);\n    lineEl.points[1] = [defaultDotX, lineEl.points[0][1] + height];\n  }\n  lineEl.points[2][0] = lineEl.points[1][0] + defaultLengthWithCenterDot;\n  // adjust the curvature of the second line segment\n  lineEl.points[2][1] = lineEl.points[1][1] + initAdjLength * ratio * 0.8;\n};\n \nconst setTextXY = (rect, text) =&gt; {\n  text.x = rect.x + (rect.width - text.width) / 2;\n  text.y = rect.y + (rect.height - text.height) / 2;\n};\n \nconst setChildrenXY = (parent, children, line, elementsMap) =&gt; {\n  children.x = parent.x + parent.width + line.points[2][0];\n  children.y =\n    parent.y + parent.height / 2 + line.points[2][1] - children.height / 2;\n  if (\n    [&quot;rectangle&quot;, &quot;diamond&quot;, &quot;ellipse&quot;].includes(children.type) &amp;&amp;\n    ![null, undefined].includes(children.boundElements)\n  ) {\n    const textDesc = children.boundElements.filter(\n      (el) =&gt; el.type === &quot;text&quot;\n    )[0];\n    if (textDesc !== undefined) {\n      const textEl = elementsMap.get(textDesc.id);\n      setTextXY(children, textEl);\n    }\n  }\n};\n \n/**\n * returns the height of the upper part of all child nodes\n * and the height of the lower part of all child nodes\n * @param {Number[]} childrenTotalHeightArr\n * @returns {Number[]} [topHeight, bottomHeight]\n */\nconst getNodeCurrentHeight = (childrenTotalHeightArr) =&gt; {\n  if (childrenTotalHeightArr.length &lt;= 0) return [0, 0];\n  else if (childrenTotalHeightArr.length === 1)\n    return [childrenTotalHeightArr[0] / 2, childrenTotalHeightArr[0] / 2];\n  const heightArr = childrenTotalHeightArr;\n  let topHeight = 0,\n    bottomHeight = 0;\n  const isEven = heightArr.length % 2 === 0;\n  const mid = Math.floor(heightArr.length / 2);\n  const topI = mid - 1;\n  const bottomI = isEven ? mid : mid + 1;\n  topHeight = isEven ? 0 : heightArr[mid] / 2;\n  for (let i = topI; i &gt;= 0; i--) {\n    topHeight += heightArr[i];\n  }\n  bottomHeight = isEven ? 0 : heightArr[mid] / 2;\n  for (let i = bottomI; i &lt; heightArr.length; i++) {\n    bottomHeight += heightArr[i];\n  }\n  return [topHeight, bottomHeight];\n};\n \n/**\n * handle the height of each point in the single-level tree\n * @param {Array} lines\n * @param {Map} elementsMap\n * @param {Boolean} isEven\n * @param {Number} mid &#039;lines&#039; array midpoint index\n * @returns {Array} height array corresponding to &#039;lines&#039;\n */\nconst handleDotYValue = (lines, elementsMap, isEven, mid) =&gt; {\n  const getTotalHeight = (line, elementsMap) =&gt; {\n    return elementsMap.get(line.endBinding.elementId).totalHeight;\n  };\n  const getTopHeight = (line, elementsMap) =&gt; {\n    return elementsMap.get(line.endBinding.elementId).topHeight;\n  };\n  const getBottomHeight = (line, elementsMap) =&gt; {\n    return elementsMap.get(line.endBinding.elementId).bottomHeight;\n  };\n  const heightArr = new Array(lines.length).fill(0);\n  const upI = mid === 0 ? 0 : mid - 1;\n  const bottomI = isEven ? mid : mid + 1;\n  let initHeight = isEven ? 0 : getTopHeight(lines[mid], elementsMap);\n  for (let i = upI; i &gt;= 0; i--) {\n    heightArr[i] = initHeight + getBottomHeight(lines[i], elementsMap);\n    initHeight += getTotalHeight(lines[i], elementsMap);\n  }\n  initHeight = isEven ? 0 : getBottomHeight(lines[mid], elementsMap);\n  for (let i = bottomI; i &lt; lines.length; i++) {\n    heightArr[i] = initHeight + getTopHeight(lines[i], elementsMap);\n    initHeight += getTotalHeight(lines[i], elementsMap);\n  }\n  return heightArr;\n};\n \n/**\n * format single-level tree\n * @param {any} parent\n * @param {Array} lines\n * @param {Map} childrenDescMap\n * @param {Map} elementsMap\n */\nconst formatTree = (parent, lines, childrenDescMap, elementsMap) =&gt; {\n  lines.forEach((item) =&gt; setCenter(parent, item));\n \n  const isEven = lines.length % 2 === 0;\n  const mid = Math.floor(lines.length / 2);\n  const heightArr = handleDotYValue(lines, childrenDescMap, isEven, mid);\n  lines.forEach((item, index) =&gt; {\n    if (isEven) {\n      if (index &lt; mid) setTopCurveDotOnLine(item, heightArr[index], index + 1);\n      else setBottomCurveDotOnLine(item, heightArr[index], index - mid + 1);\n    } else {\n      if (index &lt; mid) setTopCurveDotOnLine(item, heightArr[index], index + 1);\n      else if (index === mid) setMidCurveDotOnLine(item);\n      else setBottomCurveDotOnLine(item, heightArr[index], index - mid);\n    }\n  });\n  lines.forEach((item) =&gt; {\n    if (item.endBinding !== null) {\n      setChildrenXY(\n        parent,\n        elementsMap.get(item.endBinding.elementId),\n        item,\n        elementsMap\n      );\n    }\n  });\n};\n \nconst generateTree = (elements) =&gt; {\n  const elIdMap = new Map([[elements[0].id, elements[0]]]);\n  let minXEl = elements[0];\n  for (let i = 1; i &lt; elements.length; i++) {\n    elIdMap.set(elements[i].id, elements[i]);\n    if (\n      !(elements[i].type === &quot;arrow&quot; || elements[i].type === &quot;line&quot;) &amp;&amp;\n      elements[i].x &lt; minXEl.x\n    ) {\n      minXEl = elements[i];\n    }\n  }\n  const root = {\n    el: minXEl,\n    totalHeight: minXEl.height,\n    topHeight: 0,\n    bottomHeight: 0,\n    linkChildrensLines: [],\n    isLeafNode: false,\n    children: [],\n  };\n  const preIdSet = new Set(); // The id_set of Elements that is already in the tree, avoid a dead cycle\n  const dfsForTreeData = (root) =&gt; {\n    if (preIdSet.has(root.el.id)) {\n      return 0;\n    }\n    preIdSet.add(root.el.id);\n    let lines = root.el.boundElements.filter(\n      (el) =&gt;\n        el.type === &quot;arrow&quot; &amp;&amp;\n        !preIdSet.has(el.id) &amp;&amp;\n        elIdMap.get(el.id)?.startBinding?.elementId === root.el.id\n    );\n    if (lines.length === 0) {\n      root.isLeafNode = true;\n      root.totalHeight = root.el.height + 2 * defaultGap;\n      [root.topHeight, root.bottomHeight] = [\n        root.totalHeight / 2,\n        root.totalHeight / 2,\n      ];\n      return root.totalHeight;\n    } else {\n      lines = lines.map((elementDesc) =&gt; {\n        preIdSet.add(elementDesc.id);\n        return elIdMap.get(elementDesc.id);\n      });\n    }\n \n    const linkChildrensLines = [];\n    lines.forEach((el) =&gt; {\n      const line = el;\n      if (\n        line &amp;&amp;\n        line.endBinding !== null &amp;&amp;\n        line.endBinding !== undefined &amp;&amp;\n        !preIdSet.has(elIdMap.get(line.endBinding.elementId).id)\n      ) {\n        const children = elIdMap.get(line.endBinding.elementId);\n        linkChildrensLines.push(line);\n        root.children.push({\n          el: children,\n          totalHeight: 0,\n          topHeight: 0,\n          bottomHeight: 0,\n          linkChildrensLines: [],\n          isLeafNode: false,\n          children: [],\n        });\n      }\n    });\n \n    let totalHeight = 0;\n    root.children.forEach((el) =&gt; (totalHeight += dfsForTreeData(el)));\n \n    root.linkChildrensLines = linkChildrensLines;\n    if (root.children.length === 0) {\n      root.isLeafNode = true;\n      root.totalHeight = root.el.height + 2 * defaultGap;\n      [root.topHeight, root.bottomHeight] = [\n        root.totalHeight / 2,\n        root.totalHeight / 2,\n      ];\n    } else if (root.children.length &gt; 0) {\n      root.totalHeight = Math.max(root.el.height + 2 * defaultGap, totalHeight);\n      [root.topHeight, root.bottomHeight] = getNodeCurrentHeight(\n        root.children.map((item) =&gt; item.totalHeight)\n      );\n    }\n \n    return totalHeight;\n  };\n  dfsForTreeData(root);\n  const dfsForFormat = (root) =&gt; {\n    if (root.isLeafNode) return;\n    const childrenDescMap = new Map(\n      root.children.map((item) =&gt; [item.el.id, item])\n    );\n    formatTree(root.el, root.linkChildrensLines, childrenDescMap, elIdMap);\n    root.children.forEach((el) =&gt; dfsForFormat(el));\n  };\n  dfsForFormat(root);\n};\n \nconst elements = ea.getViewSelectedElements();\ngenerateTree(elements);\n \nea.copyViewElementsToEAforEditing(elements);\nawait ea.addElementsToView(false, false);"},"assets/excalidraw/gre-question.excalidraw":{"slug":"assets/excalidraw/gre-question.excalidraw","filePath":"assets/excalidraw/gre-question.excalidraw.md","title":"gre-question.excalidraw","links":["assets/excalidraw/assets/gre-question.excalidraw/Pasted-Image-20230519100812_250.png","assets/excalidraw/assets/gre-question.excalidraw/Pasted-Image-20230519104821_548.png"],"tags":["excalidraw"],"content":"⚠  Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠\nExcalidraw Data\nText Elements\n这里说的逻辑直连，物理上应该是一个一个连接，既然如此，跳数怎么下降的呢？ \n是否所有GRE隧道链路上的机器都需要开一个端口进行\nGRE报文的收发？ \nEmbedded Files\n6c8c306854694a9810f2759a580c27c2950ac3c5: Pasted Image 20230519100812_250.png\n393a584e570d243d8c3c6bdce913b1b18931176c: Pasted Image 20230519104821_548.png"},"assets/对称加密-202306071102.excalidraw":{"slug":"assets/对称加密-202306071102.excalidraw","filePath":"assets/对称加密-202306071102.excalidraw.md","title":"对称加密-202306071102.excalidraw","links":[],"tags":["excalidraw"],"content":"⚠  Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠\nExcalidraw Data\nText Elements\n接收方 \n密文 \n解密算法 \n明文 \n密钥 \n发送方 \n明文 \n加密算法 \n密文 \n密钥 \n密文 \n同一个密钥 \n发送方 \n消息 \n认证码计算 \n认证码 \n密钥 \n接收方 \n认证码计算 \n密钥 \n同一个密钥 \n消息 \n认证码 \n消息 \n认证码 \n认证码 \n比较 "},"diary/2022-05-23":{"slug":"diary/2022-05-23","filePath":"diary/2022-05-23.md","title":"2022-05-23","links":[],"tags":[],"content":"Title\nThis is a diary.\nsee a image\n"},"diary/2022-05-26":{"slug":"diary/2022-05-26","filePath":"diary/2022-05-26.md","title":"2022-05-26","links":["notes/cpp/TypeTraits介绍.html","tags/copy-on-write.html","tags/endian.html","tags/ifdef.html","tags/endif.html","tags/if.html"],"tags":["diary","copy-on-write","endian","ifdef","endif","if"],"content":"\n2022-05-26\n\nIf you can’t explain it simply, you don’t understand it well enough.\n— Albert Einstein\n\nWhat is cpp type traits?\nCf. www.internalpointers.com/post/quick-primer-type-traits-modern-cpp\nTypeTraits介绍\nkeywords: mmap, copy-on-write\n\nCopy on write\ncopy-on-write\nCopy-on-write (sometimes referred to as “COW”) is an optimization strategy used in computer programming. The fundamental idea is that if multiple callers ask for resources which are initially indistinguishable, you can give them pointers to the same resource. This function can be maintained until a caller tries to modify its “copy” of the resource, at which point a true private copy is created to prevent the changes becoming visible to everyone else. All of this happens transparently to the callers. The primary advantage is that if a caller never makes any modifications, no private copy need ever be created.\n“Copy on write” means more or less what it sounds like: everyone has a single shared copy of the same data until it’s written, and then a copy is made.\nCopy发生在write之时，此前所有人共享一份数据。当某某请求修改这份数据时，copy一份给他自己去改，不要影响共享的那份。\n\nHow to teach endian\nOn /r/programming is this post about byte-order/endianness. It gives the same information as most documents on the topic. It is wrong. It’s been wrong for over 30 years. Here’s how it should be taught.\nOne of the major disciplines in computer science is parsing/formatting. This is the process of converting the external format of data (file formats, network protocols, hardware registers) into the internal format (the data structures that software operates on).\nIt should be a formal computer-science discipline, because it’s actually a lot more difficult than you’d expect. That’s because the majority of vulnerabilities in software that hackers exploit are due to parsing bugs. Since programmers don’t learn about parsing formally, they figure it out for themselves, creating ad hoc solutions that are prone to bugs. For example, programmers assume external buffers cannot be larger than internal ones, leading to buffer overflows.\nAn external format must be well-defined. What the first byte means must be written down somewhere, then what the second byte means, and so on. For Internet protocols, these formats are written in RFCs, such as RFC 791 for the “Internet Protocol”. For file formats, these are written in documents, such as those describing GIF files, JPEG files, MPEG files, and so forth.\nAmong the issues is how integers should be represented. The definition must include the size, whether signed/unsigned, what the bits means (almost always 2s-compliment), and the byte-order. Integers that have values above 255 must be represented with more than one byte. Whether those bytes go left-to-right or right-to-left is known as byte-order.\nWe also called this endianness, where one form is big-endian and the other form is little-endian. This is a joke, referring back to Jonathan Swift’s tale Gulliver’s Travels, where two nations were at war arguing whether an egg should be cracked on the big end or the little end. The joke refers to the Holy Wars in computing where two sides argued strongly for one byte-order or the other. The commentary using the term “endianess” is that neither format matters.\nHowever, big-endian is how humans naturally process numbers. If we have the hex value 0x2211, then we expect that representing this number in a file/protocol will consist of one byte with the value 0x22 followed by another byte with the value 0x11. In a little-endian format specification, however, the order of bytes will be reversed, with a value of 0x2211 represented with 0x11 followed by 0x22.\nThis is further confused by the fact that the nibbles in the byte will still be written in conventional, big-endian order. In other words, the big-endian format for the number 0x1234 is 0x12 0x34. however, the little-endian format is 0x34 0x12  — not 0x43 0x21 as you might naively expect trying to swap everything around in your mind.\nIf little-endian is so confusing to the human mind, why would anybody ever use it? The answer is that it can be more efficient for logic circuits. Or at least, back in the 1970s, when CPUs had only a few thousand logic gates, it could be more efficient. Therefore, a lot of internal processing was little-endian, and this bled over into external formats as well.\nOn the other hand, most network protocols and file formats remain big-endian. Format specifications are written for humans to understand, and big-endian is easier for us humans.\nSo once you understand the byte-order issue in external formats, the next problem is figuring out how to parse it, to convert it into an internal data structure. Well, we first have to understand how to parse things in general.\nThere are two ways of parsing thing: buffered or streaming. In the buffered model, you read in the entire input first (like the entire file, or the entire network packet), then parse it. In the streaming mode, you read a byte at a time, parse that byte, then read in the next byte. Stream mode is best for very large files or for streaming data across TCP network connections.\nHowever, buffered parsing is the general way most people do it, so I’ll assume that in this guide.\nLet’s assume you’ve read in the file (or network data) into a buffer we’ll call buf. Your parse that buffer at the current offset until you reach the end.\nGiven that, then the way you’d parse a big-endian integer x is the following line of code:\n x = buf[offset] * 256 + buf[offset+1];\nOr, if you prefer logical operators, you might do it as:\n x = buf[offset]&lt;&lt;8 | buf[offset+1];\nCompilers always translate multiplication by powers-of-2 into shift instructions, so either statement will perform the same. Some compilers are smart enough to recognize this pattern as parsing an integer, and might replace this with loading two bytes from memory and byte-swapping instead.\nFor a little-endian integer in the external data, you’d reverse how you parse this, like one of the following two statements.\nx = buf[offset+1] * 256 + buf[offset];\nx = buf[offset] + buf[offset+1] * 256;\nIf we were talking about JavaScript, C#, or a bunch of other languages, at this point the conversation about endianess would end. But if talking about C/C++, we’ve got some additional wrinkles to deal with.\nThe problem with C is that it’s a low-level language. That means it exposes the internal format of integers to the programmer. In other words, the above code focuses on the external representation of integers, and doesn’t care about the internal representation. It doesn’t care if you are using an x86 little-endian CPU or some RISC big-endian CPU.\nBut in C, you can parse an integer by relying upon the internal CPU representation. It would look something like the following:\n x = (short)(buf + offset);\nThis code produces different results on a little-endian machine and a big-endian machine. If the two bytes are 0x22 and 0x11, then on a big-endian machine this produces a short integer with a value of 0x2211, but a little-endian machine produces the value of 0x1122.\nIf the external format is big-endian, then on a little-endian machine, you’ll have to byte-swap the result. In other words, the code would look something like:\n x = (short)(buf + offset);\n ifdef LITTLE_ENDIAN\n x = (x &gt;&gt; 8) | ((x &amp; 0xFF) &lt;&lt; 8);\n endif\nOf course, you’d never write code that looks like this. Instead, you’d use a macro, as follows:\n x = ntohs((short)(buf + offset));\nThe macro means network-to-host-short, where network byte-order is big-endian, and host byte-order is undefined. On a little-endian host CPU, the bytes are swapped as shown above. On a big-endian CPU, the macro is defined as nothing. This macro is defined in standard sockets libraries, like &lt;arpa/inet.h&gt;. There are a broad range of similar macros in other libraries for byte swapping integers.\nIn truth, this is not how it’s really done, parsing an individual integer at a time. Instead, what programmers do is define a packed C structure that corresponds to the external format they are trying to parse, then cast the buffer into that structure.\nFor example, in Linux is the include file &lt;netinet/ip.h&gt; which defines the Internet protocol header:\nstruct ip {\nif BYTE_ORDER == LITTLE_ENDIAN \nu_char ip_hl:4, /* header length */\nip_v:4; /* version */\nendif\nif BYTE_ORDER == BIG_ENDIAN \nu_char ip_v:4, /* version */\nip_hl:4; /* header length */\nendif\nu_char ip_tos; /* type of service */\nshort ip_len; /* total length */\nu_short ip_id; /* identification */\nshort ip_off; /* fragment offset field */\nu_char ip_ttl; /* time to live */\nu_char ip_p; /* protocol */\nu_short ip_sum; /* checksum */\nstruct in_addr ip_src,ip_dst; /* source and dest address */\n};\nTo “parse” the header, you’d do something like:\n strict ip *hdr = (struct ip *)buf;\n printf(“checksum = 0x%04x\\n”, ntohs(ip→ip_sum));\nThis is considered the “elegant” way of doing things, because there is no “parsing” at all. On big-endian CPUs, it’s also a no-op — it costs precisely zero instructions in order to “parse” the header, since both the internal and external structures map exactly.\nIn C, though, the exact format of structures in undefined. There is often padding between structure members to keep integers aligned on natural boundaries. Therefore, compilers have directives to declare a structure as “packed” to get rid of such padding, this strictly defining the internal structure to match the external structure.\nBut this is the wrong wrong wrong way of doing it. Just because it’s possible in C doesn’t mean it’s a good idea.\nSome people think it’s faster. It’s not really faster. Even low-end ARM CPUs are super fast these days, multiple issue with deep pipelines. What determines their speed is more often things like branch mispredictions and long chain dependencies. The number of instructions is almost an afterthought. Therefore, the difference in performance between the “zero overhead” mapping of a structure on top of external data, versus parsing a byte at a time, is almost immeasurable.\nOn the other hand, there is the cost in “correctness”. The C language does not define the result of casting an integer as shown in the above examples. As wags have pointed out, instead of returning the expected two-byte number, acceptable behavior is to erase the entire hard disk.\nIn the real world, undefined code has lead to compiler problems as they try to optimize around issues. Sometimes important lines of code are removed from a program because the compiler strictly interprets the rules of the C language standard. Using undefined behavior in C truly produces undefined results — quite at odds from what the programmer expected.\nThe result of parsing a byte at a time is defined. The result of casting integers and structures is not. Therefore, that practice should be avoided. It confuses compilers. It confuses static and dynamic analyzers that try to verify the correctness of code.\nMoreover, there is the practical matter that casting such things confuses programmers. Programmers understand parsing external formats fairly well, but mixing internal/external endianess causes endless confusion. It causes no end to buggy code. It causes no end to ugly code. I read a lot of open-source code. Code that parses integers the right way is consistently much easier to read than code that uses macros like ntohs(). I’ve seen code where the poor confused programmer keeps swapping integers back and forth, not understanding what’s going on, and simply adding another byte-swap whenever the input to the function was in the wrong order.\nConclusion\nThere is the right way to teach endianess: it’s a parser issue, dealing with external data formats/protocols. You deal with in in C/C++ the same way as in JavaScript or C# or any other language.\nThen there is wrong way to teach endianess, that it’s a CPU issue in C/C++, that you intermingle internal and external structures together, that you swap bytes. This has caused no end of trouble over the years.\nThose teaching endianess need to stop the old way and adopt the new way.\n\nBonus: alignment\nThe thing is that casting integers has never been a good solution. Back in the 1980s and the first RISC processors, like SPARC, integers had to be aligned on even byte boundaries or the program would crash. Formats and protocols would be defined to keep these things aligned most of the time. But every so often, a odd file would misalign things, and the program would mysteriously crash with a “bus” error.\nThankfully, this nonsense has disappeared, but even today a lot of processors have performance problems with unaligned data. In other words, casting a structure on top of data appears to cost zero CPU instructions, but this ignore the often considerable effort it took to align all the integers before this step was reached.\n\nBonus: sockets\nThe API for network programming is “sockets”. In some cases, you have to use the ntohs() family of macros. For example, when binding to a port, you execute code like the following:\n sin.sin_port = htons(port);\nYou do this not because the API defines it this way, not because you are parsing data.\nSome programmers make the mistake of keeping the byte-swapped versions of IP addresses and port numbers throughout their code. This is wrong. Their code should keep these in the correct format, and only passed through these byte-swapping macros on the Interface to the sockets layer.\nendian\n\nadapted from blog.erratasec.com/2016/11/how-to-teach-endian.html#.Yo-UmHVBxhE\n"},"diary/2022-05-29":{"slug":"diary/2022-05-29","filePath":"diary/2022-05-29.md","title":"2022-05-29","links":["tags/templater.html","tags/obsidian.html","__obex/templater/templates/generic.html"],"tags":["diary","templater","obsidian"],"content":"\n2022-05-29\n\nThe best and most beautiful things in the world cannot be seen, nor touched… but are felt in the heart.\n— Helen Keller\n\n今天属于Cyndi\n \n \nThe use of templater\ntemplater obsidian\n\nshbgm.ca/obsidian/docs/how-to-use-templater-js-scripts\ngithub.com/SilentVoid13/Templater/discussions/187\nsilentvoid13.github.io/Templater/commands/execution-command.html\n\n调试方法\n在obsidian中按Ctrl+Shift+I呼出调试窗口，在console页签中可以直接获取到obsidian.d.ts中的API。\n例如：\n\n另请参阅generic中关于Javascript代码段的调用，代码段返回值默认无输出，其结果存储在tR变量中，若想输出，应将其写入tR变量1。\nJavascript语法参考:\n\nlearnxinyminutes.com/docs/javascript/\nTry Js Online\n\nFootnotes\n\n\nHow to output a value from a JavaScript Execution Command ? ↩\n\n\n"},"diary/2022-05-30":{"slug":"diary/2022-05-30","filePath":"diary/2022-05-30.md","title":"2022-05-30","links":["tags/职位要求参考.html"],"tags":["diary","职位要求参考"],"content":"\n2022-05-30\n\nThere is some self-interest behind every friendship. There is no friendship without self-interests. This is a bitter truth.\n— Chanakya\n\n博客网站出现许多未被编入索引\n\nsee: www.yundianseo.com/currently-not-indexed-issue/\nTwo sum\nProblem: www.code-recipe.com/post/two-sum\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n#include &lt;algorithm&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;sstream&gt;\n \nusing std::vector;\nusing std::unordered_map;\nusing std::cout;\nusing std::endl;\nusing std::string;\n \nvoid PrintVec(const vector&lt;int&gt;&amp; v)\n{\n    for (auto e : v)\n    {\n        cout &lt;&lt; e &lt;&lt; &#039; &#039;;\n    }\n}\n \nvoid HandleInput(vector&lt;int&gt;&amp; array, int&amp; target)\n{\n    while (true)\n    {\n        array.clear();\n        cout &lt;&lt; &quot;Please input the array, separated by space:\\n&quot;;\n        string line;\n        std::getline(std::cin, line);\n        std::istringstream is(line);\n        try {\n            for (int val; is &gt;&gt; val; array.push_back(val)) {}\n        }\n        catch (std::exception())\n        {\n            continue;\n        }\n        break;\n    }\n    cout &lt;&lt; &quot;\\nYou entered: &quot;;\n    PrintVec(array);\n \n    cout &lt;&lt; &quot;Please input the target number:\\n&quot;;\n    std::cin &gt;&gt; target;\n}\n \n \nclass Solution\n{\npublic:\n    static vector&lt;int&gt; TwoSum(const vector&lt;int&gt;&amp; array, int target)\n    {\n        unordered_map&lt;int, int&gt; idx_map {};\n        for (size_t i=0; i &lt; array.size(); ++i)\n        {\n            int remainder = target - array[i];\n            auto idx_iter = idx_map.find(remainder);\n            if (idx_iter != idx_map.end())\n                return vector&lt;int&gt;{static_cast&lt;int&gt;(i), idx_iter-&gt;second};\n            else\n                idx_map[array[i]] = i;\n        }\n        return vector&lt;int&gt;();\n    }\n};\n \n \nint main()\n{\n \n    vector&lt;int&gt; array {7,2,13,11};\n    int target = 9;\n    HandleInput(array, target);\n    auto ret = Solution::TwoSum(array, target);\n \n    if (ret.empty())\n        cout &lt;&lt; &quot;no answer.&quot;;\n    else\n        PrintVec(Solution::TwoSum(array, target));\n \n    return 0;\n}\n本岗位主要负责蚂蚁海量数据访问、变更、灾备等所依托的数据中间件的设计和研发：\n\n跨多个存储集群（DB、缓存和 OSS 等）数据访问代理中间件，具有分布式路由、弹性伸缩和容灾等能力；\n跨DB、服务的高性能分布式事务中间件，包括维护开源项目Seata；\n符合金融系统要求的数据、服务灾备机制与方案，如严格的数据安全性、业务正确性和业务连续性等；\n\n本岗位P6/P7/P8均有需求，期待你的加入！\n\n有三年以上的数据中间件、DB或存储系统研发经验；\n熟练掌握 Java/C++/Go/Rust任意一种编程语言，掌握并发、网络编程和数据库编程；\n对CAP、高可用架构、事务等理论有深入理解，并有一定的实践经验；\n熟悉并具有Cobar、TDDL、Druid、Calcite等数据中间件开发经验者优先；\n熟悉并具有XA、TCC等分布式事务框架或者解决方案经验者优先；\n有技术热情和较强的学习能力，有很好的问题分析和技术攻关能力，有良好的团队合作和沟通能力。\n\n职位要求：\n1、具备扎实的数据结构、算法设计、设计模式、操作系统、网络编程等基础知识；\n2、熟练使用c++基础语言进行研发，多线程、多进程、内存共享、网络通信编程技术；\n3、熟悉实时流计算引擎或离线计算引擎，有对应的工程经验，例如：storm、hadoop、spark、flink等；\n4、了解大规模、高并发、分布式系统设计，有相关开发经验优先；\n5、了解机器学习和深度学习算法，有算法工程开发经验优先；\n6、有搜索/推荐/广告系统和业务经验优先，具备良好的沟通和协作能力、持续的自驱力和较强的责任感。\n职位要求参考"},"diary/2022-05-31":{"slug":"diary/2022-05-31","filePath":"diary/2022-05-31.md","title":"2022-05-31","links":["tags/css.html"],"tags":["diary","css"],"content":"\n2022-05-31\n\nArriving at one point is the starting point to another.\n— John Dewey\n\n如何定义CSS变量\ncss\ncf. www.ruanyifeng.com/blog/2017/05/css-variables.html"},"diary/2022-06-01":{"slug":"diary/2022-06-01","filePath":"diary/2022-06-01.md","title":"2022-06-01","links":[],"tags":["diary"],"content":"\n2022-06-01\n\nYou must welcome change as the rule but not as your ruler.\n— Denis Waitley\n\nQ: 字符串常量存储在哪个区？\nA: 静态数据区\nQ: volatile关键字的作用？\nA: 不知。让该数据的写操作具有原子性？"},"diary/2022-06-02":{"slug":"diary/2022-06-02","filePath":"diary/2022-06-02.md","title":"2022-06-02","links":["tags/python.html","tags/print.html"],"tags":["diary","python","print"],"content":"\n2022-06-02\n\nAction may not always bring happiness; but there is no happiness without action.\n— Benjamin Disraeli\n\nWhy is printing to stdout so slow? Can it be sped up?\npython print\npython的print很慢，flush，io的差别\nsee also issues.apache.org/jira/browse/LOG4J2-2239\n古文节选\n《唐雎不辱使命》\n秦王使人谓安陵君曰：「寡人欲以五百里之地易安陵，安陵君其许寡人！」安陵君曰：「大王加惠，以大易小，甚善。虽然，受地于先王，愿终守之，弗敢易。」秦王不说。安陵君因使唐雎使于秦。\n秦王谓唐雎曰：「寡人以五百里之地易安陵，安陵君不听寡人，何也？且秦灭韩亡魏，而君以五十里之地存者，以君为长者，故不错意也。今吾以十倍之地，请广于君，而君逆寡人者，轻寡人与？」唐雎对曰：「否，非若是也。安陵君受地于先王而守之，虽千里不敢易也，岂直五百里哉？」\n秦王怫然怒，谓唐雎曰：「公亦尝闻天子之怒乎？」唐雎对曰：「臣未尝闻也。」秦王曰：「天子之怒，伏尸百万，流血千里。」唐雎曰：「大王尝闻布衣之怒乎？」秦王曰：「布衣之怒，亦免冠徒跣，以头抢地耳。」唐雎曰：「此庸夫之怒也，非士之怒也。夫专诸之刺王僚也，彗星袭月；聂政之刺韩傀也，白虹贯日；要离之刺庆忌也，仓鹰击于殿上。此三子皆布衣之士也，怀怒未发，休祲降于天，与臣而将四矣。若士必怒，伏尸二人，流血五步，天下缟素，今日是也。」挺剑而起。\n秦王色挠，长跪而谢之曰：「先生坐，何至于此！寡人谕矣。夫韩、魏灭亡，而安陵以五十里之地存者，徒以有先生也。」\nsee: 大方广网-智慧话语 汤头歌"},"diary/2022-06-05":{"slug":"diary/2022-06-05","filePath":"diary/2022-06-05.md","title":"2022-06-05","links":[],"tags":["diary","life"],"content":"\n2022-06-05\n\nWe should all be thankful for those people who rekindle the inner spirit.\n— Albert Schweitzer\n\n交管123换证\n需先到指定医院体检：\n\n杭州许可医院列表： 驾驶人体检就近办理：互联网体检医院汇总表\n"},"diary/2022-06-13":{"slug":"diary/2022-06-13","filePath":"diary/2022-06-13.md","title":"2022-06-13","links":[],"tags":["diary"],"content":"\n2022-06-13\n\nYou’re never a loser until you quit trying.\n— Mike Ditka\n\nfuck: undefined\nthis: undefined"},"diary/2022-06-15":{"slug":"diary/2022-06-15","filePath":"diary/2022-06-15.md","title":"2022-06-15","links":["notes/cpp/模板.html","work/netease/工作汇报/月报.html"],"tags":["diary"],"content":"\n2022-06-15\n\nMotivation is the art of getting people to do what you want them to do because they want to do it.\n— Dwight D. Eisenhower\n\n模板\nTrigger偶现CustomProp为空\n\n\n开启新号加速后，两个新号使用同一个模板赋值，CustomProp的拷贝其实是按引用的，所以一个号的修改会影响另一个号，同时也会影响模板。\n月报"},"diary/2022-07-06":{"slug":"diary/2022-07-06","filePath":"diary/2022-07-06.md","title":"2022-07-06","links":[],"tags":["diary"],"content":"\n2022-07-06\n\nWisdom is the power to put our time and our knowledge to the proper use.\n— Thomas J. Watson\n\n\n"},"diary/2022-07-07":{"slug":"diary/2022-07-07","filePath":"diary/2022-07-07.md","title":"2022-07-07","links":[],"tags":["diary"],"content":"\n2022-07-07\n\nThe best thing in every noble dream is the dreamer…\n— Moncure D. Conway\n\nTortoise Git: code repo"},"diary/2022-07-12":{"slug":"diary/2022-07-12","filePath":"diary/2022-07-12.md","title":"2022-07-12","links":["tags/达夫设备.html","tags/duff-device.html"],"tags":["diary","达夫设备","duff-device"],"content":"\n2022-07-12\n\nThe saddest aspect of life right now is that science gathers knowledge faster than society gathers wisdom.\n— Isaac Asimov\n\n达夫设备\n达夫设备 duff-device\n参见： mthli.xyz/duff-device/\n循环展开：\n// 正常情况下的 for 循环，\n// 需要连续迭代 100000000 次\nint sum = 0;\nfor (int i = 0; i &lt; 100000000; i++) {\n    sum += i;\n}\n \n// 每次循环展开 5 次，\n// 只用迭代 20000000 次即可\nint sum = 0;\nfor (int i = 0; i &lt; 100000000; i += 5) {\n    sum += i;\n    sum += i + 1;\n    sum += i + 2;\n    sum += i + 3;\n    sum += i + 4;\n}\n有如下一段程序（routine），是从 Evans &amp; Sutherland Picture System II 中提取出来的，用于将一个 short 数组拷贝到 IO 数据寄存器上：\nsend(to, from, count)\nregister short *to, *from;\nregister count;\n{\n    do\n        *to = *from++;\n    while (--count &gt; 0);\n}\n使用达夫设备：\nsend(to, from, count)\nregister short *to, *from;\nregister count;\n{\n    register n = (count + 7) / 8;   // =&gt; n = ceil(count / 8)\n    switch (count % 8) {\n    case 0: do { *to = *from++;\n    case 7:      *to = *from++;\n    case 6:      *to = *from++;\n    case 5:      *to = *from++;\n    case 4:      *to = *from++;\n    case 3:      *to = *from++;\n    case 2:      *to = *from++;\n    case 1:      *to = *from++;\n            } while (--n &gt; 0);\n    }\n}\n它的妙处在于：能够处理\\frac{count}{8}除不尽的情况，其中n = \\lceil \\frac{count}{8} \\rceil ，利用switch语句的fall-through性质，第一次如果count除不尽8, 则会直接命中余数，然后接着往下走，共执行余数次语句。之后通过while循环，每循环做8次语句（循环展开），最后得到想要的结果。"},"diary/2022-07-18":{"slug":"diary/2022-07-18","filePath":"diary/2022-07-18.md","title":"2022-07-18","links":["tags/gcc.html","tags/cpp.html"],"tags":["diary","gcc","cpp"],"content":"\n2022-07-18\n\nThe happiness of a man in this life does not consist in the absence but in the mastery of his passions.\n— Alfred Tennyson\n\n月报\n其他\n\nCustomProp int-key 检查\n\nAoiCustomProperty嵌套pack兼容（目前发现新的问题）\nmbs_test测试环境配置\n嵌套pack的test case (doing)\n\n\ndcs代码检查修改\nNPC阵营数据统一，数据刷新\n资源依赖：对话编辑器资源依赖迭代 &amp; parser单元测试 &amp; 问题修复\n任务新号加速代码review &amp; 迭代\n整理大世界无缝进出位面方案\n\n阅读采集相关代码\n部分采集物可带入位面 &amp; 测试\n\n\n悬赏刷新规则迭代\nGM指令：刷新悬赏列表支持添加必刷任务列表\n新增AttrAnimGraphClientOnly供ClientOnly对象使用\n相关bug排查&amp;修复\n\n编辑器\n\n悬赏配置节点导入/导入迭代\n悬赏新增启用/禁用条件（编辑器&amp;游戏端）\n\nUI\n\n拆解台PC端UI开发\n\n学习UI新组件的使用（其中一个特点就是对策划前置工作的要求）\n策划对UI表格不熟悉，配表缓慢，偶有阻塞，沟通成本相对较高\n\n\n悬赏界面屏蔽下雨效果，界面文本/图片常量迭代\n任务追踪标记位置接口提供\n\ngcc编译的四个步骤\nCf. www.cnblogs.com/zjiaxing/p/5557549.html\ngcc/g++在执行编译工作的时候，分为以下四个过程：\n\n预处理，生成.i的文件  「g++ -E main.cpp &gt; main.i」\n将预处理后的文件转换成汇编语言，生成.s文件  「g++ -S main.i（生成main.s）」\n汇编变为目标代码(机器代码)生成.o的文件  「g++ -c main.s（生成main.o）」\n连接目标代码,生成可执行程序「g++ main.o -o main（生成可执行文件main）」\n\ngcc cpp"},"diary/2022-07-21":{"slug":"diary/2022-07-21","filePath":"diary/2022-07-21.md","title":"2022-07-21","links":["notes/cpp/static关键字.html","notes/cpp/链接.html"],"tags":["diary"],"content":"\n2022-07-21\n\nWe are all something, but none of us are everything.\n— Blaise Pascal\n\nstd::atomic使用场景：多读一写\noperator++重载\n前置&amp;后置\n#include &lt;cstdio&gt;\n \nclass A\n{\npublic:\n    A&amp; operator++() // ++a, pre-increment\n    {\n        printf(&quot;operator++()\\n&quot;);\n        a_++;\n        return *this;\n    }\n    void operator++(int) // a++, post-increment\n    {\n        printf(&quot;operator++(int)\\n&quot;);\n        ++a_;\n    }\nprivate:\n    int a_ = 0;\n};\n \n \nint main()\n{\n    A a;\n    ++a;    // call operator++()\n    a++;    // call operator++(int)\n    return 0;\n}\nStorage duration\nAll objects in a program have one of the following storage durations:\n\n\nautomatic storage duration. The storage for the object is allocated at the beginning of the enclosing code block and deallocated at the end. All local objects have this storage duration, except those declared static, extern or thread_local.\n\n\nstatic storage duration. The storage for the object is allocated when the program begins and deallocated when the program ends. Only one instance of the object exists. All objects declared at namespace scope (including global namespace) have this storage duration, plus those declared with static or extern. See Non-local variables and Static local variables for details on initialization of objects with this storage duration.\n\n\nthread storage duration. The storage for the object is allocated when the thread begins and deallocated when the thread ends. Each thread has its own instance of the object. Only objects declared thread_local have this storage duration. thread_local can appear together with static or extern to adjust linkage. See Non-local variables and Static local variables for details on initialization of objects with this storage duration. (since C++11)\n\n\ndynamic storage duration. The storage for the object is allocated and deallocated upon request by using dynamic memory allocation functions. See new-expression for details on initialization of objects with this storage duration.\n\n\nThe storage duration of subobjects and reference members is that of their complete object.\nsee also Static local variables, linkage."},"diary/2022-07-24":{"slug":"diary/2022-07-24","filePath":"diary/2022-07-24.md","title":"2022-07-24","links":["notes/GPG使用方法.html","diary/file:/usr/share/doc/neomutt/manual.html"],"tags":["diary"],"content":"\n2022-07-24\n\nPitching is the art of instilling fear.\n— Sandy Koufax\n\nGPG使用方法\nNeoMutt配置163邮箱发信\n# 一行式发信\n$ echo &quot;sample mail text&quot; | neomutt -s &quot;Mail from NeoMutt&quot; guyueyizhi@qq.com -a neomuttrc -a ~/Pictures/cpp-style.png\n# 读取文件内容发信\n$ neomutt -s &quot;这是主题&quot; -a 附件.jpg receiver@example.com &lt; 正文.txt\n查看日志\n$ neomutt -d2 -l log\n正在使用级别 2 进行调试，输出到文件 &#039;log0&#039;\n配置参考\n\nwiki.archlinux.org/title/Mutt\nlocal doc\ngithub.com/neomutt/samples\n推荐阅读： talau.info/post/my-muttrc-with-multiple-imap-accounts\n"},"diary/2022-08-02":{"slug":"diary/2022-08-02","filePath":"diary/2022-08-02.md","title":"2022-08-02","links":["notes/cpp/默认参数.html","notes/cpp/sizeof-operator.html"],"tags":["diary"],"content":"\n2022-08-02\n\nQuality is never an accident; it is always the result of intelligent effort.\n— John Ruskin\n\n\n默认参数与虚函数联合的副作用\nsizeof operator\n"},"diary/2022-08-10":{"slug":"diary/2022-08-10","filePath":"diary/2022-08-10.md","title":"2022-08-10","links":[],"tags":["diary"],"content":"\n2022-08-10\n\nBelieve deep down in your heart that you’re destined to do great things.\n— Joe Paterno\n\n月报（7.15 — 8.10)\nUI\n\nPC任务界面开发 &amp; 后续UI表现调整\n\n增加二级tab，切tab关闭tips\n\n\n拆解台表现调优\n任务编辑器增加评分配置 &amp; 任务面板相关迭代\n任务面板动效接入\n\n商城交易\n\nNPC商城导表，服务端物品出售逻辑（ui工程没给到，后续联调流程）\n物品交易功能（贩卖机）方案 &amp; 讨论\n阅读msa文档 &amp; TradeService开发，存盘/恢复测试\n贩卖机购买服务端逻辑（后续与仓储设施联调）\n\n其他\n\nCustomProp嵌套pack test case\n整理CustomProp嵌套问题 &amp; 思考方案\n任务空trigger优化代码review\n资源探测功能开发 &amp; 测试\n\n以玩家为中心发出一个圆形探测波，触及的物体挂上3dui，持续x秒销毁\n目前采用临时行为文件，后续仍要迭代\n相关配置导表，3dui逻辑\n\n\n领地合居：拆解物品增加当前领地入侵计数 &amp; 测试\n解谜玩法方案讨论\n\nBug\n\n排查修复任务图标、3dui相关问题\n排查&amp;修复任务编辑器上传trace\n"},"diary/2022-08-15":{"slug":"diary/2022-08-15","filePath":"diary/2022-08-15.md","title":"2022-08-15","links":[],"tags":["diary"],"content":"\n2022-08-15\n\nHonesty is the best policy.\n— Benjamin Franklin\n\n滑动窗口算法\n对于连续内存空间，定两个索引，称之为左游标和右游标。对每一个左游标，先将右游标右移，判断约束条件，一旦满足，则将左游标右移。\n\nzhuanlan.zhihu.com/p/129018030\ngithub.com/labuladong/fucking-algorithm/blob/master/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%8A%80%E5%B7%A7.md\nwangxujunjie-github-io.vercel.app/2021/02/02/2021-2-2-hua-dong-chuang-kou-suan-fa/\n"},"diary/2022-09-08":{"slug":"diary/2022-09-08","filePath":"diary/2022-09-08.md","title":"2022-09-08","links":[],"tags":["diary"],"content":"\n2022-09-08\n\nWhen something is important enough, you do it even if the odds are not in your favor.\n— Elon Musk\n\n月报\n任务\n\n任务输出：触发indicator交互，需求讨论 &amp; 编辑器配置 &amp; 测试\n新增输出：改变玩家位置 &amp; 编辑器配置支持 &amp; 测试\n任务谓语：与指定目标距离、释放探测技能\n兼容任务编辑器新增trigger的检查\n简化新增一个任务输出的流程\n\n编辑器端将每个输出的检查逻辑迁移到各自输出节点\n去除错误检查对ACTION常量定义的依赖\n\n\n调整玩家移动距离的检查间隔，提高“与指定坐标距离”的精度\n迭代废除trigger功能：在重接任务时重置该任务的废除trigger信息\n部分任务文本/图片常量引用策划配表\n攻击私有NPC支持显示进度\n\nUI\n\n整理NPC商城开发过程中遇到的问题\nNPC商城UI开发\n\n商城分购买/售卖两个界面，整体表现通过切换tab实现\n每个界面都有普通物品、枪械、防具、蓝图、近战武器等多种格子且两个界面要复用这些格子\n开发期间许多表现问题需要联合ui组程序、ui同学、策划等沟通，方案变更等\n\n\nPC端任务hud接入 &amp; 临时拆分副本及公共事件的逻辑\n集中修复任务界面相关表现问题\n\n折叠收起保持hover状态\n切tab状态重置\n点击tab关闭tips\n第一个tab不显示任务数量为0的任务类型\n任务面板悬浮态残留问题处理\n\n\n任务面板动效接入\n任务编辑器增加推荐评分配置 &amp; 任务面板UI迭代\n\nBug\n\n排查&amp;修复资源探测技能trace，服务端迭代了属性\n排查任务编辑器引发的对话删除trace\n协助策划修改版署分支对话/任务文本\n协助排查任务流程中NPC碰撞问题 &amp; 行为树配置不生效问题\n排查&amp;修复任务NPC节点创建模型trace（发送了修改前的数据）\n排查探索条件未完成问题（QA配错）\n排查&amp;修复退出登录任务3dui trace（期间有其他trace中断了移除逻辑）\n\n其他\n\n工作排期\n探索功能读取策划配置，相关配置导表，3dui处理\n领地合居：拆解物品增加当前领地入侵计数 &amp; 测试\nNPC商店物品出售功能开发\n玩家交易功能服务端开发\n\n整理方案\n开发TradeService用于记录单个逻辑服的成交价格 &amp; 简单验证\n增加TradeService的配置，测试存盘/恢复流程\n贩卖机购买逻辑（扣除代币，物品加背包，上报成交价，发放代币）\n\n\n"},"diary/2022-11-10":{"slug":"diary/2022-11-10","filePath":"diary/2022-11-10.md","title":"2022-11-10","links":[],"tags":["diary"],"content":"\n2022-11-10\n\nDo not overrate what you have received, nor envy others. He who envies others does not obtain peace of mind.\n— Buddha\n\n\n无锁队列实现&amp;使用场景？\n内存有限情况下，hash频繁碰撞到一个桶，该如何解决？\n互斥锁，原子变量的底层原理是什么？如何做到数据同步的？\n\n成年人的精神世界似乎很难满足。以前，买一个机械键盘，降噪耳机，都能高兴好半天。现在却觉得没啥好开心的，只有赚更多的钱才能让我开心。"},"diary/2022-12-12":{"slug":"diary/2022-12-12","filePath":"diary/2022-12-12.md","title":"2022-12-12","links":[],"tags":["diary"],"content":"\n2022-12-12\n\nIn a controversy the instant we feel anger we have already ceased striving for the truth, and have begun striving for ourselves.\n— Buddha\n\n11.1 — 11.30 月报\n任务\n\n任务标记配置新方案\n\n编辑器定制枚举，根据任务类型自动选择默认值\nets文件配置迁移，前期兼容，后期移除\n新任务标记MapItem开发（大小地图）\n大地图范围圆新增服从小地图配置\n\n\n任务目标合并进度显示 &amp; 编辑器配置支持\n任务谓语：与NPC确认 &amp; 对话界面增加NPC确认选项\n工具服任务(task&amp;trigger)ID生成逻辑迭代 &amp; 自测：之前工具服生成id时基于本地数据缓存，如果两个工具服实例同时产生id，容易互相影响；现调整为每次生成id从数据库读取当前id，基于最新的id去生成，可一定程度上缓解多个工具服实例带来的影响（原则上逻辑依赖工具服是一个单点）\n任务输出：解锁空间法则技能、清空背包装备和防具\n任务谓语：处于空间技能状态、完成指定难度boss本/收容井副本\n限时任务功能\n\nTriggerTimer剩余时间接口\n编辑器配置开发\n倒计时UI接入\n\n\n任务变动通知NPC绑定头顶UI\n\n编辑器\n\n任务编辑器预览时高亮正在执行的trigger节点\n远程节点增删属性的数据兼容\n\n调研sunshine远程节点的数据兼容方案\n节点图数据的远程升级\n迭代打开文件的流程：先进行节点图数据升级，收到升级后的数据再创建editor，加载节点图\n\n\n二级界面新增“预览任务”快捷菜单\n\n旅途\n\n旅途界面各种迭代，表现调优，动效接入\n任务界面各种迭代，表现调优，动效接入\n任务&amp;旅途hud动效接入\n旅途hud增加解锁机制\n旅途&amp;任务中心提示开发\n取消追踪功能&amp;UI表现\n旅途引用的生存界面支持播放视频\n任务&amp;旅途界面音效接入\n任务hud进度屏蔽进度条\n任务&amp;旅途hud迭代：进度拆分显示 &amp; 相关接口迭代，地图tips迭代；删除UITask旧代码\n\n成就\n\n文档，交互稿，相关导表\n系统功能开发\n成就UI开发\n动效接入\n\n拆解台\n\n拆解按钮改为长按\n一级tab处理，按钮消失改为灰态，滑动前未出现item排查修复\n三种格子的悬浮态、选中态增加\n近战武器拆解支持\n界面音效接入\n\n其他\n\nNPC功能入口新增旅途界面\n可探索采集物聚类显示\n相关导表超时预加载处理\n提供TaskDataTools方便ui层获取任务相关数据\nNPC商店接入重复获取相同蓝图直接变为碎片的接口\n\nbug\n\n排查任务编号重复问题：工具组误传代码导致策划们使用了两个工具服，而之前的逻辑依赖工具服是个单点\n排查任务3dui相关问题\n排查NPC商城打开trace：商品对应的物品编号被删除\n排查任务图标位置异常问题（公有NPC位置获取失败，增加公有NPC创建时向任务推送位置的逻辑）\n排查&amp;修复旅途hud不显示的问题（动效原因）\n排查&amp;修复旅途hud进度更新问题\n修复任务标记方案迭代后NPC标记连线传参失效的问题\n修复悬赏任务不刷新已完成任务的问题\n处理NPC商城购买确认界面销毁时残留tips\n"},"diary/2023-01-09":{"slug":"diary/2023-01-09","filePath":"diary/2023-01-09.md","title":"2023-01-09","links":[],"tags":["diary"],"content":"\n2023-01-09\n\nLet us revere, let us worship, but erect and open-eyed, the highest, not the lowest; the future, not the past!\n— Charlotte Perkins Gilman\n\n2022.12月报\n任务\n\n解谜trigger置顶功能\n\n解谜任务hud开发\n追踪规则开发\n编辑器配置支持\n迭代解谜置顶切换逻辑，之前如果手动追踪前一个被追踪的任务，不会触发刷新；增加解谜和任务切换的动画\n\n\n部分任务谓语支持进度显示\n\n增加step内部进度变动的通知时机 &amp; 测试 &amp; 删除旧的监控背包任务物品变动的代码\n\n\n限时任务UI开发 &amp; 断线恢复\n任务&amp;旅途界面补充音效接入\n排查任务hud动效异常：在大地图操作任务追踪时，hud隐藏，动效无法播放，导致回调没有调到\n射灯节点、点光节点开发\n\n编辑器节点开发，拖拽编辑\n客户端任务创建灯光功能开发：涉及场景和space_no加载时机，比较复杂\n\n因为灯光依赖场景，所以需要等场景加载完成，否则场景加载完成会清除visual，而应用层无感知\n退出登录重新进入时，由于avatar.initialize在clientzone之前，触发逻辑去拿GameWorldMgr.cur_prepared()返回true，但此时的gamelworld其实是GWLogin，也无法通过GameWorldMgr.cur_space_no去拿当前space编号\n最后采用avatar.cur_space_no的属性回调，通过WaitEvtMgr等待zone创建，接着等待场景加载完成，再做灯光的创建\n\n\n\n\n调整使用探测技能谓语的监控条件：从使用探矿到使用空间法则\n悬赏任务刷新规则迭代\n\nUI\n\nNPC商城\n\n调整NPC商城购买、出售弹窗层级，滑条为0显示相应tips\n单个出售弹窗样式优化功能开发\nNPC商城代币图标调整\n商品部分，批量出售部分迭代为RecycleDelegate\nprofile NPC商城退出卡顿：UINavigation的on_destroy调用过多（已通知业伟优化）\n\n\n悬赏NPC挂接3dui规则迭代\n\n悬赏任务NPC头顶3DUI常规状态下分为两种状态：普通（黑色图标）和可提交（绿色）\nNPC头顶只挂接一个任务图标，其他trigger不管\n当NPC身上有多个任务的时候，优先显示其他类型任务的图标；悬赏任务的trigger直接切换为可提交状态即可\n所有头顶挂接任务图标的NPC，都沿用2的规则\n支持一个单位有多个标记，并按一定规则显示优先级最高的一个\n\n\n成就界面\n\n成就界面按照key排序\n成就类别item添加红点\n成就类别item增加悬浮态\n\n\n任务编辑器地图标记节点增加名称显示\n任务相关中心提示迭代\n旅途&amp;成就&amp;任务UI\n\n奖励格子迭代：增加悬浮态\n奖励格子依据物品类型显示不同的tips\n任务详情面板完成任务条目划线效果接入（程序接入）\n旅途、成就界面调整锁定状态，上锁的界面不允许通过tab进入\n旅途条目透明度调整\n任务hud子目标指示器颜色调整\n\n\n\n其他\n\nNPC商城sa日志\n排查编辑器属性无法置空的问题（任务编辑器采用旧版资源窗口，需要手动添加空的资源类型）\n排查任务单位死亡端口问题, 策划保存的数据不对，使用的是Sunshine2.5\n探矿功能支持多个规则：之前全局使用一个规避则并使用客户端aoi，不支持多个半径探测；迭代为使用CollectMgr遍历\nsunshine2.6启用新资源任务PRes类型trace排查：Bayan插件重写了sunshine的核心PropertyHandle，覆盖了原本的，导致加载属性面板的时候，PRes类型的PropertyHandle类型选取错误，引发trace\n矿物探测功能SA日志接入开发\n\nbug\n\n修复废除trigger的逻辑问题\n修复地图任务tips不显示地图描述的问题\n修复探矿功能未按配表筛选可探测物的问题\n修复任务编辑器启用新资源后部分PRes资源缺失的问题：在PRes的content拼接ResType前缀以示区分\n修复拆解台物品选中后滑动列表在滑回来选中态会改变的问题\n修复领取悬赏参数非法报错\n"},"diary/2023-03-08":{"slug":"diary/2023-03-08","filePath":"diary/2023-03-08.md","title":"2023-03-08","links":["tags/openwrt.html","tags/路由器.html"],"tags":["diary","openwrt","路由器"],"content":"\n2023-03-08\n\nThe personal life deeply lived always expands into truths beyond itself.\n— Anaïs Nin\n\n小米路由器3 刷open-wrt\n相关链接：\n\nblog.csdn.net/adingge/article/details/125362140\ndownloads.x-wrt.com/rom/\nschaepher.github.io/2019/10/12/xiaomi-router-r3-openwrt/\nblog.kidhero.club/p/%E5%B0%8F%E7%B1%B3%E8%B7%AF%E7%94%B1%E5%99%A83%E5%88%B7%E6%9C%BA%E8%AE%B0%E5%BD%95/\nopenwrt.org/toh/xiaomi/mir3#get_sshdropbear_access\nwww.awaimai.com/2852.html\n\n路由器文件共享（Webdav）\n使用lighttpd的webdav插件，运行在X-wrt上，在局域网内就可以直接启用webdav共享。相关链接：\n\nWebDAV Share\nHow To Set Up WebDAV With Lighttpd\n\nLuCI on lighttpd\nOpenWrt默认使用uhttpd作为luci的webserver，无奈其不支持webdav，因此换成了lighttpd. 如此一来，luci也要跑在lighttpd上，参考wiki.\n内网https配置\n在配置完webdav之后，原想通过Android APP FolderSync进行手机数据的同步。不成想他竟然不支持http，强制要求server端为https.\n于是参考，\n\nDon’t forget about encryption!\nSecure HTTP\nSetting up a simple SSL configuration with a self-signed certificate\n将局域网内的webdav server设为https.\n\nFirst, go into your SSL Certificates directory and do:\ncd /etc/lighttpd/certs\nopenssl req -new -x509 -keyout lighttpd.pem -out lighttpd.pem -days 365 -nodes\nchmod 400 lighttpd.pem\nIf lighttpd starts are root — the default in many service configs — then the certificate can be owned by root with permissions 0400, as lighttpd reads the certificates before dropping privileges to www-data (or other account, depending on the distro config).\nThen edit /etc/lighttpd/lighttpd.conf and add:\n$SERVER[&quot;socket&quot;] == &quot;:443&quot; {\n  ssl.engine = &quot;enable&quot; \n  ssl.pemfile = &quot;/etc/lighttpd/certs/lighttpd.pem&quot; \n}\nAfter restarting the webserver, you should be able to access your webserver through https.\n如何生成自签名证书： devopscube.com/create-self-signed-certificates-openssl/ ，仅限局域网使用。\nKsmbd文件共享\n增加用户，配置密码的方式：root登陆openwrt，执行\nksmbd.adduser -a &lt;username&gt; -p &lt;password&gt;\nsee: github.com/stupidloud/nanopi-openwrt/issues/479#issuecomment-811889064\nopenwrt 路由器"},"diary/2023-03-11":{"slug":"diary/2023-03-11","filePath":"diary/2023-03-11.md","title":"2023-03-11","links":[],"tags":["diary"],"content":"\n2023-03-11\n\nYou’ve got to go out on a limb sometimes because that’s where the fruit is.\n— Will Rogers\n\narchlinux u盘自动挂载\n参考：www.jianshu.com/p/68808f566017\npacman -S udev udisks2\n \ncd /etc/udev/rules.d/\ntouch my.rules\n# vim my.rules\n \nACTION==&quot;add&quot;, SUBSYSTEMS==&quot;usb&quot;, SUBSYSTEM==&quot;block&quot;, RUN{program}+=&quot;/bin/mkdir /media/%k&quot; ,RUN{program}+=&quot;/usr/bin/systemd-mount --no-block --collect $devnode /media/%k&quot;\nsystemctl restart udisks2.service"},"diary/2023-03-30":{"slug":"diary/2023-03-30","filePath":"diary/2023-03-30.md","title":"2023-03-30","links":["tags/firefox.html"],"tags":["diary","firefox"],"content":"\n2023-03-30\n\nTo accomplish great things, we must not only act, but also dream; not only plan, but also believe.\n— Anatole France\n\nFirefox添加自定义搜索引擎\nfirefox\nsuperuser.com/a/1756774"},"diary/2023-04-23":{"slug":"diary/2023-04-23","filePath":"diary/2023-04-23.md","title":"2023-04-23","links":[],"tags":["diary"],"content":"\n2023-04-23\n\nWhat we think determines what happens to us, so if we want to change our lives, we need to stretch our minds.\n— Wayne Dyer\n\n\n随板AC的意义是什么？\n性能数据支持对设备、单板、接口、AP、光模块和远端模块级别性能指标数据呈现，用户可以在性能概览界面针对单指标创建监控图表来观察性能数据，也可以在统计列表界面查看具体指标的详细KPI数据，帮助用户快速识别设备、单板、接口、AP、光模块和远端模块的状态。\nKPI数据的意义是什么？"},"diary/2024-09-24":{"slug":"diary/2024-09-24","filePath":"diary/2024-09-24.md","title":"2024-09-24","links":[],"tags":["diary","自我介绍","个人介绍","个人简介","intro"],"content":"教育经历\n\n2010.09 — 2013.06 安徽省当涂县第一中学\n2013.09 — 2017.06 武汉理工大学，信息与计算科学\n2017.09 — 2020.07 中国科学院大学，通信与信息系统\n\n科研经历\n基于生成对抗网络的分类模型研究 2019.02 – 2020.02\n基于文章 1 以及文章 2，从信息论的角度探究输入噪声的分布情况对生成器性能的影响，从而指导设计出更好的噪声分布，提升网络的性能，并尝试从信息论的角度解释参数的意义和模型合理性。发表文章：\n\n基于互信息约束的生成对抗网络分类模型研究 [Github]\n\n使用深度学习模型预测基因表达量的高低 2018.10 – 2019.01\n在 NIPS2017 的文章基础上，复现了其主要工作。使用 bedtools 和 samtools 将原始的生物大数据提取出组蛋白修饰信号与基因表达的对应关系。使用 CNN 训练获得权重，输出分类结果。\n数据预处理是该文章实现的难点。从数据的下载、剪接，到有效信息的提取，接触并动手写了一些 Shell 和 Python 脚本。\n使用机器学习方法解决保险市场预测问题 2018.05\n使用 SVM 分析保险业务客户的历史信息，训练模型并预测有办理保险意向的客户，并对客户的理赔概率进行分析，从而制定不同的联系策略，最大化保险公司收益。\n实习经历\n盛趣游戏 上海 2019.07 – 2019.09\n服务器引擎部，游戏开发实习生 学习了 Asio、Protobuf、Cmake 等工具。会用 Asio 写基本的网络程序，会用 pb 封装自定义消息，会用 cmake 实现自动化构建。期间也学习了 Unix 系统网络 API，会调用系统 API 进行简单的 socket 编程。\n顽岩资产 上海 2019 年夏\n软件开发实习生 实习期间学习了综合交易平台 CTP 的工作机制，API 的调用以及数据的获取。并类比尝试使用比特币交易平台火币网 API 获取行情数据，转换成自己所需的格式。\n工作经历\n网易（杭州）网络有限技术公司 杭州 2020.08 – 2023.01\nStarry 工作室，游戏研发工程师\n\n\n任务系统\n\n参与开发了一套灵活的任务系统：实现了条件之间的与或非嵌套，将任务输出与条件解耦；通过基本单元之间的自由连接，可以配置出丰富的任务内容\n开发任务编辑器并实现了一套易扩展的实时数据检查系统，有效降低了错误配置的概率\n实现了任务编辑的预览功能：任务数据编辑过程中，可随时在客户端预览该任务，有助于编辑过程中的自测，极大简化了此前验证任务流程的繁琐性\n打通了任务编辑器与其他工具（对话、战场、单位编辑器等）的编辑流程，在编辑任务时能够很方便地创建对话，单位，副本等数据\n\n\n\n对话系统\n\n开发了一套带分支可回溯的线性对话系统\n开发了对话编辑器：可视化创建/摆放 NPC，对话内容实时预览，满足常见对话表现需求\n\n\n\n商城、物品拆解、维修、委托等游戏功能\n\n\n华为技术有限公司 南京 2023.04 – 2024.07\nNCE 分析开发部，2023.04 – 2023.08\n完成了 GRE（Generic Routing Encapsulation）拨测业务 Golang 到 C++ 的转换，端到端梳理了业务流程，分析并拆解了 Golang 代码；输出相应 C++ 版本的替代方案，进行方案澄清；开发过程中为避免引入三方库，自行开发了简单的日志模块、单生产者–单消费者循环队列、对象池，进行穿刺验证。\n城域路由器开发部，2023.08 – 2024.07\n学习了 PPPoE/PPP 协议，了解用户上线报文交互过程。熟悉路由器开发工作流，资源、脚本、组件分层。了解命令行建模、下发流程。了解常见路由器设备操作，交互，如配置 BAS 口，使用测试仪上线用户。担任版本新硬件开发接口人。\n自我评价\n本人求真务实，踏实肯干，对待工作认真负责。乐于与人交流，积极学习新技术，乐于钻研。平时喜欢折腾一些小而轻的实用工具。"},"diary/2024-11-02":{"slug":"diary/2024-11-02","filePath":"diary/2024-11-02.md","title":"2024-11-02","links":["__zettel/202412202251ssh问题记录.html"],"tags":["diary","问题","速记","terminfo"],"content":"\n202412202251ssh问题记录"},"diary/2025-08-22":{"slug":"diary/2025-08-22","filePath":"diary/2025-08-22.md","title":"2025-08-22","links":[],"tags":["diary","life","车检","年检","年审"],"content":"\n2025-08-22\n\n\n                  \n                  No pessimist ever discovered the secrets of the stars, or sailed to an uncharted land, or opened a new heaven to the human spirit. \n                  \n                \n\n— Helen Keller\n\n\n南京车辆年检\n材料\n\n机动车检验申请表（现场领取）\n行驶证（正副本）\n所有人身份证（原件）\n交强险保单+车船税证明（一般交强险电子保单均包含）\n保证车辆无事故\n"},"inbox/appendToInbox":{"slug":"inbox/appendToInbox","filePath":"inbox/appendToInbox.md","title":"appendToInbox","links":["inbox/inbox/20241220_221268-ti.html","inbox/inbox/2024-12-20-22-12-32---hisdaf.html","inbox/2024-12-20.html","inbox/task/qtasks.html","inbox/2022-07-03.html","inbox/求职/ToLearn.html"],"tags":[],"content":"2024-12-20 22:22(周五)\n20241220_221268-ti.md: qcap\n2024-12-20 22:14(周五)\n2024-12-20-22-12-32 - hisdaf.md: h\n2024-12-20 21:40(周五)\nqtasks: jklasdfjasdfasdf\n2022-07-03 23:07(周日)\nToLearn.md: one more\n\n 函数指针与成员函数指针\n python如何实现多线程\n 线程执行后的返回值如何获取\n #pragma pack的作用是什么？编译器指令，指定最小对齐单\n\npragma pack(8): 一般情况下按8字节对齐\npragma pack(4): 指定按4字节对齐\npragma pack(1): 指定按1字节对齐，内存用量减少，但寻址性能下降，时间换空间\n\n\n"},"inbox/task/qtasks":{"slug":"inbox/task/qtasks","filePath":"inbox/task/qtasks.md","title":"qtasks","links":[],"tags":[],"content":"\n qtaskllll 📆 2024-12-20\n this should in qtask 📆 2024-12-20\n fine thank you 📆 2022-07-03\n yes i am 📆 2022-07-03\n\nThis file is a inbox for quick captured tasks."},"index":{"slug":"index","filePath":"index.md","title":"🌱欢迎👏","links":["__zettel/202509302140quartz发布obsidian.html","README.html"],"tags":[],"content":"\nLearn2live stands for “learn to live”, learn something for fun, for work, for life…\n\n\n学而乐，学而用，学而活。\n\n\n心系红尘万千事，辗转百年始读书。\n闲言碎语何堪记，且予岁月证蹉跎。\n\n这是一个欢迎页面。这里（下称本站）实际上是我个人obsidian仓库的一个子集。在平时工作生活中，我会将学到的知识点、踩过的坑、觉得有趣的东西，简要记录在obsidian仓库。除去其中可能包含公司、个人隐私的部分，其余部分均是可以公开的。本页面是公开之后特意新增的介绍页面。\n这些笔记不会详细阐述一个话题，而是包含基础信息和必要的链接（对内或对外）。然而，这些信息已经足够让你快速了解一个话题，了解你需要的了解的部分，而不是一上来就几十页的PDF，打击你的积极性。\n本站内容均为原始个人笔记，95%都是手打的，所以你可能觉得它非正式。是的，它始终是非正式，工作中，略显凌乱的。知识在于记录，积累，链接。就像人脑学习事物的规律一样！创建本站的目的包括，\n\n自用参考。方便本人查阅，任何时间，任何地点，均能访问自己的笔记。\n分享知识。如果你觉得某篇笔记帮到了你，那这个目的就达成了。\n\n本站对于不同人群的受益率可能是，\n\n对我本人：80%\n对其他人：20%\n\n本站如何构建？\n参考202509302140quartz发布obsidian\n一些链接\n\nPersonal Manual：早期维护的个人手册，readthedocs+sphinx\nDigital Garden Entry：用digital-garden插件搭的半成品🔗\n水阙：略正式的博客\nLinks - 水阙：链接的链接\nREADME：原始介绍\n"},"life/人文":{"slug":"life/人文","filePath":"life/人文.md","title":"人文","links":[],"tags":[],"content":"人文\n几个传统节日\n上巳节，俗称三月三、三月节、三日节，是源于中国的传统节日，也见于汉字文化圈其他地区。相传三月三是黄帝、玄天上帝诞辰，也是哪吒太子升天日，还是中国神话中高媒神诞辰，高媒是媒人之神，可保佑媒人，亦可保佑男女恋爱顺利。高媒通说女娲，但尚有简狄、伏羲、勾芒等说法。\n花朝節，又稱花神節，或稱作百花生日，是中國傳統的節日。其時間在各朝代地區不同，中國早期以農曆二月十二或二月十五為花朝節。清代以後則一般北方以二月十五為花朝，而南方則以二月十二日為花朝節，與南北氣候不同有關。西南少數民族則以二月初二為花朝節。花朝節的風俗各地也有所不同，有種花、賞花等。\n三元节是道教的三个节日：\n\n以农历正月十五为上元节，一般称为“元宵节”；\n以农历七月十五为中元节，又称“鬼节、七月半”；\n以农历**十月十五为下元节**。\n\n道教有天、地、水三官大帝载录世人善恶之说，三元节，就是“三官大帝”的诞辰，并以天官生日为上元节，为天官赐福之日，要举行祈福法事；地官生日为中元节，为地官赦罪之日，要普渡孤魂；水官生日为下元节，为水官解厄之日，请神明为运势不好的人消灾解难。\n中国四大鬼节分别为：上巳节（农历三月三）、清明节（公历4月4-6日交节）、中元节（盂兰节、农历七月十五）、寒衣节（农历十月初一）。"},"life/公积金提取材料":{"slug":"life/公积金提取材料","filePath":"life/公积金提取材料.md","title":"公积金提取材料","links":[],"tags":[],"content":"公积金提取材料\n\n 二手房转让合同\n 增值税普通发票\n 不动产权证\n 贷款合同\n 银行一年还贷明细（盖章）\n 本人身份证、\n 结婚证、\n 户口本、\n 银行卡\n\n办事处\n\n    \n                    \n                        \n                            \n                                中心各服务网点分布及服务情况\n                            \n                        \n                    \n                    \n                        \n                            \n                                服务网点     凤起路综合服务大厅\n                            \n                        \n                    \n                    \n                        \n                            \n                                网点地址\n                            \n                        \n                        \n                            \n                                西湖区凤起路619号\n                            \n                        \n                    \n                    \n                        \n                            \n                                服务时间\n                            \n                        \n                        \n                            \n                                工作日上午8：30-12：00，下午13：00-16：30\n                            \n                        \n                    \n                    \n                        \n                            \n                                业务受理范围\n                            \n                        \n                        \n                            \n                                1.公积金和住房补贴缴存、提取；\n                            \n                            \n                                2.公积金和住房补贴信息变更、年检、调整；\n                            \n                            \n                                3.住房补贴业务材料受理及审核；\n                            \n                            \n                                4.省直单位公房维修基金使用、退款业务材料受理；\n                            \n                            \n                                5.房改、住房补贴政策咨询；\n                            \n                            \n                                6.房改申报受理；\n                            \n                            \n                                7.开具个人房改及住房补贴情况证明。\n                            \n                            \n                                其中3-7项业务在20-22号窗口办理\n                            \n                        \n                    \n                    \n                        \n                    \n                    \n                        \n                            \n                                服务网点     古墩路综合服务大厅\n                            \n                        \n                    \n                    \n                        \n                            \n                                网点地址\n                            \n                        \n                        \n                            \n                                西湖区古墩路97号浙商财富中心2号楼\n                            \n                        \n                    \n                    \n                        \n                            \n                                服务时间\n                            \n                        \n                        \n                            \n                                业务受理范围\n                            \n                        \n                    \n                    \n                        \n                            \n                                B2楼\n                            \n                            \n                                归集区\n                            \n                            \n                                办证区\n                            \n                            \n                                房改区\n                            \n                        \n                        \n                            \n                                工作日\n                            \n                            \n                                上午8：30-12：00\n                            \n                            \n                                下午13：30-16：30\n                            \n                        \n                        \n                            \n                                1.公积金和住房补贴缴存、提取；\n                            \n                            \n                                2.商品房预告及抵押权预告登记；\n                            \n                            \n                                3.商品房现房及抵押权登记；\n                            \n                            \n                                4.商品房预告转现及抵押转现登记；\n                            \n                            \n                                5.二手房买卖及抵押权登记；\n                            \n                            \n                                6.公积金贷款抵押注销；\n                            \n                            \n                                7.住房补贴业务材料受理及审核；\n                            \n                            \n                                8.房改、住房补贴政策咨询；\n                            \n                            \n                                9.房改申报受理；\n                            \n                            \n                                10.开具个人房改及住房补贴情况证明。\n                            \n                        \n                    \n                    \n                        \n                            \n                                一楼\n                            \n                            \n                                信贷服务区\n                            \n                        \n                        \n                            \n                                工作日\n                            \n                            \n                                上午8：30-12：00\n                            \n                            \n                                下午13：00-17：00\n                            \n                        \n                        \n                            \n                                1.公积金信贷业务受理；\n                            \n                            \n                                2.开具公积金存贷证明；\n                            \n                            \n                                3.公积金贷款结清证明领取；\n                            \n                            \n                                4.杭州市区住房情况查档；\n                            \n                            \n                                5.个人征信报告查询。\n                            \n                        \n                    \n                    \n                        \n                            \n                                三楼\n                            \n                            \n                                住房资金服务区（318室）\n                            \n                        \n                        \n                            \n                                工作日\n                            \n                            \n                                上午8：30-12：00\n                            \n                            \n                                下午14：00-16：30\n                            \n                        \n                        \n                            \n                                维修基金业务受理。\n                            \n                        \n                    \n                    \n                        \n                    \n                    \n                        \n                            \n                                服务网点     公积金下沙服务网点\n                            \n                        \n                    \n                    \n                        \n                            \n                                网点地址\n                            \n                        \n                        \n                            \n                                钱塘区下沙经济开发区6号大街新加坡科技园中信银行内\n                            \n                        \n                    \n                    \n                        \n                            \n                                服务时间\n                            \n                        \n                        \n                            \n                                工作日上午9：00—12：00，下午13：30—16：30\n                            \n                        \n                    \n                    \n                        \n                            \n                                业务受理范围\n                            \n                        \n                        \n                            \n                                公积金和住房补贴缴存、提取。\n                            \n                        \n                    \n                    \n                        \n                    \n                    \n                        \n                            \n                                服务网点     公积金钱江新城服务网点\n                            \n                        \n                    \n                    \n                        \n                            \n                                网点地址\n                            \n                        \n                        \n                            \n                                上城区市民街196 号圣奥商务大厦一楼农业银行内\n                            \n                        \n                    \n                    \n                        \n                            \n                                服务时间\n                            \n                        \n                        \n                            \n                                工作日上午9：00—12：00，下午13：30—16：30\n                            \n                        \n                    \n                    \n                        \n                            \n                                业务受理范围\n                            \n                        \n                        \n                            \n                                公积金和住房补贴缴存、提取。\n                            \n                        \n                    \n                    \n                        \n                    \n                    \n                        \n                            \n                                服务网点     公积金滨江服务网点\n                            \n                        \n                    \n                    \n                        \n                            \n                                网点地址\n                            \n                        \n                        \n                            \n                                滨江区江南大道518号兴耀大厦一楼杭州联合银行滨江支行内\n                            \n                        \n                    \n                    \n                        \n                            \n                                服务时间\n                            \n                        \n                        \n                            \n                                工作日上午9：00—11:30，下午13：30—16：30\n                            \n                        \n                    \n                    \n                        \n                            \n                                业务受理范围\n                            \n                        \n                        \n                            \n                                公积金和住房补贴缴存、提取。\n                            \n                        \n                    \n                    \n                        \n                        \n                    \n                    \n                        \n                            \n                                服务网点     公积金城北服务网点\n                            \n                        \n                    \n                    \n                        \n                            \n                                网点地址\n                            \n                        \n                        \n                            \n                                拱墅区东新路541号-543号交通银行东新支行内\n                            \n                        \n                    \n                    \n                        \n                            \n                                服务时间\n                            \n                        \n                        \n                            \n                                工作日上午9：00—12:00，下午13：30—16：30\n                            \n                        \n                    \n                    \n                        \n                            \n                                业务受理范围\n                            \n                        \n                        \n                            \n                                公积金和住房补贴缴存、提取。\n                            \n                        \n                    \n    \n\nsee: gjj.jgswj.zj.gov.cn/col/col1229569131/index.html"},"life/养生/人体各系统":{"slug":"life/养生/人体各系统","filePath":"life/养生/人体各系统.md","title":"人体内脏结构","links":[],"tags":["养生"],"content":"消化系统\n\n\n\n\n\n\n图源： www.100md.com/html/dir/2003/04/03/9578.htm\n图集： health.ifeng.com/c/7fE2EM2vlZN\n泌尿系统\n\n\n生殖系统\n\n男性\n女性\n\n\n\n\n\ncf. zhuanlan.zhihu.com/p/359837103\n经脉学位\n\n男性人体穴位图：十四经穴高清图解\nwww.100md.com/html/201504/1952/7577.htm\n手指同身寸法（取穴比量方法示范图）\n穴位大全图解\n"},"life/养生/孕妇驱蚊":{"slug":"life/养生/孕妇驱蚊","filePath":"life/养生/孕妇驱蚊.md","title":"孕妇驱蚊","links":[],"tags":[],"content":"孕妇如何安全防蚊驱蚊\n\n【防蚊篇】\n1、讲究卫生不给蚊子生存空间，想要与蚊子说拜拜，首先不要到草丛、臭水沟等一些蚊子聚会的地方去，对长期久待的家居空间一定要保持卫生，尤其把容易滋生和繁殖蚊子的角落清洁干净，绝不要给它留下生存空间。\n2、用有盖垃圾桶，还要勤清理。垃圾堆是蚊子的最爱，居家生活不要把鸡蛋壳、菜叶、肉渣、易拉罐、矿泉水瓶等容易变质、积水的垃圾乱扔，最好用有盖垃圾桶，并及时清理垃圾，免得增加蚊子繁殖的几率。\n3、池内不留死水，马桶随时盖上。静水和阻塞的地方也是蚊子繁殖之地，它产卵后很快孵化成幼虫。因此，清除室内积水，特别是水槽、拖把池、盥洗池内不要留死水，随时盖上马桶盖子， 能有效防止蚊虫的滋生。检查家里地漏、下水道等处防止积水，有必要可喷洒杀虫剂。\n4、纱窗不留“破绽”，植物定期换水。阻隔蚊子还得要靠纱窗、纱门、蚊帐，检查它们有无“破绽”，有的话赶紧处理修补。在家或出门都随手关闭纱窗、纱门，晚上睡觉前就应该拉好蚊帐，要不门户大开蚊子就长驱直入了。如果家中养得有水生植物，一定要定期换水，以免招蚊。\n【驱蚊篇】\n1、灯泡啤酒等也能驱蚊。想要与蚊子彻底说拜拜，除了想办法阻止它来，还要有办法在它来了后赶它走或消灭它。不喷驱蚊水、不熏蚊香、不用杀蚊剂，民间很多土办法驱蚊灭蚊也管用，既绿色又环保。\n使用蚊香之后，应该开窗通风透气\n2、放薰衣草等驱蚊植物。市面上有很多驱蚊植物，可以买回放置在家中，不过孕妇很多花香不能闻，最好买薰衣草、茉莉花、薄荷等无害植物。\n3、安装红灯泡同样赶蚊子。由于蚊子害怕橘红色的光线，室内安装橘红色灯泡，也有驱蚊效果。\n4、睡觉前调低空调温度。夏天基本家家都要使用空调，在睡觉前可以把空调开低一点，降温了自然不会有蚊子飞来。但注意孕妇不能久吹空调，睡前最好定时1小时后关闭。\n5、艾草+菖蒲浸泡拖地。到药房购买艾草+菖蒲加水浸泡后，用来拖地，室内能有效驱蚊。用水煮开后还可当驱蚊水用。房间里挂上阴干艾条也能驱蚊。\n6、涂擦大蒜或维生素B1。蚊子还讨厌大蒜味道，经常食用大蒜或将其涂抹在身上，蚊子都不会接近你。如果你嫌大蒜味道不好闻，也可以用维生素B1泡水擦身，也有好收效。\n7、八角+茴香泡水洗澡。调味品中八角+茴各取两枚，温水泡后用其水洗澡，蚊子也不敢接近你。\n8、点燃干桔皮、干茶叶。如果蚊子较多的话，可以用晒干的桔皮或茶叶代替蚊香，点燃后熏在室内，既能驱蚊，又可消除屋内异味。\n【止痒篇】\n1、口水也可有效止痒。如果孕妇被蚊子叮咬了，又不敢用含有各种添加剂的花露水、止痒药膏，那就用医生推荐的天然物品止痒消毒。\n2、肥皂水或盐水减轻痒感。用肥皂水或盐水治疗蚊子叮咬后的痒痛是一种有效的办法。如果严重，可使用少量万金油+盐涂抹叮咬处减轻痒感。\n3、切开的大蒜能消毒止痒。如果不外出，在被蚊子叮咬后可剥一颗蒜，切开用断面涂抹蚊子咬的包，能有效止痒\n4、芦荟叶的汁液消肿止痒。被蚊子叮咬后红肿、奇痒，可将芦荟叶洗干净后掰开，用汁液涂擦红肿处，就能消肿止痒。\nReferences\n\nm.mama.cn/bk/art/11832/\n"},"life/养生/汤头歌":{"slug":"life/养生/汤头歌","filePath":"life/养生/汤头歌.md","title":"汤头歌","links":[],"tags":[],"content":"《汤头歌诀》汤头歌诀\n　　汤头歌诀 清 汪昂\n　　叙\n　　古人治病，药有君臣，方有奇偶，剂有大小，此汤头所由来也。仲景为方书之祖，其《伤寒论》中既曰太阳证、少阳证、太阴证、少阴证矣，而又曰麻黄证、桂枝证、柴胡证、承气证等。不以病名病，而以药名病。明乎因病施药，以药合证，而后用之，岂苟然而已哉！令人不辨证候，不用汤头，率意任情，治无成法，是犹制器而废准绳，行阵而弃行列，欲以已病却疾，不亦难乎？盖古人制方，佐使君臣，配合恰当；从治正治，意义深长。如金科玉律，以为后人楷则。惟在善用者，神而明之，变而通之，如淮阴背水之阵，诸将疑其不合兵法，而不知其正在兵法之中也。旧本有汤头歌诀，辞多鄙率，义弗赅明，难称善本。不揣愚瞽，重为编辑，并以所主病证括入歌中，间及古人用药制方之意。某病某汤，门分义悉；理法兼备，体用具全；千古心传，端在于此。实医门之正宗，活人之彀率也。然古方甚多，难以尽录。量取便用者，得歌二百首。正方、附方共三百有奇。盖易则易知，简则易从。以此提纲挈领，苟能触类旁通，可应无穷之变也。是在善读者加之意耳。\n　　康熙甲戌夏月休宁八十老人汪昂题\n　　凡例\n　　一、本集诸歌，悉按沈约诗韵。其中平仄不能尽页者，以限于汤名、药名，不可改易也。\n　　二、古歌四句，仅载一方，尚欠详顺。本集歌不限方，方不限句；药味药引，俱令周明；病证治法，略为兼括。或一方而连汇多方，方多而歌省，并示古人用药触类旁通之妙，间及加减之法，便人取裁。\n　　三、《医学入门》载歌三百首，东垣歌二百六十八首，皆不分门类。每用一方，搜索殆遍。本集歌止二百首，而方三百有奇，分为二十门。某病某汤，举目易了。方后稍为训释，推明古人制方本义，使用药者有所根据，服药者得以参稽，庶觉省便。\n　　四、歌后注释，所以畅歌词之未备，颇经锤炼。读者倘不鄙夷，亦可诵习也。\n　　五、拙着《医方集解》，网罗前贤方论，卷帙稍繁，不便携带。故特束为歌诀，附于本草之末，使行旅可以轻 ，缓急得以应用也。\n　　六、是书篇章虽约，苟熟读之，可应无穷之变，远胜前人盈尺之书数部。有识之士，当不以愚言为狂僭也。\n　　 庵汪昂 漫识\n　　补益之剂\n　　十首、附方七\n　　补益之剂\n　　四君子汤\n　　《局方》中和义，参术茯苓甘草比。（人参、白术、茯苓各二钱，甘草一钱。气味中和，故名君子。）益以夏陈半夏、陈皮名六君子汤，祛痰补气阳虚饵。（二陈除痰，四君补气，脾弱阳虚宜之。）除却半夏名异功（散，钱氏。）或加香砂胃寒使。（加木香、砂仁，行气温中\n　　补益之剂\n　　升阳益胃\n　　（汤，东垣）参术 ，黄连半夏草陈皮。苓泻防风羌独活，柴胡白芍枣姜随。〔黄 二两，人参、半夏、炙甘草各一钱，羌活、独活、防风、白芍（炒）各五钱，陈皮四钱，白术、茯苓、泽泻、柴胡各三钱，黄连二钱。每服三钱，加姜枣煎。六君子助阳，补脾除痰；重用黄，补气固胃；柴胡、羌、独，除湿升阳；泽泻、茯苓，泻热降浊。加芍药和血敛阴，少佐黄连以退阴火。按：东垣治疗首重脾胃，而益胃又以升阳为先，故每用补中、上升下渗之药。此方补中有散，发中有收，脾胃诸方多从此仿也。〕\n　　补益之剂\n　　黄鳖甲\n　　（散，罗谦甫）地骨皮，艽菀参苓柴半知。地黄芍药天冬桂，甘桔桑皮劳热宜。（治虚劳骨蒸，晡热咳嗽，食少盗汗：黄 、鳖甲、天冬各五钱，地骨、秦艽、茯苓、柴胡各三钱，紫菀、半夏、知母、生地、白芍、桑皮、炙草各二钱半，人参、肉桂、桔梗各钱半。每服一两，加姜煎。鳖甲、天冬、知、芍，补水养阴；参、 、桂、苓、甘草，固卫助阳；桑、桔泻肺热，菀、夏理痰嗽；艽、柴、地骨退热升阳。为表里气血交补之剂。）\n　　补益之剂\n　　秦艽鳖甲\n　　（散，罗谦甫）治风劳，地骨柴胡及青蒿。当归知母乌梅合，止嗽除蒸敛汗高。（鳖甲、地骨皮、柴胡各一两，青蒿五钱，秦艽、当归、知母各五钱，乌梅五钱。治略同前，汗多倍黄。此方加青蒿、乌梅，皆敛汗退蒸之义。）\n　　补益之剂\n　　秦艽扶羸汤\n　　（汤，《直指》）鳖甲柴，地骨当归紫菀偕。半夏人参兼炙草，肺劳蒸嗽服之谐。（治肺痿骨蒸，劳嗽声嘎，自汗体倦：柴胡二钱，秦艽、鳖甲、地骨、当归、人参各钱半，柴菀、半夏、甘草炙各一钱，加姜、枣煎。按：黄 鳖甲散盖本此方，除当归加余药，透肌解热，柴胡、秦艽、干葛为要剂，故骨蒸方中多用之。此方虽表里交治，而以柴胡为君。）\n　　补益之剂\n　　紫菀汤\n　　（海藏）中知母贝，参苓五味阿胶偶。再加甘桔治肺伤，咳血吐痰劳热久。（治肺伤气极，劳热咳嗽，吐痰吐血，肺痿肺痈：紫菀、知母、贝母、阿胶各二钱，人参、茯苓、甘草、桔梗各五分，五味十二粒，一方加莲肉。以保肺止嗽为君，故用阿胶、五味；以清火化痰为臣，故用知母、贝母，佐以参、苓、甘草，扶土以生金；使以桔梗，上浮而利膈。气极，六极之一。）\n　　补益之剂\n　　百合固金\n　　（汤，赵蕺庵）二地黄，玄参贝母桔甘藏。麦冬芍药当归配，喘咳痰血肺家伤。（生地二钱，熟地三钱，麦冬钱半，贝母、百合、当归、白芍、甘草各一钱，玄参、桔梗各八分。\n　　火旺则金伤，故以玄参、二地助肾滋水；麦冬、百合保肺安神，芍药、当归平肝养血，甘、桔、贝母清金化痰，泻以甘草培本，不欲以苦寒伤生发之气也。）\n　　补益之剂\n　　补肺阿胶\n　　（散，钱氏）马兜铃，鼠粘甘草杏糯停。肺虚火盛人当服，顺气生津嗽哽宁。（阿胶两半，马兜铃焙、鼠粘子炒、甘草炙、糯米各一两，杏仁七钱。牛蒡利膈滑痰，杏仁降润气嗽。\n　　李时珍曰：马兜铃非取补肺，取其清热降气，肺自安也。其中阿胶、糯米，乃补肺之正药。\n　　补益之剂\n　　小建中汤\n　　（仲景）芍药多，（即桂枝加芍药汤再加饴糖，名建中。）桂姜甘草大枣和。更加饴糖补中脏，虚劳腹冷服之瘥。（芍药六两，桂枝、生姜各三两，甘草一两，枣十二枚，饴糖一升。）\n　　增入黄 名亦尔，〔再加黄 两半，各黄 建中汤（《金匮》）。若除饴糖，则名黄 五物汤，不名建中矣。今人用建中者，绝不用饴糖，何哉？〕表虚身痛效无过。又有建中十四味，阴斑劳损起沉 。（亦有阴证发斑者，淡红隐隐，散见肌表，此寒伏于下，逼其无根之火熏肺而然，若服寒药立毙。）十全大补加附子，麦夏苁蓉仔细哦。（即十全大补汤加附子、麦冬、半夏、肉苁蓉，名十四味建中汤。十四味除茯苓、白术、麦冬、川芎、熟地、肉苁蓉，名八味大建中\n　　补益之剂\n　　益气聪明汤\n　　（东垣）蔓荆，升葛参 黄柏并。并加芍药炙甘草，耳聋目障服之清。（参、 各五钱，蔓荆子、葛根各三钱，黄柏、白芍各二钱，升麻钱半，炙草一钱，每服四钱。人之中气不足，清阳不升，则耳目不聪明。蔓荆、升、葛，升其清气；参、 、甘草，补其中气，而以芍药平肝木，黄柏滋肾水也。）\n　　发表之剂\n　　十四首、附方八\n　　发表之剂\n　　麻黄汤\n　　（仲景）中用桂枝，杏仁甘草四般施。发热恶寒头项痛，伤寒服此汗淋漓。〔麻黄（去节）三两，桂枝二两，杏仁七十枚（去皮尖），甘草（炙）一两。伤寒太阳表证无汗，用此发之。麻黄善发汗，恐其力猛，故以桂枝监之，甘草和之，不令大发也。按：桂、麻二汤虽治太阳证，而先正每云皆肺药，以伤寒必自皮毛入，而桂、麻又入肺经也。〕\n　　发表之剂\n　　桂枝汤\n　　（仲景）治太阳（中）风，芍药甘草姜枣同。（桂枝、芍药、生姜各三钱，炙草三两，大枣干二枚。治太阳中风有汗，用此解肌，以和营卫，中犹伤也。仲景《伤寒论》通用。）\n　　桂麻相合名各半汤，太阳如疟此为功。（热多寒少，如疟状者，宜之。）\n　　发表之剂\n　　大青龙汤\n　　（仲景）桂麻黄，杏草石膏姜枣藏。（麻黄六两，桂枝、炙草各三两，杏仁四十枚，石膏鸡子大，生姜三两，大枣十二枚。）太阳无汗兼烦躁，（烦为阳、为风，躁为阴、为寒。必太阳证兼烦躁者，方可用之。以杏、草佐麻黄发表，以姜、枣佐桂枝解肌，石膏质重泻火，气轻亦达肌表。义取青龙者，龙兴而云升雨降，郁热赖除，烦躁乃解也。若少阴烦躁，而误服此则逆。）风寒两解此为良。（麻黄汤治寒，桂枝汤治风，大青龙小风寒而两解之。陶节庵曰：此汤险峻，今人罕用。）\n　　发表之剂\n　　小青龙汤\n　　（仲景）治水气，喘咳呕哕渴利慰。（太阳表证未解，心下有水气者用之。或喘或咳，或呕或哕，或渴或利，或短气，或小便秘，皆水气内积所致。）姜桂麻黄芍药甘，细辛半夏兼五味。〔干姜、麻黄、桂枝、芍药（酒炒）、炙草、细辛各二两，半夏、五味子各半升。桂枝解表，使水从汗泄；芍药敛肺，以收喘咳；姜、夏、细辛润肾行水，止渴呕，亦表里分消之意。〕\n　　发表之剂\n　　葛根汤\n　　（仲景）内麻黄襄，二味加入桂枝汤。（桂枝、芍药、炙草各二两，姜三两，枣十二枚，此桂枝汤也，加葛根四两，麻黄三两。）轻可去实因无汗，（中风表实，故汗不得出。《十剂》曰：轻可去实，葛根、麻黄之属是也。）有汗加葛无麻黄。（名桂枝加葛根汤，仲景治太阳有汗恶风。）\n　　发表之剂\n　　升麻葛根汤\n　　钱氏（钱乙），再加芍药甘草是。（升麻三钱，葛根、芍药各二钱，炙草一钱。轻可去实，辛能达表，故用升药发散阳明表邪。阳邪盛则阴气虚，故加芍药敛阴和血。升麻、甘草升阳解毒，故亦治时疫。）阳明发热与头疼，无汗恶寒均堪倚。（及目痛鼻干、不得卧等症。）亦治时疫与阳斑，痘疹已出慎勿使。（恐升散重虚其表也。）\n　　发表之剂\n　　九味羌活\n　　（汤，张元素）用防风，细辛苍芷与川芎。黄芩生地同甘草，三阳解表益姜葱。\n　　防风、苍术各钱半，白芷、川芎、生地、甘草各一钱，细辛五分，加生姜、葱白煎。）阳虚气弱人禁用，加减临时在变通。（洁古制此汤，以代麻黄、桂枝、青龙、各半等汤。用羌、防、苍、细、芎、芷，各走一经，祛风散寒，为诸路之应兵。加黄芩泄气中之热，生地泄血中之热，甘草以调和诸药。然黄芩、生地，寒滞未可概施，用时宜审。）\n　　发表之剂\n　　十神汤\n　　《局方》里葛升麻，陈草芎苏白芷加。麻黄赤芍兼香附，时行（瘟疫）感冒效堪夸。（葛根、升麻、陈皮、甘草、川芎、白芷、紫苏、麻黄、赤芍、香附等分，加姜、葱煎，治风寒两感，头痛发热，无汗恶寒，咳嗽鼻塞。芎、麻、升、葛、苏、芷、香附，辛香利气，发表散寒。加芍药者，敛阴气于发汗之中；加甘草者，和阳气于疏利之队也。吴绶曰：此方用升麻、葛根，能解阳明瘟疫时气。若太阳伤寒发热，用之则引邪入阳明，传变发斑矣，慎之！）\n　　发表之剂\n　　神术散\n　　（《局方》）用甘草苍，细辛 本芎芷羌。（苍术二两，炙草、细辛， 本、白芷、川芎、羌活各一两，每服四钱，生姜、葱白煎。）各走一经祛风湿，（太阴苍术，少阴细辛，厥阴、少阳川芎，太阳羌活、 本，阳明白芷。此方与九味羌活汤意同，加 本，除黄芩、生地、防风，较羌活汤更稳。）风寒泄泻总堪尝。太无神术（散，太无，丹溪之师）即平胃（散），加入菖蒲与藿香。（陈皮为君二钱，苍术、浓朴各一钱，炙草、菖蒲、藿各钱半，治岚瘴瘟疟时气。）海藏神术（散）苍防草，太阳无汗代麻黄。（苍术、防风各二两，炙草一两，用代仲景麻黄汤，治太阳伤寒无汗。）若以白术易苍术，太阳有汗此汤良。（名白术汤，用代桂枝汤，治太阳伤风有汗。二术主治略同，特有止汗、发汗之异。）\n　　发表之剂\n　　麻黄附子细辛汤\n　　（仲景）发表温经两法彰。（麻黄 、细辛各二两，附子一枚炮。麻黄发太阳之汗，附子温少阴之经，细辛为肾经表药，联属其间。）若非表里相兼治，少阴反热曷能康。（少阴证，脉沉属里，当无热，今反发热，为太阴表证未除。）\n　　发表之剂\n　　人参败毒\n　　（散，《活人》。毒即热湿也）茯苓草，枳桔柴前羌独芎。薄荷少许姜三片，时行感冒有奇功。（人参、茯苓、枳壳、桔梗、柴胡、羌活、独活、川芎各一两，甘草五钱，每服二两，加薄荷、生姜煎。羌活理太阳游风，独活理少阴伏风，兼能去湿除痛，川芎、柴胡和血升清，枳壳、前胡行痰降气，甘、桔、参、茯清肺强胃，辅正匡邪也。喻嘉言曰：暑湿热三气门中，推此方为第一。俗医减却人参，曾与他方有别耶？）去参名为败毒散，加入消风（散，见风门）治亦同。（合消风散名消风败毒散。）\n　　发表之剂\n　　再造散\n　　（节庵）用参 甘，桂附羌防芎芍参。细辛加枣煨姜煎，阳虚无汗法当谙。〔人参、黄、甘草、川芎、白芍（酒炒）、羌活、防风、桂枝、附子（炮）、细辛（煨），姜、大枣煎。\n　　以参、 、甘、姜、桂、附大补其阳，助羌、防、芎、细散寒发表。加芍药者，于阳中敛阴，散中有收也。陶节庵曰：发热头痛，恶寒无汗，服汗剂汗不出者，为阳虚不能作汗，名无汗证。庸医不识，不论时令，遂以麻黄重剂劫取其汗，误人死者多矣。又曰：人第知参、 能止汗，而不知其能发汗，以在表药队中，则助表药而解散也。〕\n　　发表之剂\n　　麻黄人参芍药汤\n　　（东垣）桂枝五味麦冬襄。归 甘草汗兼补，虚人外感服之康。〔麻黄、白芍、黄 、当归、甘草（炙）各一钱，人参、麦冬各三分，桂枝五分，五味五粒。东垣治一人内蕴虚热，外感大寒而吐血，法仲景麻黄汤，加补剂制此方，一服而愈。原解曰：麻黄散外寒，桂枝补表虚，黄 实表益卫，人参益气固表，麦冬、五味保肺气，甘草补脾，芍药安太阳，当归和血养血。〕\n　　发表之剂\n　　神白散\n　　（《卫生家宝》）用白芷甘，姜葱淡豉与相参。（白芷一两，甘草五钱，淡豉五十粒，姜三片，葱白三寸，煎服取汗。）一切风寒皆可服，疏表祛邪效可推。（必须得汗，服乃有效。）\n　　豉一升，名葱豉汤。）用代麻黄汤功不惭。伤寒初觉头痛身热，便\n　　攻里之剂\n　　七首 附方四\n　　攻里之剂\n　　大承气汤\n　　（仲景）用芒硝，枳实大黄浓朴饶。〔大黄四两（酒洗），芒硝三合，浓朴八两，枳实五枚〕。救阴泻热功偏擅，急下阳明有数条。（大黄治大实，芒硝治大燥大坚，二味治无形血药；浓朴治大满，枳实治痞，二味治有形气药。热毒传入阳明胃府，痞、满、燥、实、坚全见，杂证、三焦实热，并须以此下之。胃为水谷之海，土为万物之母。四旁有病，皆能传入胃府，则不复传他经矣。陶节庵曰：伤寒热邪传里，须看热气浅深用药，大承气最紧，小承气次之，调\n　　攻里之剂\n　　小承气汤\n　　（仲景）朴实黄，〔大黄四两，浓朴二两（姜炒），枳实三枚（麸炒）。〕谵狂痞硬上焦强。\n　　（热在上焦则满，在中焦则硬，胃有燥粪则谵语，不用芒硝者，恐伤下焦真阴也。）益以羌活名三化（汤，）中风闭实可消详。（用承气治二便，加羌活治风，中风体实者可偶用。然涉虚者多，不可轻投。）\n　　攻里之剂\n　　调胃承气\n　　（汤，仲景）硝黄草，〔大黄（酒浸）、芒硝各一两，甘草（炙）五钱。〕甘缓微和将胃保。（用甘草甘以缓之，微和胃气，勿令大泄下。）不用朴实伤上焦，（不用浓朴、枳实，恐伤上焦氤氲之气也。）中焦燥实服之好。\n　　攻里之剂\n　　木香槟榔\n　　（丸，张子和）青陈皮，枳壳柏连棱术随。大黄黑丑兼香附，芒硝水丸量服之。一切实积能推荡，泻痢食疟用咸宜。〔木香、槟榔、青皮（醋炒）、陈皮、枳壳（炒）、黄柏（酒炒）\n　　、棱、莪术（并醋煮），各五钱，大黄（酒浸）一两，香附、牵牛各二两，芒硝，水丸，量虚实服。木香、香附、青、陈、枳壳利气宽肠，黑牵牛、槟榔下气尤速，气行则无痞满后重之患矣。连、柏燥实清热，棱、莪行气破血，硝、黄去血中伏热，并为推坚峻品。湿热积滞去，则二便调而三焦通泰矣。盖宿垢不净，清阳终不得升，亦通因通用之意也。〕\n　　攻里之剂\n　　枳实导滞\n　　（丸，东垣）首大黄，芩连曲术茯苓襄。泽泻蒸饼糊丸服，湿热积滞力能攘。〔大黄一两，枳实（麸炒）、黄芩（酒炒）、黄连（酒炒）、神曲（炒）各五钱，白术（土炒）、茯苓三钱，泽泻二钱，蒸饼糊丸，量虚实服之。大黄、枳实荡热去积，芩、连佐之以清热，苓、泻佐之以利湿，神曲佐之以消食。又恐苦寒力峻，故加白术补土固中。〕若还后重兼气滞，木香导滞（丸）加槟榔。\n　　攻里之剂\n　　温脾\n　　（汤，《千金》）参附与干姜，甘草当归硝大黄。寒热并行治寒积，脐腹绞结痛非常。人参、附子、甘草、芒硝各一两，大黄五两，当归、干姜各三两，煎服，日三。本方除当归、芒硝，亦名温脾汤，治久痢赤白、脾胃冷、实不消。硝、黄以荡其积，姜、附以祛其寒，参、草、当归以保其血气。按：古人方中，多有硝、黄、柏、连与姜、茱、桂、附寒热并用者，亦有参、术、硝、黄补泻并用者，亦有大黄、麻黄汗下兼行者，令人罕识其旨。姑录此方，以见治疗之妙不一端也。）\n　　攻里之剂\n　　蜜煎导法通大便，\n　　（仲景用蜜熬如饴，捻作挺子，掺皂角末，乘热纳谷道中，或掺盐。）或将（猪）胆汁灌肛中。（用猪胆汁醋和，以竹管插肛门中，将汁灌入，顷当大便，名猪胆汁导法，仲景）。\n　　不欲苦寒伤胃府，阳明无热勿轻攻。（胃府无热而便秘者，为汗多津液不足，不宜用承气妄攻。此仲景心法，后人罕识，故录三方于攻下之末。）\n　　涌吐之剂\n　　二首、附方六汗、吐、下、和，乃治疗之四法。经曰：在上者涌之，其高者因而越之，故古人治病，用吐法者最多。朱丹溪曰：吐中就有发散之义。张子和曰：诸汗法古方多有之，惟以吐发汗者，世罕知之。今人医疗，惟用汗、下、和，而吐法绝置不用，可见时师之缺略。特补涌吐一门，方药虽简，而法不可废也。若丹溪用四物、四君引吐，又治小便不通，亦用吐法，是又在用者之圆神矣。\n　　涌吐之剂\n　　瓜蒂散\n　　（仲景）中赤小豆，（甜瓜蒂炒黄与赤小豆为末，热水或 水调，量虚实服之。）或入藜芦郁金凑。（张子和去赤豆加藜芦、防风，一方去赤豆加郁金、韭汁，俱名三圣散。鹅翎探吐，并治风痰。）此吐实热与风痰，（瓜蒂吐实热，藜芦吐风痰。）虚者参芦（散）一味勾。（虚人痰壅不得服瓜蒂者，以参芦代之，或加竹沥。）若吐虚烦栀豉汤，（仲景，栀子十四枚，豉四合，治伤寒后虚烦。）剧痰乌附尖方透。（丹溪治许白云，用瓜蒂、栀子、苦参、藜芦，屡吐不透，后以浆水和乌附尖服，始得大吐。）古人尚有烧盐方，一切积滞功能奏。（烧盐热汤调服，以指探吐，治霍乱、宿食、冷痛等症。《千金》曰：凡病宜吐，大胜用药。）\n　　涌吐之剂\n　　稀涎\n　　（散，严用和）皂角白矾斑，〔皂角四挺（去皮弦炙），白矾一两，为末，每服五分。\n　　白矾酸苦涌泄，能软顽痰；皂角辛咸通窍，专制风木。此专门之兵也，国中风时宜用之。〕或益藜芦微吐间。风中痰升人眩仆，当先服此通其关。（令微吐稀涎，续进他药。）通关散用细辛皂（角，为末，）吹鼻得嚏保生还。（卒中者用此吹鼻，有嚏者可治，无嚏者为肺气已绝。）\n　　和解之剂\n　　九首、附方五\n　　和解之剂\n　　小柴胡汤\n　　（仲景）和解供，半夏人参甘草从。更用黄芩加姜枣，少阳百病此为宗。（柴胡八两，半夏半升，人参、甘草、黄芩、生姜各三两，大枣十二枚。治一切往来寒热，胸满胁痛，心烦喜呕，口苦耳聋，咳渴悸利，半表半里之证。属少阳经者，但见一症即是，不必悉具。胆府清净，无出无入，经在半表半里，法宜和解。柴胡升阳达表，黄芩退热和阴，半夏祛痰散逆，参、草辅正补中，使邪不得复传入里也。）\n　　和解之剂\n　　四逆散\n　　（仲景）里用柴胡，芍药枳实甘草须。（柴胡、芍药炒、枳实麸炒、甘草炙等分。）\n　　此是阳邪成厥逆，（阳邪入里，四肢逆而不温。）敛阴泄热平剂扶。（芍药敛阴，枳实泄热，甘草和逆，柴胡散邪，用平剂以和解之。）\n　　和解之剂\n　　黄连汤\n　　（仲景）内用干姜，半夏人参甘草藏。更用桂枝兼大枣，寒热平调呕痛忘。〔黄连（炒）、干姜（炮）、甘草、桂枝各三两，人参二两，半夏半升，大枣十二枚，治胸中有热而欲呕，胃中有寒而作痛，或丹田有热，胸中有寒者，仲景亦用此汤。按：此汤与小柴胡汤同意，以桂枝易柴胡，黄连易黄芩，以干姜易生姜，余药同，皆是和解之意。但小柴胡汤属少阳药，此汤\n　　和解之剂\n　　黄芩汤\n　　（仲景）用甘芍并，二阳合利加枣烹。（治太阳、少阳合病，下利：黄芩三两，芍药、甘草各二两，枣十二枚。阳邪入里，故以黄芩彻其热，甘草、大枣和其太阴。）此方遂为治痢祖，后人加味或更名。（利，泻泄也；痢，滞下也。仲景本治伤寒下利，《机要》用此治痢，更名黄芩芍药汤；洁古治痢加木香、槟榔、大黄、黄连、当归、官桂，名芍药汤。）再加生姜与半夏，（名黄芩加生姜半夏汤，仲景。）前症兼呕此能平。单用芍药与甘草（炙，等分，名芍药甘草汤，仲景。）散逆止痛能和营。（虞天民曰：白芍不惟治血虚，兼能行气。腹痛者，营气不\n　　和解之剂\n　　逍遥散\n　　（《局方》）用当归芍，柴芩术草加姜薄。〔柴胡、当归（酒拌）、白芍（酒炒）、白术（土炒、茯苓各一钱，甘草（炙）五分，加煨姜、薄荷煎。〕散郁除蒸功最奇，（肝虚则血病，归、芍养血平肝；木盛则土衰，术、草和中补土，柴胡升阳散热，茯苓利湿宁心，生姜暖胃祛痰，薄木郁则火郁，火郁则土郁，土郁则金郁，金郁则水郁。五行相因，自然之理也。余以一方治木郁，而诸郁皆解，逍遥散是也。）调经八味丹栀着。（加丹皮、栀子各八味逍遥散，治肝伤血少。）\n　　和解之剂\n　　藿香正气\n　　（散，《局方》）大腹苏，甘桔陈苓术朴俱。夏曲白芷加姜枣，感伤（外感内伤）岚瘴并能驱。〔藿香、大腹皮、紫苏、茯苓、白芷各三两，陈皮、白术（土炒）、浓朴（姜汁炒）、半夏曲、桔梗各二两，甘草一两，每服五钱，加姜、枣煎。藿香理气和中，辟恶止呕；苏、芷、桔脾去湿，以辅正气。正气通畅，则邪逆自除矣。〕\n　　和解之剂\n　　六和\n　　（汤，《局方》）藿朴杏砂呈，半夏木瓜赤茯苓。术参扁豆同甘草，姜枣煎之六气平。（藿香、浓朴、砂仁、半夏、木瓜、赤茯苓、白术、人参、扁豆、甘草，加姜、枣煎，能御风、寒、暑、湿、燥、火六气，故名曰六和。藿、朴、杏、砂理气化食，参、术、陈、夏补正匡脾，豆、瓜祛暑，赤茯行水。大抵以理气健脾为主，脾胃既强，则诸邪不能干矣。）或益香藿或苏叶，伤寒伤暑用须明。（伤寒加苏叶，伤暑加香藿。）\n　　和解之剂\n　　清脾饮\n　　（严用和）用青朴柴，芩夏甘苓白术偕。更加草果姜煎服，热多阳疟此方佳。〔青皮、浓朴（醋炒）、柴胡、黄芩、半夏（姜制）、甘草（炙）、茯苓、白术（土炒）、草果（煨），加姜煎。疟不止，加酒炒常山一钱，乌梅二个；大渴，加麦冬、知母。疟疾，一名脾寒，盖因脾胃受伤者居多。此方乃加减小柴胡汤从温脾诸方而一变也。青、柴平肝破滞，朴、夏平胃祛痰，芩、苓清热利湿，术、草补脾调中，草果散太阴积寒，除痰截疟。〕\n　　和解之剂\n　　痛泻要方\n　　（刘草窗）陈皮芍，防风白术煎丸酌。〔白术（土炒）三两，白芍（酒炒）四两，陈皮（炒）半两，防风一两，或煎或丸，久泻加升麻。〕补土泻木理肝脾，（陈皮理气补脾，防、芍泻木益土）。若作食伤医便错。（吴鹤皋曰：伤食腹痛，得泻便减，今泻而痛不减，故责之土败木贼也\n　　表里之剂\n　　八首、附方五\n　　表里之剂\n　　大柴胡汤\n　　（仲景）用大黄，枳实苓夏白芍将。煎加姜枣表兼里，妙法内攻并外攘。（柴胡八两，大表证未除，里证又急者。柴胡解表，大黄、枳实攻里，黄芩清热，芍药敛阴、半夏和胃止呕，姜、枣调和营卫。按：本方、次方治少阳阳明，后方治太阴阳明，为不同。）柴胡（加）\n　　芒硝义亦尔，（小柴胡汤加芒硝六两，仲景。）仍有桂枝（加）大黄汤。（仲景桂枝汤内加大黄一两，芍药三两，治太阳误下，转属太阴，大实痛者。）\n　　表里之剂\n　　防风通圣\n　　（散，河间）大黄硝，荆芥麻黄栀芍翘。甘桔芎归膏滑石，薄荷芩术力偏饶。表里交攻阳热盛，外科疡毒总能消。〔大黄（酒蒸）、芒硝、防风、荆芥、麻黄、黑栀、白芍（炒）、连翘、川芎、当归、薄荷、白术各五钱，桔梗、黄芩、石膏各一两，甘草二两，滑石三两，加姜、葱煎。荆、防、麻黄、薄荷发汗而散热搜风，栀子、滑石、硝、黄利便而降火行水，芩、桔、石膏清肺泻胃，川芎、归、芍养血补肝，连翘散气聚血凝，甘、术能补中燥湿，故能汗不伤表，下不伤里也。〕\n　　表里之剂\n　　五积散\n　　（《局方》）治五般积，（寒积、食积、气积、血积、痰积。）麻黄苍芷芍归芎。枳桔桂姜甘茯朴，陈皮半夏加姜葱。（当归、川芎、白芍、茯苓、桔梗各八分，苍术、白芷、浓朴、陈皮各六分，枳壳七分，麻黄、半夏各四分，肉桂、干姜、甘草各三分，重表者用桂枝。桂、麻解表散寒，甘、芍和里止痛，苍、朴平胃，陈、夏行痰，芎、归养血，茯苓利水，姜、芷祛寒湿，枳、桔利膈肠。一方统治多病，唯善用者，变而通之。）除桂枳陈余略炒，（三味生用，余药微炒，名熟料五积散。）熟料尤增温散功。温中解表祛寒湿，散痞调经用各充。（陶节庵曰：凡阴证伤寒，脉浮沉无力，均当服之，亦可加附子。）\n　　表里之剂\n　　三黄石膏\n　　（汤）芩柏连，栀子麻黄豆豉全。姜枣细茶兼热服，（寒因热用。）表里三焦热盛宣。（石膏两半，黄芩、黄连、黄柏各七钱，栀子三十个，麻黄、淡豉各二合，每服一两，姜三片、枣二枚、茶一撮煎，热服。治表里三焦大热，谵狂斑衄，身目俱黄。黄芩泻上焦，黄连泻中焦，黄柏泻下焦，栀子通泻三焦之火以清里，麻黄、淡豉散寒发汗而解表，石膏体重能泻肺胃之火，气轻亦能解肌也。）\n　　表里之剂\n　　葛根黄芩黄连汤\n　　（仲景），甘草四般治二阳。（治太阳桂枝证，医误下之，邪入阳明，协热下利，脉促喘而汗出者，葛根八两，炙草、黄芩各二两，黄连三两。）解表清里兼和胃，喘汗自利保平康。\n　　（成无己曰：邪在里，宜见阴脉，促为阳盛，知表未解也。病有汗出而喘者，为邪气外甚，今喘而汗出，为里热气逆，与此方散表邪、清里热。脉数而止曰促，用葛根者，专主阳明之表。）\n　　表里之剂\n　　参苏饮\n　　（元戎）内用陈皮，枳壳前胡半夏宜。干葛木香甘桔茯，内伤外感此方推。〔人参、紫苏、前胡、半夏（姜制）、干葛、茯苓各七钱半，陈皮、枳壳（麸炒）、桔梗、木香、甘草各二钱，每服二钱，加姜、枣煎。治外感内伤，发热头痛，呕逆咳嗽，痰眩风泻。外感重者，去枣加葱白。苏、葛、前胡解表，参、芩、甘草补中，陈皮、木香行气破滞，半夏、枳、桔利膈祛痰。〕参前若去芎柴入，饮号芎苏治不瘥。（去人参、前胡，加川芎、柴胡，名芎苏饮，不服参者宜之。）香苏饮（《局方》）仅陈皮草，感伤内外亦堪施。〔香附（炒）、紫苏各二钱，陈皮（\n　　表里之剂\n　　茵陈丸\n　　（《外台》）用大黄硝，鳖甲常山巴豆邀。杏仁栀豉蜜丸服，汗吐下兼三法超。时气毒疠及疟痢，一丸两服量病调。〔茵陈、芒硝、鳖甲（炙）、栀子各二两，大黄五两，常山、杏仁（炒）各三两，巴豆一两（去心皮炒），豉五合，蜜丸梧子大。每服一丸，或吐或利，不应再服。一丸不应，以热汤投之。栀子、淡豉，栀豉汤也，合常山可以涌吐，合杏仁可以解肌。\n　　大黄、芒硝，承气汤也，可以荡热去实，合茵陈可以利湿退黄，加巴豆大热以祛脏腑积寒，加鳖甲滋阴以退血分寒热。此方备汗、吐、下三法，虽云劫剂，实是佳方。〕\n　　表里之剂\n　　大羌活汤\n　　即九味，己独知连白术暨。（即九味羌活汤加防己、知母、独活、黄连、生地、川芎、知母各一两，余药各三钱，每服五钱。）散热培阴表里和，伤寒两感瘥堪慰。（两感伤寒，一曰太阳与少阴俱病，二曰阳明与太阴俱病，三曰少阳与厥阴俱病。阴阳表里，同时俱病，欲汗则有里证，欲下则有表证。经曰：其两感于寒者，必死。仲景无治法，洁古为制此方，间有生者。羌、独、苍、防、细辛，以散寒发表；芩、连、防己、知母、芎、地，以清里培阴；白术、甘草，以固中和表里。）\n　　消补之剂\n　　七首、附方六\n　　消补之剂\n　　平胃散\n　　（《局方》）是苍术朴，陈皮甘草四般药。〔苍术（泔浸）二钱，浓朴（姜汁炒）、陈皮（去白）、甘草（炙）各一钱，姜、枣煎。〕除湿散满驱瘴岚，调胃诸方从此扩。（苍术燥湿强脾，浓朴散满平胃，陈皮利气行痰，甘草和中补土，泄中有补也。）或合二陈（名平陈汤，治痰）\n　　或五苓，（名胃苓汤，治泄。）硝黄麦曲均堪着。（加麦芽、神曲消食，加大黄、芒硝荡积。）\n　　若合小柴（胡）名柴平（汤），煎加姜枣能除疟。又不换金正气散，即是此方加夏藿（半夏、藿香。）\n　　消补之剂\n　　保和（丸）\n　　神曲与山楂，苓夏陈翘菔（音卜）子加。曲糊为丸麦（芽）汤下，亦可方中用麦芽。〔山楂（去核）三两，神曲、茯苓、半夏各一两，菔子（微炒）、连翘各五钱。山楂消肉食，麦芽消谷食，神曲消食解酒，菔子下气，制曲、茯苓渗湿，连翘散结，陈、夏健脾化痰。此内伤而气末病者，故但以和平之品消而化之，不必攻补也。〕太安丸内加白术（二两，）中消兼补效堪夸。\n　　消补之剂\n　　健脾（丸）\n　　参术与陈皮，枳实山楂麦 （芽）随。曲糊作丸米饮下，消补兼行胃弱宜。〔人参、白术（土炒）各二两，陈皮、麦芽（炒）各一两，山楂两半，枳实（麸炒）三两。陈皮、枳实理气化积，山楂消肉食，曲、麦消谷食，人参、白术益气强脾。〕枳术丸（洁古）亦消兼补，〔白术（土炒）〕、〔枳实（麸炒）〕等分。荷叶烧饭上升奇。（荷叶包陈米饭，煨干为丸，引胃气及少\n　　消补之剂\n　　参苓白术\n　　（散）扁豆陈，山药甘莲砂薏仁。（数药利气强脾。）桔梗上浮（载药上行）兼保肺，（恐燥药上僭。）枣汤调服益脾神。〔人参、茯苓、白术（土炒）、陈皮、山药、甘草（炙）各一斤，扁豆（炒）十二两，莲肉（炒）、砂仁、苡仁（炒）、桔梗各半斤，共为末，每服二钱，枣汤或米饮调下。〕\n　　消补之剂\n　　枳实消痞\n　　（丸，东垣）四君全，麦芽夏曲朴姜连。蒸饼糊丸消积满，清热破结补虚痊。〔炒）、黄连（姜汁炒）各五钱，人参、白术（土炒）、半夏曲、浓朴（姜汁炒）、茯苓各三钱，甘草（炙）、干姜各二钱。黄连、枳实治痞君药，麦、夏、姜、朴温胃散满，参、术、苓、甘燥湿补脾，使气足脾运，痞乃化也。〕\n　　消补之剂\n　　鳖甲饮子\n　　（《严氏》）治疟母，（久疟不愈，中有结癖。）甘草 术芍芎偶。草果槟榔浓朴增，乌梅姜枣同煎服。〔鳖甲（醋炙）、黄 、白术（土炒）、甘草、陈皮、川芎、白芍（酒炒）、草果（面煨）、槟榔、浓朴等分，姜三片，枣二枚，乌梅少许煎。鳖甲属阴入肺，退热散结为君，甘、陈、 、术助阳补气，川芎、白芍养血和阴，草果温胃，槟榔破积，浓朴散满，甘草和中，乌梅酸敛，姜、枣和营卫。〕\n　　消补之剂\n　　葛花解酲\n　　（汤）香砂仁，二苓参术蔻青陈。神曲干姜兼泽泻，温中利湿酒伤珍。〔葛花、砂仁、豆蔻各一钱，木香一分，茯苓、人参、白术（炒）、青皮、陈皮各四分，神曲（炒）、干姜、猪苓、泽泻各五分，专治酒积及吐泻痞塞。砂、蔻、神曲皆能解酒，青皮、木香、干姜行气温中，葛花引湿热从肌肉出，苓、泻引湿热从小便出，益以参、术固其中气也。〕\n　　理气之剂\n　　十一首、附方八\n　　理气之剂\n　　补中益气\n　　（汤，东垣） 术陈，升柴参草当归身。〔黄 （蜜炙）钱半，人参、甘草（炙）各一钱，白术（土炒）、陈皮（留白）、归身各五分，升麻、柴胡各三分，加姜、枣煎。表虚者，升麻用蜜水炒用。东垣曰：升、柴味薄性阳，能引脾胃清气行于阴道，以资春气之和；又引参、 、甘草上行，充实腠理，使卫外为固。凡补脾胃之气，多以升阳补气名之者，此也。〕虚劳内伤功独擅，亦治阳虚外感因。（虚人感冒，不在发散者，此方可以代之，或加辛散药。）\n　　木香苍术易归术，调中益气畅脾神。（除当归、白术，加木香、苍术，名调中益气汤。前方加白芍、五味子，发中有收，亦名调中益气汤，俱李东垣方。）\n　　理气之剂\n　　乌药顺气\n　　（汤，严用和）芎芷姜，橘红枳桔及麻黄。僵蚕炙草姜煎服，中气厥逆此方详。（厥逆痰塞，口噤脉伏，身温为中风，身冷为中气。中风多痰涎，中气无痰涎，以此为辨。许学士云：中气之证，不可作中风治。喻嘉言曰：中风证多挟中气。乌药、橘红各二钱，川芎、白芷、枳壳、桔梗、麻黄各一钱，僵蚕（去丝嘴炒）、炮姜、炙草各五分，加姜、枣煎。麻、梗、芎、芷发汗散寒，以顺表气；乌、姜、陈、枳行气祛痰，以顺里气。加僵蚕清化消风，甘草协和诸药。古云气顺则风散，风邪卒中，当先治标也。）\n　　理气之剂\n　　越鞠丸\n　　（丹溪）治六般郁，气血痰火湿食因。（此六郁也。）芎苍香附兼栀曲，气畅郁舒痛闷伸。\n　　（吴鹤皋曰：香附开气郁，苍术燥湿郁，抚芎调血郁，栀子清火郁，神曲消食郁，各等分，面糊为丸。又湿郁加茯苓、白芷，火郁加青黛，痰郁加半夏、栝蒌、海石，血郁加桃仁、红花，气郁加木香、槟榔，食郁加麦芽、山楂，挟寒加吴茱萸。）又六郁汤苍芎附，甘苓橘半栀砂仁。（苍术、川芎、香附、甘草、茯苓、橘红、半夏、栀子、砂仁。此前方加味，兼治痰郁，看六郁中之重者为君，余药听加减用之。）\n　　理气之剂\n　　苏子降气\n　　（汤，《局方》）橘半归，前胡桂朴草姜根据。下虚上盛痰嗽喘，亦有加参贵合机。〔苏子、橘红、半夏、当归、前胡、浓朴（姜汁炒）各一钱，肉桂、炙甘草各五分，加姜煎。一方无桂加沉香。苏子、前胡、橘红、半夏降气行痰，气行则痰行也。数药兼能发表，加当归和血，甘草缓中。下虚上盛，故用官桂引火归元。如气虚亦有加人参、五味者。〕\n　　理气之剂\n　　四七汤\n　　（《三因》）理七情气，（七气，寒、热、喜、怒、忧、愁、恚也，亦名七气汤。）半夏浓朴茯苓苏。〔半夏（姜汁炒）五钱，浓朴（姜汁炒）三钱，茯苓四钱，紫苏二钱。郁虽由乎气，亦多挟湿挟痰，故以半夏、浓朴除痰散满，茯苓、苏叶利湿宽中。湿去痰行，郁自除矣。〕姜枣煎之舒郁结，痰涎呕痛尽能纾。又有局方名四七汤，参桂夏草妙更殊。（人参、官桂、半夏各一钱，甘草五分，加姜煎。人参补气，官桂平肝，姜制半夏祛痰，甘草和中，并不用利气之药。汤名四七者，以四味治人之七情也。）\n　　理气之剂\n　　四磨\n　　（汤，《严氏》）亦治七情侵，人参乌药及槟沉。（人参、乌药、槟榔、沉香等分。气逆，故以乌药、槟榔降而顺之。加参者，恐伤其气也。）浓磨煎服调逆气，实者枳壳易人参。去参加入木香枳（实），五磨饮子白酒斟。（白酒磨服，治暴怒卒死，名气厥。）\n　　理气之剂\n　　代赭旋复汤\n　　仲景用人参，半夏甘姜大枣临。重以镇逆咸软痞，痞硬（音硬）噫（音爱）气（赭石一两，参二两，旋复、甘草各三两，半夏半升，生姜五两，枣十二枚。旋复之咸以软坚，赭石之重以镇逆，姜、夏之辛以散虚痞，参、甘、大枣之甘以补胃弱。）\n　　理气之剂\n　　绀珠正气天香散\n　　香附干姜苏叶陈。乌药舒郁兼除痛，气行血活自经匀。（香附八钱，乌药二钱，陈皮、苏叶各一钱，干姜五分，每服五、六钱。乌、陈入气分而理气，香、苏入血分而利气，干姜兼入气血，用辛温以顺气平肝，气行则血行经自调，而痛自止矣。）\n　　理气之剂\n　　橘皮竹茹\n　　（汤）治呕呃，参甘半夏陈皮麦。赤茯再加姜枣煎，方由金匮此加辟。（《金匮》方，橘皮、竹茹各二升，人参一两，甘草五两，生姜半斤，枣三十枚，名橘皮竹茹汤，治哕逆，即呃逆也。后人加半夏、麦冬、赤茯苓、枇杷叶。呃逆由胃火上冲，肝胆之火助之，肺金之气不得下降也。竹茹、麦冬、枇杷叶清肺和胃而降气，肺金清则肝木自平矣。二陈降痰逆，赤茯苓泻心火，生姜呕家圣药，久病虚赢，故以参、甘、大枣扶其胃气。）\n　　理气之剂\n　　丁香柿蒂\n　　（汤，《严氏》）人参姜，呃逆因寒中气戕。（丁香、柿蒂各二钱，人参一钱，。）济生香蒂仅二味，（亦名丁香柿蒂汤，加姜煎。古方单用柿蒂，取其苦温降气；《济生》加丁香、生姜，取其开郁散痰；加参者，扶其胃气也。）或加竹橘用皆良。（加竹茹、橘红，各丁香柿蒂竹茹汤，治同。）\n　　理气之剂\n　　定喘\n　　（汤）白果与麻黄，款冬半夏白皮桑。苏杏黄芩兼甘草，肺寒膈热哮喘尝。〔白果三十枚（炒黄），麻黄、半夏（姜制）、款冬各三钱，桑皮（蜜炙）、苏子各二钱，杏仁、黄芩各钱半，甘草一钱，加姜煎。麻黄、杏仁、桑皮、甘草散表寒而清肺气，款冬温润，白果收涩，定喘而\n　　理血之剂\n　　十三首、附方六\n　　理血之剂\n　　四物\n　　（汤）地芍与归芎，血家百病此方通。〔当归（酒洗）、生地各三钱，白芍二钱，川芎钱半。当归辛、苦、甘温，入心脾，生血为君；生地甘寒，入心肾，滋血为臣；芍药酸寒，入肝脾，敛阴为佐；川芎辛温，通行血中之气为使。〕八珍（汤）合入四君子（参、术、苓、草，）气血双疗功独崇。（四君补气，四物补血。）再加黄 与肉桂，（加黄 助阳固卫，加肉桂引火归元。）十全大补（汤）补方雄。（补方之首。）十全除却 地草，（除生地、黄 、甘草。）加粟（米百粒）煎之名胃风（汤。张元素治风客肠胃，飧泄完谷及 牙闭。）\n　　理血之剂\n　　人参养荣\n　　（汤）即十全（汤，见前四物下。）除却川芎五味联。陈皮远志加姜枣，脾肺气血补方先。（即十全大补汤除川芎，加五味、陈皮、远志。薛立斋曰：气血两虚，变生诸症，不问脉病，但服此汤，诸症悉退。）\n　　理血之剂\n　　归脾汤\n　　（《济生》）用术参 ，归草茯神远志随。酸枣木香龙眼肉，煎加姜枣益心脾。怔忡健忘俱可却，肠风崩漏总能医。〔人参、白术（土炒）、茯神、枣仁、龙眼肉各二钱，黄 （蜜炙）\n　　钱半，当归（酒洗）、远志各一钱，木香、甘草（炙）各八分。血不归脾则妄行，参、 、草、术之甘温以补脾，志、茯、枣仁、龙眼之甘温、酸苦以补心，当归养血，木香调气，气壮则自能摄血矣。〕\n　　理血之剂\n　　养心汤\n　　用草 参，二茯芎归柏子等。夏曲远志兼桂味，再加酸枣总宁心。〔黄 （蜜炙）、茯苓、茯神、川芎、当归（酒洗）、半夏曲各一两，甘草（炙）一钱，人参、柏子仁（去油）、五味子、远志、枣仁（炒）各二钱半，每服五钱。参、 补心气，芎、归养心血，二茯、柏仁、远志泄心热而宁心神，五味、枣仁收心气散越，半夏去扰心之痰涎，甘草补土以培心子，赤桂引药以达心经。〕\n　　理血之剂\n　　当归四逆\n　　（汤，仲景）桂枝芍，细辛甘草木通着。再加大枣治阴厥，脉细阳虚由血弱。〔当归、桂枝、芍药、细辛各二两，甘草（炙）、木通各二两，枣二十五枚。成氏曰：通脉者，必先入心补血，当归之苦以助心血。心苦缓，急食酸以收之，芍药之酸，以收心气。肝苦急，急食甘以缓之，甘草、大枣、木通以缓阴血。〕内有久寒加姜茱，（素有久寒者，加吴茱萸二升、生姜半斤酒煎，名四逆加吴茱萸生姜汤，仲景。）发表温中通脉络。（桂枝散表风，吴茱萸、生姜、细辛温经，当归、木通通经复脉。）不用附子及干姜，助阳过剂阴反灼。（姜附四逆在于回阳，当归四逆在于益血复脉，故虽内有久寒，止加生姜、吴茱，不用干姜、附子，恐反灼其阴也。）\n　　理血之剂\n　　桃仁承气\n　　（汤、仲景）五般奇，甘草硝黄并桂枝。〔桃仁五十枚（去皮尖研），大黄四两，芒硝、桂枝、甘草各二两。硝、黄、甘草，调胃承气汤也。热甚搏血，故加桃仁润燥缓肝，表证未除，故加桂枝调经解表。〕热结膀胱小腹胀，如狂蓄血最相宜。（小腹胀而小便自利，知为血蓄下焦，蓄血发热故如狂。）\n　　理血之剂\n　　犀角地黄\n　　（汤）芍药丹，（生地半两，白芍一两，丹皮、犀角二钱半。每服五钱。）血升胃热火邪干。斑黄阳毒皆堪治，（犀角大寒，解胃热而清心火；芍药酸寒，和阴血而散肝火；丹皮苦寒，泻血中之伏火；生地大寒，凉血而滋水，以期平诸经之僭逆也。）或益柴芩总伐肝。（因怒致血者，加柴胡、黄芩。）\n　　理血之剂\n　　咳血方\n　　（丹溪）中诃子收，栝蒌海石山栀投。青黛蜜丸口噙化，咳嗽痰血服之瘳。〔诃子（煨取肉）、栝蒌仁（去油）、海石（去砂）、栀子（炒黑）、青黛（水飞）等分，蜜丸，嗽甚加杏仁。青黛清肝泻火，栀子清肺凉心，栝蒌润燥滑痰，海石软坚止嗽，诃子敛肺定喘。不用血药者，火退而自止也。〕\n　　理血之剂\n　　东垣秦艽白术丸\n　　归尾桃仁枳实攒。地榆泽泻皂角子，糊丸血痔便艰难。（大肠燥结故便难。）秦艽、白术、归尾（酒洗）、桃仁（研）、地榆各一两，枳实（麸炒）、泽泻、皂角子（烧存性）各五钱，糊丸。归尾、桃仁以活血，秦艽、皂子以润燥，枳实泄胃热，泽泻泻湿邪，地榆以破血止血，白术以燥湿益气。仍有苍术防风剂，润血疏风燥湿安。（本方除白术、当归、地榆，加苍术、防风、大黄、黄柏、槟榔，名秦艽苍术汤。除枳实、皂角、地榆，加防风、升麻、柴胡、陈皮、炙甘草、黄柏、大黄、红花，名秦艽除风汤，治并同。）\n　　理血之剂\n　　槐花散\n　　用治肠风，侧柏（叶）黑荆（芥）枳壳充。为末等分米饮下，宽肠凉血逐风功。（槐花、柏叶凉血，枳实宽肠，荆芥理血疏风。）\n　　理血之剂\n　　小蓟饮子藕\n　　（节）蒲黄（炒黑），木通滑石生地襄。归草（当归、甘草）黑栀（子）淡竹叶，（等分煎服。）血淋热结服之良。（小蓟、藕节散瘀血，生地凉血，蒲黄止血，木通泻心火达小肠，栀子散郁火\n　　理血之剂\n　　四生丸\n　　（《济生》）用三般叶，侧柏艾荷生地协。（侧柏叶、艾叶、荷叶、生地黄。）等分生捣如泥煎，血热妄行止衄惬。（侧柏、生地补阴凉血，荷叶散瘀血、留好血，艾叶生者性温，理气止血。）\n　　理血之剂\n　　复元活血汤\n　　（《发明》）柴胡，花粉当归山甲俱。桃仁红花大黄草，损伤瘀血酒煎祛。〔柴胡五钱，花粉、当归、穿山甲（炮）、甘草、红花各二钱，桃仁五十枚（去皮尖研），大黄一两。每服一两，酒煎。血积必干，两胁属肝胆经，故以柴胡引用为君，以当归活血脉，以甘草缓其急，以大黄、桃仁、红花、山甲、花粉破血润血。〕\n　　祛风之剂\n　　十二首、附方四\n　　祛风之剂\n　　小续命汤\n　　（《千金》）桂附芎，麻黄参芍杏防风。黄芩防己兼甘草，六经风中此方通。〔通治六经中风， 斜不遂，语言蹇涩及刚柔二痉，亦治厥阴风湿：防风一钱二分，桂枝、麻黄、人参、白芍（酒炒）、杏仁（炒研）、川芎（酒洗）、黄芩（酒洗）、防己、甘草（炙）各八分，附子四分，姜、枣煎。麻黄、杏仁，麻黄汤也，治寒；桂枝、芍药，桂枝汤也，治风。参、草补气，芎、芍养血，防风治风淫，防己治湿淫，附子治寒淫，黄芩治热淫，故为治风套剂。\n　　刘宗浓曰：此方无分经络，不辨寒热，虚实虽多，亦奚以为？昂按：此方今人罕用，然古今风方，多从此方损益为治。〕\n　　祛风之剂\n　　大秦艽汤\n　　（《机要》）羌活防，芎芷辛芩二地黄。石膏归芍芩甘术，风邪散见可通尝。〔邪散见，不拘一经者：秦艽、石膏各三两，羌活、独活、防风、川芎、白芷、黄芩（酒炒）、生地（酒洗）、熟地、当归（酒洗）、茯苓、白芍（酒炒）、甘草（炙）、白术（土炒）各一两，细辛五钱，每服一两。刘宗浓曰：秦艽汤愈风，虽有补血之药，而行经散风之剂居其大半，将何以养血而益筋骨也？昂按：治风有三法，解表、攻里、行中道也。国中必挟外感，故用风药解表散寒，而用血药、气药调里，活血降火也。〕\n　　祛风之剂\n　　三生饮\n　　（《局方》）用乌附星，三皆生用木香听。〔生南星一两，生川乌、附子（去皮）各五钱，木香二两。〕加参对半扶元气，（每服一两，加参一两。）卒中痰迷服此灵。（乌、附燥热，行经逐寒；南星辛热，除痰散风。重用人参以扶元气，少佐木香以行逆气。《医贯》曰：此行经散痰之剂，斩关擒王之将，宜急用之。凡中风口开为心绝，手撒为脾绝，眼合为肝绝，遗尿为肾绝，鼻鼾为肺绝。吐沫直视，发直头摇，面赤如朱，汗缀如珠者，皆不治。若服此汤，间有生者。）星香散亦治卒中，体肥不渴邪在经。（中脏、中腑者重，中经者稍轻。胆星八钱散痰，木香二行气，为末服。《易简》和姜煎服，名星香散。）\n　　祛风之剂\n　　地黄饮子\n　　（河间）山茱斛，麦味菖蒲远志茯。苁蓉桂附巴戟天，少入薄荷姜枣服。〔熟地、山萸肉、石斛、麦冬、五味、石菖蒲、远志、茯苓、内苁蓉、官桂、附子（炮）、巴戟等分，每服五钱，加薄荷少许煎。〕 厥风痱能治之，（凡口噤身冷为 厥，四肢不收为风痱。）火归水中水生木。（熟地以滋根本之肾，桂、附、苁蓉、巴戟以返真元之火，山茱、石斛平胃温肝，志、苓、菖蒲补心通肾，麦、味保肺以滋水源，水火既交，风火自息矣。刘河间曰：中风，非外中之风，良由将息失宜，心火暴甚，肾水虚衰，不能制之，故卒倒无知也。治宜和脏腑，通经络，便是治风。《医贯》曰：痰涎上涌者，水不归元也；面赤烦渴者，火不归元也。惟桂、附能引火归元，火归水中，则水能生木，木不生风，而风自息矣。）\n　　祛风之剂\n　　独活汤\n　　（丹溪）中羌独防，芎归辛桂参夏菖。茯神远志白薇草， （音炽纵）昏愦力能匡。\n　　〔羌活、独活、防风、当归、川芎、细辛、桂心、人参、半夏、菖蒲、茯神、远志、白薇各五钱，甘草（炙）二钱半，每服一两，加姜、枣煎。肝属风而主筋，故 为肝邪。二活、防风治风，辛、桂温经，半夏除痰，芎、归和血，血活则风散也。肝移热于心则昏愦。人参补心气，菖蒲开心窍，茯神、远志安心，白薇退热止风。风静火熄，血活神宁， 自已矣。〕\n　　祛风之剂\n　　顺风匀气\n　　（散）术乌沉，白芷天麻苏叶参。木瓜甘草青皮合， 僻偏枯口舌 。〔口眼 斜，偏枯不遂，皆由宗气不能周于一身。白术二钱，乌药钱半，天麻、人参各五分，苏叶、白芷、木瓜、青皮、甘草（炙）、沉香（磨）各三分，加姜煎。天麻、苏、芷以疏风气，乌药、青、沉以行黄柏苍术 天南星，桂枝（横行）防己（下行）及威灵（仙，上下行。）桃仁红花龙胆草（下行，）羌芷（上行）川芎（上下行）神曲停痛风湿热与痰血，上中下通用之听。〔黄柏（酒炒）、苍术（泔浸）、南星、姜、枣各二两，防己、桃仁（去皮尖）、胆草、白芷、川芎、神曲（炒）各一两，桂枝、威灵仙、红花、羌活各二钱半，面糊丸，名上中下通用痛风方，丹溪。黄柏清热，苍术燥湿，龙胆泻火，防己利水，四者治湿与热。桃仁、红花活血祛瘀，川芎血中气药，南星散风燥痰，四者活血与痰。羌活去百节风，白芷去头面风，桂枝、威灵仙去臂胫风，四者所以治风。和神曲者，消中焦陈积之气也。症不兼者，加减为治。\n　　祛风之剂\n　　独活寄生\n　　（汤，《千金》）艽防辛，芎归地芍桂苓均。杜仲牛膝人参草，冷风顽痹屈能伸。〔独活、桑寄生、秦艽、防风、细辛、川芎（酒洗）、当归（酒洗）、白芍（酒炒）、熟地、桂心、茯苓、杜仲（姜汁炒断丝）、牛膝、人参、甘草等分，每服四钱。〕若去寄生加 续（黄 、续断，）汤名三痹古方珍。（名三痹汤，治风寒湿三痹。喻嘉言曰：此方用参 四物一派补药，加艽、\n　　祛风之剂\n　　消风散\n　　内羌防荆芎朴参苓陈草并。僵蚕蝉蜕藿香入，为末茶调或酒行，头痛目昏项背急，顽麻瘾疹服之清。〔人参、防风、茯苓、川芎、羌活、僵蚕（炒）、蝉蜕、藿香各二两，荆芥、浓朴（姜汁炒）、陈皮（去白）、甘草（炙）各五钱，每服三钱，茶调下。疮癣，酒下。羌、防、芎、荆，治头目、项背之风，僵蚕、蝉蜕散咽膈、皮肤之风，藿香、浓朴去恶散满，参、苓\n　　祛风之剂\n　　川芎茶调散\n　　（《局方》）荆防，辛芷薄荷甘草羌。目昏鼻塞风攻上，正偏头痛悉平康。〔薄荷三钱，川芎、荆芥各四钱，防风钱半，细辛一钱，羌活、白芷、甘草（炙）各二钱，为末，每服三钱，茶调下。羌活治太阳头痛，白芷治阳明头痛，川芎治少阳、厥阴头痛，细辛治少阴头痛，防风为风药卒徒，薄荷、荆芥散风热而清头目。以风热攻上，宜于升散，巅顶之上，惟风药可到也。加甘草以缓中，加茶调以清降。〕方内若加僵蚕菊，菊花茶调（散）用亦臧。（菊花清头目，僵蚕去风疾。）\n　　祛风之剂\n　　青空\n　　（膏，东垣）芎草柴芩连，羌防升之入顶巅。为末茶调如膏服，正偏头痛一时蠲。〔川芎五钱，甘草（炙）一两半，柴胡七钱，黄芩（酒炒）、黄连（酒炒）、羌活、防风各一两，每服三钱。风寒湿热上攻头脑则痛，头两傍属少阳，偏头痛属少阳相火。芩、连苦寒，以羌、防、芎、\n　　祛风之剂\n　　人参荆芥散\n　　（《妇宝》）熟地，防风柴枳芎归比。酸枣鳖羚桂术甘，血风劳作风虚治。〔血脉空疏，乃感风邪，寒热盗汗，久渐成劳。人参、荆芥、熟地、柴胡、枳壳、枣仁（炒）、鳖甲（童便炙）、羚羊角、白术各五分，防风、甘草（炙）、当归、川芎、桂心各三分，加姜煎。荆、防、柴、羚以疏风平木，地黄、鳖甲以退热滋阴，草、枣仁以敛汗补虚，除烦进食。〕\n　　祛寒之剂\n　　十二首、附方二\n　　祛寒之剂\n　　理中汤\n　　（仲景）主理中乡，（仲景曰：理中者，理中焦。）甘草人参术黑姜。〔白术（土炒）二两，人参、干姜（炮）、甘草（炙）各一两，治太阴厥逆，自利不渴，脉沉无力。人参补气益脾为君，白术健脾燥湿为臣，甘草和中补土为佐，干姜温胃散寒为使。〕呕利腹痛阴寒盛，或加附子总扶阳。（名附子理中汤。）\n　　祛寒之剂\n　　真武汤\n　　（仲景）壮肾中阳，茯苓术芍附生姜。〔附子一枚（炮），白术二两（炒），茯苓、白芍（炒）、生姜各三两。〕少阴腹痛有水气，悸眩 惕保安康。（中有水气，故心悸头眩；汗多亡阳，故肉 筋惕。 ，音纯，动貌。苓、术补土利水，以疗悸眩；姜、附回阳益火，以逐虚寒；芍药敛阴和营，以止腹痛。真武，北方水神。肾中火足，水乃归元。此方补肾之阳，壮火而利水，故名。）\n　　祛寒之剂\n　　四逆汤\n　　（仲景）中姜附草，三阴厥逆太阳沉。〔附子一枚（生用），干姜一两，炙甘草二两，冷服。专治三阴厥逆，太阳初证脉沉亦用之。〕或益姜葱参芍桔，通阳复脉力能任（音仁。面赤，格阳于上也，加葱白通阳；腹痛，加芍药和阴；咽痛，加桔梗利咽；利止、脉不出，加人参补气复脉；呕吐，加生姜以散逆气。）\n　　祛寒之剂\n　　白通加\n　　（人）尿猪胆汁（汤，仲景。尿，音鸟，去声，小便也。俗读平声，非。）干姜附子兼葱白。〔附子一枚（炮），干姜一两，葱白四茎，此白通汤也。葱白以通阳气，姜、附子以散阴寒，加人尿五合，猪胆汁一合。〕热因寒用妙义深，阴盛格阳厥无脉。（阴寒内甚，格阳于外，故厥逆无脉，纯与热药，则寒气格拒，不得达入，故于热剂中加尿汁，寒药以为引用，使得入阴而回阳也。）\n　　祛寒之剂\n　　吴茱萸汤\n　　（仲景）人参枣，重用生姜温胃好。阳明寒呕（太阳热呕忌用）少阴（下）利，厥阴头痛皆能保。〔吴茱萸一升（炮），人参三两，生姜六两，枣十二枚。姜、茱、参、枣，补土散寒。茱萸辛热，能入厥阴，治肝气上逆而致呕利腹痛。〕\n　　祛寒之剂\n　　益元\n　　（汤，《活人》）艾附与干姜，麦味知连参草将。（附子（炮）、艾叶、干姜、麦冬、五味子、知母、黄连、人参、甘草。艾叶辛热，能回阳。）姜枣葱煎入童便（冷服），内寒外热名戴阳（症。此阴盛格阳之症，面赤身热，不烦而躁，但饮水不入口，为外热内寒。此汤姜、附加知、连，与白通加人尿、猪胆汁同意，乃热因寒药为引用也。按：内热曰烦，为有根之火；外热曰躁，为无根之火。故但躁不烦及先躁后烦，皆不治。）\n　　祛寒之剂\n　　回阳救急\n　　（汤，节庵曰即四逆汤）用六君，桂附干姜五味群。（附子炮、干姜、肉桂、人分，白术、茯苓各一钱，半夏、陈皮各七分，甘草三分，五味九粒，姜煎。）加麝三厘或（猪）胆汁，三阴寒厥见重勋。（姜、桂、附子祛其阴。六君温补，助其阳气。五味、人参以生其脉。加麝香者，以通其窍；加胆汁者，热因寒用也。）\n　　祛寒之剂\n　　四神\n　　（丸）故纸吴茱萸，肉蔻五味四般须。大枣百枚姜八两，〔破故纸四两（酒浸炒），吴茱萸一两（盐水炒），肉豆蔻三两（面里煨），五味子三两（炒），枣、生姜同煎。枣烂即去姜，捣枣肉为丸，临卧盐汤下，若早服，不能敌一夜之阴寒也。〕五更肾泻火衰扶。（由肾命火衰，不能生脾土，故五更将交阳分，阳虚不能键闭而泄泻，不可专责脾胃也。破故纸辛温，能补相火，以通君火，火盛乃能生土；肉豆蔻暖胃固阳，吴茱萸燥脾去湿，五味子补肾涩精，生姜温中，大枣补土，亦以防水也。）\n　　祛寒之剂\n　　浓朴温中\n　　（汤）陈草苓，干姜草蔻木香停。煎服加姜治腹痛，虚寒胀满用皆灵。（浓朴、陈皮各一钱，甘草、茯苓、草豆蔻、木香各五分，干姜三分，加姜煎。干姜、草蔻辛热以散其寒，陈皮、广木香辛温以调其气，浓朴辛温以散满，茯苓甘淡以利湿，甘草甘平以和中。寒散气行，痛胀自已矣。）\n　　祛寒之剂\n　　寒疝痛用导气汤\n　　川楝茴香与木香。吴茱煎以长流水，散寒通气利小肠。（疝，亦名小肠气。川楝四钱，木香二钱，茴香二钱，吴茱萸一钱，汤泡同煎。川楝苦寒，入肝舒筋，能导小肠、膀胱之热从小水下行，为治疝君药。茴香暖胃散寒，吴茱萸温肝燥湿，木香行三焦通气。）\n　　祛寒之剂\n　　疝气方\n　　（丹溪）用荔枝核，栀子山楂枳壳益。（荔枝双结，状类睾丸，能入肚肾，辟寒散滞。\n　　栀子泻火利水，枳壳行气破症，山楂散瘀 积。睾，音皋，肾子也。）再入吴茱暖厥阴，（疝乃厥阴肝邪，非肾病，以肝脉络阴器也。）长流水煎疝痛释。（等分，或为末，空心服。）\n　　祛寒之剂\n　　橘核丸\n　　（《济生》）中川楝桂，朴实延胡藻带昆。桃仁二木酒糊合， 疝痛顽盐酒吞。（橘核、川酒糊为丸，盐汤或酒下。橘核、木香能入厥阴气分而行气，桃仁、延胡索能入厥阴气分而活血，川楝、木通能导小肠、膀胱之湿，官桂能祛肝肾之寒，枳实、浓朴行结水而破宿血，昆布、藻、带寒行水而咸软坚。）\n　　祛暑之剂\n　　五首、附方十\n　　祛暑之剂\n　　三物香薷\n　　（饮，《局方》）豆朴先，（香薷辛温香散，能入脾肺，发越阳气以散蒸热。浓朴除湿散满，扁豆清暑和脾。）若云热盛加黄连。（名黄连香薷饮，《活人》治中暑热盛，口渴心烦。）\n　　或加苓草（茯苓、甘草）名五物（香薷饮），利湿祛暑木瓜宣。（加木瓜名六味香薷饮，木瓜、茯苓治湿盛。）再加参 与除术，兼治内伤十味全。（六味加参、 、陈皮、白术，名十味香薷饮。）二香（散）合入香苏饮，（五味香薷饮合香苏饮。香附、紫苏、陈皮、苍术，名二香散，治外感内伤，身寒腹胀。）仍有藿薷（汤）香葛（汤）传。（三物香薷饮合藿香正气散，名藿薷汤，治伏暑吐泻；三物香薷饮加葛根，名香葛汤，治暑月伤风。）\n　　祛暑之剂\n　　清暑益气\n　　（汤，东垣）参草 ，当归香味青陈皮。曲柏葛根苍白术，升麻泽泻枣姜随。〔人参、黄、甘草（炙）、当归（酒洗）、麦冬、五味、青皮（麸炒）、陈皮（留白）、神曲（炒）、黄柏（酒炒）、葛根、苍术、白术（土炒）、升麻、泽泻，加姜、枣煎。热伤气，参、 补气敛汗；湿伤脾，二术燥湿强脾。火旺则金病而水衰，故用麦、味保肺生津，黄柏泻火滋水，青皮理气而破滞，当归养血而和阴，曲、草和中而消食，升、葛以升清，泽泻以降浊也。〕\n　　祛暑之剂\n　　缩脾饮\n　　用清暑气，砂仁草果乌梅暨。甘草葛根扁豆加，吐泻烦渴温脾胃。（砂仁、草果（乌梅、甘草（炙）各四两，扁豆（炒研）、葛根各二两。暑必兼温，而湿属脾土，故用砂仁、草果利气温脾，扁豆解暑渗湿，葛根升阳生津，甘草补土和中，乌梅清热止渴。）古人治暑多用温，（如香薷饮、大顺散之类。）暑为阴证此所谓。（洁古曰：中热为阳证，为有余；中暑为阴证，为不足。经曰：脉虚身热，得之伤暑。）大顺（散）杏仁姜桂甘，散寒燥湿斯为贵。（先将甘草、白砂仁，次入干姜、杏仁（炒），合肉桂为末，每服一钱。吴鹤皋曰：此非治暑，乃治暑月饮冷受伤之脾胃耳。）\n　　祛暑之剂\n　　生脉散\n　　麦味与人参，保肺清心治暑淫。气少汗多兼口渴，病危脉绝急煎斟。（人参五分八分，五味子九粒。人参大补肺气，麦冬甘寒润肺，五味酸收敛肺，并能泻火生津。盖心主脉，肺朝百脉，补肺清心，则气充而脉复。将死脉绝者服之，能令复生。夏月火旺烁金，尤宜服之。）\n　　祛暑之剂\n　　六一（散）\n　　滑石同甘草，解肌行水兼清燥。统治表里及三焦，热渴暑烦泻痢保。（滑石六两，甘草一两，灯心汤下，亦有用姜汤下者。滑石气轻解肌，质重泻火，滑能入窍，淡能行水，故能通治上下表里之湿热，甘草泻火和中，又以缓滑石之寒滑也。）益元（散）碧玉与鸡苏（散），砂黛薄荷加之好。（前方加辰砂，名益元散，取其清心；加青黛，名碧玉散，取其凉肝；加薄荷，\n　　利湿之剂\n　　十三首、附方八\n　　利湿之剂\n　　五苓散\n　　（仲景）治太阳府，（太阳经热传入膀胱府者用之。）白术泽泻猪茯苓。膀胱化气添官桂，利便消暑烦渴清。〔猪苓、茯苓、白术（炒）各十八铢，泽泻一两六铢，桂枝半两，每服三钱。二苓甘淡利水，泽泻甘咸泻水，能入肺肾而通膀胱，导水以泄火邪。加白术者，补土所以制水；加官桂者，气化乃能出也。经曰：膀胱者，州都之官，津液藏焉，气化则能出矣。〕除桂名为四苓散，无寒但渴服之灵。（湿胜则气不得施化，故渴，利其湿则渴自止。）猪苓汤（仲景）除桂与术，加入阿胶滑石停。（猪苓、茯苓、泽泻、阿胶、滑石各一两。滑石泻火解肌，最能行水。吴鹤皋曰：以诸药过燥，故加阿胶以存津液。）此为利湿兼泻热，黄胆（小）\n　　便闭渴呕宁。（五苓治湿胜，猪苓兼热胜。）\n　　利湿之剂\n　　小半夏加茯苓汤\n　　（仲景）。行水散痞有生姜。（半夏一升，茯苓三钱，生姜半斤。除茯苓，名小半夏汤。）\n　　加桂除夏治悸厥，茯苓甘草汤名彰。（加桂枝、甘草，除半夏，名茯苓甘草汤，仲景治伤寒水气乘心，厥而心下悸者，先治其水，却治其厥。火因水而下行，则眩悸止而痞满治矣。）\n　　利湿之剂\n　　肾着汤\n　　（《金匮》）内用干姜，茯苓甘草白术襄。伤湿身痛与腰冷，亦名甘姜苓术汤。〔、茯苓各四两，炙甘草、白术（炒）各二两。数药行水补土，此湿邪在经而未入腑脏者。〕黄防己（汤，《金匮》）除姜茯，术甘姜枣共煎尝。此治风水与诸湿，身重汗出服之良。〔黄、防己各一两，白术七钱半，甘草（炙）五钱，加姜、枣煎。防己大辛苦寒，通行十二经，开窍行水；黄 生用达表，白术燥湿强脾，并能止汗。加甘草者，益土所以制水，又以缓防己之峻急也。〕\n　　利湿之剂\n　　舟车\n　　（丸，河间）牵牛及大黄，遂戟芫花又木香。青皮橘皮加轻粉，燥实阳水却相当。〔口渴面赤，气粗便秘而肿胀者，为阳水。黑牵牛四两炒，大黄二两（酒浸），甘遂（面里煨）、芫花（醋炒）、大戟（面里煨）、青皮（炒）、橘红各一两，木香五钱，轻粉一钱，水丸。牵牛、大黄、遂、戟、芫花行水厉药，木香、青、陈以行气，少加轻粉以透经络，然非实证不可轻投。〕\n　　利湿之剂\n　　疏凿\n　　（饮）槟榔及商陆，苓皮大腹同椒目。赤豆艽羌泻木通，煎益姜皮阳水服。（槟榔、商陆、茯苓皮、大腹皮、椒目、赤小豆、秦艽、羌活、泽泻、木通等分，加姜皮、枣煎。艽、羌散湿上升，通、泻泄湿下降，苓、腹、姜皮行水于皮肤，椒、豆、商、槟攻水于腹里，亦上下表里分消之意。）\n　　利湿之剂\n　　实脾\n　　（汤，《严氏》）苓术与木瓜，甘草木香大腹加。草蔻附姜兼浓朴，虚寒阴水效堪夸。〔便利不渴而肿胀者，为阴水。茯苓、白术（土炒）、木瓜、甘草、木香、大腹皮、草豆蔻（煨）、附子（炒）、黑姜、浓朴（炒），加姜、枣煎。脾虚，补以苓、术、甘草；脾寒，温以蔻、附、黑姜；脾湿，利以茯苓、大腹；脾滞，导以浓朴，木香。又土之不足，由于木之有余，木瓜、木香皆能平肝泻木，使木不克土而脾和，则土能制水而脾实矣。经曰：湿胜则地泥，实土正所以制水也。〕\n　　利湿之剂\n　　五皮饮\n　　（澹寮）用五般皮，陈茯姜桑大腹奇。（陈皮、茯苓皮、姜皮、桑白皮、大腹皮）。或用五加（皮）易桑白，脾虚肤胀此方司。（脾不能为胃行其津液，故水肿。半身以上，宜汗；半身以下，宜利小便。此为于泻水之中，仍寓调补之意。皆用皮者，水溢皮肤，以皮行皮也。）\n　　利湿之剂\n　　羌活胜湿\n　　（汤，《局方》）羌独芎，甘蔓 木与防风。湿气在表头腰重（痛），发汗升阳有异功。\n　　风能胜湿升能降，（气升则水自降。）不与行水渗湿同。〔湿气在表宜汗。又风能胜湿，故用风药上升，使湿从汗散。羌活、独活各一钱，川芎、甘草（炙）、 本、防风各五分，蔓荆子三分。如有寒湿，加附子、防己。〕若除独活芎蔓草，除湿（汤）升麻苍术充。（除独活、川芎、蔓荆子、甘草，加升麻、苍术，名羌活除湿汤，治风湿身痛。）\n　　利湿之剂\n　　大橘皮汤\n　　治湿热，五苓六一二方缀。陈皮木香槟榔增，能消水肿及泄泻。（用五苓散，赤茯苓一钱，猪苓、泽泻、白术、桂各五分；用六一散，滑石六钱，甘草一钱，加陈皮钱半，木香、槟榔各三分，每服五钱，加姜煎。小水并入大肠，致小肠不利而大便泄泻。二散皆行水泄热之药，加槟榔峻下，陈皮、木香理气，以利小便而实大便也。水肿亦湿热为病，故皆治之。）\n　　利湿之剂\n　　茵陈蒿汤\n　　（仲景）治疸黄，阴阳寒热细推详。阳黄大黄栀子入，〔瘀热在里，口渴便闭，色，脉沉实者，为阳黄。茵陈六两，大黄二两（酒浸），栀子十四枚。茵陈发汗利水，能泄太栀子十五枚，甘草一两。按：阳黄胃有瘀热者，宜下之。如发热者，则势外出而不内入，不必汗下，惟用栀子、黄柏，清热利湿以和解之。若小便利，色白无热者，仲景作虚劳治，用小建中汤。）\n　　利湿之剂\n　　八正\n　　（散，《局方》）木通与车前， 蓄大黄滑石研。（甘）草梢瞿麦兼栀子，煎加灯草痛淋蠲。（一方有木香，治湿热下注，口渴咽干，淋痛尿血，小腹急满。木通、灯草、瞿麦降心火人小肠，车前清肝火入膀胱，栀子泻三焦郁火，大黄、滑石泻火利水之捷药， 蓄利便涌淋，草梢入茎止痛。虽治下焦，而不专于治下，必三焦通利，水乃下行也。）\n　　利湿之剂\n　　萆厘清\n　　（饮）石菖蒲，（甘）草梢乌药益智俱。（甘草梢减半，余药等分。）或益茯苓盐煎服，（加盐少许。）通心固肾浊精驱（遗精、白浊。萆 能泄厥阴、阳明湿热，去浊厘清；乌药疏逆气而止便数，益智固脾胃而开郁结，石菖蒲开九窍而通心，甘草梢达肾茎而止痛，使温热去而心肾通，则气化行而淋浊止矣。此以疏泄为禁止者也。）\n　　利湿之剂\n　　缩泉（丸）\n　　益智同乌药（等分），山药（为）糊丸便数需。（盐汤下，治便数遗尿。）\n　　利湿之剂\n　　当归拈痛\n　　（汤，东垣）羌防升，猪泽茵陈芩葛朋。二术苦参知母草，疮疡湿热服皆应。〔洗）、羌活、防风、升麻、猪苓、泽泻、茵陈、黄芩（酒炒）、葛根、苍术、白术（土炒）、苦参、知母（并酒炒）、甘草（炙）。羌活通关节，防风散留湿，苦参、黄芩、茵陈、知母以泄热，当归以和气血，升、葛助阳而升清，芩、泻泄湿而降浊，参、甘、二术补正固中，使苦寒不伤胃，疏泄不损气也。刘宗浓曰：此方东垣本治湿热香港脚，后人用治诸疮，甚验。〕\n　　润燥之剂\n　　十三首、附方二\n　　润燥之剂\n　　炙甘草汤\n　　（仲景）参姜桂，麦冬生地大麻仁。大枣阿胶加酒服，虚劳肺痿效如神。〔甘草（炙）、人参、生姜、桂枝各三两，阿胶、蛤粉各二两，生地一斤，麦冬、麻仁（研）各半升，枣十二枚，水、酒各半煎。仲景治伤寒脉结代，心动悸及肺痿唾多。《千金翼》用治虚劳，《宝鉴》用治呃逆，《外台》用治肺痿。参、草、麦冬益气复脉，阿胶、生地补血养阴，枣、麻润滑以缓脾胃，姜、桂辛温以散余邪。）\n　　润燥之剂\n　　滋燥养荣\n　　（汤）两地黄，芩甘归芍及艽防。（艽、防，风药润剂。）爪枯肤燥兼风秘，火烁金伤血液亡。（当归（酒洗）二钱，生地、熟地、白芍（炒）、黄芩（酒炒）、秦艽各一钱，防风、甘草各五分。）\n　　润燥之剂\n　　活血润燥生津饮\n　　（丹溪。）二冬熟地兼栝蒌。桃仁红花及归芍，利秘通幽善泽枯。（熟地、当归、白芍各一钱，天冬、麦冬、栝蒌各八分，桃仁（研）、红花各五分。）\n　　润燥之剂\n　　韭汁牛乳\n　　（饮，丹溪）反胃滋，养荣散瘀润肠奇。五汁安中（饮，张任候）姜梨藉，三般加入用随宜。（牛乳半斤，韭菜汁少许，滚汤顿服，名韭汁牛乳饮。牛乳六分，韭汁、姜汁、藕汁、梨汁各一分，和服名五汁安中饮，并治噎膈。反胃噎膈，由火盛血枯，或有瘀血寒痰，阻滞胃口，故食入反出也。牛乳润燥养血为君，韭汁、藕汁消瘀益胃，姜汁温胃散痰，梨汁消痰降火，要审症用之。或加陈酒亦佳，以酒乃米成也。）\n　　润燥之剂\n　　润肠丸\n　　（东垣）用归尾羌，桃仁麻仁及大黄。（归尾、羌活、大黄各五钱，桃仁、火麻仁各一两，蜜丸。归尾、桃仁润燥活血，羌活散火搜风，大黄破结通幽，麻仁润肠利窍。）或加艽防皂角子，（风湿加秦艽、防风、皂角子烧存性研。皂子得湿则滑，善通便秘，艽、防治风。）\n　　风秘血秘善通肠。（治风燥、血燥致大汤秘。）\n　　润燥之剂\n　　通幽汤\n　　（东垣）中二地俱，桃仁红花归草濡。升麻升清以降浊，（清阳不升，则浊阴不降，故大便不通。生地、熟地各五分，桃仁（研）、红花、当归身、甘草（炙）、升麻各一钱。）噎塞便闭此方需。有加麻仁大黄者，当归润肠汤名殊。（以上药皆润燥通肠。）\n　　润燥之剂\n　　搜风顺气\n　　（丸）大黄蒸，郁李麻仁山药增。防独车前及槟枳，菟丝牛膝山茱仍。中风风秘及气秘，肠风下血总堪凭。（大黄（九蒸九晒）五两，火麻仁、郁李仁（去皮）、山药（酒蒸）、车前子、牛膝（酒蒸）、山茱肉三两，菟丝子（酒浸）、防风、独活、槟榔、枳壳（麸炒）各一两，蜜丸。防、独润肾搜风，槟、枳顺气破滞、大黄经蒸晒则性稍和缓，同二仁滑利，润燥通幽。牛膝、车前下行利水，加山药、山茱、菟丝固本益阳，不使过于攻散也。）\n　　润燥之剂\n　　消渴方\n　　（丹溪）中花粉连，藕汁（生）地汁牛乳研。（粉、连研为末，诸汁调研。）或加姜（汁）\n　　蜜为膏服，泻火生津益血痊。（黄连泻心火，生地滋肾水，藕汁益胃，花粉生津，牛乳润燥益血。）\n　　润燥之剂\n　　白茯苓丸\n　　治肾消，花粉黄连萆 调。二参熟地覆盆子，石斛蛇床 要。（ ，音皮鸱，即鸡肫皮也。茯苓、花粉、黄连、萆 、人参、玄参、熟地黄、覆盆子各一两，石斛、蛇床子各七钱半，鸡肫皮三十具（微炒），蜜丸，磁石汤下。黄连降心火，石斛平胃热，熟地、玄参生肾水，覆盆、蛇床固肾精，人参补气，花粉生津，茯苓交心肾，萆 利湿热， 治膈消，磁石色黑属水，假之入肾也。）\n　　润燥之剂\n　　猪肾荠汤\n　　（《千金》）参茯神，知芩葛草石膏因。磁石天花同黑豆，强中消渴此方珍。〔下消之证，茎长兴盛，不交精出，名强中。缘服邪术热药而毒盛也。猪肾一具，大豆一升，荠 、人参、石膏各三两，磁石（绵裹）、茯神、知母、黄芩、葛根、甘草、花粉各二两，先煮豆、肾，去滓，以药分三服。知、苓、石膏以泻邪火，人参、甘草以固正气，葛根、花粉以生津，荠、黑豆最能解毒，磁石、猪肾引之人肾也。〕\n　　润燥之剂\n　　地黄饮子\n　　（《易简》）参 草，二地二冬枇斛参。泽泻枳实疏二腑，躁烦消渴血枯含。〔人参、黄、甘草（炙）、天冬、麦冬、生地、枇杷叶（蜜炙）、石斛、泽泻、枳实（麸炒），每服二钱。参、 、甘草以补其气，气能生水，二地、二冬以润其燥，润能益血，石斛平胃，枇杷补气，泽泻泻膀胱之火，枳实宣大肠之滞，使二腑清，则心、肺二脏之气得以下降，而渴自止。〕\n　　润燥之剂\n　　酥蜜膏酒\n　　（《千金》）用饴糖，二汁百部及生姜。杏枣补脾兼润肺，声嘶气惫酒温尝。〔酥蜜、饴糖、枣肉、杏仁（细研）、百部汁、生姜汁，共煎一炊，久如膏，温酒细细咽服之。〕\n　　润燥之剂\n　　清燥\n　　（汤，东垣）二术与黄 ，参苓连柏草陈皮。猪泽升柴五味曲，麦冬归地痿方推。〔治肺金受湿热之邪，痿 喘促，口干便赤，黄 钱半，苍术（炒）一钱，白术（炒）、陈皮、泽泻各五分，人参、茯苓、升麻各三分，当归（酒洗）、生地、麦冬、甘草（炙）、神曲炒、黄柏（酒炒）、猪苓各二分，柴胡、黄连（炒）各一分，五味九粒，煎。肺属辛金，主气；大肠为庚金，主津。燥金受湿热之邪，则寒水生化源绝，而痿 喘渴诸症作矣。参、 、苓、术、陈、草补土以生金，麦、味保金而生水，连、柏、归、地泻火滋阴，猪、泽、升、柴升清降浊，则燥金整肃，水出高原，而诸病平矣。此方不尽润药，因有清燥二字，故附记于此。\n　　然东垣所云清燥\n　　泻火之剂\n　　二十七首、附方九\n　　泻火之剂\n　　黄连解毒汤\n　　（毒即火热也）四味，黄柏黄芩栀子备，（等分）。躁狂大热呕不眠，吐（血）衄（鼻血，音女六切）斑黄均可使。若云三黄石膏汤，再加麻黄及淡鼓。（见表里。）此为伤寒温毒盛，三焦表里相兼治。栀子金花（丸）加大黄，（黄芩、黄柏、黄连、栀子、大黄，水丸。）润肠泻热真堪倚\n　　泻火之剂\n　　附子泻心\n　　（汤，仲景）用三黄，寒加热药以维阳。〔芩、连各一两，大黄二两，附子一枚（炮）。\n　　恐三黄重损其阳，故加附子。〕痞乃热邪寒药治，（伤寒痞满，从外之内，满在胸而不在胃，多属热邪，故宜苦泻。若杂病之痞，从内之外，又宜辛热。）恶寒加附始相当。（经曰：心下痞，按之软，关脉浮者，大黄黄连泻心汤。心下痞而复恶寒，汗出者，附子泻心肠。）大黄附子汤同意，温药下之妙异常。〔大黄、细辛各二两，附子一枚（炮）。《金匮》阳中有阴，宜以温药下其寒，后人罕识其旨。〕\n　　泻火之剂\n　　半夏泻心\n　　（汤，仲景）黄连芩，干姜甘草与人参。大枣和之治虚痞，法在降阳而和阴。〔半夏半斤，黄连一两，干姜、黄芩、甘草（炙）、人参各三两，大枣十二枚。治伤寒下之早，胸满而不痛者，为痞；身寒而呕，饮食不下，非柴胡证。凡用泻心者，多属误下，非传经热邪。\n　　否而不泰为痞。泻心者，必交阴阳；通上下者，必和其中，故用参、甘、大枣。〕\n　　泻火之剂\n　　白虎汤\n　　（仲景）用石膏偎，知母甘草梗米陪。（石膏一斤，知母六两，甘草二两，粳米六合。）\n　　亦有加入人参者，（名人参白虎汤。）燥烦热渴舌生苔。（白虎，西方金神。此方清肺金而泻胃火，故名。然必实热方可用之，或有血虚身热，脾虚发热及阴盛格阳，类白虎汤证，误投之，不可救也。按：白虎证脉洪大有力，类白虎证脉大而虚，以此为辨。又当观小便，赤者为内热，白者为内寒也。）\n　　泻火之剂\n　　竹叶石膏汤\n　　（仲景）人参，麦冬半夏竹叶灵。甘草生姜兼粳米，暑烦热渴脉虚寻。〔竹叶膏一斤，人参三两，甘草（炙）三两，麦冬一升，半夏、粳米各半升，加姜煎。治伤寒解后，呕渴少气。竹叶、石膏之辛寒，以散余热；参、甘、粳、麦之甘平，以补虚生津；姜、夏之辛温，以豁痰止呕。〕\n　　泻火之剂\n　　升阳散火\n　　（汤，东垣）葛升柴，羌独防风参芍侪。生炙二草加姜枣，阳经火郁发之佳。（柴胡八钱，葛根、升麻、羌活、独活、白芍各五钱，防风二钱半，炙甘草三钱，生甘草二钱，每服五钱，加姜、枣煎。火发多在肝、胆之经，以木盛能生火，而二经俱挟相火，故以柴胡散肝为君，羌、防以发太阳之火，升、葛以发阳明之火，独活以发少阴之火。加参、甘者，补土以泄火；加白芍者，泻肝而益脾，但令散中有补，发中有收也。）\n　　泻火之剂\n　　凉膈\n　　（散，《局方》）硝黄栀子翘，黄芩甘草薄荷饶。竹叶蜜煎疗膈上，（叶生竹上，故治上焦。）中焦燥实服之消。〔连翘四两，大黄（酒浸）、芒硝、甘草各二两，栀子（炒黑）、黄芩（酒炒）、薄荷各一两，为末，每服三钱，加竹叶、生蜜煎。连翘、薄荷、竹叶以升散于上，栀、芩、硝、黄以推泻于下，使上升下行，而膈自清矣。加甘草、生蜜者，病在膈，甘以缓之也。潘\n　　泻火之剂\n　　清心莲子\n　　（饮，《局方》）石莲参，地骨柴胡赤茯苓。 草麦冬车前子，躁烦消渴及崩淋。〔石莲、人参、柴胡、赤茯苓、黄各三钱，黄芩（酒炒）、地骨皮、麦冬、车前子、甘草（炙）\n　　各二钱。参、 、甘草补虚泻火，柴胡、地骨退热平肝，黄芩、麦冬清热上焦，赤茯苓、车前利湿下部，中以石莲交其心肾也。〕\n　　泻火之剂\n　　甘露\n　　（饮，《局方》）两地（生、熟）与茵陈，芩枳枇杷（黄芩、枳壳、枇杷叶）石斛伦。甘草二冬（天、麦）平胃热，（等分煎。二地、甘、石斛平脾胃之虚热，清而兼补，黄芩、茵陈折热而去温，枳壳、枇杷抑气而降火。）桂苓犀角可加均。（加茯苓、肉桂，名桂苓甘露饮。\n　　《本事方》加犀\n　　泻火之剂\n　　清胃散\n　　（东垣）用升麻（黄）连，当归生地牡丹全。或益石膏平胃热，口疮吐衄（口血、鼻血）及牙宣（齿龈出血。黄连泻心火，亦泻脾火，丹皮、生地平血热，当归引血归经，石膏泻阴阳之火，升麻升阳明之清。昂按：古人治血，多用升麻。然上升之药，终不可轻施。）\n　　泻火之剂\n　　泻黄\n　　（散）甘草与防风，石膏栀子藿香充。炒香蜜酒调和服，胃热口疮并见功。（防风四两，甘草二两，黑栀子一两，藿香七钱，石膏五钱。栀子、石膏泻肺胃之火，藿香辟恶调中，甘草补脾泻热。重用防风者，能发脾中伏火，又能于土中泻木也。）\n　　泻火之剂\n　　钱乙泻黄\n　　（散）升防芷，芩夏石斛同甘枳。亦治胃热及口疮，火郁发之斯为美。（升麻、防风、白枳壳以清热开郁，石斛、甘草以平胃调中。）\n　　泻火之剂\n　　泻白\n　　（散，钱乙）桑皮地骨皮，甘草粳米四般宜。（桑白皮、地骨皮各一钱，甘草五分，粳米百粒。桑皮泻肺火，地骨退虚热，甘草补土生金，粳米和中清肺。李时珍曰：此泻肺诸方之准绳也。）参茯知芩皆可入，（人参、茯苓、知母、黄芩听加，名加减泻白散。）肺炎喘嗽此方施。\n　　泻火之剂\n　　泻青丸\n　　（钱乙）用龙胆栀，下行泻火大黄资。羌防升上芎归润，火郁肝经用此宜。〔龙胆草、黑栀子、大黄（酒蒸）、羌活、防风、川芎、当归（酒洗），等分，蜜丸，竹叶汤下。羌、防引火上升，栀、胆、大黄抑火下降，芎、归养肝血而润肝燥。〕\n　　泻火之剂\n　　龙胆泻肝\n　　（汤，《局方》）栀芩柴，生地车前泽泻偕。木通甘草当归合，肝经湿热力能排。〔胆草（酒炒）、栀子（酒炒）、黄芩（酒炒）、生地（酒炒）、柴胡、车前子、泽泻、木通、当归、甘草（生用）。龙胆、柴胡泻肝胆之火，黄芩、栀子泻肺与三焦之热，以佐之泽泻泻肾经之湿，木通、车前泻小肠、膀胱之湿；以佐之归、地养血补肝，甘草缓中益胃，不令苦寒过于泄下也。〕\n　　泻火之剂\n　　当归龙荟\n　　（丸，《宣明》）用四黄，龙胆芦荟木麝香。黑栀青黛姜汤下，一切肝火尽能攘。〔当归大黄（酒浸）、青黛（水飞）、芦荟各五钱，木香二钱，麝香五分，蜜丸，姜汤下。肝木为生火之原，诸经之火因之而起，故以青黛、龙胆入木经而直折之，而以大黄、芩、连、栀、柏通平上下三焦之火也。芦荟大苦、大寒，气臊入肝。恐诸药过于寒泻，故用当归养血补肝，用姜汤辛温为引。加木、麝者，取其行气通窍也。然非实热，不可轻投。〕\n　　泻火之剂\n　　左金\n　　（丸，丹溪）茱莲六一丸，肝经火郁吐吞酸。〔黄连六两（姜汁炒），吴茱萸一两（盐汤泡），亦名茱连丸。肝实则作痛，或呕酸。心为肝子，故用黄连泻心清火，使火不克金，则金能制木而肝平矣。吴茱萸能入厥阴行气解郁，又能引热下行，故以为反佐。寒者正治，热者反治，使之相济以立功也。左金者，使肺右之金得行于左而平肝也。〕再加芍药名戊己（丸），热泻热痢服之安。（戊为胃土，己为脾土，加芍药伐肝安脾，使木不克土。）\n　　泻火之剂\n　　连附六一（汤）\n　　治胃痛，寒因热用理一般。（黄连六两，附子一两，亦反佐也。）\n　　泻火之剂\n　　导赤\n　　（散，钱乙）生地与木通，（甘）草梢竹叶四般攻。口糜淋痛小肠火，引热同归小便中（等分煎。生地凉心血，竹叶清心气，木通泻心火入小肠，草梢达肾茎而止痛。）\n　　泻火之剂\n　　清骨散\n　　用银柴胡，胡连秦艽鳖甲符。地骨青蒿知母草，骨蒸劳热保无虞。〔银柴胡钱半，胡黄连、秦艽、鳖甲（童便炙）、地骨皮、青蒿、知母各一钱，甘草（炙）五分。地骨、胡连、知母以平内热，柴胡、青蒿、秦艽以散表邪，引诸药入骨而补阴，甘草和诸药而泻火。〕\n　　泻火之剂\n　　普济消毒\n　　（饮，东垣）芩连鼠，玄参甘桔蓝根侣。升柴马勃连翘陈，僵蚕薄荷为末咀。〔黄芩（酒子、板蓝根、马勃、连翘、薄荷各一钱，僵蚕、升麻各七分，末服，或蜜丸噙化。〕或加人参及大黄，（虚者加人参，便秘加大黄。）大头天行力能御。（大头天行，亲戚不相访，问染者多不救。原文曰：芩、连泻心肺之火为君，玄参、陈皮、甘草泻火补肺为臣，连翘、薄荷、鼠粘、蓝根、僵蚕、马勃散肿消毒定喘为佐，升麻、柴胡散阳明、少阳二经之阳，桔梗为舟楫，不令下行为载。李东垣曰：此邪热客心肺之间，上攻头面为肿，以承气汤泻之，是为诛伐无过，遂处此方，全活甚众。）\n　　泻火之剂\n　　清震汤\n　　河间治雷头风，升麻苍术两般充。（二味，《局方》名升麻汤。）荷叶一枚升胃气，邪从上散不传中。（头面肿痛疙瘩，名雷头风，一云头如雷鸣。东垣曰：邪在三阳，不可过用寒药重剂误伐无过，处清震汤升阳解毒，盖取震为雷之义。）\n　　泻火之剂\n　　桔梗汤\n　　（《济生》）中用防已，桑皮贝母栝蒌子。甘枳当归薏杏仁，黄 百合姜煎此。（桔梗、防己、栝蒌、贝母、当归、枳壳、薏苡仁、桑白皮各五分，黄 七分，杏仁、百合、甘草各三分，姜煎。）肺痈吐脓或咽干，便秘大黄可加使。（一方有人参，无枳壳。黄 补肺气，杏仁、薏仁、桑皮、百合补肺清火，栝蒌、贝母润肺除痰，甘、桔开提气血，利膈散寒，防己散肿除风，泻湿清热，当归以和血，枳壳以利其气。）\n　　泻火之剂\n　　清咽太平\n　　（丸）薄荷芎，柿霜甘桔及防风。犀角蜜丸治热膈，早间咯血颊常红。（两颊，肺肝之部。早间，寅卯木旺之时。木盛生火，来克肺金。薄荷十两，川芎、柿霜、甘草、防风、犀角各二两，桔梗三两，蜜丸。川芎，血中气药，散瘀升清；防风，血药之使，搜肝泻肺。薄荷理血散热，清咽除蒸，犀角凉心清肝，柿霜生津润肺，甘草缓炎上之火势，桔梗载诸药而上浮。）\n　　泻火之剂\n　　清斑青黛\n　　（饮，陶节庵）栀连犀，知母玄参生地齐。石膏柴胡人参（甘）草，便实参去大黄跻。\n　　（去人参，加入大黄。）姜枣煎加一匙醋，阳邪里实此方稽。（发斑虽由胃热，亦诸经之火有以助之。青黛、黄连清肝火，栀子清胃火。引以柴胡，使达肌表；使以姜、枣，以和营卫。\n　　热毒入里，亦由胃虚，故以人参、甘草益胃。加醋者，酸以收之也。）\n　　泻火之剂\n　　辛夷散\n　　（严氏）里 （本）防风，白芷升麻与木通。芎细（川芎、细辛）甘草茶调服，鼻生息肉此方攻。（肺经湿热，上蒸于脑，入鼻而生息肉，犹湿地得热而生芝菌也。诸药等分，末服三钱。辛夷、升麻、白芷能引胃中清阳上行头脑，防风、 本能入巅顶燥湿祛风，细辛散热通窍，川\n　　泻火之剂\n　　苍耳散\n　　（陈无择）中用薄荷，辛夷白芷四般和。葱茶调服疏肝肺，清升浊降鼻渊瘥。〔苍耳子（炒）二钱半，薄荷、辛夷各五钱，白芷一两，末服。凡头面之疾，皆由清阳不升，浊阴逆上所致。浊气上烁于脑，则鼻流浊涕为渊。数药升阳通窍，除湿散风，故治之也。〕\n　　泻火之剂\n　　妙香\n　　（散，王荆公）山药与参 ，甘桔二茯远志随。少佐辰砂木香麝，惊悸郁结梦中遗。〔山药二两（乳汁炒），人参、黄 （蜜炙）、茯苓、茯神、远志（炒）各一两，桔梗、甘草各三钱，辰砂二钱，木香二钱半，麝香一钱，为末，每服二钱，酒下。山药固精，参、 补气，远志、二茯清心宁神，桔梗、木香疏肝清肺，丹、麝镇心，散郁辟邪，甘草补中，协和诸药，使精、气、神相根据，邪火自退。不用固涩之药，为泄遗良剂，以其安神利气，故亦治惊悸郁结。〕\n　　除痰之剂\n　　十首、附方五\n　　除痰之剂\n　　二陈汤\n　　（《局方》）用半夏陈，益以茯苓甘草臣。〔半夏（姜制）二钱，陈皮（去白）、茯苓各一钱，甘草五分，加姜煎。〕利气调中兼去湿，一切痰饮此为珍。（陈皮利气，甘草和中，苓、夏除湿，气顺湿除，痰饮自散。）导痰汤内加星枳，顽痰胶固力能驯。（加胆星以助半夏，加枳实以成冲墙倒壁之功。）若加竹茹与枳实，汤名温胆可宁神。（二陈汤加竹茹、枳实，名温胆汤，治胆虚不眠。）润下丸（丹溪）仅陈皮草，利气祛痰妙绝伦。〔陈皮（去白）八两，盐五两（水浸洗），甘草二两，蜜炙，蒸饼糊丸，姜汤下，或将陈皮盐水煮晒，同甘草为末，名二肾散，不可多服，\n　　除痰之剂\n　　涤痰汤\n　　（严氏）用半夏星，甘草橘红参茯苓。竹茹菖蒲兼枳实，痰迷舌强服之醒。〔治中风痰迷心窍，舌强不能言；半夏（姜制）、胆星各二钱半，橘红、枳实、茯苓各三钱，人参、菖蒲各一钱，竹茹七分，甘草五分，加姜煎。此即导痰汤加人参扶正，菖蒲开痰，竹茹清金。〕\n　　除痰之剂\n　　青州白丸\n　　星夏并，白附川乌俱用生。晒露糊丸姜薄引，风痰瘫痪小儿惊。〔半夏（水浸生两，南星、白附子各二两，川乌（去皮脐）五钱。四味俱生用，为末，袋盛，水摆出粉，再擂瘫痪，酒下；惊风，薄荷汤下。痰之主也，由于风寒湿。星、夏辛温，祛痰燥湿；乌、附辛热，散寒逐风。浸而曝之，杀其毒也。〕\n　　除痰之剂\n　　清气化痰\n　　（丸）星夏橘，杏仁枳实栝蒌实。芩苓姜汁为糊丸，气顺火消痰自失。〔半夏（姜胆星各两半，橘红、枳实（麸炒）、杏仁（去皮尖）、栝蒌仁（去油）、黄芩（酒炒）、茯苓各一两，姜制，糊丸，淡姜汤下。气能发火，火能生痰。陈、杏降逆气，枳实破滞气，芩、瓜平热气，星、夏燥湿气，茯苓行水气。水湿火热，皆生痰之本也，故化痰必以清气为先。〕\n　　除痰之剂\n　　顺气消食化痰丸\n　　（瑞竹堂），青皮星夏莱菔（子）攒。曲麦山楂葛杏附，蒸饼为糊姜汁搏。〔半夏（姜制）、胆星各一斤，陈皮（去白）、青皮、苏子、沉香（水炒）、莱菔子、生姜、麦芽（炒）、神曲（炒）、山楂（炒）、葛根、杏仁（去皮尖炒）、香附（醋炒），各一两，姜汁和，蒸饼为糊丸。\n　　痰由湿生，星、夏燥湿；痰因气升，苏子、杏仁降气；痰因气滞，青、陈、香附导滞；痰生于酒食，曲、葛解酒，楂、麦消食。湿去食消，则痰不生，气顺则喘满自止矣。〕\n　　除痰之剂\n　　滚痰丸\n　　（王隐君）用青礞石，大黄黄芩沉木香。百病多因痰作祟，顽痰怪证力能匡。〔青礞石一两（用焰硝一两，同入瓦罐，盐泥固济， 至石色如金为度），大黄（酒蒸）、黄芩（酒洗）\n　　各八两，沉香五钱，为末，水丸，姜汤下，量虚实服。礞石 悍，能攻陈积伏匿之痰；大黄荡热实，以开下行之路；黄芩凉心肺，以平上僭之火；沉香能升降诸气，以导诸药，为使。\n　　然非物理，不可轻投。〕\n　　除痰之剂\n　　金沸草散\n　　（《活人》）前胡辛，半夏荆甘赤茯因。煎加姜枣除痰嗽，肺感风寒头目颦。〔旋复花、前胡、细辛各一钱，半夏五分，荆芥钱半，甘草（炙）三分，赤茯苓六分。风热上壅，故生痰作嗽。荆芥发汗散风，前胡、旋复消痰降气，半夏燥痰散逆，甘草发散缓中，细辛温经，茯苓利湿，用赤者，入血分而泻丙丁也。〕局方（金沸草散）不用细辛茯，加入麻黄赤芍均。\n　　（治\n　　除痰之剂\n　　半夏天麻白术汤\n　　白术、神曲（炒）各一钱，人参、黄 、陈皮、苍术、茯苓、泽泻、天麻各五分，干姜三分，黄柏（酒洗）二分。痰厥，非半夏不能除；风虚，非天麻不能定。二术燥湿益气，参、 泻火补中，陈皮调气升阳，苓、泻泻热导水，曲、麦化滞助脾，干姜以涤中寒，黄柏以泻在泉少火也。〕\n　　除痰之剂\n　　常山饮\n　　（《局方》）中知贝取，乌梅草果槟榔聚。姜枣酒水煎露之，劫痰截疟功堪诩。〔常山（烧酒炒）二钱，知母、贝母、草果（煨）、槟榔各一钱，乌梅二个，一方加穿山甲、甘草。\n　　疟未发时，面东温服。知母治阳明独胜之热，草果治太阴独胜之寒，二经和则阴阳不致交争矣。常山吐痰行水，槟榔下气破积，贝母清火散痰，乌梅敛阴退热。须用在发散表邪及提出阳分之后为宜。〕\n　　除痰之剂\n　　截疟七宝\n　　（饮，《易简》）常山果，槟榔朴草青陈多。水酒合煎露一宵，阳经实疟服之妥。〔常山面东温服。常山吐痰，槟榔破积，陈皮利气，青皮伐肝，浓朴平胃，草果消膏梁之痰。加甘草，入胃佐常山引吐也。〕\n　　收涩之剂\n　　九首、附方二\n　　收涩之剂\n　　金锁固精\n　　（丸）芡莲须，龙骨蒺藜牡蛎需。莲粉（为）糊丸盐酒下，涩精秘气滑遗无。〔芡实（蒸）、莲蕊须、沙苑蒺藜（炒），各二两，龙骨（酥炙）、牡蛎（盐水煮一日夜， 粉），各一两，莲子粉为糊丸，盐汤吞服，或酒下。芡实固精补脾，牡蛎涩精清热，莲子交通心肾，蒺藜补肾益精，龙骨、莲须皆固精收脱之品。〕\n　　收涩之剂\n　　茯菟丹\n　　（《局方》）疗精滑脱，菟苓五味石莲末。酒煮山药为糊丸，亦治强中及消渴。〔强中者，下消之人，茎长兴盛，不交精出也。菟丝子十两（酒浸），五味子八两，白茯苓、石莲各三两，山药六两，酒煮为糊丸。漏精，盐汤下；赤浊，灯心汤下；白浊，茯苓汤下；消渴，米饮下。菟丝强阴益阳，五味涩精生水，石莲精心止浊，山药利湿固脾，茯苓甘淡而渗，于补之中能泄肾邪也。〕\n　　收涩之剂\n　　治浊固本\n　　（丸）莲蕊须，砂仁连柏二苓俱。益智半夏同甘草，清热利湿固兼躯。〔固本之中，兼利湿热。莲须、黄连（炒）各二两，砂仁、黄柏、益智仁、半夏（姜制）、茯苓各一两，猪苓二两，甘草（炙）三钱。精浊多由湿热与痰，连、柏清热，二苓利湿，半夏除痰。湿热多由郁滞，砂、智利气，兼能固肾强脾。甘草补土和中，莲须则涩以止脱也。〕\n　　收涩之剂\n　　诃子散\n　　（东垣）用治寒泻，炮姜粟壳橘红也。〔诃子（煨）七分，炮姜六分，罂粟壳（去蒂蜜炙）、橘红各五分，末服。粟壳固肾涩肠，诃子收脱住泻，炮姜逐冷补阳，陈皮升阳调气。〕河间（诃子散）木香诃草连，仍用术芍煎汤下。〔诃子一两半（生煨），木香五钱，黄连三钱，甘草二钱，为末煎，白术白芍汤调服。久泻，以此止之，不止者，加入浓朴二钱。〕二方药异治略同，亦\n　　收涩之剂\n　　桑螵蛸散\n　　（寇宗 ）治便数，参苓龙骨同龟壳。菖蒲远志及当归，补肾宁心健忘觉。〔桑螵蛸（盐水炒）、茯苓（一用茯神）、龙骨（ ）、龟板（酥炙）、菖蒲（盐炒）、远志、当归等分，为末，临卧服二钱，人参汤下。治小便数而欠，补心虚，安神。虚则便数，故以人参、螵蛸补之；热则便欠，故以龟板滋之，当归润之。菖蒲、茯苓、远志，并能清心热而通心肾，使心行，则小肠之腑自宁也。〕真人养脏（汤，罗谦甫）诃粟壳，肉蔻当归桂木香。术芍参甘为涩剂，脱肛久痢早煎尝。〔诃子（面里裹煨）一两二钱，罂粟壳（去蒂蜜炙）三两六钱，肉豆蔻（面里裹煨）五钱，当归、白术（炒）、白芍（酒炒）、人参各六钱，木香二两四钱，桂八钱，生甘草一两八钱，每服四钱。脏寒甚加附子，一方无当归，一方有干姜。脱肛由于虚寒，参、术、甘草以补其虚，官桂、豆蔻以温其寒。木香调气，当归和血，芍药酸以收敛，诃子、粟壳涩以止脱。〕\n　　收涩之剂\n　　当归六黄\n　　（汤）治汗出，（醒而汗出曰自汗，寐而汗出曰盗汗。） 柏芩连生熟地。（当归、黄柏、黄连、黄芩、二地等分，黄 加倍。）泻火固表复滋阴，（汗由阴虚，归、地以滋其阴；汗由火扰，黄芩、柏、连以泻其火；汗由表虚，倍用黄 ，以固其表。）加麻黄根功更异。（李时珍曰：麻黄根走表，能引诸药至卫分而固腠理。）或云此药太苦寒，胃弱气虚在所忌。\n　　收涩之剂\n　　柏子仁丸\n　　人参术，麦麸牡蛎麻黄根。再加半夏五味子，阴虚盗汗枣丸吞。〔柏子仁（炒研去油）\n　　二两，人参、白术、牡蛎（ ）、麻黄根、半夏、五味子各一两，麦麸五钱，枣肉丸，米饮下。心血虚则卧而汗即出，柏仁养心宁神，牡蛎、麦麸凉心收脱，五味敛汗，半夏燥湿，麻黄根专走肌表，引参、术以固卫气。〕\n　　收涩之剂\n　　阳虚自汗牡蛎散\n　　黄 浮麦麻黄根。〔牡蛎（ 研）、黄 、麻黄根各一钱，浮小麦百粒，煎。牡蛎、浮麦凉心止汗，黄 、麻黄根走肌表而固卫。〕扑法芎 牡蛎粉，（扑汗法：白术、 本、川芎各二钱半，糯米粉两半，为末，袋盛，周身补之。）或将龙骨牡蛎扪。（龙骨、牡蛎为末，合糯米粉等分，亦可扑法。）\n　　杀虫之剂\n　　二首\n　　杀虫之剂\n　　乌梅丸\n　　（仲景）用细辛桂，人参附子椒姜继。黄连黄柏及当归，温脏安蛔寒厥剂。〔乌梅三百个（醋浸蒸），细辛、桂枝、附子（炮）、人参、黄柏各六两，黄连一斤，干姜十两，川椒（去汗），当归各四两，治伤寒厥阴证，寒厥吐蛔。虫得酸则伏，故用乌梅；得苦则安，故用连、柏\n　　杀虫之剂\n　　化虫\n　　（丸）鹤虱及使君，槟榔芜荑苦楝群，白矾胡粉糊丸服，肠胃诸虫永绝氛。〔槟榔、鹤虱、苦楝根（东引者）、胡粉（炒）各一两，使君子、芜荑各五钱，枯矾一钱半，面糊丸，亦可末服。数药皆杀虫之品，单服尚可治之，汇萃为丸，而虫焉有不死者乎！〕\n　　痈疡之剂\n　　六首、附方二\n　　痈疡之剂\n　　真人活命\n　　（饮）金银花，防芷归陈草节加。贝母天花兼乳没，穿山角刺酒煎嘉。〔金银花二钱，当归（酒洗）、陈皮（去白）各钱半，防风七分，白芷、甘草节、贝母、天花粉、乳香各一钱，没药五分，二味另研。候药熟，下皂角刺五分，穿山甲三大片（锉，蛤粉炒，去粉用），好酒煎服，恣饮尽醉。忍冬、甘草散热解毒，痈疮圣药，花粉、贝母清痰降火，防风、白芷燥湿排脓，当归和血，陈皮行气，乳香托里护心，没药散瘀消肿，山甲、角刺透经络而溃坚，加酒以行药势也。〕一切痈疽能溃散，（已成者溃，未成者散。）溃后忌服用毋差。大黄便实可加使，铁器酸物勿沾牙。\n　　痈疡之剂\n　　金银花酒\n　　加甘草，奇疡恶毒皆能保。〔金银花五两（生者更佳），甘草一两，水煎一日一夜，服尽。〕护膜须用蜡矾丸，（黄蜡二两，白矾一两，溶化为丸，酒服十丸，加至百丸则有力，使毒不攻心。一方加雄黄，名雄矾丸，蛇咬尤宜服之。）二方均是疡科宝。\n　　痈疡之剂\n　　托里十补\n　　（散，即《局方》十宣散）参 芎，归桂白芷及防风。甘桔浓朴酒调服，痈疡脉弱赖之充。（人参、黄 、当归各二钱，川芎、桂心、白芷、防风、甘草、桔梗、浓朴各一钱，热酒调服。参、 补气，当归和血，甘草解毒，防风发表，浓朴散满，桂枝、桔梗排脓，表里气血交治，共成内托之功。）\n　　痈疡之剂\n　　托里温中\n　　（汤，孙彦和）姜附羌，茴木丁沉共四香。陈皮益智兼甘草，寒疡内陷呕泻良。（附子（炮）四钱，炮姜、羌活各三钱，木香钱半，茴香、丁香、沉香、益智仁、陈皮、甘草各二钱，加姜五片煎。治疮疡变寒内陷，心痞便溏，呃逆昏 。疡寒内陷，故用姜附温中助阳，羌活通关节，炙草益脾元，益智、丁、沉以止呃进食，茴、木、陈皮以散满除痞。此孙彦和治王伯禄臂疡，盛夏用此，亦舍时从证之变法也。）\n　　痈疡之剂\n　　托里定痛\n　　（汤）四物兼，（地黄、川芎、当归、白芍。）乳香没药桂心添。再加蜜炒罂粟壳，溃疡虚痛去如拈。（罂粟壳收涩，能止诸痛；四物活血，托里充肌。乳香能引毒瓦斯外出，不致内攻，，与没药并能消肿止痛。）\n　　痈疡之剂\n　　散肿溃坚\n　　（汤，东垣）知柏连，花粉黄芩龙胆宣。升柴翘葛兼甘桔，归芍棱莪昆布全。〔黄芩八钱半（酒炒半生用），知母、黄柏（酒炒）、花粉、胆草（酒炒）、桔梗、昆布各五钱，柴胡四钱，升麻、连翘、甘草（炙）、三棱（酒炒）、莪术（酒洗炒）各三钱，葛根、归尾（酒洗）、白芍（酒炒）各二钱，每服五、六钱，先浸后煎。连翘、升、葛解毒升阳，甘、桔、花粉排脓利膈，归、芍活血，昆布散痰，棱、莪破血行气，龙胆、知、柏、芩、连大泻诸经之火也。〕\n　　经产之剂\n　　十二首、附方二十二妇人诸病与男子同，惟行经妊娠，则不可以例治，故立经产一门。\n　　经产之剂\n　　海藏妊娠六合汤\n　　四物为君妙义长。（当归、地黄、川芎、白芍。）伤寒表虚地骨桂，（表虚自汗，发热恶寒，头痛脉浮，四物四两加桂枝、地骨皮各七钱，二药解肌实表，名表虚六合汤。）表实细辛兼麻黄。（头痛身热，无汗脉紧，四物四两加细辛、麻黄各五钱，二药温经发汗，名表实六合汤。）少阳柴胡黄芩入，（寒热胁痛，心烦喜呕，口苦脉弦，为少阳证。加柴胡解表，黄芩清里，名柴胡六合汤。）阳明石膏知母藏。（大热烦渴，脉大而长，为阳明证，加白虎汤清肺泻胃，名石膏六合汤。）小便不利加芩泻，（加茯苓、泽泻利水，名茯苓六合汤。）不眠黄芩栀子良。（汗下后不得眠，加黄芩、栀子养阴除烦，名栀子六合汤。）风湿防风与苍术，（兼风兼湿，肢节烦痛，心热脉浮，加防风搜风、苍术燥湿，名风湿六合汤。）发斑蕴毒升翘将。（下后不愈，蕴毒发斑如锦纹者，加升麻、连翘散火解毒，名升麻六合汤。）胎动血漏名胶艾，（伤寒汗下后，胎动漏血，加阿胶、艾叶养血安胎，名胶艾四物汤。）虚痞朴实颇相当。（胸满痞胀，加浓朴、枳实炒，散满消痞，名朴实六合汤。）脉沉寒厥亦桂附。（身冷拘急，腹痛脉沉，亦有不得已而加附子、肉桂散寒回阳者，名附子六合汤。）便秘蓄血桃仁黄。\n　　（大便秘，小便赤而脉实数，或膀胱蓄血，亦有加桃仁、大黄润燥通幽者，名大黄六合汤。）\n　　安胎养血先为主，余因各症细参详。后人法此治经水，过多过少别温凉。温六合汤加芩术，（加黄芩、白术治经水过多，黄芩抑阳，白术补脾，脾能统血。）色黑后期连附商。（加黄连清热，香附行气，名连附六合汤。）热六合汤栀连益，（加栀子、黄连治血热妄行。）寒六合汤加附姜。（加炮姜、附子治血海虚寒。）气六合汤加陈朴，（加陈皮、浓朴治气郁经阻。）风六合汤加艽羌。（加秦艽、羌活治血虚风痉。）此皆经产通用剂，说与时师好审量。\n　　经产之剂\n　　胶艾汤\n　　（《金匮》）中四物先，阿胶艾叶甘草全。（阿胶、川芎、甘草各二两，艾叶、当归各三两，芍药、地黄各四两，酒水煎，内阿胶烊化服。四物养血，阿胶补阴，艾叶补阳，甘草和胃，加酒行经。）妇人良方单胶艾，（亦名胶艾汤。）胎动血漏腹痛痊。胶艾四物加香附，（香附用童便、盐水、酒、醋各浸三日，炒。）方名妇宝（丹）调经专。\n　　经产之剂\n　　当归散\n　　（《金匮》）益妇人妊，术芍芎归及子芩。安胎养血宜常服，产后胎前功效深。（妇人怀妊，宜温服之，临盆易产，自无众疾。当归、川芎、芍药、黄芩各一斤，白术半斤，为末，酒调服。丹溪曰：黄芩、白术，安胎之圣药。盖怀妊宜清热凉血，血不妄行则胎安。黄芩养阴退阳，能除胃热；白术补脾，亦除胃热。脾胃健则能化血养胎，自无半产胎动血漏之患也。）\n　　经产之剂\n　　黑神散\n　　（《局方》）中熟地黄，归芍甘草桂炮姜。蒲黄黑豆童便酒，消瘀下胎痛逆忘。〔瘀血攻冲则作痛，胞胎不下，亦由血滞不行。诸药各四两，黑豆（炒去皮）半斤，酒、童便合煎。\n　　熟地、归、芍润以濡血，蒲黄、黑豆滑以行血，黑姜、官桂热以动血，缓以甘草，散以童便，行\n　　经产之剂\n　　清魂散\n　　（《局方》）用泽兰叶，人参甘草川芎协。荆芥理血兼祛风，产中昏晕神魂帖。〔泽兰、人参、甘草（炙）各三分，川芎五分，荆芥一钱，酒调下。川芎、泽兰和血，人参、甘草补气。外感风邪，荆芥能疏血中之风。肝藏魂，故曰魂魂。〕\n　　经产之剂\n　　羚羊角散\n　　（《本事方》）杏薏仁，防独芎归又茯神。酸枣木香和甘草，子痫风中均回春。〔羚羊角屑一钱，杏仁、薏仁、防风、独活、川芎、当归、茯神、枣仁（炒）各五分，木香、甘草各二枣、茯以宁心神，芎、归以和血，杏仁、木香以利气，薏仁、甘草以调脾。〕\n　　经产之剂\n　　当归生姜羊肉汤\n　　（《金匮》），当归三两，生姜五两，羊肉一斤。产中腹痛褥劳匡。（产后发热，自汗身痛，名褥劳。腹痛者，瘀血未去，则新血自不生也。）亦有加入参 者，（气能生血。羊肉辛热，用气血之属以补气血，当归引入血分，生姜引入气分，以生新血。加参、 者，气血交补也。）\n　　千金四物甘桂姜。（《千金》羊肉汤，芎、归、芍、地、甘草、干姜、肉桂，\n　　经产之剂\n　　达生\n　　（散，丹溪。达，小羊也，取其易生）紫苏大腹皮，参术甘陈归芍随。再加葱叶黄杨脑，孕妇临盆先服之。〔大腹皮三钱，紫苏、人参、白术（土炒）、陈皮、当归（酒洗）、白芍（酒洗）各一钱，甘草（炙）三钱，青葱五叶，黄杨脑七个，煎。归、芍以益其血，参、术以补其气，陈、腹、苏、葱以疏其壅。不虚不滞，产自无难矣。〕若将川芎易白术，（名）\n　　紫苏饮子（严氏）子悬宜。（胎气不和，上冲心腹，名子悬。）\n　　经产之剂\n　　妊娠转胞参术饮\n　　（丹溪。转胞者，气血不足，或痰饮阻塞，胎为胞逼，压在一边，故脐下急痛，而小便或数或闭也。）芎芍当归熟地黄。炙草陈皮（留白）兼半夏，气升胎举自如常。（此即人参汤除茯苓，加陈皮、半夏以除痰，加姜煎。）\n　　经产之剂\n　　牡丹皮散\n　　（《妇人良方》）延胡索，归尾桂心赤芍药。牛膝棱莪酒水煎，气行瘀散血瘕削。（瘀血半煎。桂心、丹皮、赤芍、牛膝以行其血，三棱、莪术、归尾、延胡索兼行血中气滞、气中血滞，则结者散矣。）\n　　经产之剂\n　　固经丸\n　　（《妇人良方》）用龟板君，黄柏樗皮香附群。黄芩芍药酒丸服，漏下崩中色黑殷。〔治经多不止，色紫黑者，属热。龟板（炙）四两，黄柏（酒炒）、芍药（酒炒）各二两，樗皮（炒）、香附（童便浸炒），各两半，黄芩（酒炒）二两，酒丸。阴虚不能制胞络之火，故经多。龟板、芍药滋阴壮水，黄芩清上焦，黄柏泻下焦，香附辛以散郁，樗皮涩以收脱。〕\n　　经产之剂\n　　柏子仁丸\n　　（《良方》）熟地黄，牛膝续断泽兰芳。卷柏加之通血脉，经枯血少肾肝匡。〔柏子仁（去油）、牛膝（酒浸）、卷柏各五钱，熟地一两，续断、泽兰各三两，蜜丸，米饮下。经曰：心气不得下降，则月事不来。柏子仁安神养心，熟地、续断、牛膝补肝益肾，泽兰、卷柏活血通经。〕\n　　附便用杂方\n　　三首\n　　附便用杂方\n　　望梅丸\n　　（ 庵）用盐梅肉，苏叶薄荷与柿霜。茶末麦冬糖共捣，旅行 服胜琼浆。〔盐梅肉四两，麦冬去心，薄荷叶（去梗）、柿霜、细茶各一两，紫苏叶（去梗）五钱，为极细末，白霜糖四两，共捣为丸，鸡子大。旅行带之，每含一丸，生津止渴，加参一两尤妙。〕\n　　附便用杂方\n　　骨灰固齿\n　　（牙散）猪羊骨，腊月腌成 研之。骨能补骨咸补肾，坚牙健啖老尤奇。（用腊月腌猪羊骨，火 ，细研，每晨擦牙，不可间断。至老而其效益彰，头上齿骨亦佳。）\n　　附便用杂方\n　　软脚散\n　　中芎芷防，细辛四味研如霜。轻撒鞋中行远道。足无针 汗皆香。（防风、白芷，川芎、细辛各二钱半，为末。行远路者，撒少许于鞋内，步履轻便，不生针 ，足汗皆香。）\n　　小儿稀痘方\n　　一首、附方三\n　　小儿稀痘方\n　　稀痘神\n　　（米以功）丹三种豆，粉草细末竹筒装。腊月厕中浸洗净，风干配入梅花良。丝瓜藤丝煎汤服，一年一次三年光。（用赤小豆、黑豆、绿豆、粉草各一两，细末，入竹筒中，削皮留节，凿孔入药，杉木塞紧，溶蜡封固，浸腊月厕中；一月取出，洗浸，风干。每药一两，腊月梅花片三钱，以雪中花片落地者，不着人手，以针刺取更妙。如急出用，入纸套中略烘即干。儿大者服一钱，小者五分，以霜后丝瓜藤上小藤丝煎汤，空腹服。忌荤腥十二日，解出黑粪为验。每年服一次，二次可稀，三次永不出矣。）又方蜜调忍冬末，（顾骧宇。）不住服之效亦强。（金银花为末，糖调，不住服之。）更有玄参菟丝子，（娄江王相公。）蜜丸如弹空心尝。白酒调化日二次，〔菟丝子半斤（酒浸二宿，煮干去皮），玄参四两，共为细末，蜜丸，弹子大，白酒调下，每日二次。〕或加犀麦生地黄。（又方加生地、麦冬四钱，犀角二两。）\n　　此皆验过稀痘法，为力简易免仓皇。\n　　\n【提示】本文档来源：国学大师(www.guoxuedashi.net)\n古典图书集成《国学大师》集成古典图书2万种28万卷约24亿字。\n原文链接：www.guoxuedashi.net/a/9173h/75815d.html"},"life/养生/瘀青":{"slug":"life/养生/瘀青","filePath":"life/养生/瘀青.md","title":"瘀青","links":[],"tags":["保健","瘀青"],"content":"1、红色瘀青 \n红色瘀青代表很新鲜的瘀伤。瘀伤有时候只要花数分钟至一两天便可以完全恢复,复原的速度根据你出血的位置多深,会出现红色是因为新鲜的血液从破裂的血管流到了组织,铁、氧含量高的新鲜血液还呈现红色所致。 \n2、蓝色瘀青 \n有时你的瘀青会在短期间内改变颜色,因为从血管流失的血液氧含量迅速减低,血液颜色就会不断变暗,最后会呈现深蓝并带点紫色。如果你碰伤的血管是在肌肤的更里层,瘀青甚至会跳过红色的阶段,直接出现蓝紫色的痕迹。 \n3、紫色瘀青 \n紫色的瘀青在外观上跟成因上都跟蓝色极为相似,状况大概都会维持1-3天。颜色越鲜明、浓烈的话就代表内部伤得越深,甚至还有可能会出现黑色。在这个时期,身体会快速地制造出新的红血球,将它运输到受伤的部位。 \n4、绿色瘀青 \n瘀青过了几天会转变成绿色,红血球在破裂后会产生血红蛋白,而愈合阶段中身体会把血红蛋白转变成新的化学物质,因而改变了它的颜色。这个阶段的瘀血常常以绿色为中心,外围绕着蓝紫色的边界。 \n5、黄色瘀青 \n瘀青呈现黄色的时候,就代表瘀伤快好啦!在这个阶段,大部份的血红蛋白都已经被分解完毕,变成了胆红素,这会使皮肤表层看起来像黄色。而在这个最终阶段里,身体还在清理那些从血管漏出来的细胞,清完后瘀青就彻底康复啰! \n虽然大多数的状况下,瘀青都会透过上述的那些阶段自己进行愈合,所以我们可以不用去管它,但如果你想减少疼痛或肿胀,或为了美观想让瘀青早点消失,可以试试下面的办法!\n处理方法\n方法1:48小时内敷冰袋 \n在瘀青的地方敷上冰袋或其他冰冻的东西,就可以有效解除疼痛或肿胀。一天约敷三次,每次以10-20分钟为限。 \n方法2:抬高患处 \n将瘀青的部位抬高到超出心脏的水平,然后同时敷冰袋,可以减少出血的面积。\n方法3:48小时过后热敷 \n在刚受伤的48小时内,尽量避免浸泡热水、用热水淋浴、热敷,或是喝下太多的酒精。但再过两天后,如果大部分的肿胀已经消失了,就可以开始对伤处进行热敷,跟冰敷一样一天进行三次,每次10-20分钟。这可以加速血液的流动,并帮助愈合过程。 \n方法4:包裹患处 \n在瘀青肿胀消失后,你可以开始试着和缓地运动该部位,帮助它恢复弹性。这个阶段也可以用弹性绷带包裹患处,稍微进行压缩,但切记不要包得太紧,以免又回复成肿胀的状态。一但觉得有点发麻,就要把绷带放松一点。 \n方法5:涂抹外伤药 \n药店一般都有卖跌打损伤的药物,涂抹点药就能够帮助伤口尽快复原。\nReferences\n\n想加快恢复淤青 试试这些招\n"},"life/养生/药性赋":{"slug":"life/养生/药性赋","filePath":"life/养生/药性赋.md","title":"药性赋","links":[],"tags":[],"content":"《药性赋》，原书未著撰人，据考证约为金元时代作品。原为中医初学中药的启蒙书。该书将248种常用中药按药性分寒、热、温、平四类，用韵语编写成赋体，言简意赅，朗朗上口，便于诵读记忆。尤其是对药性概括精辟，一经铭记在心，受用终生，颇受历代读者喜爱，传沿至今，长盛不衰。\n由于原书用歌赋韵语编写，文词过简，读之难以深悟。我们于60年代编写出版了《药性赋白话解》一书。该书一经刊行，即深受读者欢迎，已印行22次，连续多年排为畅销书之列。随着中药学的发展，一版已不能满足现代读者要求。为此，北京中医药大学中药教研室对此书进行了二版修订，内容更为丰富实用，除“白话解”外，增加了药物的现代用量用法、配伍应用、附方、注意事项，并加入按语，据药源不同、炮制之别、药理精微、功能对比等，阐述用法之异。读者熟读本书，便可打下坚实的药性基本功，终生受益。\n第一章 寒性药\n诸药赋性，此类最寒。\n犀角解乎心热；羚羊清乎肺肝。泽泻利水通淋而补阴不足；海藻散瘿破气而治疝何难。闻之菊花能明目清头风；射干疗咽闭而消痈毒；薏苡理脚气而除风湿；藕节消瘀血而止吐衄。瓜蒌子下气润肺喘兮，又且宽中，车前子止泻利小便兮，尤能明目。是以黄柏疮用，兜铃嗽医。地骨皮有退热除蒸之效，薄荷叶宜消风清肿之施。宽中下气，枳壳缓而枳实速也；疗肌解表，干葛先而柴胡次之。百部治肺热，咳嗽可止；栀子凉心肾，鼻衄最宜。玄参治结热毒痈，清利咽膈；升麻消风热肿毒，发散疮痍。 尝闻腻粉抑肺而敛肛门；金箔镇心而安魂魄。茵陈主黄疸而利水；瞿麦治热淋之有血。 朴硝通大肠，破血而止痰僻；石膏治头痛，解肌而消烦渴。前胡除内外之痰实；滑石利六腑之涩结。天门冬止嗽，补血涸而润心肝；麦门冬清心，解烦渴而除肺热。又闻治虚烦、除哕呕，须用竹茹；通秘结、导瘀血，必资大黄。宣黄连治泠热之痢，又厚肠胃而止泻；淫羊藿疗风寒之痹，且补阴虚而助阳。茅根止血与吐衄；石苇通淋与小肠。熟地黄补血且疗虚损；生地黄宣血更医眼疮。赤芍药破血而疗腹痛，烦热亦解；白芍药补虚而生新血，温热尤良。 若乃消肿满逐水于牵牛；除热毒杀虫于贯众。金铃子治疝气而补精血；萱草根治五淋而消乳肿。侧柏叶治血山崩漏之疾；香附子理气血妇人之用。地肤子利膀胱，可洗皮肤之风；山豆根解热毒，能止咽喉之痛。白藓皮去风治筋弱，而疗足顽痹；旋覆花明目治头风，而消痰嗽壅。又况荆芥穗清头目便血，疏风散疮之用；瓜蒌根疗黄疸毒痈，消渴解痰之忧。地榆疗崩漏，止血止痢；昆布破疝气，散瘿散瘤。疗伤寒、解虚烦，淡竹叶之功倍；除结气、破瘀血，牡丹皮之用同。知母止嗽而骨蒸退；牡蛎涩精而虚汗收。贝母清痰止咳嗽而利心肝；桔梗开肺利胸膈而治咽喉。若夫黄芩治诸热，兼主五淋；槐花治肠风，亦医痔痢。常山理痰结而治温疟；葶苈泻肺喘而通水气。此六十六种药性之寒者也。\n第二章 热性药\n药有温热，又当审详。\n欲温中以荜拨；用发散以生姜。五味子止嗽痰，且滋肾水；腽肭脐疗痨瘵，更壮元阳。 原夫川芎祛风湿、补血清头；续断治崩漏、益筋强脚。麻黄表汗以疗咳逆；韭子壮阳而医白浊。川乌破积，有消痰治风痹之功；天雄散寒，为去湿助精阳之药。观夫川椒达下，干姜暖中。胡芦巴治虚泠之疝气；生卷柏破症葭而血通。白朮消痰壅、温胃，兼止吐泻；菖蒲开心气、散泠，更治耳聋。丁香快脾胃而止吐逆；良姜止心气痛之攻冲。肉苁蓉填精益肾；石硫黄暖胃驱虫。胡椒主去痰而除泠；秦椒主攻痛而去风。吴茱萸疗心腹之泠气；灵砂定心脏之怔忡。盖夫散肾泠、助脾胃，须毕澄茄；疗心痛、破积聚，用蓬莪朮。缩砂止吐泻安胎、化酒食之剂；附子疗虚寒反胃、壮元阳之方。白豆蔻治泠泻，疗痈止痛于乳香；红豆蔻止吐酸，消血杀虫于干漆。岂知鹿茸生精血，腰脊崩漏之均补；虎骨壮筋骨，寒湿毒风之并祛。檀香定霍乱，而心气之痛愈；鹿角秘精髓，而腰脊之痛除。消肿益血于米醋；下气散寒于紫苏。扁豆助脾，则酒有行药破结之用；麝香开窍，则葱为通中发汗之需。尝观五灵脂治崩漏，理血气之刺痛；麒麟竭止血出，疗金疮之伤折。糜茸壮阳以助肾；当归补虚而养血。乌贼骨止带下，且除崩漏目翳；鹿角胶住血崩，能补虚羸劳绝。白花蛇治瘫痪，疗风痒之癣疹；乌梢蛇疗不仁，去疮疡之风热。乌药有治泠气之理；禹余粮乃疗崩漏之因。巴豆利痰水，能破寒积；独活疗诸风，不论新久。山茱萸治头晕遗精之药；白石英医咳嗽吐脓之人。厚朴温胃而去呕胀，消痰亦验；肉桂行血而疗心痛，止汗如神。是则鲫鱼有温胃之功；代赭乃镇肝之剂。沉香下气补肾，定霍乱之心痛；橘皮开胃去痰，导壅滞之逆气。此六十六种药性之热者也。\n第三章 温性药\n温药总括，医家素谙。 木香理乎气滞；半夏主于痰湿。苍朮治目盲，燥脾去湿宜用；萝卜去膨胀，下气治面尤堪。况夫钟乳粉补肺气，兼疗肺虚；青盐治腹痛，且滋肾水。山药而腰湿能医；阿胶而痢嗽皆止。赤石脂治精浊而止泄，兼补崩中；阳起石暖子宫以壮阳，更疗阴痿。 诚以紫苑治嗽，防风怯风，苍耳子透脑止涕，威灵仙宣风通气。细辛去头风，止嗽而疗齿痛；艾叶治崩漏、安胎而医痢红。羌活明目驱风，除湿毒肿痛；白芷止崩治肿，疗痔瘘疮痈。若乃红蓝花通经，治产后恶血之余；刘寄奴散血，疗烫火金疮之苦。减风湿之痛则茵芋叶；疗折伤之症责骨碎补。 藿香叶辟恶气而定霍乱；草果仁温脾胃而止呕吐。巴戟天治阴疝白浊，补肾尤滋；元胡索理气痛血凝，调经有助。尝闻款冬花润肺，去痰嗽以定喘；肉豆蔻温中，止霍乱而助脾。抚芎走经络之痛；何首乌志疮疥之资。姜黄能下气、破恶血之积；防己宜消肿、去风湿之施。蒿本除风，主妇人阴痛之用；仙茅益肾，扶元气虚弱之衰。乃曰破故纸温肾，补精髓与劳伤；宣木瓜入肝，疗脚气并水肿。杏仁润肺燥止嗽之剂；茴香治疝气肾疼之用。诃子生精止渴，兼疗滑泄之痾；秦艽攻风逐水，又除肢节之痛。槟榔豁痰而逐水，杀刺白虫；杜仲益肾而添精，去腰膝重。当知紫石英疗惊悸崩中之疾，橘核仁治腰痛疝气之真。金樱子兮涩精；紫苏子兮下气涎。淡豆豉发伤寒之表；大小蓟除诸血之鲜。益智安神，治小便之频数；麻仁润肺，利六腑之燥坚。抑又闻补虚弱、排疮脓，莫若黄耆；强腰脚、壮筋骨，无如狗脊。 菟丝子补肾以明目；马兰花治疝而有益。此五十四种药性之温者也。\n第四章 平性药\n详论药性，平和惟在。\n以磠砂而去积；用龙齿以安魂。青皮快膈除膨胀，且利脾胃；芡实益精治白浊，兼补真元。原夫木贼草去目翳，崩漏亦医；花蕊石治金疮，血行则却。决明和肝气，治眼之剂；天麻主头眩，怯风之药。甘草和诸药而解百毒，盖以气平；石斛平胃气而补肾虚，更医脚弱。观乎商陆治肿，覆盆益精。琥珀安神而散血；朱砂镇心而有灵。牛膝强足补精，兼疗腰痛；龙骨止汗住泄，更治血崩。甘松理风气而痛止；蒺藜疗风疮而目明。人参润肺宁心，开脾助胃；蒲黄止崩治衄，消痨调经。岂不以南星醒脾，去惊风痰吐之忧；三棱破积，除血块气滞之症。没食主泄泻而神效；皂角治风痰而响应。桑螵蛸疗遗精之泄；鸭头血医水肿之盛。蛤蚧治痨嗽，牛蒡子疏风壅之痰；全蝎主风瘫，酸枣仁去怔忡之病。尝闻桑寄生益血安胎，且止腰痛；大腹子去膨下气，亦令胃和。小草、远志，俱有宁心之妙；木通、猪苓，尤为利水之多。莲肉有清心醒脾之用；没药乃治疮散血之科。郁李仁润肠宣血，去浮肿之疾；茯神宁心益智，除惊悸之痾。白茯苓补虚劳，多在心脾之有眚；赤茯苓破结血，独利水道以无毒。因知麦芽有助脾化食之功；小麦有止汗养心之力。 白附子去面风之游走；大腹皮治水肿之泛溢。椿根白皮主泻血；桑根白皮主喘息。桃仁破瘀血兼治腰痛；神曲健脾胃而进饮食。五加皮坚筋骨以立行；柏子仁养心神而有益。抑又闻安息香辟恶，且止心腹之痛；冬瓜仁醒脾，实为饮食之资。僵蚕治诸风之喉闭；百合恋肺痨之嗽萎。赤小豆解热毒，疮肿宜用；枇杷叶下逆气，哕呕可医。连翘排疮脓与肿毒；石南叶利筋骨与毛皮。谷芽养脾，阿魏除邪气而破积；紫河车补血，大枣和药性以开脾。然而鳖甲治痨疟，兼破症葭；龟甲坚筋骨，更疗崩疾。乌梅主便血疟疾之用；竹沥治中风声音之失。此六十八种药性之平者也。\nReferences\n\n药性赋\n"},"life/生育保险":{"slug":"life/生育保险","filePath":"life/生育保险.md","title":"生育保险","links":["life/马鞍山市男职工未就业配偶生育保险待遇申请表.docx.html"],"tags":[],"content":"第三章   居民生育保险篇\n二十一、享受我市居民生育保险待遇需要符合哪些条件?\n（一）符合国家、省、市计划生育政策；  \n（二）参加我市当年居民医疗保险的居民或个人通过劳动人事代理机构参加城镇职工基本医疗保险并可享受职工医疗保险待遇的参保人员。        \n二十二 、参保居民享受哪些生育保险待遇?\n居民生育保险享受生育医疗待遇，包括下列内容：\n（一）妊娠期间所必需的门诊常规检查费用；\n（二）分娩期间所必需的检查费、接生费、手术费、住院床位费和药费；\n（三）分娩期间生育并发症费用；\n（四）分娩期间新生儿所必需的常规诊疗费和药费；\n（五）计划内生育发生的流产、引产费用。\n二十三、居民生育保险报销比例是多少？\n  参保居民在协议管理医疗机构发生的符合规定的生育医疗费用，由生育保险资金分别按一级及以下医疗机构100%、二级医疗机构90%、三级医疗机构80%的比例支付。其中，不符合临床手术指征的剖宫产，发生的符合规定的生育医疗费用，个人先支付20%，剩余部分按规定的比例支付。\n二十四、参保居民计划生育手术费用如何解决？\n参保居民计划生育手术费用居民生育保险资金不予支付，仍按计划生育政策有关规定从原渠道解决。\n二十五、参保居民妊娠期间生育并发症、产假期间生育并发症及异位妊娠的费用如何办理？\n参保居民妊娠期间生育并发症、产假期间生育并发症及异位妊娠住院治疗，按照居民基本医疗保险住院就医结算办法办理。\n第四章 男职工未就业配偶生育保险篇\n二十六、男职工未就业配偶享受待遇需要符合哪些条件？\n（一）参保男职工符合享受职工生育保险待遇的条件；  \n（二）配偶在生育保险协议管理医疗机构发生的生育医疗费用；\n（三）配偶未就业；\n（四）配偶未享受社会保险中的生育医疗待遇。\n二十七、男职工未就业配偶生育保险审核手续如何办理？\n未就业配偶确诊妊娠后，携带《马鞍山市男职工未就业配偶生育保险待遇申请表》（可在马鞍山市医保中心官网下载、也可在选定的协议管理医疗机构或是医保中心大厅综合服务窗口领取）、男职工本人社会保障卡、夫妻双方身份证、结婚证、生育服务登记卡及围产保健手册到生育保险经办机构综合窗口办理审核备案手续，未登记备案前发生的费用自理。\n备案后选择在本市生育的，到选定的生育保险协议管理医疗机构刷卡实时结算。\n备案后到异地生育的，按照《马鞍山市男职工未就业配偶生育保险待遇申请表》下方说明要求到经办机构办理报销手续。\n二十八、男职工未就业配偶享受哪些生育保险待遇？\n男职工未就业配偶享受生育医疗费用（不含生育并发症医疗费用）包括：\n（一） 妊娠期间所必需的门诊常规检查费用；\n（二） 分娩期间所必需的检查费、接生费、手术费、住院床位费和药费；\n（三） 分娩期间新生儿所必需的常规诊疗费和药费；\n（四） 计划内生育发生的流产、引产费用。\n二十九、男职工未就业配偶享受待遇标准？\n男职工未就业配偶在生育保险协议管理医疗机构发生的符合规定的生育医疗费用，按照居民生育保险的支付比例执行。结算标准按照我市居民异地生育结算标准限额支付，低于结算标准的，按实支付。\nCf. www.masybzx.com/index.php\n\n总体来说，选择居民基本医疗保险的方式参保，比“男职工未就业配偶”更方便划算：\n\n无需填写《马鞍山市男职工未就业配偶生育保险待遇申请表》\n享受“分娩期间生育并发症费用”的生育保险待遇\n"},"life/社保转移":{"slug":"life/社保转移","filePath":"life/社保转移.md","title":"社保转移","links":[],"tags":[],"content":"五险：养老保险、医疗保险（含生育保险）、失业保险、工伤保险，工伤保险由单位缴纳，其余各险均由员工个人和单位共同缴纳\n\n养老保险转移：掌上12333，12333官网：si.12333.gov.cn；均可在线办理\n医疗保险：浙里办出具参保凭证，再询转入地转入条件及流程，按步骤办理即可\n失业保险：杭州市人力和社会保障局官网，弄到一个“失业保险转移接续函”，再询转入地转入条件及流程，依次办理\n工伤保险：工伤保险无法转出\n\n一金：住房公积金\n住房公积金转移：南京需要连续缴纳六个月后才可办理转入手续，杭州转出需要封存6个月及以上可办理转出"},"life/福利相关/南京医保":{"slug":"life/福利相关/南京医保","filePath":"life/福利相关/南京医保.md","title":"南京医保","links":[],"tags":["医保","南京"],"content":"政策地址：ybj.nanjing.gov.cn/gkml/202212/t20221231_3792597.html"},"notes/CVX-notes":{"slug":"notes/CVX-notes","filePath":"notes/CVX notes.md","title":"CVX notes","links":[],"tags":["math"],"content":"CVX notes\nPreliminaries\n1. PSD\nM is positive semidefinite matrix \\iff all principal submatrices P of M are PSD\n\nNote: This follows by considering the quadratic form x^T Mx and looking at the components of x corresponding to the defining subset of principal submatrix. The converse is trivially true.\n\nM is PSD \\iff all principal minors are non-negative (所有主子式非负)\n将M写成二次型：\nx^T M x = \\sum_{i,j}M_{ij}x_ix_j\n于是取 x 为标准基 e_i  ~\\implies M_{ii} \\ge 0 \\implies \\mathbf{tr}(M) \\ge 0 , 再取x为零向量只有 i，j两个位置为 1，则\n\\begin{gathered}\nx^T M x = M_{ii}M_{jj} - M_{ij}^2 \\ge 0 ~~(PSD) \\\\\n\\implies M_{ij} \\le \\sqrt{M_{ii}M_{jj}} \\le \\frac{M_{ii} + M_{jj}}{2}\n\\end{gathered}\n\n2. Matrix norm\nGeneral definition of a norm: \nMatrix norm:\n\nFrobenius norm: \\|A\\|_F := \\sqrt{\\langle A,A\\rangle_F} = \\sqrt{\\mathbf{tr}(A^*A)}\nInduced norm: \\|A\\|_p := \\sup_\\limits{\\|x\\|_p = 1} \\|Ax\\|_p\nNuclear norm: \\|A\\|_{nuclear} := \\sum \\sigma_i(A) (奇异值之和)\nSpectral norm: \\|A\\|_{spectral} := \\lambda_1 (最大特征值)\n\nSpectrial radius\n\n\n\n3. Duality\nTwo equivalent ways to represent a convex set:\n\nstandard representation: The family of points in the set\ndual representation: The set of halfspaces containing the set (半平面的交集)\n\nA closed convex set S is the intersection of all closed halfspaces H containing it.\n\n\nPolar\nLet S \\subseteq \\mathbb{R}^n be a convex set containing the origin. The polar of S is defined as follows\nS^{\\circ} := \\{y ~|~ y^Tx \\le 1, ~\\forall x \\in S\\}\nNote\n\npolar is one way of representing the all halfspaces containing a convex set\nevery halfspace a^Tx \\le b with b \\neq 0 can be written as a “normalized” inequality y^T x \\le 1, by dividing by b\nS^{\\circ} can be thought of as the normalized representations of halfspaces containing S\n\nProperties of the polar:\n\nS^{\\circ\\circ} = S\nS^{\\circ} is a closed convex set containing the origin\nWhen 0 is in the interior of S, then S^{\\circ} is bounded\nWhen S is non-convex, S^{\\circ} = (\\mathbf{conv}(S))^{\\circ}, and S^{\\circ\\circ} = \\mathbf{conv}(S)\n\n\n\nPolar duality of convex cones\n\nNotes\n\nK^{\\circ\\circ} = K\nK^{\\circ} is closed and convex\n\nConjugation of convex functions\nLet f: \\mathbb{R}^n \\mapsto \\mathbb{R}\\cup\\{\\infty\\} be a convex function. The conjugation of f is\nf^*(y) := \\sup_\\limits{x}(y^Tx - f(x))\n\nProperties of the conjugate\n\nf^{**} = f\nf^* is convex (supremum of affine functions of y)\n\n\n\n\nConvex sets\n\n\nConvex functions\n\n\naffine is convex: f(x) = a^T x+b\n\n\naffine 既凸也凹\n\n\n任何范数是凸的\n\n\nProof: let \\pi(x) be a norm of x, then\n\n\nf is convex \\iff epi(f) is convex\n\n\n\n1. Closed convex\nA convex function f is called closed if its epigraph is a closed set.\n\n\nf which is convex and continuous on a closed domain is a closed function. (norms)\n\n\nall differentiable convex functions are closed with domf = \\mathbb{R}^n.\n\n\n当考虑一个凸函数时，通常认为在domf外取值为\\infty\n\n\nJensen’s inequality:\n\n\nCorollary:\n\npf:  f(x) = f(\\sum\\alpha_i x_i) \\le \\sum \\alpha_i f(x_i) \\le \\max_\\limits{i} f(x_i)\n\n\n\n\n2. Level sets\n\n\nNote: the convexity of level sets does not characterize convex functions, but quasiconvex functions.\n\n\nconvex f is closed \\implies all its level sets are closed\n\nSome convex sets\n\nnorm ball (\\{x\\in \\mathbb{R}^n | \\|x\\| \\le 1\\}) is convex and closed\n椭球(\\{x | (x-a)^T Q (x-a) \\le r^2\\}) is convex and closed\n\npf: x^TQy := \\langle  x, y \\rangle 满足内积的三条性质\n\nbilinearity\nsymmetry\npositivity\n上述三条性质 \\iff Q is PSD\n\n\n\n\\epsilon-neighborhood: \n\n\n\n3. Operations perserving convexity of functions\n\nstability under taking weighted sums: f,g \\mapsto \\lambda f + \\mu g, \\; \\lambda,\\mu \\ge 0\nstability under affine substitutions of the argument: x \\mapsto Ax+b or f(x) \\mapsto \\phi(x) = f(Ax+b)\nstability under taking pointwise sup: \\{f_i\\}_{i \\in \\mathcal{I}} \\mapsto g(x) := \\sup_\\limits{i \\in \\mathcal{I}}f_i(x), 凸函数族 \\{f_i\\}_{i \\in \\mathcal{I}} 逐点取上确界而成的函数也是凸的\nstability under partial minimization: f(x,y) jointly convex in (x,y), then g(x) = \\inf_\\limits{y} f(x,y) is convex (suppose g is proper, i.e., &gt; -\\infty everywhere and is finite at least at one point)\nstability under perspective: f(x) \\mapsto g(x,t) = tf(x/t), \\mathbf{dom}g = \\{(x,t) | x/t \\in \\mathbf{dom}f, t &gt; 0\\}\n\n\n4. Detect convexity\nNecessary and Sufficient Convexity Condition for smooth function:\n\n一阶可微的光滑函数 f 是凸的 \\iff  f&#039;(x) 单调非减\n二阶可微的光滑函数 f 是凸的 \\iff  f&#039;&#039;(x) \\ge 0\n\nsubgradient property is characteristic of convex functions: \n\n5. Subgradient\nExamples\n\n\n\n\n\n\n\n6. Optimality conditions\n凸函数的局部最优等价于全局最优。\n第一充要条件（凸函数）\nx^* \\in \\mathbf{dom}f is the minimizer \\iff 0 \\in \\partial f(x^*)\n\n7. Strong convexity\nA differentiable function f is strongly convex if\nf(y) \\ge f(x) + \\nabla f(x)^T(y-x) + \\frac{\\mu}{2} \\|y-x\\|^2\nNote\n\nf is not necessarily differentiable, (see the equivalent definition)\nif f is non-smooth, gradient → subgradient\nstrong convexity \\implies strict convexity\n\n\nNote: Intuitively speaking, strong convexity means that there exists a quartic lower bound on the growth of the function.\n\nEquivalent definition\n\\begin{align}\n\t\t&amp;(i)~f(y)\\ge f(x)+\\nabla f(x)^T(y-x)+\\frac{\\mu}{2}\\lVert y-x \\rVert^2,~\\forall x, y.\\\\\n\t\t&amp;(ii)~g(x) = f(x)-\\frac{\\mu}{2}\\lVert x \\rVert^2~\\text{is convex},~\\forall x.\\\\\n\t\t&amp;(iii)~\\langle \\nabla f(x) - \\nabla f(y),x-y \\rangle \\ge \\mu \\lVert x-y\\rVert^2,~\\forall x, y.\\\\\n\t\t&amp;(iv)~f(\\alpha x+ (1-\\alpha) y) \\le \\alpha f(x) + (1-\\alpha) f(y) - \\frac{\\alpha (1-\\alpha)\\mu}{2}\\Vert x-y\\rVert^2,~\\alpha \\in [0,1].\\\\\n\t\t&amp;(v)~\\nabla^2 f(x) \\succeq \\mu \\boldsymbol{I}\n\\end{align}\n\n\nLagrange Duality\nConsider an optimization problem in standard form (not necessarily convex)\n\\begin{array}{ll}\n\\underset{x}{\\text{minimize}} &amp; f_0(x) \\\\\n\\text{subject to} &amp; f_i(x) \\le 0, ~i=1,\\cdots,m \\\\\n~\t&amp; h_i(x) = 0, ~i=1,\\cdots,p\n\\end{array}\nThe Lagrangian is\nL(x,\\boldsymbol{\\lambda},\\boldsymbol{\\mu}) = f_0(x) + \\sum_{i=1}^m \\lambda_i f_i(x) + \\sum_{i=1}^p \\mu_i h_i(x)\nThe Lagrange dual function is defined as\ng(\\lambda, \\mu) = \\inf_{x} L(x,\\lambda,\\mu)\n\nLagrange dual problem\n\\begin{array}{ll}\n\\underset{\\lambda, \\mu}{\\text{maximize}} &amp; g(\\lambda, \\mu) \\\\\n\\text{subject to} &amp; \\boldsymbol{\\lambda} \\succeq \\mathbf{0}\n\\end{array}\nWeak duality\nd^* \\le p^*\n\nd^*: optima of dual problem\np^*: optima of primal problem\nduality gap: p^* -  d^*\nalways hold\n\nStrong dualiy\nd^* = p^*\n\nconstraint qualifications \\implies strong duality\nSlater’s Constraint Qualification: a convex problem is strictly feasible (i.e., \\exists ~x \\in \\mathbf{int} \\mathcal{D}: x \\in \\Omega)\n\nComplementary slackness\n\nKKT conditions\n\n\n\n\nCones\nTagent cone\nLet M be a (nonempty) convex set and x^* \\in M, the tagent cone of M at x^* is the cone\n\\begin{split}\nT_M(x^*) &amp;= \\{h \\in \\mathbb{R}^n | x^* + th \\in M, \\; \\forall t &gt; 0 \\} \\\\\n&amp;= \\{y \\in \\mathbb{R}^n ~|~ y - x^* \\in M\\}\n\\end{split}\nNote:\n\nGeometrically, this is the set of all directions leading from x^* inside M\nconvex but not necessarily closed\nfact: if x^* is a minimizer, then \\forall h \\in T_M(x^*) \\implies h^T \\nabla f(x^*) \\ge 0. （因为tangent cone里面都是可行解，所以必须不是下降方向）\nT_M(x^*) = \\mathbb{R}^n \\iff x^* \\in \\mathbf{int}M\n\ne.g. 多面体\nM = \\{x | Ax \\le b\\} = \\{x | a_i^Tx \\le b_i, \\; i = 1,\\dots,m\\}\nthe tangent cone at x^* is\nT_M(x^*) = \\{h~|~a_i^T h \\le 0, ~\\forall i, ~a_i^T x^* = b_i\\}\n\nNormal cone:  the polar cone of tangent cone\nN_M(x^*) = \\{g \\in \\mathbb{R}^n ~|~ \\langle g, y-x^*\\rangle \\le 0, ~\\forall y \\in M\\}\nNote:\n\nnormal cone is the polar to tangent cone, i.e.,\n\n\\begin{split}\nT_M(x^*) &amp;= \\{g \\in \\mathbb{R}^n ~|~ \\langle g, y-x^*\\rangle \\ge 0, ~\\forall y \\in M\\} \\\\\nN_M(x^*) &amp;= \\{g \\in \\mathbb{R}^n ~|~ \\langle g, y-x^*\\rangle \\le 0, ~\\forall y \\in M\\}\n\\end{split}\n\nfact: if x^* is a minimizer, then -\\nabla f(x^*) \\in N_M(x^*).\n\n\n\n\nAlgorithm convergence\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n~Stepsize RuleConvergence RateIteration ComplexityGradient descentstrongly convex &amp; smooth\\eta_t = \\frac{2}{\\mu + L}O\\left(\\frac{\\kappa -1}{\\kappa +1}\\right)^tO\\left(\\frac{\\log\\frac{1}{\\epsilon}}{\\log\\frac{\\kappa+1}{\\kappa-1}}\\right)convex &amp; smooth\\eta_t = \\frac{1}{L}O(\\frac{1}{\\sqrt{t}})O(\\frac{1}{\\epsilon})Frank-Wolfe(strongly) convex &amp; smooth\\eta_t = \\frac{1}{t}O(\\frac{1}{\\sqrt{t}})O(\\frac{1}{\\epsilon})Projected GDconvex &amp; smooth\\eta_t = \\frac{1}{L}O(\\frac{1}{\\sqrt{t}})O(\\frac{1}{\\epsilon})strongly convex &amp; smooth\\eta_t = \\frac{1}{L}O\\left((1-\\frac{1}{\\kappa})^t\\right)O(\\kappa\\log\\frac{1}{\\epsilon})Subgradient methodconvex &amp; Lipschitz\\eta_t = \\frac{1}{\\sqrt{t}}O(\\frac{1}{\\sqrt{t}})O(\\frac{1}{\\epsilon^2})strongly convex &amp; Lipschitz\\eta_t = \\frac{1}{t}O\\left(\\frac{1}{t}\\right)O(\\frac{1}{\\epsilon})Proximal GDconvex &amp; smooth (w.r.t. f)\\eta_t = \\frac{1}{L}O(\\frac{1}{t})O(\\frac{1}{\\epsilon})strongly convex &amp; smooth (w.r.t. f)\\eta_t = \\frac{1}{L}O\\left((1-\\frac{1}{\\kappa})^t\\right)O(\\kappa\\log\\frac{1}{\\epsilon})"},"notes/GPG使用方法":{"slug":"notes/GPG使用方法","filePath":"notes/GPG使用方法.md","title":"GPG使用方法","links":[],"tags":["gpg","pgp","gnu","加密","解密","数字签名","安全","linux"],"content":"GPG使用方法\n更新过期时间\n更新过期的key\n$ gpg -k  # list public key\n$ gpg -K  # list private key\n$ gpg --edit-key &lt;optional-key-id&gt;\nyychi@~&gt; gpg --edit-key 4064117B3192D56BACCCBB68B6210039643FFB28\ngpg (GnuPG) 2.2.36; Copyright (C) 2022 g10 Code GmbH\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n \n私钥可用。\n \nsec  rsa3072/B6210039643FFB28\n     创建于：2019-04-16  有效至：2024-07-23  可用于：SC  \n     信任度：绝对        有效性：绝对\nssb  rsa3072/87BFC8C3205F2DB6\n     创建于：2019-04-16  有效至：2022-10-22  可用于：E   \n[ 绝对 ] (1). Bingb Hu (yychi) &lt;guyueshui002@gmail.com&gt;\n \ngpg&gt; expire \n将要变更主密钥的过期时间。\n请设定这个密钥的有效期限。\n         0 = 密钥永不过期\n      &lt;n&gt;  = 密钥在 n 天后过期\n      &lt;n&gt;w = 密钥在 n 周后过期\n      &lt;n&gt;m = 密钥在 n 月后过期\n      &lt;n&gt;y = 密钥在 n 年后过期\n密钥的有效期限是？(0) 3m\n密钥于 2022年10月22日 星期六 22时07分21秒 CST 过期\n这些内容正确吗？ (y/N) y\n \nsec  rsa3072/B6210039643FFB28\n     创建于：2019-04-16  有效至：2022-10-22  可用于：SC  \n     信任度：绝对        有效性：绝对\nssb  rsa3072/87BFC8C3205F2DB6\n     创建于：2019-04-16  有效至：2022-10-22  可用于：E   \n[ 绝对 ] (1). Bingb Hu (yychi) &lt;guyueshui002@gmail.com&gt;\n \ngpg&gt; key 1  # 选择子key,可以看到ssb*被选中了\n \nsec  rsa3072/B6210039643FFB28\n     创建于：2019-04-16  有效至：2022-10-22  可用于：SC  \n     信任度：绝对        有效性：绝对\nssb* rsa3072/87BFC8C3205F2DB6\n     创建于：2019-04-16  有效至：2022-10-22  可用于：E   \n[ 绝对 ] (1). Bingb Hu (yychi) &lt;guyueshui002@gmail.com&gt;\n \ngpg&gt; expire\n将要变更子密钥的过期时间。 # 注意这里是子密钥了\n请设定这个密钥的有效期限。\n         0 = 密钥永不过期\n      &lt;n&gt;  = 密钥在 n 天后过期\n      &lt;n&gt;w = 密钥在 n 周后过期\n      &lt;n&gt;m = 密钥在 n 月后过期\n      &lt;n&gt;y = 密钥在 n 年后过期\n密钥的有效期限是？(0) \n加密/解密\n$ gpg -r &lt;key-id&gt; -e somefile.txt  # 加密文件\n$ echo &quot;abc&quot; | gpg -r &lt;key-id&gt; -e  # 加密文本\n \n$ gpg -r &lt;key-id&gt; -d somefile.txt.gpg  # 使用指定key解密文件\nCf.\n\ngist.github.com/jhjguxin/6037564\nwww.yangqi.show/posts/gpg-tutorial 这个讲的更好\n\n改变密钥功能（capability）\n参见：unix.stackexchange.com/a/654150\n在edit-key模式中，选中需要编辑的key，键入change-usage改变密钥用途。\ngpg&gt; change-usage\n变更主密钥的用途。\n\nRSA 密钥的可实现的功能： 签名（Sign） 认证（Certify） 加密（Encrypt） 身份验证（Authenticate） \n目前启用的功能： 签名（Sign） 认证（Certify） \n\n   (S) 签名功能开关\n   (E) 加密功能开关\n   (A) 身份验证功能开关\n   (Q) 已完成\n\n您的选择是？ s\n\nReferences\n\nGPG masterkey and subkey for encryption and signature and default keys\nThe GNU Privacy Handbook\n加密软件 GPG 入门教程\nGPG 最佳实践\n"},"notes/TCP协议":{"slug":"notes/TCP协议","filePath":"notes/TCP协议.md","title":"TCP协议","links":["notes/network/计算机网络基础.html"],"tags":["tcp"],"content":"TCP协议\n连接的建立\n\n注意：\n\nSYN=1,ACK=0表示请求连接的报文\nSYN=1,ACK=1表示同意连接\nSYN=0,ACK=1表示确认连接，此刻之后Client进入ESTABLISHED状态\n\n可以看到，主动打开连接的一方（client）自收到另一方（server）同意连接报文（SYN=1,ACK=1）后进入ESTABLISHED状态，而server需收到client的确认连接报文（SYN=0,ACK=1）后才进入ESTABLISHED状态。\n为啥多这一次呢？参见此处。\n\n另可参考TCP：连接的建立和终止."},"notes/asio/Asynchronous-Operations":{"slug":"notes/asio/Asynchronous-Operations","filePath":"notes/asio/Asynchronous Operations.md","title":"Asynchronous Operations","links":[],"tags":[],"content":"Asynchronous Operations\nAn asynchronous operation is the basic unit of composition in the Asio asynchronous model. Asynchronous operations represent work that is launched and performed in the background, while the user’s code that initiated the work can continue with other things.\n\n\n\n\n\n\n\n                  \n                    Property of synchronous operations\n                  \n                \n\n                  \n                    Equivalent property of asynchronous operations\n                  \n                \n\n\n\n\n                  \n                    When a synchronous operation is generic (i.e. a template) the\n                    return type is deterministically derived from the function and\n                    its arguments.\n                  \n                \n\n                  \n                    When an asynchronous operation is generic, the completion handler&#039;s\n                    arguments&#039; types and order are deterministically derived from\n                    the initiating function and its arguments.\n                  \n                \n\n\n\n                  \n                    If a synchronous operation requires a temporary resource (such\n                    as memory, a file descriptor, or a thread), this resource is\n                    released before returning from the function.\n                  \n                \n\n                  \n                    If an asynchronous operation requires a temporary resource (such\n                    as memory, a file descriptor, or a thread), this resource is\n                    released before calling the completion handler.\n                  \n                \n\n\n\nThe latter is an important property of asynchronous operations, in that it allows a completion handler to initiate further asynchronous operations without overlapping resource usage.\n\n对于同步操作，申请的临时资源在函数返回前释放；\n对于异步操作，申请的临时资源在回调函数调用前释放。\n\nSome concepts\nIn computer science, an algorithm is called non-blocking if failure or suspension of any thread cannot cause failure or suspension of another thread;\nWait-freedom is the strongest non-blocking guarantee of progress, combining guaranteed system-wide throughput with starvation-freedom. An algorithm is wait-free if every operation has a bound on the number of steps the algorithm will take before the operation completes.\nLock-freedom allows individual threads to starve but guarantees system-wide throughput. An algorithm is lock-free if, when the program threads are run for a sufficiently long time, at least one of the threads makes progress (for some sensible definition of progress). All wait-free algorithms are lock-free.\nBlock就是线程放弃CPU时间片，触发系统调度。当一个线程尝试拿mutex而未果，它就会block，等待下次被调度，继续尝试拿这个mutex.\n锁的作用就是让本来可以并发执行的code，按次序执行。另外，编译器出于优化目的会将一些指令重排，有一些方法（memory barrier）可以告诉编译器不要重排。原子操作就是在指令级别上无法打断的操作，中断只能发生在指令与指令之间，所以，单条指令是原子的。当然，在多核处理器上，未必成立。\n原子操作是不可分割的，即保证其他线程在操作完成一半时永远不会看到该操作。\n值得注意的是，重排不仅发生在编译器，CPU也会处于效率目的对指令进行重排。因此，如果保证代码按照所写的顺序执行是一个很复杂的问题。\nCPU 重新排序比编译器重新排序更微妙。 你永远无法直接看到它发生，你只能看到莫名其妙的 bug。 为了防止对读取和写入进行 CPU 重新排序，需要在某些处理器上使用内存屏障指令。\n参考链接：learn.microsoft.com/zh-cn/windows/win32/dxtecharts/lockless-programming"},"notes/asio/同步异步阻塞非阻塞":{"slug":"notes/asio/同步异步阻塞非阻塞","filePath":"notes/asio/同步异步阻塞非阻塞.md","title":"同步异步阻塞非阻塞","links":[],"tags":["同步","异步","阻塞","非阻塞"],"content":"同步异步阻塞非阻塞\n四个概念：\n\n同步（Synchronous）\n异步( Asynchronous)\n阻塞( Blocking )\n非阻塞( Nonblocking)\n\n进程间的通信是通过 send() 和 receive() 两种基本操作完成的。具体如何实现这两种基础操作，存在着不同的设计。 消息的传递有可能是阻塞的或非阻塞的 – 也被称为同步或异步的：\n\n阻塞式发送（blocking send）. 发送方进程会被一直阻塞， 直到消息被接受方进程收到。\n非阻塞式发送（nonblocking send）。 发送方进程调用 send() 后， 立即就可以其他操作。\n阻塞式接收（blocking receive） 接收方调用 receive() 后一直阻塞， 直到消息到达可用。\n非阻塞式接受（nonblocking receive） 接收方调用 receive() 函数后， 要么得到一个有效的结果， 要么得到一个空值， 即不会被阻塞。\n\nReferences\n\n怎样理解阻塞非阻塞与同步异步的区别？ - 萧萧的回答 - 知乎 www.zhihu.com/question/19732473/answer/241673170\n"},"notes/cpp/CPP基础":{"slug":"notes/cpp/CPP基础","filePath":"notes/cpp/CPP基础.md","title":"CPP基础","links":["diary/2022-07-21.html","notes/cpp/链接.html","tags/链接.html","tags/编译.html","tags/linkage.html"],"tags":["链接","编译","linkage"],"content":"CPP基础\n名字（name，变量、函数、类等）拥有两种属性：\n\nstorage duration，简称duration，约等于一个名字的生命周期（lifetime），表明了它何时创建，何时销毁\nlinkage，表明了该名字的链接属性。Internal linkage只有单文件可见，external linkage是所有文件可见。一言蔽之，就是名字暴露给链接器的可见性。\n\nStorage class specifiers 用于修饰一个名字，控制上面两种独立属性的变化。\nStorage duration有以下几种：\n\nautomatic storage duration: 局部变量（名字），始于代码段开始，销毁于代码段结束。\nstatic storage duration: 静态变量，始于程序开始执行，终于程序结束运行。\nthread storage duration: 线程独占，thread local，随线程开始和销毁。\ndynamic storage duration: 开始和销毁由用户自己申请。\n\nLinkage表示一个名字是否具有linkage. 如果一个名字有linkage，当这个名字出现在其他作用域时，它们指的是同一个东西。如果一个变量，函数或其他名字，在多处声明，但它们没有linkage，那么它们指的不是一个东西，将会生成多个实例。\nLinkage有以下几种：\n\nno linkage: 变量（名字）只能在当前作用域使用。\ninternal linkage: 变量（名字）可以在当前编译单元的所有作用域使用。\nexternal linkage: 变量（名字）可以在其他编译单元的某些作用域中使用。Variables and functions with external linkage also have language linkage, which makes it possible to link translation units written in different programming languages.\n\nSummary: Scope determines where a variable is accessible. Duration determines where a variable is created and destroyed. Linkage determines whether the variable can be exported to another file or not.\n分离编译\na.c中定义了一个变量a要在b.c中使用，正确的做法：（b.c中的extern是变量前置声明的格式1，并非修饰符，表示该变量定义在某处）\n// a.c\nint a = 3;\n \n// b.c\n#include &lt;stdio.h&gt;\nextern int a;\nint main()\n{\n    printf(&quot;a=%d\\n&quot;, a);\n    return 0;\n}\n$ g++ a.c b.c\na=3\nb.c中去掉extern关键字，编译器会认为这是定义一个整形变量a2，因此会报重复定义的错误。\n// a.c\nint a = 3;\n \n// b.c\n#include &lt;stdio.h&gt;\nint a;\nint main()\n{\n    printf(&quot;a=%d\\n&quot;, a);\n    return 0;\n}\n$ g++ a.c b.c\n/usr/bin/ld: /tmp/cc6qujc6.o:(.bss+0x0): multiple definition of `a&#039;; /tmp/ccp6J7M6.o:(.data+0x0): first defined here\ncollect2: error: ld returned 1 exit status\n\n\n                  \n                  ATTENTION\n                  \n                \n\n这里如果用gcc编译，是可以链接通过的。\n\n\nAn identifier’s linkage determines whether multiple declarations of an identifier refer to the same entity (object, function, reference, etc…) or not.\n\nAn identifier with no linkage means the identifier only refers to itself. This includes:\n\nLocal variables\nUser-defined type definitions (such as enums and classes) declared inside a block\n\n\nAn identifier with internal linkage can be accessed anywhere within the file it is declared. This includes:\n\nStatic global variables (initialized or uninitialized)\nStatic functions\nConst global variables\nFunctions declared inside an unnamed namespace\nUser-defined type definitions (such as enums and classes) declared inside an unnamed namespace\n\n\nAn identifier with external linkage can be accessed anywhere within the file it is declared, or other files (via a forward declaration). This includes:\n\nFunctions\nNon-const global variables (initialized or uninitialized)\nExtern const global variables\nInline const global variables\nUser-defined type definitions (such as enums and classes) declared inside a namespace or in the global scope\n\n\n\nwww.learncpp.com/cpp-tutorial/scope-duration-and-linkage-summary\n\n\n                  \n                  Attention\n                  \n                \n\nInline函数直接放在头文件定义，如果在头文件声明，源文件实现，会报链接错误。因为在一个编译单元内，编译器需要看到inline函数的实现才能展开。如果inline的实现在另一个cpp中（编译单元），那么我在这个编译单元看不到inline的实现，也就无法展开。\n\n\n静态链接\n链接 编译 linkage\n编译过程分为四步3：\n\n预处理：处理源代码中的预处理指令（#include，#define，#if，#elif，#else等），生成一个没有宏定义、没有条件编译指令、没有特殊符号的输出文件（.i）。这一阶段只是文本的处理，并不发生实质性的编译过程。\n编译：经过预编译得到的输出文件中，只有常量（如数字、字符串、变量的定义，以及C语言的关键字）；编译程序所要作得工作就是通过词法分析和语法分析，在确认所有的指令都符合语法规则之后，将其翻译成等价的中间代码表示或汇编代码。\n汇编：汇编过程实际上指把汇编语言代码翻译成目标机器指令的过程。对于被翻译系统处理的每一个C语言源程序，都将最终经过这一处理而得到相应的目标文件。目标文件中所存放的也就是与源程序等效的目标的机器语言代码。\n链接：链接程序的主要工作就是将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够被操作系统装入执行的统一整体。\n\n\n\n预编译\n\n将.c 文件转化成 .i文件\n使用的gcc命令是：gcc –E\n对应于预处理命令cpp\n\n\n编译\n\n将.c/.h文件转换成.s文件\n使用的gcc命令是：gcc –S\n对应于编译命令 cc –S\n\n\n汇编\n\n将.s 文件转化成 .o文件\n使用的gcc 命令是：gcc –c\n对应于汇编命令是 as\n\n\n链接\n\n将.o文件转化成可执行程序\n使用的gcc 命令是： gcc\n对应于链接命令是 ld\n\n\n\n总结起来编译过程就上面的四个过程：预编译处理(.c) ⇒ 编译、优化程序（.s、.asm）⇒ 汇编程序(.obj、.o、.a、.ko) ⇒ 链接程序（.exe、.elf、.axf等）。\n静态链接\n在静态链接方式下，函数的代码将从其所在的静态链接库中被拷贝到最终的可执行程序中。这样该程序在被执行时这些代码将被装入到该进程的虚拟地址空间中。静态链接库实际上是一个目标文件的集合，其中的每个文件含有库中的一个或者一组相关函数的代码。\n示例\n// file: bird.h\n#ifndef __BIRD_H__\n#define __BIRD_H__\n#include &lt;string&gt;\nclass Bird\n{\nprivate:\n    std::string name_;\n    std::string identity() { return &quot;Bird/&quot; + name_; }\n \npublic:\n    Bird(const std::string&amp; name): name_(name) {}\n    Bird(const char* name): name_(name) {}\n    void eat(std::string food);\n    void fly();\n};\n#endif /* ifndef __BIRD_H__ */\n \n// file: bird.cpp\n#include &quot;bird.h&quot;\n#include &lt;iostream&gt;\nvoid Bird::eat(std::string food)\n{\n    std::cout &lt;&lt; identity() &lt;&lt; &quot; eats &quot; &lt;&lt; food &lt;&lt; std::endl;\n}\n \nvoid Bird::fly()\n{\n    std::cout &lt;&lt; identity() &lt;&lt; &quot; static flys&quot; &lt;&lt; std::endl;\n}\n \nBird poppy(&quot;caozhiqiang&quot;);\n \n// file: joshua.cpp\n#include &lt;iostream&gt;\nvoid joshua()\n{\n    std::cout &lt;&lt; &quot;joshua in static lib&quot; &lt;&lt; std::endl;\n}\n$ g++ -c bird.cpp joshua.cpp\n$ ls\nbird.cpp  bird.h  bird.o  joshua.cpp  joshua.o\n$ ar -r libjoshua.a bird.o joshua.o\nar: 正在创建 libjoshua.a\n$ ls\nbird.cpp  bird.h  bird.o  joshua.cpp  joshua.o  libjoshua.a\n上面创建了一个静态库libjoshua.a，其实就是将目标文件（机器码）打包，接下来创建一个文件使用这个静态库。\n// file: main.cpp\n#include &lt;iostream&gt;\n#include &quot;bird.h&quot;\n \nvoid joshua();  // declare func of libjoshua\n \nint main()\n{\n    extern Bird poppy;  // declare variable poppy of libjoshua\n    poppy.eat(&quot;rice&quot;);\n    poppy.fly();\n \n    Bird zag(&quot;Zag&quot;);  // use class Bird of libjoshua\n    zag.eat(&quot;fruit&quot;);\n    zag.fly();\n \n    joshua();\n    return 0;\n}\n$ g++ main.cpp libjoshua.a -o main\n$ ./main\nBird/caozhiqiang eats rice\nBird/caozhiqiang static flys\nBird/Zag eats fruit\nBird/Zag static flys\njoshua in static lib\n动态链接\n在动态链接的方式下，函数的代码被放到称作是动态链接库或共享对象的某个目标文件中。链接程序此时所作的只是在最终的可执行程序中记录下共享对象的名字以及其它少量的登记信息。在此可执行文件被执行时，动态链接库的全部内容将被映射到运行时相应进程的虚地址空间。动态链接程序将根据可执行程序中记录的信息找到相应的函数代码。\n\nNULL vs nullptr\nstackoverflow.com/questions/20509734/null-vs-nullptr-why-was-it-replaced\n\nNULL就是数字0，可以发生那些隐式转换\nnullptr (C++11)的类型是std::nullptr_t，它可以转换为任意指针类型（包括类的成员指针），却不能转换成其他类型（int, bool, etc.）\n\n此外，在函数重载决议中也有区别，\nvoid func(int n);\nvoid func(char* s);\n \nfunc(NULL); // call func(int)\n\n==,是一个运算符，满足结合律，运算结果为,右边的的表达式的求值。==\nFootnotes\n\n\n6.7 — External linkage and variable forward declarations ↩\n\n\n且非const全局变量具有external linkage，这就是说，对linker而言，a.c中的a具有外部链接，b.c中的a也是如此，所以会产生重复定义。但，如果a具有内部链接（internal linkage），则对linker而言，他们只是恰好同名的两个不同实体。 ↩\n\n\nC/C++程序编译过程详解 ↩\n\n\n"},"notes/cpp/TypeTraits介绍":{"slug":"notes/cpp/TypeTraits介绍","filePath":"notes/cpp/TypeTraits介绍.md","title":"TypeTraits介绍","links":[],"tags":["cpp"],"content":"Type traits are a clever technique used in C++ template metaprogramming that gives you the ability to inspect and transform the properties of types.\nFor example, given a generic type T — it could be int, bool, std::vector or whatever you want — with type traits you can ask the compiler some questions: is it an integer? Is it a function? Is it a pointer? Or maybe a class? Does it have a destructor? Can you copy it? Will it throw exceptions? … and so on. This is extremely useful in conditional compilation, where you instruct the compiler to pick the right path according to the type in input. We will see an example shortly.\nType traits can also apply some transformation to a type. For example, given T, you can add/remove the const specifier, the reference or the pointer, or yet turn it into a signed/unsigned type and many other crazy operations. Extremely handy when writing libraries that make use of templates.\nThe beauty of these techniques is that everything takes place at compile time with no runtime penalties: it’s template metaprogramming, after all. I assume you know a bit about C++ templates for the rest of this article. This guide is a great introduction if you don’t.x\n\nadapted from \n\nReferences\n\nA quick primer on type traits in modern C++ \nC++ Type traits \n"},"notes/cpp/cpp-learn":{"slug":"notes/cpp/cpp-learn","filePath":"notes/cpp/cpp-learn.md","title":"C++ 学习笔记","links":["tags/define.html","notes/cpp/模板.html","tags/include.html","tags/defined.html","tags/inclue.html","notes/cpp/字节序.html","notes/cpp/链接.html"],"tags":["cpp","note","define","include","defined","inclue"],"content":"诚如是，Life is too short to learn c++. 此篇记录一些我在学习cpp过程中遇到的一些知识点，仅作记录并梳理之效。里面可能会有大量参考其他网络博客，如有侵权，请联系我删除之。\nc++之父的 glossary: Bjarne Stroustrup’s C++ Glossary, 里面有c++名词的简短解释，以c++之父的角度哦。\nReactor v.s. Proactor\n\nepll/wait: reactor模式，不停轮询，发现有事做，就做！\nasio: proactor模式，先注册好事件，如果事情发生了，通过回调函数处理。\n\n几个常用的宏\n\n__func__: name of an function, exists in C99/C++11 (__FUNCTION__ is non standard)\n__LINE__: line number of the code\n__FILE__: filename of the file\n__DATE__ and __TIME__: as you wish\n\n不要在ctor里调用虚函数\n总结来说：基类部分在派生类部分之前被构造，当基类构造函数执行时派生类中的数据成员还没被初始化。如果基类构造函数中的虚函数调用被解析成调用派生类的虚函数，而派生类的虚函数中又访问到未初始化的派生类数据，将导致程序出现一些未定义行为和bug。 \nctor应该设计的尽量简单，确保对象可以被正确构造。在ctor中调用本类的非静态成员都是不安全的，因为他们还没被构造，而有些成员是依赖对象的，而此时对象还没有被成功构造。\nctor不能是虚函数\n\n\n从存储空间角度：虚函数对应一个vtable（虚函数表），这大家都知道，可是这个vtable其实是存储在对象的内存空间的。问题出来了，如果构造函数是虚的，就需要通过 vtable来调用，可是对象还没有实例化，也就是内存空间还没有，无法找到vtable，所以构造函数不能是虚函数。\n\n\n从使用角度：虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义呀。所以构造函数没有必要是虚函数。\n\n\n虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。\n\n构造函数不需要是虚函数，也不允许是虚函数，因为创建一个对象时我们总是要明确指定对象的类型，尽管我们可能通过实验室的基类的指针或引用去访问它。但析构却不一定，我们往往通过基类的指针来销毁对象。这时候如果析构函数不是虚函数，就不能正确识别对象类型从而不能正确调用析构函数。\n\n——————————————————\n版权声明：本文为CSDN博主「cainiao000001」的原创文章，遵循CC 4.0 by-sa版权协议，转载请附上原文出处链接及本声明。\n原文链接：blog.csdn.net/cainiao000001/article/details/81603782\n虚函数的工作原理\nzhuanlan.zhihu.com/p/60543586\nC++ 规定了虚函数的行为，但将实现方法留给了编译器的作者。不需要知道实现方法也可以很好的使用虚函数，但了解虚函数的工作原理有助于更好地理解概念。\n通常，编译器处理虚函数的方法是：给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。\n这种数组称为虚函数表（Virtual Function Table, vtbl）。\n虚函数表是一个数组，数组的元素是指针，指针指的是虚函数的地址。\n具有虚函数的类的实例，都会在头部存一个指向虚函数表的指针。\n常见类型所占空间大小\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTYPEBytes(unsigned) int4(unsigned) short2(unsigned) long8float4double8long double16(unsigned) char1bool1\n指针占几个字节 指针即为地址，指针几个字节跟语言无关，而是跟系统的寻址能力有关，譬如以前是16为地址，指针即为2个字节，现在一般是32位系统，所以是4个字节，以后64位，则就为8个字节。\n\nNOTE: 类成员函数指针一般为普通指针的两倍大小。\n\nliteral 5.0类型为double，5.0f类型为float。不加f后缀默认double.\n静态成员的初始化\n当一个类包含静态成员时，最好的做法是在类中声明，在类外初始化。由于静态成员是所有对象共享的，如果在类内初始化，则每个对象构造时，都要执行一遍静态成员的初始化，这无疑是一种浪费。\nstruct A\n{\n  static int a;\n  int b;\n  void fun();\n  ...\n};\n \nint A::a = 233;\n \nclass B\n{\npublic:\n  void fun();\n  ...\nprivate:\n  static string str_;\n  bool done_;\n};\n \nstring B::str_ = &quot;hello, i am static&quot;;\n析构函数的调用时机\nThe destructor is called whenever an object’s lifetime ends, which includes\n\nprogram termination, for objects with static storage duration\nthread exit, for objects with thread-local storage duration\nend of scope, for objects with automatic storage duration and for temporaries whose life was extended by binding to reference\ndelete-expressin, for objects with dynamic storage duration\nend of the full expression, for nameless temporaries\nstack unwinding (栈回溯), for objects with automatic storage duration when an exception escapes their block, uncaught.\n\ncf. en.cppreference.com/w/cpp/language/destructor\n常量\nLiteral constants\n字面值常量\nCf. www.learncpp.com/cpp-tutorial/literals/\nSymbolic constants\n符号常量\nCf. www.learncpp.com/cpp-tutorial/const-constexpr-and-symbolic-constants/\n\nConst variables must be initialized\nFunction parameters for arguments passed by value should not be made const.\nDon’t use const with return by value.\n\nRuntime vs compile-time constants\nRuntime constants are constants whose initialization values can only be resolved at runtime (when your program is running). The following are examples of runtime constants:\n#include &lt;iostream&gt;\n \nvoid printInt(const int x) // x is a runtime constant because the value isn&#039;t known until the program is run\n{\n    std::cout &lt;&lt; x;\n}\n \nint main()\n{\n    std::cout &lt;&lt; &quot;Enter your age: &quot;;\n    int age{};\n    std::cin &gt;&gt; age;\n \n    const int usersAge { age }; // usersAge is a runtime constant because the value isn&#039;t known until the program is run\n \n    std::cout &lt;&lt; &quot;Your age is: &quot;;\n    printInt(age);\n \n    return 0;\n}\nCompile-time constants are constants whose initialization values can be determined at compile-time (when your program is compiling). The following are examples of compile-time constants:\nconst double gravity { 9.8 }; // the compiler knows at compile-time that gravity will have value 9.8\nconst int something { 1 + 2 }; // the compiler can resolve this at compiler time\nCompile-time constants enable the compiler to perform optimizations that aren’t available with runtime constants. For example, whenever gravity is used, the compiler can simply substitute the identifier gravity with the literal double 9.8.\nTo help provide more specificity, C++11 introduced the keyword constexpr, which ensures that a constant must be a compile-time constant.\n\nAny variable that should not be modifiable after initialization and whose initializer is known at compile-time should be declared as constexpr.\nAny variable that should not be modifiable after initialization and whose initializer is not known at compile-time should be declared as const.\n\nNote that literals are also implicitly constexpr, as the value of a literal is known at compile-time.\nA constant expression is an expression that can be evaluated at compile-time. For example:\n#include &lt;iostream&gt;\nint main()\n{\n\tstd::cout &lt;&lt; 3 + 4; // 3 + 4 evaluated at compile-time\n\treturn 0;\n}\nIn the above program, because the literal values 3 and 4 are known at compile-time, the compiler can evaluate the expression 3 + 4 at compile-time and substitute in the resulting value 7. That makes the code faster because 3 + 4 no longer has to be calculated at runtime.\nConstexpr variables can also be used in constant expressions:\n#include &lt;iostream&gt;\nint main()\n{\n\tconstexpr int x { 3 };\n\tconstexpr int y { 4 };\n\tstd::cout &lt;&lt; x + y; // x + y evaluated at compile-time\n\treturn 0;\n}\nIn the above example, because x and y are constexpr, the expression x + y is a constant expression that can be evaluated at compile-time. Similar to the literal case, the compiler can substitute in the value 7.\nObject-like preprocessor macros v.s. symbolic constants\nObject-like macro has the form:\n#define identifier substitution_text\nWhenever the preprocessor encounters this directive, any further occurrence of identifier is replaced by substitution_text. The identifier is traditionally typed in all capital letters, using underscores to represent spaces.\n\nAvoid using define to create symbolic constants macros. Use const or constexpr variables instead.\n\nMacros can have naming conflicts with normal code. For example:\n#include &quot;someheader.h&quot;\n#include &lt;iostream&gt;\n \nint main()\n{\n    int beta { 5 };\n    std::cout &lt;&lt; beta;\n \n    return 0;\n}\nIf someheader.h happened to define a macro named beta, this simple program would break, as the preprocessor would replace the int variable beta’s name with whatever the macro’s value was. This is normally avoided by using all caps for macro names, but it can still happen.\nUsing symbolic constants throughout a multi-file program\nCf. www.learncpp.com/cpp-tutorial/sharing-global-constants-across-multiple-files-using-inline-variables/\n模板\n预编译\nCf. www.learncpp.com/cpp-tutorial/introduction-to-the-preprocessor/\n#include\nWhen you include a file, the preprocessor replaces the include directive with the contents of the included file. The included contents are then preprocessed (along with the rest of the file), and then compiled.\nMacro defines\nThe define directive can be used to create a macro. In C++, a macro is a rule that defines how input text is converted into replacement output text.\nThere are two basic types of macros: object-like macros, and function-like macros.\nObject-like macros can be defined in one of two ways:\n#define identifier\n#define identifier substitution_text\nObject-like macros don’t affect other preprocessor directives\n结论：宏展开在预编译指令(Preprocessor directives)无效。\n#define PRINT_JOE\n#ifdef PRINT_JOE    // 此处会否将&#039;PRINT_JOE&#039;替换为空呢？\n// ...\nMacros only cause text substitution for normal code. Other preprocessor commands are ignored. Consequently, the PRINT_JOE in #ifdef PRINT_JOE is left alone.\nFor example:\n#define FOO 9 // Here&#039;s a macro substitution\n \n#ifdef FOO // This FOO does not get replaced because it’s part of another preprocessor directive\n    std::cout &lt;&lt; FOO; // This FOO gets replaced with 9 because it&#039;s part of the normal code\n#endif\nIn actuality, the output of the preprocessor contains no directives at all — they are all resolved/stripped out before compilation, because the compiler wouldn’t know what to do with them.\nThe scope of defines\nOnce the preprocessor has finished, all defined identifiers from that file are discarded. This means that directives are only valid from the point of definition to the end of the file in which they are defined. Directives defined in one code file do not have impact on other code files in the same project.\n宏定义仅在本文件有效，一旦预编译阶段结束，所有宏都将失效。因为，预编译就是将所有的预编译指令都处理掉，该替换的替换（宏展开），该选择的选择，该丢弃的丢弃（条件编译），然后交给编译器去编译，谨记：编译器是读不懂预编译指令的！\nConsider the following example:\nfunction.cpp:\n#include &lt;iostream&gt;\n \nvoid doSomething()\n{\n#ifdef PRINT\n    std::cout &lt;&lt; &quot;Printing!&quot;;\n#endif\n#ifndef PRINT\n    std::cout &lt;&lt; &quot;Not printing!&quot;;\n#endif\n}\nmain.cpp:\nvoid doSomething(); // forward declaration for function doSomething()\n \n#define PRINT\n \nint main()\n{\n    doSomething();\n    return 0;\n}\nThe above program will print:\nNot printing!\n\nEven though PRINT was defined in main.cpp, that doesn’t have any impact on any of the code in function.cpp (PRINT is only defined from the point of definition to the end of main.cpp). This will be of consequence when we discuss header guards in a future lesson.\nHeader files\nCf. www.learncpp.com/cpp-tutorial/header-files/\n对于多文件项目，文件是单独编译的。要想调用一个自定义函数，linker必须能找到这个函数在哪里定义。\nint add(int, int);  // forward declaration\n \nint main()\n{\n    // add(3, 5);\n    return 0;\n}\n上述文件是可以编译通过的，因为没有发生对add的调用，所以linker不会去找add的定义（当然如果要找也找不到）。\n但是如果某处发起了对add的调用（例如去掉注释），那么上述程序在link阶段会报错：\nyychi@~&gt; clang test_linker.cpp\n/usr/bin/ld: /tmp/test_linker-e1bb8b.o: in function `main&#039;:\ntest_linker.cpp:(.text+0x1a): undefined reference to `add(int, int)&#039;\nclang-13: error: linker command failed with exit code 1 (use -v to see invocation)\n在多文件编程时，往往需要forawrd declaration，这些前置声明必须在其他某个地方被定义且只被定义一次。这样，linker才能正确的完成链接。任何重复定义或未定义都会在link阶段报错。\n考虑如下例子：\nadd.cpp:\nint add(int x, int y)\n{\n    return x + y;\n}\nmain.cpp:\n#include &lt;stdio.h&gt;\n \nint add(int, int);\n \nint main()\n{\n    int x = 1, y = 2;\n    int z = add(x, y);\n    printf(&quot;z=%d\\n&quot;, z);\n    return 0;\n}\n在编译main.cpp的时候，因为有add的前置声明，所以可以通过。但为了link的时候能够找到add的定义，add.cpp必须也被编译，所以正确的编译方式应该是：\n$ clang main.cpp add.cpp\nUse of header files\n从上面的论述我们隐约可见，在多文件编程中，我们可能会大量的使用前置声明（forward declaration），一旦文件多起来，这将非常枯燥。所以头文件的出现就是为了解决这个问题：把所有的声明放在一起。\nLet’s write a header file to relieve us of this burden. Writing a header file is surprisingly easy, as header files only consist of two parts:\n\nA header guard.\nThe actual content of the header file, which should be the forward declarations for all of the identifiers we want other files to be able to see.\n\nadd.h:\n// 1) We really should have a header guard here, but will omit it for simplicity (we&#039;ll cover header guards in the next lesson)\n \n// 2) This is the content of the .h file, which is where the declarations go\nint add(int x, int y); // function prototype for add.h -- don&#039;t forget the semicolon!\nmain.cpp:\n#include &quot;add.h&quot; // Insert contents of add.h at this point.  Note use of double quotes here.\n#include &lt;iostream&gt;\n \nint main()\n{\n    std::cout &lt;&lt; &quot;The sum of 3 and 4 is &quot; &lt;&lt; add(3, 4) &lt;&lt; &#039;\\n&#039;;\n    return 0;\n}\nadd.cpp:\n#include &quot;add.h&quot; // Insert contents of add.h at this point.  Note use of double quotes here.\n \nint add(int x, int y)\n{\n    return x + y;\n}\nWhen the preprocessor processes the #include &quot;add.h&quot; line, it copies the contents of add.h into the current file at that point. Because our add.h contains a forward declaration for function add, that forward declaration will be copied into main.cpp. The end result is a program that is functionally the same as the one where we manually added the forward declaration at the top of main.cpp.\nConsequently, our program will compile and link correctly.\n\nTwo wrong cases\n\n如上图所示，会产生一个重复定义的错误。由于add.h中包含了函数定义，而非前置声明。编译main.cpp的时候，add.h中的代码插入到main.cpp中，产生一次add函数的定义。同理，编译add.cpp的时候也定义了一次add函数。link阶段会发生歧义，以致报错。\n此时如果不编译add.cpp其实是可行的：\n\n但谁又能保证只有一个文件#include &quot;add.h&quot;呢？所以头文件中应该只包含声明，而不应该包含实现。\n\nThe primary purpose of a header file is to propagate declarations to code files.\n\nKey insight: Header files allow us to put declarations in one location and then import them wherever we need them. This can save a lot of typing in multi-file programs.\nHeader files should generally not contain function and variable definitions, so as not to violate the one definition rule. An exception is made for symbolic constants (which we cover in lesson 4.15 — Symbolic constants: const and constexpr variables).\n标准库自动链接\n\n注意：clang 不会自动链接，需要手动链接\nclang main.cpp -lstdc++\n\n更新：clang++ 等于 clang -lstdc++，类似的，g++ 等于 gcc -lstdc++.\nWhen it comes to functions and variables, it’s worth keeping in mind that header files typically only contain function and variable declarations, not function and variable definitions (otherwise a violation of the one definition rule could result). std::cout is forward declared in the iostream header, but defined as part of the C++ standard library, which is automatically linked into your program during the linker phase.\n\nThe include order of header files\nCf. www.learncpp.com/cpp-tutorial/header-files/  for “the inclue order of header files”.\nA view of memory and fundamental data types in cpp\nCf. www.learncpp.com/cpp-tutorial/introduction-to-fundamental-data-types/\nThe smallest unit of memory is a binary digit (also called a bit), which can hold a value of 0 or 1. You can think of a bit as being like a traditional light switch — either the light is off (0), or it is on (1). There is no in-between. If you were to look at a random segment of memory, all you would see is …011010100101010… or some combination thereof.\nMemory is organized into sequential units called memory addresses (or addresses for short). Similar to how a street address can be used to find a given house on a street, the memory address allows us to find and access the contents of memory at a particular location.\nPerhaps surprisingly, in modern computer architectures, each bit does not get its own unique memory address. This is because the number of memory addresses are limited, and the need to access data bit-by-bit is rare. Instead, each memory address holds 1 byte of data. A byte is a group of bits that are operated on as a unit. The modern standard is that a byte is comprised of 8 sequential bits.\nData types\nBecause all data on a computer is just a sequence of bits, we use a data type (often called a “type” for short) to tell the compiler how to interpret the contents of memory in some meaningful way. You have already seen one example of a data type: the integer. When we declare a variable as an integer, we are telling the compiler “the piece of memory that this variable uses is going to be interpreted as an integer value”.\nWhen you give an object a value, the compiler and CPU take care of encoding your value into the appropriate sequence of bits for that data type, which are then stored in memory (remember: memory can only store bits). For example, if you assign an integer object the value 65, that value is converted to the sequence of bits 0100 0001 and stored in the memory assigned to the object.\nConversely, when the object is evaluated to produce a value, that sequence of bits is reconstituted back into the original value. Meaning that 0100 0001 is converted back into the value 65.\nFortunately, the compiler and CPU do all the hard work here, so you generally don’t need to worry about how values get converted into bit sequences and back.\nAll you need to do is pick a data type for your object that best matches your desired use.\n谨记：内存只能存bit，只能寻址寻到byte这一层，如果数据按内存边界对齐，寻址会更快（一次读）。\n示例：\nint* p = nullptr;\nprintf(&quot;p=%p\\n&quot;, p); // p=(nil)\nprintf(&quot;p+1=%p\\n&quot;, p+1);  // p+1=0x4\nprintf(&quot;rp+1=%p\\n&quot;, reinterpret_cast&lt;char*&gt;(p) + 1);  // rp+1=0x1\n由于内存地址空间有限，且按bit寻址的场景很少，所以寻址单位一般是byte。A byte is a group of bits that are operated on as a unit. The modern standard is that a byte is comprised of 8 sequential bits.\n移位\n#include &lt;cstdint&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n \nstatic void print(int32_t a, uint32_t b, size_t n_shift)\n{\n    cout &lt;&lt; &quot;a=&quot; &lt;&lt; a &lt;&lt; &quot;; b=&quot; &lt;&lt; b &lt;&lt; endl;\n \n    cout &lt;&lt; &quot;left shift &quot; &lt;&lt; n_shift &lt;&lt; &quot; bit(s) of a is: &quot; &lt;&lt; (a &lt;&lt; n_shift) &lt;&lt; endl;\n    cout &lt;&lt; &quot;left shift &quot; &lt;&lt; n_shift &lt;&lt; &quot; bit(s) of b is: &quot; &lt;&lt; (b &lt;&lt; n_shift) &lt;&lt; endl;\n    cout &lt;&lt; &quot;right shift &quot; &lt;&lt; n_shift &lt;&lt; &quot; bit(s) of a is: &quot; &lt;&lt; (a &gt;&gt; n_shift) &lt;&lt; endl;\n    cout &lt;&lt; &quot;right shift &quot; &lt;&lt; n_shift &lt;&lt; &quot; bit(s) of b is: &quot; &lt;&lt; (b &gt;&gt; n_shift) &lt;&lt; endl;\n}\n \nint main()\n{\n    int32_t a = 0xffffffff;\n    uint32_t b = 0xffffffff;\n    print(a, b, 1);\n    cout &lt;&lt; &quot;------------\\n&quot;;\n    print(0xbfffffff, b, 1);\n    return 0;\n}\n \n/**\n * Output on my machine:\n \na=-1; b=4294967295\nleft shift 1 bit(s) of a is: -2\nleft shift 1 bit(s) of b is: 4294967294\nright shift 1 bit(s) of a is: -1\nright shift 1 bit(s) of b is: 2147483647\n------------\na=-1073741825; b=4294967295\nleft shift 1 bit(s) of a is: 2147483646\nleft shift 1 bit(s) of b is: 4294967294\nright shift 1 bit(s) of a is: -536870913\nright shift 1 bit(s) of b is: 2147483647\n \n */\n从内存连续bit来看，a和b都是存了4 byte的1，区别仅仅是data type不一样，导致了截然不同的结果。\n移位操作\n\n右移\n\n无符号右移，低位丢失高位补0\n有符号右移，低位丢失，高位补符号位（正为0, 负为1）\n\n\n左移：高位丢失，低位补0\n\na和b左移一位都得到：\n0xfffffffe: 如果是int解释为-2, unsigned int解释为4294967294=2^32 - 2\n\na右移一位得到\n0xffffffff: 注意负数右移，高位补1，int解释为-1\n\nb右移一位得到\n0x7fffffff: 高位补0, unsigned int解释为2147483647=2^31-1\n\n注意，负的可能左移成正的，因此，有符号的移位是不安全的。\n#include &lt;iostream&gt;\n \nint main()\n{\n    signed int s { -1 };\n    unsigned int u { 1 };\n \n    if (s &lt; u) // -1 is implicitly converted to 4294967295, and 4294967295 &lt; 1 is false\n        std::cout &lt;&lt; &quot;-1 is less than 1\\n&quot;;\n    else\n        std::cout &lt;&lt; &quot;1 is less than -1\\n&quot;; // this statement executes\n \n    return 0;\n}\nNOTE:\n\n注意无符号数相减得负数会导致溢出\nusigned和--运算符，可能减至负数溢出\n除非确定变量值非负，否则尽量避免使用unsigned\n切忌不要在数学计算中混用unsigned和signed，此时signed会隐式转换为unsigned\nunsigned numbers are preferred when dealing with bit manipulation\nstd::int8_t和std::uint8_t可能知识char和unsigned char的别名，可能有坑（参考：www.learncpp.com/cpp-tutorial/introduction-to-type-conversion-and-static_cast/）\n\nBest practice\nFavor signed numbers over unsigned numbers for holding quantities (even quantities that should be non-negative) and mathematical operations. Avoid mixing signed and unsigned numbers.\n字节序\n链接\nInline function\n考虑如下场景，有一段代码很独立，适合抽成一个函数，但你又担心函数调用开销，此时inline function就是你的最佳选择。关于合适使用inline function，下面这段话给了一定的意见：\n\nFor functions that are large and/or perform complex tasks, the overhead of the function call is typically insignificant compared to the amount of time the function takes to run. However, for small functions, the overhead costs can be larger than the time needed to actually execute the function’s code! In cases where a small function is called often, using a function can result in a significant performance penalty over writing the same code in-place.\n\nInline function的好处包括：\n\n没有函数调用的开销\n编译器对展开后的代码有更大的优化空间（如常量替换）\n\nHowever, inline expansion has its own potential cost: if the body of the function being expanded takes more instructions than the function call being replaced, then each inline expansion will cause the executable to grow larger. Larger executables tend to be slower (due to not fitting as well in caches).\n\n注意：inline只是对编译器的一个建议，是否会真的展开取决于编译器的优化策略。\n\nHowever, in modern C++, the inline keyword is no longer used to request that a function be expanded inline. There are quite a few reasons for this:\n\nUsing inline to request inline expansion is a form of premature optimization, and misuse could actually harm performance.\nThe inline keyword is just a hint — the compiler is completely free to ignore a request to inline a function. This is likely to be the result if you try to inline a lengthy function! The compiler is also free to perform inline expansion of functions that do not use the inline keyword  as part of its normal set of optimizations.\nThe inline keyword is defined at the wrong level of granularity. We use the inline keyword on a function declaration, but inline expansion is actually determined per function call. It may be beneficial to expand some function calls and detrimental to expand others, and there is no syntax to affect this.\n\n注意：在modern cpp中，用inline修饰的不违反ODR（one definition rule），因此可用于\n\n头文件中修饰常量作为global const的最佳方案1\n头文件中修饰constexpr函数2使所有include该文件的源文件都能使用该函数，注意constexpr函数是默认inline的\n\n\nAllowing functions with a constexpr return type to be evaluated at either compile-time or runtime was allowed so that a single function can serve both cases. Otherwise, you’d need to have separate functions (a constexpr version and a non-constexpr version) — and since return type isn’t considered in function overload resolution, you’d have to name the functions different things!\nA constexpr function that is eligible to be evaluated at compile-time will only be evaluated at compile-time if the return value is used where a constant expression is required. Otherwise, compile-time evaluation is not guaranteed.\nThus, a constexpr function is better thought of as “can be used in a constant expression”, not “will be evaluated at compile-time”.\n\nUnnamed namespace\nAn unnamed namespace (also called an anonymous namespace) is a namespace that is defined without a name, like so:\n#include &lt;iostream&gt;\n \nnamespace // unnamed namespace\n{\n    void doSomething() // can only be accessed in this file\n    {\n        std::cout &lt;&lt; &quot;v1\\n&quot;;\n    }\n}\n \nint main()\n{\n    doSomething(); // we can call doSomething() without a namespace prefix\n \n    return 0;\n}\n特点：\n\nAll content declared in an unnamed namespace is treated as if it is part of the parent namespace.\nAll identifiers inside an unnamed namespace are treated as if they had internal linkage.\n\n解决的问题：Unnamed namespaces will also keep user-defined types (something we’ll discuss in a later lesson) local to the file, something for which there is no alternative equivalent mechanism to do.\nAbout switch clause\nPut another way, defining a variable without an initializer is just telling the compiler that the variable is now in scope from that point on. This happens at compile time, and doesn’t require the definition to actually be executed at runtime.\nint calculate(int x, int y, char op)\n{\n    int ret = 0;\n    switch (op)\n    {\n    case &#039;+&#039;:\n        return x + y;\n        case &#039;-&#039;:\n        return x - y;\n        case &#039;*&#039;:\n        return x * y;\n        case &#039;/&#039;:\n        return x / y;\n        case &#039;%&#039;:\n        return x % y;\n        default:\n        throw std::invalid_arguments(&quot;invalid operator&quot;);\n    }\n}\n避免大量栈分配\n程序在运行期间，函数内的局部变量存储在栈中，而栈的总量是有限的。局部变量占用的栈空间过大时，可能导致栈溢出。在定义函数需要充分考虑单个函数及全调用栈的开销，并对函数中的局部变量大小进行一定限制，避免因占用过多的栈空间导致程序运行失败。\n宏里面使用完整括号。\nReferences\n\n理解字节序\n\nFootnotes\n\n\n6.9 — Sharing global constants across multiple files (using inline variables) ↩\n\n\n6.14 — Constexpr and consteval functions ↩\n\n\n"},"notes/cpp/gdb基础":{"slug":"notes/cpp/gdb基础","filePath":"notes/cpp/gdb基础.md","title":"GDB 基本用法","links":["__zettel/202502181657gdb-attach.html"],"tags":["debug","gdb","cpp"],"content":"废话以后有时间再加。\n首先编译时开启调试选项：\ng++ main.cpp -g -O0\n-O0指定编译器的优化级别为0，即不优化。\n\n然后编译出来的可执行文件，默认名字是a.out. 直接了当，用gdb打开之，\ngdb a.out\n要调试必然要打断点，两种方式：指定行数；指定函数。\n(gdb) break 10  // create breakpoint at line 10\n(gdb) break main  // create breakpoint at the entrance of main\n使用list在gdb中查看代码块以确定你要在哪一行设置断点（这就很麻烦，所以一般直接在main函数打个断点，然后单步去run）。\n设好断点以后，使用run启动程序，程序会在断点处停顿，等待你的输入指令。\n\n使用next进行单步执行，使用step步入。所谓步入就是如果有函数调用，程序会跟踪到所调用的函数内部的代码，而单步的话，则会直接完成函数调用，获得返回值（如果有的话）。\n使用info locals查看栈变量的值，使用info args查看函数传入参数的值。使用print &lt;variable&gt;查看指定变量的值。\n备注\n\nGDB里面的命令都有缩写（break=b, next=n, step=s, …）\n什么命令也不敲直接回车默认执行上一条命令\n使用help &lt;command&gt;来获取相关命令的使用帮助\n\n\n1.1 绑定进程\nsudo sysctl -w kernel.yama.ptrace_scope=0  # 开启attach debug的必要条件\n \ngdb &lt;bin&gt;         # GDB运行一个二进制，用于调试使用\ngdb attach &lt;pid&gt;  # 绑定正在运行的进程，原则上禁止直接attach线上进程\ngdb &lt;bin&gt; &lt;pid&gt;\ngdb -p &lt;pid&gt;\n \n# eg\ngdb -p `pidof firefox`\n202502181657gdb-attach\n1.2 查看代码\n\n查看程序代码\n\n&gt; dir &lt;source_directory&gt;  # 添加cpp原文件目录\n&gt; l                       # 默认显示暂停处代码，一直执行l会向下滚动显示\n&gt; l  &lt;function&gt;           # 显示函数代码\n&gt; l  &lt;file:function&gt;      # 显示文件中某函数代码\n&gt; l  &lt;file:line&gt;          # 显示文件中指定行数代码\n\n查看汇编指令\n\n&gt; disass                  # 显示当前汇编指令\n1.3 断点\n\n断点设置\n\n&gt; b &lt;file:line&gt;                   # 设置文件中某行断点\n&gt; b &lt;file:function&gt;               # 设置文件中某函数断点\n&gt; b &lt;namespace::class::function&gt;  # 设置某类的成员函数断点\n&gt; b &lt;location&gt; &lt;thread-id&gt;        # 设置某个线程在某处的断点 \n&gt; b &lt;location&gt; if &lt;condition&gt;     # 设置某处的条件断点\n\n断点查看\n\n&gt; info b                          # 查询所有断点\n\n断点删除/启用/禁用\n\n&gt; d &lt;break-id&gt;                    # 删除某断点\n&gt; disable  &lt;break-id&gt;             # 禁用某断点\n&gt; enable  &lt;break-id&gt;              # 启用某断点\n\n断点设置自动执行命令\n\n&gt; command &lt;break-id&gt;\n&gt; p &lt;var&gt;                         # 运行到断点处时自动打印变量&lt;var&gt;\n&gt; end\n1.4 打印变量\n\nprint打印\n\n&gt; p &lt;expr&gt;              # 打印变量&lt;var&gt;\n&gt; p &lt;var&gt;=&lt;value&gt;       # GDB过程中更改某个变量的值\n\ndisplay打印\n\n&gt; display &lt;expr&gt;        # 打印某个变量或表达式，expr 表示要查看的目标变量或表达式\n&gt; display/fmt &lt;expr&gt;    # 参数 fmt用于指定输出变量或表达式的格式\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/fmt功 能/x以十六进制的形式打印出整数。/d以有符号、十进制的形式打印出整数。/u以无符号、十进制的形式打印出整数。/o以八进制的形式打印出整数。/t以二进制的形式打印出整数。/f以浮点数的形式打印变量或表达式的值。/c以字符形式打印变量或表达式的值。\n\ndisplay和print区别在于，display会一直打印某个值\n\n\n打印protobuf message\n\n&gt; p &lt;var&gt;.DebugString()   # 使用DebugString()将proto对象内部结构打印出来\n\n打印内存地址\n\n# n：为正整数，表示需要打印的内存单元个数\n# \n# f：打印格式， 如下\n# - x: 十六进制\n# - d: 十进制\n# - u: 十六进制\n# - o: 八进制\n# - t: 二进制\n# - a: 十六进制\n# - c: 字符格式\n# - f: 浮点数\n# \n# u: 内存单元大小，如下：\n# - b: 单字节\n# - h: 双字节\n# - w: 四字节\n# - g: 八字节\n&gt; x/&lt;n/f/u&gt; &lt;addr&gt;  \t# addr: 要打印的内存地址\n\ndump内存内容至文件\n\n# 将start_addr至end_addr的内存内容以二进制形式dump到file文件，file文件名自定义即可\n&gt; dump binary memory &lt;file&gt; &lt;start_addr&gt; &lt;end_addr&gt;\n\n打印长字符串\ngdb会限制打印字符串的最大长度。使用下列命令可修改限制。\n\n&gt; show print elements     # 显示字符串最大打印长度\n&gt; set print elements 0    # 取消字符串最大打印长度\n\n打印CPU寄存器的值\n\n&gt; i r                     # 打印所有寄存器的值\n&gt; i r es                  # 打印寄存器es的值\n1.5 线程调试\n# 可事先dump某个进程下所有线程的thread id和backtrace，方便gdb调试\npstack &lt;pid&gt;\n&gt; info threads                # 查看当前所有线程信息\n&gt; bt                          # 查看当前线程的backtrace\n&gt; bt full                     # 查看当前线程更详细的backtrace(每个栈帧上的参数)\n&gt; thread &lt;thread-id&gt;          # 切换到某一个线程\n&gt; set scheduler-locking on    # 多线程环境下，只有当前被调试线程会执行\n&gt; set scheduler-locking off   # 多线程环境下，除当前被调试线程之外的其他线程也在同步执行\n&gt; set scheduler-locking step\n \n# 多线程环境下，对当前被调试线程用step调试时，其他线程不会执行；使用next调试时，其他线程也许会执行\n1.6 运行控制\n&gt; r arg1 arg2 ...             # 重新开始运行二进制，如果需要传入参数内需要arg1 arg2...\n&gt; stop                        # 暂停运行\n&gt; c                           # 继续执行(continue)\n&gt; n                           # 单步执行(next)，遇到函数则跳过\n&gt; s                           # 单步执行(step)，遇到函数则跳入函数体\n&gt; finish                      # 运行直到跳出当前函数\n&gt; until line                  # 运行直到到达指定行\n&gt; call command                # 运行C++命令\n&gt; shell                       # 进入shell模式，回到linux终端\n&gt; exit                        # 退出shell模式，回到gdb命令行\n&gt; set $var=XXX                # 设置gdb变量\n&gt; set var=XXX                 # 设置程序中变量\n1.7 结束调试\n# gdb二进制时，使用q/quit退出\n&gt; q\n&gt; quit\n# gdb attach进程时，使用detach退出\n&gt; detach\n1.8 调试core\n一般情况下，当设置了ulimit -c unlimited之后，当程序遇到异常时，会自动转储core文件（即crash时会dump core文件），方便开发者查看分析现场。\n但是，如果想对一个正常运行的进程进行转储, 可使用gcore命令：\ngcore &lt;pid&gt;       # 将进程&lt;pid&gt;转储到core文件中\n调试core文件\n# 调试core文件，两个gdb命令都可\ngdb bin core\ngdb -c core bin\n&gt; bt full         # 查看异常的backtrace\n1.9 开启日志\ngdb默认不开启日志。可使用如下命令开启\n&gt; set logging on   # 设置gdb日志开启，gdb会在当前目录下生成gdb.txt记录gdb命令行所有输出结果，方便回溯历史。\n参考：\n\nlinuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html\n100个gdb小技巧\n"},"notes/cpp/sdg-notes":{"slug":"notes/cpp/sdg-notes","filePath":"notes/cpp/sdg-notes.md","title":"sdg-notes","links":["notes/cpp/内存布局.html"],"tags":[],"content":"sdg-notes\n __    __               __           __               ____    ___                       \n/\\ \\  /\\ \\             /\\ \\      __ /\\ \\             /\\  _`\\ /\\_ \\                      \n\\ `\\`\\\\/&#039;/__  __    ___\\ \\ \\___ /\\_\\\\ \\/      ____   \\ \\ \\L\\ \\//\\ \\     ___      __     \n `\\ `\\ /&#039;/\\ \\/\\ \\  /&#039;___\\ \\  _ `\\/\\ \\\\/      /&#039;,__\\   \\ \\  _ &lt;&#039;\\ \\ \\   / __`\\  /&#039;_ `\\   \n   `\\ \\ \\\\ \\ \\_\\ \\/\\ \\__/\\ \\ \\ \\ \\ \\ \\      /\\__, `\\   \\ \\ \\L\\ \\\\_\\ \\_/\\ \\L\\ \\/\\ \\L\\ \\  \n     \\ \\_\\\\/`____ \\ \\____\\\\ \\_\\ \\_\\ \\_\\     \\/\\____/    \\ \\____//\\____\\ \\____/\\ \\____ \\ \n      \\/_/ `/___/&gt; \\/____/ \\/_/\\/_/\\/_/      \\/___/      \\/___/ \\/____/\\/___/  \\/___L\\ \\\n              /\\___/                                                             /\\____/\n              \\/__/                                                              \\_/__/ &#039;`\n\nepll/wait: reactor模式：不停轮询，发现有事做，就做！\nasio: proactor模式，先注册好事件，如果事情发生了，通过回调函数处理。\n互斥\n所有线程共享一个共同的的时间（不必是同一个公共时钟）。一个线程是一个状态机，其状态的转换称为事件。\n两个线程在“start of danger zone”那一行读了value域的值，随后又都在“end of danger zone”那一行修改了value域的值。这就造成了data race. 我们将这两行代码放入临界区内：某个时刻仅能被一个线程执行的代码段。\n如果一个线程满足下列条件，则称它是良构的：\n\n一个临界区只和唯一的mutex对象相关联，\n线程准备进入临界区时申请占有mutex，\n线程离开临界区时申请释放mutex。\n\n自旋锁与争用\n任何互斥协议都会产生这样的问题：如果不能获得锁，应该怎么做？对此有两种选择。一种方案是让其继续进行尝试，这种锁称为自旋锁，对锁的反复测试过程称为旋转或忙等待。在希望锁延迟较短的情形下，选择旋转的方式比较合乎情理。另一种方案就是挂起自己，请求操作系统调度器在处理器上调度另外一个线程，这种方式称为阻塞。由于从一个线程切换到另一个线程的代价比较大，所以只有在允许锁延迟较长的情形下，阻塞才有意义。许多操作系统将这两种策略综合起来使用，先旋转一个小的时间段然后再阻塞。旋转和阻塞都是重要的技术。\n争用指多个线程试图同时获得一个锁；高争用则意味着存在大量正在争用的线程；低争用的意思与高争用相反。\n小米面经之二\n\n自我介绍，实习工作内容\n局部静态对象和全局静态对象有什么区别\n进程间通信的方式\n有哪些同步原语\n堆内存和栈内存的区别\nint a, *b;有什么区别？（考察指针默认不开辟内存）\n\n函数模板\n6.2.4 重载与特化\n​ 为编译到函数模板的调用，编译器必须在非模板重载、模板重载和模板重载的特化间决定。\ntemplate&lt; class T &gt; void f(T);              // #1 ：模板重载\ntemplate&lt; class T &gt; void f(T*);             // #2 ：模板重载\nvoid                     f(double);         // #3 ：非模板重载\ntemplate&lt;&gt;          void f(int);            // #4 ： #1 的特化\n \nf(&#039;a&#039;);        // 调用 #1\nf(new int(1)); // 调用 #2\nf(1.0);        // 调用 #3\nf(1);          // 调用 #4\n​ 注意只有非模板和初等模板重载参与重载决议。特化不是重载，且不受考虑。只有在重载决议选择最佳匹配初等函数模板后，才检验其特化以查看何为最佳匹配。\ntemplate&lt; class T &gt; void f(T);    // #1 ：所有类型的重载\ntemplate&lt;&gt;          void f(int*); // #2 ：为指向 int 的指针特化 #1\ntemplate&lt; class T &gt; void f(T*);   // #3 ：所有指针类型的重载\n \nf(new int(1)); // 调用 #3 ，即使通过 #1 的特化会是完美匹配\n​ 即重载的优先级要高于特化。\n​ 关于模板函数重载的更多内容，参考function_template。\nmemcpy 和 memmove 的区别\nmemcpy不能应对内存重叠，memmove可以。详见man pages.\n编写多线程需要注意的点\n\n在脑中先大致想好每个线程的工作是什么，什么时候开始，什么时候结束。\n捋清楚了之后再开始动手写。\n\n调用t.join()的作用类似于，如果线程结束，主线程执行到join就可以立即返回，如果线程为结束，主线程执行到join会阻塞，直到线程结束。然后主线程继续执行。\n            main  thread1\n              +      +\n              |      |\n              |      |\n              |      |\n              |      |\nthread1.join()+------+\n              |\n              |\n              |\n              v\n\n如果某线程申请占有互斥量时，该互斥量被其他线程占有，则会引起该线程阻塞。观察者模式在计算机系统中使用甚广。\n线程安全性两个主要保证：\n\n原子操作\nCAS操作\n\n使用std::conditional_variable注意事项\n\n调用wait的线程必须占有mutex，否则undefined\n所有并发线程（如果使用同一个条件变量交互）必须使用同一个mutex，否则undefined\n\n使用std::thread注意事项\n\nthread对象构造完成即开始执行\n使用detach之后，程序失去该线程的控制权，线程结束之后资源全部释放\n使用detach之后，主线程结束时，所有资源都被释放，即便该线程还未停止\n线程之间没有父/子关系。如果线程A创建线程B，然后线程A终止，则线程B将继续执行。但如果主线程终止，则整个进程终止，自然进程下的所有线程都终止，资源释放\nAny thread can potentially access any object in the program (objects with automatic and thread-local storage duration may still be accessed by another thread through a pointer or by reference).\n\n使用std::atomic注意事项\n\natomic is neither copyable nor movable\nmutex is neither copyable nor movable\n\n加一次锁耗时大概25ns，使用lock-free的话能够提高到十几纳秒，事实上提升不大。加锁并没有想象中那么耗时，提高效率的关键是减少锁的碰撞。即一个线程占有锁的时候，其他线程不会去申请锁，因为在锁被占用的情况下去申请锁比较耗时，会先去loop一段时间，拿不到锁才会进入内核陷入睡眠等待锁，这样的耗时是比较浪费的。所以关键要减少锁的碰撞。\n有原子的函数吗，就是要么执行成功，要么失败？\n不存在，一个函数内部多少指令，在多线程的情况下，很难保证可以全部的顺序的原子的执行完成。\nFrom Shuo’s blog\n依据《Java 并发编程实践》/《Java Concurrency in Practice》一书，一个线程安全的 class 应当满足三个条件：\n\n从多个线程访问时，其表现出正确的行为\n无论操作系统如何调度这些线程，无论这些线程的执行顺序如何交织\n调用端代码无需额外的同步或其他协调动作\n\n对象构造要做到线程安全，惟一的要求是在构造期间不要泄露 this 指针，即\n\n不要在构造函数中注册任何回调\n也不要在构造函数中把 this 传给跨线程的对象\n即便在构造函数的最后一行也不行\n\n作为 class 数据成员的 Mutex 只能用于同步本 class 的其他数据成员的读和写，它不能保护安全地析构。因为成员 mutex 的生命期最多与对象一样长，而析构动作可说是发生在对象身故之后（或者身亡之时）。另外，对于基类对象，那么调用到基类析构函数的时候，派生类对象的那部分已经析构了，那么基类对象拥有的 mutex 不能保护整个析构过程。\n不要在ctor里调用虚函数\n总结来说：基类部分在派生类部分之前被构造，当基类构造函数执行时派生类中的数据成员还没被初始化。如果基类构造函数中的虚函数调用被解析成调用派生类的虚函数，而派生类的虚函数中又访问到未初始化的派生类数据，将导致程序出现一些未定义行为和bug。\nctor应该设计的尽量简单，确保对象可以被正确构造。在ctor中调用本类的非静态成员都是不安全的，因为他们还没被构造，而有些成员是依赖对象的，而此时对象还没有被成功构造。\nctor不能是虚函数\n\n\n从存储空间角度：虚函数对应一个vtable（虚函数表），这大家都知道，可是这个vtable其实是存储在对象的内存空间的。问题出来了，如果构造函数是虚的，就需要通过 vtable来调用，可是对象还没有实例化，也就是内存空间还没有，无法找到vtable，所以构造函数不能是虚函数。\n\n\n从使用角度：虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义呀。所以构造函数没有必要是虚函数。\n\n\n虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。\n\n构造函数不需要是虚函数，也不允许是虚函数，因为创建一个对象时我们总是要明确指定对象的类型，尽管我们可能通过实验室的基类的指针或引用去访问它。但析构却不一定，我们往往通过基类的指针来销毁对象。这时候如果析构函数不是虚函数，就不能正确识别对象类型从而不能正确调用析构函数。\n\n④从实现上看，vbtl在构造函数调用后才建立，因而构造函数不可能成为虚函数  \n  从实际含义上看，在调用构造函数时还不能确定对象的真实类型（因为子类会调父类的构造函数）；而且构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数\n⑤当一个构造函数被调用时，它做的首要的事情之一是初始化它的V P T R。因此，它只能知道它是“当前”类的，而完全忽视这个对象后面是否还有继承者。当编译器为这个构造函数产生代码时，它是为这个类的构造函数产生代码- -既不是为基类，也不是为它的派生类（因为类不知道谁继承它）。\n————————————————\n版权声明：本文为CSDN博主「cainiao000001」的原创文章，遵循CC 4.0 by-sa版权协议，转载请附上原文出处链接及本声明。\n原文链接：blog.csdn.net/cainiao000001/article/details/81603782\n虚函数的工作原理\nzhuanlan.zhihu.com/p/60543586\nC++ 规定了虚函数的行为，但将实现方法留给了编译器的作者。不需要知道实现方法也可以很好的使用虚函数，但了解虚函数的工作原理有助于更好地理解概念。\n通常，编译器处理虚函数的方法是：给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。\n这种数组称为虚函数表（Virtual Function Table, vtbl）。\n虚函数表是一个数组，数组的元素是指针，指针指的是虚函数的地址。\n具有虚函数的类的实例，都会在头部存一个指向虚函数表的指针。\n常见类型所占空间大小\n单位：bytes\n\n(unsigned) int: 4\n(unsigned) short: 2\n(unsigned) long: 8\nfloat: 4\ndouble: 8\nlong double: 16\n(unsigned) char: 1\nbool: 1\n\n指针占几个字节 指针即为地址，指针几个字节跟语言无关，而是跟系统的寻址能力有关，譬如以前是16为地址，指针即为2个字节，现在一般是32位系统，所以是4个字节，以后64位，则就为8个字节。\n析构函数的调用\nThe destructor is called whenever an object’s lifetime ends, which includes\n\nprogram termination, for objects with static storage duration\nthread exit, for objects with thread-local storage duration\nend of scope, for objects with automatic storage duration and for temporaries whose life was extended by binding to reference\ndelete-expressin, for objects with dynamic storage duration\nend of the full expression, for nameless temporaries\nstack unwinding (栈回溯), for objects with automatic storage duration when an exception escapes their block, uncaught.\n\nc.f. en.cppreference.com/w/cpp/language/destructor\n几个常用的宏\n\n__func__: name of an function, exists in C99/C++11 (__FUNCTION__ is non standard)\n__LINE__: line number of the code\n__FILE__: filename of the file\n__DATE__ and __TIME__: as you wish\n\nJoseph Ring\n牛客网上类似的题：\nwww.nowcoder.com/questionTerminal/f78a359491e64a50bce2d89cff857eb6\n描述：人们站在一个等待被处决的圈子里。 计数从圆圈中的指定点开始，并沿指定方向围绕圆圈进行。 在跳过指定数量的人之后，执行下一个人。 对剩下的人重复该过程，从下一个人开始，朝同一方向跳过相同数量的人，直到只剩下一个人，并被释放。\n问题即，给定人数、起点、方向和要跳过的数字，选择初始圆圈中的位置以避免被处决。\n解法：维基百科上也有，GeeksforGeeks还有视频教程。\nen.wikipedia.org/wiki/Josephus\\_problem\nwww.geeksforgeeks.org/josephus-problem-set-1-a-on-solution/\n常见的有两种解法：\n\n单链表模拟\n数学递推⇒递归求解\n\n显然，假设n个人编号：0,1,2,3,…,n-1. 从0号开始报数（报数从0开始），报到m-1的将被处决，然后从下一个人开始报数。直到剩下最后一个人，赦免之。\n第一趟：报到m的自然是编号为(m-1)%n.\n接着从 m%n 开始报数，接下来又会是谁被处决呢？\n等等，先来看看问题是什么，我希望知道幸免者的编号。在n个人，报m个数的设定下，我希望知道幸免者编号，假设这个编号就是f(n,m).\n在第一趟之后，报数从编号k=m%n开始，但是此时只有n-1个人，我还是想知道幸存者的编号。如果此时将编号重新映射一下，比如：\nk   -&gt; 0\nk+1 -&gt; 1\n...\nk-2 -&gt; n-2\n\n那么问题就变成了n-1个人，从0开始报数，报到m-1被处决，完完全全成了一个拥有同样结构的问题，但是规模更小了。显然，这个问题的解是 f(n-1, m). 但是呢，我们得到的编号却不是原来的编号了，得把编号还原回去。这很简单，假设得到的编号是x，那么映射回原编号x’\nx&#039; = (x+k)%n\n\n于是，如果我们能够知道 f(n-1, m), 那么 f(n, m) = (f(n-1,m) + m)%n. 这就得到了递推公式。接着看一下边界条件，当n = 1时， f(1, m) = 0; 结束。\nC++内存布局\n结构体\nC++规范在“结构”上使用了和C相同的，简单的内存布局原则：成员变量按其被声明的顺序排列，按具体实现所规定的对齐原则在内存地址上对齐。\nstruct S {\n    char a;     // memory location #1\n    int b : 5;  // memory location #2\n    int c : 11, // memory location #2 (continued)\n          : 0,\n        d : 8;  // memory location #3\n    struct {\n        int ee : 8; // memory location #4\n    } e;\n} obj; // The object &#039;obj&#039; consists of 4 separate memory locations\n\n类的静态成员不占用类的空间，静态成员在程序数据段中。\n\nUDP介绍\n\n摘自《计算机网络 第四版》\n\nUDP面向无连接，它传输的数据段（segment）是由8字节的头和净荷域构成的。头包含源端口和目标端口，各占16位，共4字节。两个端口分别被用来标识源机器和目标机器内部的端点。当一个UDP分组到来的时候，它的净荷部分被递交给与目标端口相关联的那个进程。这种关联关系是在调用了bind原语或者其他某一种类似的做法之后建立起来的。实际上，采用UDP而不是原始的IP，其最主要的价值是增加了源端口和目标端口。如果没有端口域，则传输层将不知道该如何处理分组；而有了端口之后，它就可以正确地提交数据段了。\n当目标端必须将一个应答送回给源端地时候，源端口是必须地。发送应答的进程只要将进来的数据段中的source port域复制道输出的数据段中的destination port域，就可以指定在发送方机器上由哪个进程来接受应答。\n另外值得提出来的可能是UDP没有做到一些事情。UDP并不考虑流控制、错误控制，在收到一个坏的数据段之后它也不重传。所有这些工作都留给用户进程。UDP所作的事情就是提供一个接口，并且在接口中增加复用（demultiplexing）的特性。他利用端口的概念将数据段解复用到多个进程中。这就是它所做的全部工作。\nUDP尤其适用域C-S架构下，客户端给服务器发送一个短的请求，并且期望一个短的应答回来，如果请求或者应答丢失，只需要超时重传。\nUDP的一个应用时DNS（Domain Name System），简单来说，如果一个程序需要根据某一个主机名（比如www.cs.berkeley.edu）来查找它的IP地址，那么，它可以给DNS服务器发送一个包含该主机名的UDP分组。服务器用一个包含该主机IP地址的UDP分组作为应答。实现不需要建立连接，事后也不需要释放连接。在网络上只要两条消息就够了。DNS在进行区域传输(主从dns server之间的数据同步)的时候使用TCP，普通的查询使用UDP。因为普通查询数据量小，比较适合用udp这种速度更快。\nRPC\n从某种意义上讲，向一台远程主机发送一个消息并获得一个应答，就如同在编程语言中执行一个函数调用一样。在这两种情况下，你都要提供一个或多个参数，然后获得一个结果。这种现象导致人们试图将网络上的请求-应答交互过程，做成像过程调用那样可以进行类型匹配和转换。这样的结构是的网络应用更加易于编程，而且人们对这种处理方式也更加熟悉。例如，假设有一个名为getIPaddress(hostname)的过程，它的工作方式为：向DNS服务器发送一个UDP分组，然后等待应答，如果在规定的时间内没有接收到应答的话，则超时并重试。通过这种方式，网络的所有细节对于程序员而言全部隐藏。\n这个领域中的关键工作由Birrel和Nelson（1984）完成。简单来说：允许本地的程序调用远程主机上的过程。当机器A上的进程调用机器B上的一个过程的时候，机器A上的调用进程被挂起，而机器B上被调用的过程则开始执行。参数信息从调用方传输到被调用方，而过程的执行结果则从反方向传递回来。对于程序员而言，所有的消息传递都是不可见的。这项技术称为RPC（Remote Procedure Call），目前已成为许多网络应用的基础。按照传统，调用过程称为客户，被调用过程称为服务器。\n当然，RPC不一定非得使用UDP分组，但是，RPC和UDP是一对很好的搭档，而且，UDP常常被用于RPC。然而，当参数或者结果值可能超过最大的UDP分组的时候，或者当所请求的操作并不幂等（即不能安全地重复多次执行，比如计数器递增地操作）的时候，可能有必要建立一个TCP连接，然后利用该连接来发送请求，而不是使用UDP来完成远程调用。\nRTC\nUDP的还被广泛应用在实时多媒体：Internet广播电台、Internet电话、音乐点播、视频会议、视频点播等。人们发现每一种应用都在重复设计几乎相同的实时传输协议，逐渐地人们意识到，为多媒体应用制定一个通用的协议是一个很好的想法，因此就诞生了RTP（Real-time Transport Protocol）。\nTCP介绍\nUDP是一个简单的协议，它有一些非常合适的用途。但是对于大多数Internet应用来说，他们更需要可靠的，按序递交的特性。所以还需要另一个协议，这就是TCP，目前它是Internet上承担任务最为繁重的一个协议。\nTCP是专门为了在不可靠的互联网上提供一个可靠的端到端字节流而设计的。每台支持TCP的机器都有一个TCP传输实体，它或者是一个库过程，或者是一个用户进程，或者是内核的一部分。在所有这些情形下，它管理TCP流，以及与IP层之间的接口。TCP传输实体接受本地进程和用户数据流，并且将他们分割成不超过64KB（在实践中，考虑到每个帧中都希望有IP和TCP头，所以通常不超过1460数据字节）的分片，然后以单独的IP数据报的形式发送每一个分片。当包含TCP数据的数据报到达一台机器的时候，他们被递交给TCP传输实体，然后TCP传输实体再重构出原始的字节流。\nIP层并不保证数据报一定被正确的递交到目标端，所以TCP需要判断超时的情况，并且需要根据需要重传数据报。即使被正确递交的数据报，也可能存在错序的问题，这也是TCP的责任，他必须把接收到的数据报按照正确的顺序重新装配成用户消息。\nTCP服务模型\n要想获得TCP服务，发送方和接收方必须创建一种被称为套接字的端点。每个套接字有一个套接字号（地址），它是由主机的IP地址以及本地主机局部的一个16为数值组成的，此16为数值被称为端口（port）。端口是一个TSAP的TCP名字。为了获得TCP服务，首先必须要显示的再发送机器的套接字和接受机器的套接字之间建立一个连接。\n一个套接字有可能同时被用于多个连接。换句话说，两个或者多个连接可能终止与同一个套接字。每个连接可以用两端的套接字标识符来标识，即（socket1, socket2）。TCP不适用虚电路号或者其他的标识符。\n1024以下的端口号被称为知名端口（well-known port），其实就是系统保留端口，有很多约定的服务和特定的端口号对应，如ssh默认端口号是22.\n所有的TCP连接都是全双工的，并且是点到点的。所谓全双工，意味着同时可在两个方向上传输数据；二点到点则意味着每个连接恰好有两个端点。TCP并不支持多播或者广播传输模式。\n一个TCP连接就是一个字节流，而不是消息流。端到端之间并不比保留消息的边界。例如，如果发送进程将4个512字节的数据块写到一个TCP流中，那么在接收进程中，这些数据有可能按4个512字节快的方式被递交，也可能是2个1024字节的数据块，或是一个2048字节的数据块，或者其他方式。接收方无法获知这些数据被写入字节流时候的单元大小。\n正如Unix中文件一样，读文件的程序无法判断该文件是怎么写成的，是一次性还是分块写入，然而，程序也无意于去弄清这个事情。一个TCP软件不理解TCP字节流的含义，也无意于弄清其含义，一个字节就是一个字节而已。\n当一个应用将数据传递给TCP的时候，TCP可能立即将数据发送出去，也可能将它缓冲起来（为了收集更多的数据从而一次发送出去），这完全由TCP软件自己来决定。然而，有时候应用程序确实希望自己的数据立即被发送出去，例如，假设一个用户已经登陆到一台远程服务器上，用户每输入一行命令就会敲入回车键，这时候该命令行应该被立即发送到远程主机，而不应该缓冲起来等待下一行命令。为了强迫将数据发送出去，应用程序可以使用PUSH标志，它相当于告诉TCP不要延迟传输过程。\n有关TCP服务的最后一个值得在这里提出来的特性是紧急数据（urgent data）。当一个交互用户通过敲入DEL或者CTRL-C来打断一个已经开始运行的远程计算过程的时候，发送方应用把一些控制信息放在数据流中，然后将它联通URGETN标志一起交给TCP。这一事件将使得TCP停止继续积累数据，而是将该连接上已有的所有数据立即传输出去。当目标端接收到紧急数据的时候，接收方应用被中断（比如，按Unix的术语来说得到了一个信号），所以它停止当前正在做的工作，并且读入数据流以找到紧急数据。紧急数据的尾部应该被标记出来，所以，如何发现紧急数据要取决于具体的应用程序。这种方案基本上只是提供了一种原始的信号机制，其余的工作全部留给应用程序自己来处理。\nTCP协议\nTCP的一个关键特征，也是主导了整个协议设计的特征是，TCP连接上的每个字节都有它独有的32位序列号。发送端和接收端的TCP实体以数据段的形式交换数据。TCP数据段（TCP segment）是由一个固定的20字节的头（加上可选的部分）以及随后的0个或者多个数据字节构成的。TCP软件决定数据段的大小，它可以将多次写操作的数据累积起来放到一个数据段中，也可以将一次写操作的数据分割到多个数据段中。有两个因素限制了段的长度：第一，每个数据段，包括TCP头在内，必须适合IP的65515字节净荷大小；其次，每个网络都有一个最大传输单元（Maximum Transfer Unit）MTU，每个数据段必须适合于MTU。在实践中，MTU通常是1500字节（以太网的净荷大小），因此它规定了数据段长度的上界。\nTCP连接的建立\nTCP使用三步握手法建立连接。为了一个建立一个连接，某一方，比如说服务器，通过执行LISTEN和ACCEPT primitives（既可以指定一个特定的源，也可以不指定）被动地等待一个进来地连接请求。\n另一端，比如客户端，执行一个CONNECT primitive，同时指定以下参数：它希望连接地IP地址和端口、它愿意接受地最大TCP分段长度，以及一些可选地用户数据（比如口令）。CONNECT primitive发送一个SYN=1和ACK=0的TCP数据段，然后等待应答。\n当这个数据段到达目标端的时候，那里的TCP实体查看一下是否有一个进程已经在Destination port域中指定的端口上执行的LISTEN。如果没有的话，它送回一个设置了RST位的应答，已拒绝客户的连接请求。\n如果某个进程正在监听端口，那么，TCP实体将进来的TCP数据段交给该进程。然后该进程可以接受或者拒绝这个连接请求。如果它接受的话，则送回一个确认数据段。在正常情况下发送的TCP数据段顺序如图（a）所示。请注意，SYN数据段只消耗1字节的序列号空间，所以它的确认是非常明确的，毫无二义性。\n\n如果两台主机同时企图在同样的两个套接字之间建立一个连接，则事件序列如上图（b）所示。这些事件的结果是，只有一个连接被建立起来，而不是两个，因为所有的连接都是由它们的端点来标识的。如果第一个请求导致建立了一个由(x,y)标识的连接，而第二个请求也建立了这样一个连接，那么，在TCP实体内部只有一个表项，即(x,y).\nTCP连接的释放\n虽然TCP连接时全双工的，但是，为了理解TCP连接的释放过程，最好将TCP连接看成一对单工连接。每个单工连接被单独释放，两个单工连接之间相互独立。为了释放一个连接，任何一方都可以发送一个设置了FIN位的TCP数据段，这表示它已经没有数据要发送了。当FIN数据段被确认的时候，这个方向上就停止传送新数据。然而，另一个方向上可能还在继续无限制地传送数据，当两个方向都停止的时候，连接才被释放。通常情况下，为了释放一个连接，需要4个TCP数据段：每个方向一个FIN和一个ACK。然而，第一个ACK和第二个FIN有可能被包含在同一个数据段中，从而将总数降低到3个。\n四次挥手。blog.csdn.net/qq_33951180/article/details/60767876\nwww.imooc.com/article/17411"},"notes/cpp/sizeof-operator":{"slug":"notes/cpp/sizeof-operator","filePath":"notes/cpp/sizeof operator.md","title":"sizeof operator","links":[],"tags":["sizeof","cpp"],"content":"sizeof operator\nsizeof 是编译期运算符，不会执行任何实质的计算，例如：\n#include &lt;iostream&gt;\n \nusing namespace std;\nint main() {\n    int y;\n    int x = 11;\n    y = sizeof(x++); //value of x doesn&#039;t change\n    cout&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;x;// prints 4 11\n}\nsizeof(x) returns the amount of memory (in bytes) that the variable or type x occupies. It has nothing to do with the value of the variable.\nint a[10];\nassert(&amp;(a[0]) + sizeof(int) == &amp;(a[1]));\n \nT t;  // varialbe t has type T\nassert(sizeof(t) == sizeof(T)); // sizeof只和类型相关\n \nsizeof(std::vector&lt;int32_t&gt;);  // =24 on my machine\nstd::vector&lt;int32_t&gt; a;\nassert(sizeof(a) == sizeof(std::vector&lt;int32_t&gt;));\na.reserve(5);\nsizeof(a); // =24\na.resize(10);\nsizeof(a); // =24\n \nint32_t b[10] {};\nsizeof(b); // =40\nsizeof(b[0]); // =4\n \ntemplate&lt;typename T&gt;\nvoid PrintSize(T t)\n{\n    printf(&quot;obj %s has size %lu\\n&quot;, typeid(t).name(), sizeof(t));\n}\n \nPrintSize(b);  // print 8, 传参时b退化为int32_t*\n \nstruct Foo {\n    int a;\n    char b;\n};\n \nsizeof(Foo); // =8, 内存对齐\nsee godbolt.org/z/no8KW1dY5\n一些规则\nsizeof一个空类，结果通常为1. 理论上来说，空类应该不占用空间，但对象必须有唯一的地址，如果不占空间，那就可能发生多个实例的地址相同的情况。因此，标准规定，空类的size为1. 当然，各编译器有实现的自由。\nsizeof一个class和sizeof它的实例化对象，必然相等。因为sizeof是编译期运算符，它的结果和变量的值毫无关系。\nsizeof一个带虚函数的类，成员隐性的增加了一个指向vtable的指针，因此会在原有基础上加上该指针的大小。sizeof和成员函数的数量，以及虚成员函数的数量无关1。所有对象共享一份vtable，但每个对象内部都包含一个指向vtable的指针。\nsizeof一个带静态数据成员的类，静态数据不参与计算size，因为静态变量不存在对象的空间中，静态变量存在静态内存区。所有实例共享的是同一份静态数据。\nlive demo: godbolt.org/z/Wc59Psb6E\n更多规则请参考ref1.\nReference\n\nC++ sizeof 总结\n\nFootnotes\n\n\n简单来说就是成员函数（虚或非虚）都是一个类一份，类的所有实例没必要各自copy一份，因为它们对所有成员都是一样的。因此，它们不占用对象的大小，它们存在代码段内存区。更多参考：stackoverflow.com/a/9451502 ↩\n\n\n"},"notes/cpp/static关键字":{"slug":"notes/cpp/static关键字","filePath":"notes/cpp/static关键字.md","title":"C++ 中的 static 关键字","links":[],"tags":["cpp"],"content":"Static members\nclass A {\npublic:\n    // non-static member (i.e., `data` is not visible in `fun1`\n    static fun1();\n    fun2();\nprivate:\n    int data;\n    static int sata;\n};\n \nA a;\na.fun1();   // valid, equivalent to the following\nA::fun1();\n\n静态成员不能访问非静态成员（因为静态成员独立与类的实例（即对象）而存在，为了在没有对象被创建的情况下，静态成员还是可以使用，所以不能访问非静态成员。）\n同理，类的任何对象不包含静态数据成员\n静态成员不与对象，不与this指针发生交互，作为结果，静态成员函数不能声明为const\n可以通过类的对象调用静态成员函数，但此调用跟对象的状态并无关系，也就是说换个对象来调用是等价的，都等价于使用类名加域作用符来调用\n静态成员一般定义在类的外部，因为每个对象都共享静态成员，避免多次定义\n静态数据成员具有静态生命周期（static duration）：从定义之时到程序结束\nView static member as a normal function that has nothing to do with the class, except you must use :: to access static members\nA static data member can have incomplete type (see example below)\n\nclass Bar {\npublic:\n// . . .\nprivate:\n    static Bar mem1; // ok: static member can have incomplete type\n    Bar *mem2; // ok: pointer member can have incomplete type\n    Bar mem3; // error: data members must have complete type\n};\nA static data member can have the same type as the class type of\nwhich it is a member. A nonstatic data member is restricted to being declared as a pointer or a reference to an object of its class.\nAs an example, we’ll define a class to represent an account record at a bank:\nclass Account {\npublic:\n    void calculate() { amount += amount * interestRate; }\n    static double rate() { return interestRate; }\n    static void rate(double);\nprivate:\n    std::string owner;\n    double amount;\n    static double interestRate;\n    static double initRate();\n};\nThe static members of a class exist outside any object. Objects do not contain data associated with static data members. Thus, each Account object will contain two data members—owner and amount. There is only one interestRate object that will be shared by all the Account objects.\nWe define a static data member similarly to how we define class member functions outside the class. We name the object’s type, followed by the name of the class, the scope operator, and the member’s own name:\n// define and initialize a static class member\ndouble Account::interestRate = initRate();\nThis statement defines the object named interestRate that is a static member of class Account and has type double. Once the class name is seen, the remainder of the definition is in the scope of the class. As a result, we can use initRate without qualification as the initializer for interestRate. Note also that although initRate is private, we can use it to initialize interestRate. As with any other member definition, a static data member definition may access the private members of its class.\n一般而言，static memeber应该在类外初始化，但某些情况可以在类内初始化\nclass Account {\npublic:\n    static double rate() { return interestRate; }\n    static void rate(double);\nprivate:\n    static constexpr int period = 30;// period is a constant expression\n    double daily_tbl[period];\n};\n\n\nStatic local variables\nFunction parameters, as well as variables defined inside the function body, are called local variables.\nMuch like a person’s lifetime is defined to be the time between their birth and death, an object’s lifetime is defined to be the time between its creation and destruction. Note that variable creation and destruction happen when the program is running (called runtime), not at compile time. Therefore, lifetime is a runtime property.\nA variable’s storage duration (usually just called duration) determines what rules govern when and how a variable will be created and destroyed. In most cases, a variable’s storage duration directly determines its lifetime.\nLocal variables have automatic duration, which means they are created at the point of definition and destroyed at the end of the block they are defined in. For example:\nint main()\n{\n    int i { 5 }; // i created and initialized here\n    double d { 4.0 }; // d created and initialized here\n \n    return 0;\n} // i and d are destroyed here\nFor this reason, local variables are sometimes called automatic variables.\nGlobal variables are created when the program starts, and destroyed when it ends. This is called static duration. Variables with static duration are sometimes called static variables.\nIn C++, variables can also be declared outside of a function. Such variables are called global variables.\nUnlike local variables, which are uninitialized by default, static variables are zero-initialized by default.\n\nScope determines where a variable is accessible. Duration determines where a variable is created and destroyed. Linkage determines whether the variable can be exported to another file or not.\n\nHere comes the word: using the static keyword on a local variable changes its duration from automatic duration to static duration. This means the variable is now created at the start of the program, and destroyed at the end of the program (just like a global variable). As a result, the static variable will retain its value even after it goes out of scope!\nAutomatic duration (default):\n#include &lt;iostream&gt;\n \nvoid incrementAndPrint()\n{\n    int value{ 1 }; // automatic duration by default\n    ++value;\n    std::cout &lt;&lt; value &lt;&lt; &#039;\\n&#039;;\n} // value is destroyed here\n \nint main()\n{\n    incrementAndPrint();\n    incrementAndPrint();\n    incrementAndPrint();\n \n    return 0;\n}\n \n/**\n * Outputs:\n * 2\n * 2\n * 2\n */\nEach time incrementAndPrint() is called, a variable named value is created and assigned the value of 1. incrementAndPrint() increments value to 2, and then prints the value of 2. When incrementAndPrint() is finished running, the variable goes out of scope and is destroyed.\nStatic duration (using static keyword):\n#include &lt;iostream&gt;\n \nvoid incrementAndPrint()\n{\n    static int s_value{ 1 }; // static duration via static keyword.  This initializer is only executed once.\n    ++s_value;\n    std::cout &lt;&lt; s_value &lt;&lt; &#039;\\n&#039;;\n} // s_value is not destroyed here, but becomes inaccessible because it goes out of scope\n \nint main()\n{\n    incrementAndPrint();\n    incrementAndPrint();\n    incrementAndPrint();\n \n    return 0;\n}\n \n/**\n * Outputs:\n * 2\n * 3\n * 4\n */\nStatic local variables that are zero initialized or have a constexpr initializer can be initialized at program start. Static local variables with non-constexpr initializers are initialized the first time the variable definition is encountered (the definition is skipped on subsequent calls, so no reinitialization happens). Because s_value has constexpr initializer 1, s_value will be initialized at program start.\nWhen s_value goes out of scope at the end of the function, it is not destroyed. Each time the function incrementAndPrint() is called, the value of s_value remains at whatever we left it at previously.\nGenerating a unique ID number is very easy to do with a static duration local variable:\nint generateID()\n{\n    static int s_itemID{ 0 };\n    return s_itemID++; // makes copy of s_itemID, increments the real s_itemID, then returns the value in the copy\n}\nThe first time this function is called, it returns 0. The second time, it returns 1. Each time it is called, it returns a number one higher than the previous time it was called. You can assign these numbers as unique IDs for your objects. Because s_itemID is a local variable, it can not be “tampered with” by other functions.\nStatic variables offer some of the benefit of global variables (they don’t get destroyed until the end of the program) while limiting their visibility to block scope. This makes them safer for use even if you change their values regularly.\n\nBest practice: Initialize your static local variables. Static local variables are only initialized the first time the code is executed, not on subsequent calls.\n\nQ: What effect does using keyword static have on a global variable? What effect does it have on a local variable?\nA: When applied to a global variable, the static keyword defines the global variable as having internal linkage, meaning the variable cannot be exported to other files.\nWhen applied to a local variable, the static keyword defines the local variable as having static duration, meaning the variable will only be created once, and will not be destroyed until the end of the program.\nStatic global variables\nIdentifiers have another property named linkage. An identifier’s linkage determines whether other declarations of that name refer to the same object or not.\nLocal variables have no linkage, which means that each declaration refers to a unique object.\nGlobal variable and functions identifiers can have either internal linkage or external linkage.\nAn identifier with internal linkage can be seen and used within a single file, but it is not accessible from other files (that is, it is not exposed to the linker). This means that if two files have identically named identifiers with internal linkage, those identifiers will be treated as independent.\nTo make a non-constant global variable internal, we use the static keyword.\nstatic int g_x; // non-constant globals have external linkage by default, but can be given internal linkage via the static keyword\n \nconst int g_y { 1 }; // const globals have internal linkage by default\nconstexpr int g_z { 2 }; // constexpr globals have internal linkage by default\n \nint main()\n{\n    return 0;\n}\nThus, when applied to a local variable, the static keyword defines the local variable as having static duration, meaning the variable will only be created once, and will not be destroyed until the end of the program.\nStatic function\nBy default, funcitons have external linkage. The static modifier change it to internal linkage, so that the function can be seen only within the file, in which the function was defined.\nTo be continued…\nReferences\n\n6.10 — Static local variables\n"},"notes/cpp/传值or引用or指针":{"slug":"notes/cpp/传值or引用or指针","filePath":"notes/cpp/传值or引用or指针.md","title":"传值or引用or指针","links":[],"tags":["cpp"],"content":"传值or引用or指针\nSo, to summarize:\n\n\nPass by value when the function does not want to modify the parameter and the value is easy to copy (ints, doubles, char, bool, etc… simple types. std::string, std::vector, and all other STL containers are NOT simple types.)\n\n\nPass by const pointer when the value is expensive to copy AND the function does not want to modify the value pointed to AND NULL is a valid, expected value that the function handles.\n\n\nPass by non-const pointer when the value is expensive to copy AND the function wants to modify the value pointed to AND NULL is a vlaid, expected value that the function handles.\n\n\nPass by const reference when the value is expensive to copy AND the function does not want to modify the value referred to AND NULL would not be a valid value if a pointer was used instead.\n\n\nPass by non-cont reference when the value is expensive to copy AND the function wants to modify the value referred to AND NULL would not be a valid value if a pointer was used instead.\n\n\nWhen writing template functions, there isn’t a clear-cut answer because there are a few tradeoffs to consider that are beyond the scope of this discussion, but suffice it to say that most template functions take their parameters by value or (const) reference, however because iterator syntax is similar to that of pointers (asterisk to “dereference”), any template function that expects iterators as arguments will also by default accept pointers as well (and not check for NULL since the NULL iterator concept has a different syntax).\n\n\nReferences\n\ncplusplus.com/articles/z6vU7k9E/\nstackoverflow.com/q/334856\n"},"notes/cpp/内存布局":{"slug":"notes/cpp/内存布局","filePath":"notes/cpp/内存布局.md","title":"内存布局","links":["notes/cpp/bit-field-struct.html","tags/内存对齐.html","tags/cpp.html","tags/mem-segment.html"],"tags":["内存对齐","cpp","mem-segment"],"content":"内存布局\n结构体\nC++规范在“结构”上使用了和C相同的，简单的内存布局原则：成员变量按其被声明的顺序排列，按具体实现所规定的对齐原则在内存地址上对齐。\nstruct S {\n    char a;     // memory location #1\n    int b : 5;  // memory location #2\n    int c : 11, // memory location #2 (continued)\n    char  : 0,\n    int d : 8;  // memory location #3\n    struct {\n        int ee : 8; // memory location #4\n    } e;\n} obj; // The object &#039;obj&#039; consists of 4 separate memory locations\n\n类的静态成员不占用类的空间，静态成员在程序数据段中。\n\n位域结构体\nbit-field-struct\n对齐\nA class is meant to store data that is somehow connected to each other.\nFor example, an array and the length of the array. These two should never go out of sync, that’s what the class is responsible for.\nIf all you want to do is store some variables, a struct is the better choice. A struct is technically almost identical to a class. Their differences are mostly conventional.\nSince x and a, and a,b,c are unrelated, let’s use a struct.\nstruct A\n{\n  int x{};\n  char a{};\n};\nNext, int and char could have any size from 1 to 64 bits. That makes it difficult to talk about these examples. C++ has fixed-width integer types. It’s up to implementations to support these types, so their use is generally discouraged. But because the size of types is important in this example, let’s use them.\n#include &lt;cstdint&gt;\n \nstruct A\n{\n  std::uint32_t x{}; // 32 bits = 4 bytes\n  std::uint8_t a{}; // 8 bits = 1 byte\n};\nI’ve used unsigned types, because signed, although irrelevant to this example, is more complicated on a bit-level.\nNow, to gather more information about what might be happening, we can play with more structs\nstruct A1 {\n  std::uint8_t a{};\n  std::uint8_t b{};\n  std::uint8_t c{};\n}; // sizeof(A1) = 3\n \nstruct A2 {\n  std::uint16_t a{};\n  std::uint8_t b{};\n}; // sizeof(A2) = 4\n \nstruct B1 {\n  std::uint32_t a{};\n  std::uint8_t b{};\n}; // sizeof(B1) = 8\n \nstruct B2 {\n  std::uint16_t a{};\n  std::uint16_t b{};\n  std::uint16_t c{};\n}; // sizeof(B2) = 6\nJust looking at the members of these structs, you might expect sizeof(A1) == sizeof(A2) and sizeof(B1) == sizeof(B2).\nThat’s not the case though, so member variable size cannot be all that matters.\nIntroducing, alignment.\nEvery type wants to be placed at a multiple of some value.\n\nA std::uint8_t wants to be placed at a multiple of 1 (ie. any address).\nA std::uint16_t wants to be placed at a multiple of 2 (0, 2, 4, 6, etc.).\nA std::uint32_t wants to be placed at a multiple of 4 (0, 4, 8, etc.).\n\n所有数据的地址必须是这个数据类型所占大小的整数倍。\nAlignment, as everything in my reply, is implementation-defined. You might see different values.\nYou can get the alignment of a type using alignof(T), just like you used sizeof(T).\nI’m using fixed-width types, but the same goes for char, int, etc.\nFor example, an std::uint32_t cannot be at address 0xab421, because that’s not a multiple of 4. If 0xab420 is already occupied, the std::uint32_t will be placed at 0xab424, the next closest address with fitting alignment.\nThe compiler does to because the CPU can read aligned values faster. Unaligned reads would cause the CPU to read memory from before and after the variable and discard it later.\nConsider this new struct\nstruct C\n{\n  std::uint8_t a{};\n  std::uint32_t b{};\n};\nand suppose an instance of C is created at address 0.\na is at placed address 0. That’s fine, std::uint8_t can be placed at any address.\nb has to be placed after a, that would be address 1. But that won’t work, because 1 is not a multiple of 4 (alignof(std::uint32_t)). To fix it, the compiler generated padding bytes between the a and b.\nstruct C_padded\n{\n  std::uint8_t a{};\n  std::uint8_t padding[3]; // This is an array. It means 3 variables of type std::uint8_t.\n  std::uint32_t b{};\n};\nNow if a is at address 0, padding occupies address 1, 2, and 3. That places b at address 4, which is fine.\nBack to A2\nstruct A2 {\n  std::uint16_t a{};\n  std::uint8_t b{};\n}; // sizeof(A2) = 4\nThis doesn’t need padding, does it? a can be placed at address 0 and b can be placed at address 2, so where does the 1 additional byte come from to cause sizeof(A2) to be 4?\nLet’s think about what alignof(A2) must be. All member variables of A2 must be properly aligned.\nalignof(A2) cannot be 1, because that would place a at odd addresses. But 2 works. In fact, using the greatest alignment of all member variables as the alignment of the struct always works.\nCool, so how is this related to the 1 extra byte we observe in A2?\nSay we have two successive instances of A2\nstruct Flowers {\n  A2 cauliflower{};\n  A2 mayflower{};\n};\nSuppose sizeof(A2) is 3, ie. sizeof(a) + sizeof(b).\nThe compiler again has to consider the alignment of the member variables. cauliflower is fine at address 0, because everything is fine at address 0. A2 has to be aligned to 2, so it cannot be placed at address 3.\n1 padding byte would have to be inserted between cauliflower and mayflower to move mayflower to address 4. Although that’s what would happen according to what I wrote so far, the compiler chooses a different approach for structs.\nUnrelated to how A2 is used, the compiler inserts 1 padding byte at the end of A2\nstruct A2_padded {\n  std::uint16_t a{};\n  std::uint8_t b{};\n  std::uint8_t padding[1];\n};\nThat’s where the 1 extra byte in A2 came from. It automatically aligns successive instances of A2 without having to insert padding. We don’t need padding between cauliflower and mayflower, because the padding is built-into A2.\nThe question now is, why does the compiler add the padding into the struct, rather than outside?\nWhy alignment?\nWhen you CPU wants to read from memory, all it can do is read a word. A word means 2 bytes of memory.\nSay you have a std::uint16_t with value 0x1234.\nIf the compiler placed the std::uint16_t at address 0x10, the memory might look like this\naddress  value\n...\n000c     83 21 // some other variable\n000e     ab cd // some other variable\n0010     12 34\n0012     ef 01 // some other variable\n...\n\nWhen the CPU wants to read the std::uint16_t, it can do so with a single read operation on address 0x10.\nIf the std::uint16_t were misaligned, eg. placed at address 0x11\naddress  value\n...\n000c     83 21 // some other variable\n000e     ab cd // some other variable\n0010     44 12\n0012     34 ef\n...\n\nthe CPU would have to read a word from 0x10 and 0x12, then discard the 0x44 and 0xef it didn’t want, before it can give you your value.\nCf.\n\nwww.learncpp.com/cpp-tutorial/object-sizes-and-the-sizeof-operator/#comment-563585\nwww.catb.org/esr/structure-packing/\n\n内存对齐\n继承下的内存布局\n一个类的实例占用的空间由非静态成员变量加一个虚函数表的指针以及因字节对齐填充的字节数构成。为什么不每个类的实例都保存所有虚函数的地址，而是一个虚函数表呢，因为这样实例所占的空间累计会更少。因为函数地址都是一样的，所以没必要每个类的实例都有这部分。\n派生类对象将会完全继承基类的成员及其内存布局，例如\nstruct A {  // sizeof(A)=8\n    int a;\n    int b;\n}\n \nstruct B : A {  // sizeof(B)=12\n    int c;\n}\n很简单，B完全继承A的布局，也不存在对齐的问题，A占8字节，B占12字节。\n再看下面这个例子：\nstruct B {  // sizeof(B)=8\n    int a;\n    short b;\n    short c;\n}\n此时，b 和 c 因为对齐机制共同占用4个字节，故B总共占用8字节。\n再看下面这个例子：\nstruct A {  // sizeof(A)=8\n    int a;\n    short b;\n}\n \nstruct B : A {  // sizeof(B)=12\n    short c;\n}\n在这个例子中，B的内存空间还是12字节，并不是8字节。\n我们画一下A，B的内存布局\nA:\nxxxx xx00\n  a   b padding\n\nB:\nxxxx xx00 xx00\n  a   b    c\n\nA是单独的一个类，但由于内存对齐，A必须按4字节对齐，所以成员b后面紧跟2个字节的padding。而B继承A，就要继承它的内存布局，所以B的内存布局有两处padding，无形之中增加了4个字节。\n按照省内存的理解，这种继承应该使用8字节的布局方案，但是c++使用的是12字节。考虑这样一个问题：\nA *pa, *pb;\npa = new A();\npb = new B();\n*pa = *pb;\n当b的指针赋值给a的时候，如果是8字节的内存布局，那么c就变成了填充的pad。导致A的内存出现了错误，所以为了避免这个问题，b将完全继承a的内存布局，这样在赋值的时候，也能正确的把a给填充。\n内存对齐带来的成员排序\nstruct A {\n    int a;\n    short b;\n    int c;\n    short d;\n}\n \nstruct B {\n    int a;\n    int c;\n    short b;\n    short d;\n}\n \nsizeof(A) // 16\nsizeof(B) // 12\nA占用的空间是16字节，而B占用的空间是12字节。所以我们在设计类成员的时候，应该将相同类型的成员放一起。这样能减少类对象所占用的内存，一个两个差很少，但是十几万的时候，内存差距就拉开了。\n程序的内存区域\ncpp mem-segment\nThe memory that a program uses is typically divided into a few different areas, called segments:\n\nThe code segment (also called a text segment), where the compiled program sits in memory. The code segment is typically read-only.\nThe bss segment (also called the uninitialized data segment), where zero-initialized global and static variables are stored.\nThe data segment (also called the initialized data segment), where initialized global and static variables are stored.\nThe heap, where dynamically allocated variables are allocated from.\nThe call stack, where function parameters, local variables, and other function-related information are stored.\n\nThe heap has advantages and disadvantages:\n\nAllocating memory on the heap is comparatively slow.\nAllocated memory stays allocated until it is specifically deallocated (beware memory leaks) or the application ends (at which point the OS should clean it up).\nDynamically allocated memory must be accessed through a pointer. Dereferencing a pointer is slower than accessing a variable directly.\nBecause the heap is a big pool of memory, large arrays, structures, or classes can be allocated here.\n\nThe stack has advantages and disadvantages:\n\nAllocating memory on the stack is comparatively fast.\nMemory allocated on the stack stays in scope as long as it is on the stack. It is destroyed when it is popped off the stack.\nAll memory allocated on the stack is known at compile time. Consequently, this memory can be accessed directly through a variable.\nBecause the stack is relatively small, it is generally not a good idea to do anything that eats up lots of stack space. This includes passing by value or creating local variables of large arrays or other memory-intensive structures.\n\nReferences\n\n12.2 — The stack and the heap\n"},"notes/cpp/函数指针":{"slug":"notes/cpp/函数指针","filePath":"notes/cpp/函数指针.md","title":"C++ 学习笔记 (1)","links":["tags/成员函数指针.html","tags/function-pointer.html"],"tags":["cpp","pointer","成员函数指针","function-pointer"],"content":"This article is mainly excerpted from LearnCpp.com\nPointer to functions\nThe syntax for creating a non-const function pointer is one of the ugliest things you will ever see in C++:\n// fcnPtr is a pointer to a function that takes no arguments and returns an integer\nint (*fcnPtr)();\nIn the above snippet, fcnPtr is a pointer to a function that has no parameters and returns an integer. fcnPtr can point to any function that matches this type.\nTo make a const function pointer, the const goes after the asterisk:\nint (*const fcnPtr)();\nIf you put the const before the int, then that would indicate the function being pointed to would return a const int.\n\nNote that the type (parameters and return type) of the function pointer must match the type of the function. Here are some examples of this:\n// function prototypes\nint foo();\ndouble goo();\nint hoo(int x);\n \n// function pointer assignments\nint (*fcnPtr1)(){ &amp;foo }; // okay\nint (*fcnPtr2)(){ &amp;goo }; // wrong -- return types don&#039;t match!\ndouble (*fcnPtr4)(){ &amp;goo }; // okay\nfcnPtr1 = &amp;hoo; // wrong -- fcnPtr1 has no parameters, but hoo() does\nint (*fcnPtr3)(int){ &amp;hoo }; // okay\nUnlike fundamental types, C++ will implicitly convert a function into a function pointer if needed (so you don’t need to use the address-of operator (&amp;) to get the function’s address). However, it will not implicitly convert function pointers to void pointers, or vice-versa.\nCalling a function using a function pointer\nThe other primary thing you can do with a function pointer is use it to actually call the function. There are two ways to do this:\nint foo(int x) { return x; }\nint main()\n{\n    int (*fcnPtr)(int){ &amp;foo }; // Initialize fcnPtr with function foo\n    (*fcnPtr)(5); // call function foo(5) via explict dereference of fcnPtr.\n    fcnPtr(5); // call function foo(5) via implicit dereference of fcnPtr.\n    return 0;\n}\nAs you can see, the implicit dereference method looks just like a normal function call — which is what you’d expect, since normal function names are pointers to functions anyway! However, some older compilers do not support the implicit dereference method, but all modern compilers should.\n\nOne interesting note: Default parameters won’t work for functions called through function pointers. Default parameters are resolved at compile-time (that is, if you don’t supply an argument for a defaulted parameter, the compiler substitutes one in for you when the code is compiled). However, function pointers are resolved at run-time. Consequently, default parameters can not be resolved when making a function call with a function pointer. You’ll explicitly have to pass in values for any defaulted parameters in this case.\n\nThe implementation of function pointers is simple: they are just “code pointers”: they hold the starting address of an assembly-language routine. The different types of function pointers exist only to ensure that the correct calling convention is used.\nThe pointer to member functions\n\nadapted from ref2\n\nA member function pointer (MFP) to a member function of class SomeClass, with the same arguments as before, is declared like this:\nfloat (SomeClass::*my_memfunc_ptr)(int, char *);\n// For const member functions, it&#039;s declared like this:\nfloat (SomeClass::*my_const_memfunc_ptr)(int, char *) const;\nNotice that a special operator (::*) is used, and that SomeClass is part of the declaration. Member function pointers have a horrible restriction: they can only point to member functions of a single class. There is a different type of member function pointer for each combination of arguments, for both types of const-ness, and for each class.\nIf you’re using member function pointers, you should always use a typedef to avoid confusion.\nYou make your function pointer point to a function float SomeClass::some_member_func(int, char *) like this:\nmy_memfunc_ptr = &amp;SomeClass::some_member_func;\n// This is the syntax for operators: \nmy_memfunc_ptr = &amp;SomeClass::operator !;\n// There is no way to take the address of a constructor or destructor\nTo invoke the member function pointer, you need to provide an instance of SomeClass, and you must use the special operator -&gt;*. This operator has a low precedence, so you need to put it in parentheses:\nSomeClass *x = new SomeClass;\n(x-&gt;*my_memfunc_ptr)(6, &quot;Another Arbitrary Parameter&quot;);\n// You can also use the .* operator if your class is on the stack.\nSomeClass y;\n(y.*my_memfunc_ptr)(15, &quot;Different parameters this time&quot;);\nIn writing this article, I have one key point to make: It is absurd that the C++ Standard allows you to cast between member function pointers, but doesn’t allow you to invoke them once you’ve done it. It’s absurd for three reasons. Firstly, the cast won’t always work on many popular compilers (so, casting is standard, but not portable). Secondly, on all compilers, if the cast is successful, invoking the cast member function pointer behaves exactly as you would hope: there is no need for it to be classed as “undefined behavior”. (Invocation is portable, but not standard!) Thirdly, allowing the cast without allowing invocation is completely useless; but if both cast and invocation are possible, it’s easy to implement efficient delegates, with a huge benefit to the language.\nYou’d probably guess that a “member function pointer”, like a normal function pointer, just holds a code pointer. You would be wrong. On almost all compilers, a member function pointer is bigger than a function pointer. Most bizarrely, in Visual C++, a member function pointer might be 4, 8, 12, or 16 bytes long, depending on the nature of the class it’s associated with, and depending on what compiler settings are used!\n【此前的成员函数指针】Let’s go back in time to the early 1980’s. When the original C++ compiler (CFront) was originally developed, it only had single inheritance. When member function pointers were introduced, they were simple: they were just function pointers that had an extra this parameter as the first argument. When virtual functions were involved, the function pointer pointed to a short bit of ‘thunk’ code. (Update, Oct 04: A discussion on comp.lang.c++.moderated has established that CFront didn’t actually use thunks, it was much less elegant. But it could have used this method, and pretending that it did, makes the following discussion a bit easier to understand.)\n【引入了多继承之后的成员函数指针】This idyllic world was shattered when CFront 2.0 was released. It introduced templates and multiple inheritance. Part of the collateral damage of multiple inheritance was the castration of member function pointers. The problem is, with multiple inheritance, you don’t know what this pointer to use until you make the call. For example, suppose you have the four classes defined below:\nclass A {\n public:\n       virtual int Afunc() { return 2; };\n};\n \nclass B {\n public: \n      int Bfunc() { return 3; };\n};\n \n// C is a single inheritance class, derives only from A\nclass C: public A {\n public: \n     int Cfunc() { return 4; };\n};\n \n// D uses multiple inheritance\nclass D: public A, public B {\n public: \n    int Dfunc() { return 5; };\n};\nSuppose we create a member function pointer for class C. In this example, Afunc and Cfunc are both member functions of C, so our member function pointer is allowed to point to Afunc or Cfunc. But Afunc needs a this pointer that points to C::A (which I’ll call Athis), while Cfunc needs a this pointer that points to C (which I’ll call Cthis). Compiler writers deal with this situation by a trick: they ensure that A is physically stored at the start of C. This means that Athis == Cthis. We only have one this to worry about, and all’s well with the world.\nNow, suppose we create a member function pointer for class D. In this case, our member function pointer is allowed to point to Afunc, Bfunc, or Dfunc. But Afunc needs a this pointer that points to D::A, while Bfunc needs a this pointer that points to D::B. This time, the trick doesn’t work. We can’t put both A and B at the start of D. So, a member function pointer to D needs to specify not only what function to call, but also what this pointer to use. The compiler does know how big A is, so it can convert an Athis pointer into a Bthis just by adding an offset (delta = sizeof(A)) to it.\nIf you’re using virtual inheritance (i.e., virtual base classes), it’s much worse, and you can easily lose your mind trying to understand it. Typically, the compiler uses a virtual function table (‘vtable’) which stores for each virtual function, the function address, and the virtual_delta: the amount in bytes that needs to be added to the supplied this pointer to convert it into the this pointer that the function requires.\nIn theory, all of these vendors could radically change their technique for representing MFPs. In practice, this is extremely unlikely, because it would break a lot of existing code. At MSDN, there is a very old article that was published by Microsoft which explains the run-time implementation details of Visual C++ [JanGray]. It’s written by Jan Gray, who actually wrote the MS C++ object model in 1990. Although the article dates from 1994, it is still relevant - excluding the bug fix, Microsoft hasn’t changed it for 15 years. Similarly, the earliest compiler I have (Borland C++ 3.0, (1990)) generates identical code to Borland’s most recent compiler, except of course that 16 bit registers are replaced with 32 bit ones.\nBy now, you know far too much about member function pointers. What’s the point? I’ve dragged you through this to establish a rule. Although these implementations are very different from one another, they have something useful in common: the assembly code required to invoke a member function pointer is identical, regardless of what class and parameters are involved. Some compilers apply optimizations depending on the inheritance nature of the class, but when the class being invoked is of incomplete type, all such optimizations are impossible. This fact can be exploited to create efficient delegates.\n\nDid you know the pointer to member function typically has the twice (not twice, but related to the class) size of the normal function pointers? I.e., suppose the pointer to functions is 8 bytes, then the pointer to member functions is 16 bytes.\nWhy?\nSee this stack overflow question: stackoverflow.com/a/12006882 , For a lot of detail, see this (scroll to “Implementations of Member Function Pointers”).\n成员函数指针 function-pointer\nSO interpretation\nIn the most normal situation, you can pretty much think of\nstruct A {\n    int i;\n    int foo() { return i; }\n};\n \nA a;\na.foo();\nas\nstruct A {\n    int i;\n};\nint A_foo( A* this ) { return this-&gt;i; };\n \nA a;\nA_foo(&amp;a);\n(Starting to look like C, right?) So you would think the pointer &amp;A::foo would just be the same as a normal function pointer. But there are a couple of complications: Multiple inheritance, and virtual functions.\nReferences\n\n12.1 — Function Pointers\nMember Function Pointers and the Fastest Possible C++ Delegates\n"},"notes/cpp/多态":{"slug":"notes/cpp/多态","filePath":"notes/cpp/多态.md","title":"多态","links":["求职/经历.html","notes/cpp/类.html","__zettel/202502241705crtp-in-cpp.html","tags/virtual-destructor.html","tags/虚析构函数.html","tags/destructor.html","notes/cpp/cpp-learn.html"],"tags":["cpp","polymorphism","virtual-destructor","虚析构函数","destructor"],"content":"多态\nVirtual function\n\nThe biggest benefit of virtual functions: the ability to structure your code in such a way that newly derived classes will automatically work with the old code without modification!\nThe signature of the derived class function must exactly match the signature of the base class virtual function in order for the derived class function to be used. 为此引入了 override关键字，意在检查稍有不慎将“虚函数重写（override）”写成了“函数重载（overload）”\nNote that if a function is marked as virtual, all matching overrides are also considered virtual, even if they are not explicitly marked as such.\n\n\nNever call virtual functions from constructors or destructors.\n\nRemember that when a Derived class is created, the Base portion is constructed first. If you were to call a virtual function from the Base constructor, and Derived portion of the class hadn’t even been created yet, it would be unable to call the Derived version of the function because there’s no Derived object for the Derived function to work on. In C++, it will call the Base version instead.\nA similar issue exists for destructors. If you call a virtual function in a Base class destructor, it will always resolve to the Base class version of the function, because the Derived portion of the class will already have been destroyed.\nPure virtual function\nA pure virtual function is a function that must be overridden in a derived class and need not be defined. A virtual function is declared to be “pure” using the curious =0 syntax. For example:\nclass Base {\npublic:\n    void f1();      // not virtual\n    virtual void f2();  // virtual, not pure\n    virtual void f3() = 0;  // pure virtual\n};\nBase b; // error: pure virtual f3 not overridden\nHere, Base is an abstract class (because it has a pure virtual function), so no objects of class Base can be directly created: Base is (explicitly) meant to be a base class. For example:\nclass Derived : public Base {\n    // no f1: fine\n    // no f2: fine, we inherit Base::f2\n    void f3();\n};\nDerived d;  // ok: Derived::f3 overrides Base::f3\nAbstract classes are immensely useful for defining interfaces. In fact, a class with no data and where all functions are pure virtual functions is often called an interface.\nBase::f3() must still be overridden in some derived class. If you don’t override a pure virtual function in a derived class, that derived class becomes abstract:\nclass D2 : public Base {\n    // no f1: fine\n    // no f2: fine, we inherit Base::f2\n    // no f3: fine, but D2 is therefore still abstract\n};\nD2 d;   // error: pure virtual Base::f3 not overridden\n包含纯虚函数的类称为虚基类（abstract class），不能实例化。\nDynamic binding\nDynamic binding means that the address of the code in a member function invocation is determined at the last possible moment: based on the dynamic type of the object at run time. It is called “dynamic binding” because the binding to the code that actually gets called is accomplished dynamically (at run time). Dynamic binding is a result of virtual functions.\n\nsee alse 静态绑定\n\nWhat’s the difference between how virtual and non-virtual member functions are called?\nNon-virtual member functions are resolved statically. That is, the member function is selected statically (at compile-time) based on the type of the pointer (or reference) to the object.\nIn contrast, virtual member function are resolved dynamically (at run-time). That is, the member function is selected dynamically (at run-time) based on the type of the object, not the type of the pointer/reference to that object. This is called “dynamic binding”. Most compilers use some variant of the following technique: if the object has one or more virtual functions, the compiler puts a hidden pointer in the object called a “virtual-pointer” or “v-pointer.” This v-pointer points to a global table called the “virtual-table” or “v-table.”\nThe compiler creates a v-table for each class that has at least one virtual function. For example, if class Circle has virtual functions for draw() and move() and resize(), there would be exactly one v-table associated with class Circle, even if there were a gazillion Cricle objects, and the v-pointer of each of those Circle objects would point to the Circle v-table. The v-table itself has pointers to each of the virtual functions in the class. For example, the Circle v-table would have three pointers: a pointer to Circle::draw(), a pointer to Circle::move(), and a pointer to Circle::resize().\n\n每个实例持有一个vptr，共享一个vtable。也就是说，含有虚函数的类只有一份vtable，它的所有实例均有一个vptr，指向这个vtable。Am I clear?\n\nDuring a dispatch of a virtual function, the run-time system follows the object’s v-pointer to the class’s v-table, then follows the appropriate slot in the v-table to the method code.\nThe space-cost overhead of the above technique is nominal: an extra pointer per object (but only for objects that will need to do dynamic binding), plus an extra pointer per method (but only for virtual methods). The time-cost overhead is also fairly nominal: compared to a normal function call, a virtual function call requires two extra fetches (one to get the value of the v-pointer, a second to get the address of the method). None of this runtime activity happens with non-virtual functions, since the compiler resolves non-virtual functions exclusively at compile-time based on the type of theco pointer.\nNote: the above discussion is simplified considerably, since it doesn’t account for extra structural things like multiple inheritance, virtual inheritance, RTTI, etc., nor does it account for space/speed issues such as page faults, calling a function via a pointer-to-function, etc.\nWhen should my destructor be virtual?\nvirtual-destructor 虚析构函数 destructor\n\n派生类析构函数会主动调用基类析构函数（内部机制），因此，当通过基类指针删除对象时，如果析构函数不是虚的，就调不到派生类析构函数，进而导致派生类的资源释放问题。\n\n==When someone will delete a derived-class object via a base-class pointer.==\nIn particular, here’s when you need to make your destructor virtual:\n\nif someone will derive from your class,\nand if someone will say new Derived, where Derived is derived from your class,\nand if someone will say delete p, where the actual object’s type is Derived but the pointer p’s type is your class.\n\nConfused? Here’s a simplified rule of thumb that usually protects you and usually doesn’t cost you anything: make your destructor virtual if your class has any virtual functions. Rationale:\n\nthat usually protects you because most base classes have at least one virtual function.\nthat usually doesn’t cost you anything because there is no added per-object space-cost for the second or subsequent virtual in your class. In other words, you’ve already paid all the per-object space-cost that you’ll ever pay once you add the first virtual function, so the virtual destructor doesn’t add any additional per-object space cost. (Everything in this bullet is theoretically compiler-specific, but in practice it will be valid on almost all compilers.)\n\nNote: in a derived class, if your base class has a virtual destructor, your own destructor is automatically virtual. You might need an explicitly defined destructor for other reasons, but there’s no need to redeclare a destructor simply to make sure it is virtual. No matter whether you declare it with the virtual keyword, declare it without the virtual keyword, or don’t declare it at all, it’s still virtual.\nBy the way, if you’re interested, here are the mechanical details of why you need a virtual destructor when someone says delete using a Base pointer that’s pointing at a Derived object. When you say delete p, and the class of p has a virtual destructor, the destructor that gets invoked is the one associated with the type of the object *p, not necessarily the one associated with the type of the pointer. This is A Good Thing. In fact, violating that rule makes your program undefined. The technical term for that is, “Yuck.”\nWhy are destructors not virtual by default?\nBecause many classes are not designed to be used as base classes. Virtual functions make sense only in classes meant to act as interfaces to objects of derived classes (typically allocated on a heap and accessed through pointers or references).\nSo when should I declare a destructor virtual? Whenever the class has at least one virtual function. Having virtual functions indicate that a class is meant to act as an interface to derived classes, and when it is, an object of a derived class may be destroyed through a pointer to the base. For example:\nclass Base {\n    // ...\n    virtual ~Base();\n};\nclass Derived : public Base {\n    // ...\n    ~Derived();\n};\nvoid f()\n{\n    Base* p = new Derived;\n    delete p;   // virtual destructor used to ensure that ~Derived is called\n}\nHad Base’s destructor not been virtual, Derived’s destructor would not have been called – with likely bad effects, such as resources owned by Derived not being freed.\nWhy don’t we have virtual constructors?\nA virtual call is a mechanism to get work done given partial information. In particular, virtual allows us to call a function knowing only an interfaces and not the exact type of the object. To create an object you need complete information. In particular, you need to know the exact type of what you want to create. Consequently, a “call to a constructor” cannot be virtual.\nsee also ctor不能是虚函数 and 不要在ctor里调用虚函数.\nFor example:\n#include &lt;iostream&gt;\nusing namespace std;\n \nclass Base\n{\npublic:\n    Base() { Foo(); }\n    virtual void Foo() { cout &lt;&lt; &quot;Base::Foo\\n&quot;; }\n};\n \n \nclass Derived : public Base\n{\npublic:\n    Derived(): Base() {}\n    virtual void Foo() { cout &lt;&lt; &quot;Derived::Foo\\n&quot;; }\n};\n \nint main()\n{\n    Derived* d = new Derived();\n    d-&gt;Foo();\n    return 0;\n}\nwill outputs\nBase::Foo\nDerived::Foo\n\nNote that, when we call the constructor of Derived, no dynamic binding happened.\nNever call virtual functions during construction or destruction\nYou shouldn’t call virtual functions during construction or destruction, because the calls won’t do what you think, and if they did, you’d still be unhappy.  During base class construction, virtual functions never go down into derived classes.\nBase class constructors execute before derived class constructors, derived class data members have not been initialized when base class constructors run. If virtual functions called during base class construction went down to derived classes, the derived class functions would almost certainly refer to local data members, but those data members would not yet have been initialized. That would\nbe a non-stop ticket to undefined behavior.\nIt’s actually more fundamental than that. During base class construction of a derived class object, the type of the object is that of the base class. Not only do virtual functions resolve to the base class, but the parts of the language using runtime type information (e.g.,\ndynamic_cast (see Item 27) and typeid) treat the object as a base class type.  An object doesn’t become a derived class object until execution of a derived class constructor begins.\nThe same reasoning applies during destruction. Once a derived class destructor has run, the object’s derived class data members assume undefined values, so C++ treats them as if they no longer exist. Upon entry to the base class destructor, the object becomes a base class object, and all parts of C++ — virtual functions, dynamic_casts, etc., — treat it that way.\n构造函数执行完，对象才算构造完成。如果要在对象构造中去动态绑定，我们知道它的原理其实是通过对象的vptr去访问vtable, 进而查询得到正确的调用地址。对象在构造中，如果调用到派生类的方法，而该方法又依赖于派生类新增的数据成员（此时还未被初始化），那么这次访问就不太合理。所以C++干脆就不让在构造函数里面调虚函数，调了也不会发生动态绑定。\n同理，在析构函数中，如果调用到派生类的方法，而该方法又依赖派生类的数据成员，此时派生类的数据成员可能被销毁1，那么这次访问依旧是不合法的。\nThings to Remember\n✦ Don’t call virtual functions during construction or destruction, because such calls will never go to a more derived class than that of the currently executing constructor or destructor\nReferences\n\nInheritance — virtual functions\nEffective C++, Scott Meyers, 3rd Edition\n\nFootnotes\n\n\n构造时，总是先构造基类成员，再构造派生类成员。析构时相反，先销毁派生类成员，再销毁基类成员。 ↩\n\n\n"},"notes/cpp/字节序":{"slug":"notes/cpp/字节序","filePath":"notes/cpp/字节序.md","title":"字节序","links":[],"tags":["cpp","endian"],"content":"/**\n * This file test the endian of your machine:\n * big-endian or little-endian, by visiting\n * the memory sequentially byte by byte of\n * a intendly constructed integer.\n */\n \n#include &lt;cstdint&gt;\n#include &lt;stdio.h&gt;\n#include &lt;iostream&gt;\n \nusing namespace std;\n \nstatic void print(void* ptr, size_t size)\n{\n    // convert to char* so we can visit the memory byte by byte\n    unsigned char* _ptr = static_cast&lt;unsigned char*&gt;(ptr);\n    // print the value of each byte in ptr\n    for (size_t i = 0; i &lt; size; ++i)\n        cout &lt;&lt; static_cast&lt;int&gt;(_ptr[i]);\n    cout &lt;&lt; endl;\n}\n \nint main()\n{\n    uint32_t a = 0x01020304;\n    /*\n     * if it prints 4321, indicates 低位在前，对应little-endian\n     * it it prints 1234, indicates 高位在前，对应big-endian\n     */\n    print(&amp;a, 4);\n    return 0;\n}\n \n/**\n * Output on my machine\n4321\n */\n字节序就是计算机存储数据的时候将低位数据存在低位地址还是高位地址。举个例子，数值0x2211使用两个字节储存：高位字节是0x22，低位字节是0x11。\n\n大端字节序：高位字节在前，低位字节在后，这是人类读写数值的方法。\n小端字节序：低位字节在前，高位字节在后，即以0x1122形式储存。\n\n如果太多记不住，至少要记住：\n\n字节序的概念: 读一段内存从低位向高位读（从左往右），先读到高位字节还是低位字节\n符合人类读写数值的方法是大端序（big-endian）\n\n既然如此，我们要判断一台机器是big-endian还是little-endian，只需要构造一端内存，按字节从低位地址向高位地址访问，看看低位地址存的是高位字节，还是低位字节即可。\n且看上述代码，构造了一个整数0x01020304，然后通过将首地址转成char*的方式去按字节读取内存中的值（这样做的目的是，char*可以逐字节的读取内存；而int*一次指针移动会移动sizeof(int)个字节）。读出来如果是符合书写习惯的1234, 则表明机器是big-endian, 反之little-endian.\n这也是一段内存的两种不同的解释方式，recall that Because all data on a computer is just a sequence of bits, we use a data type (often called a “type” for short) to tell the compiler how to interpret the contents of memory in some meaningful way.\n\n\n                  \n                  Hint\n                  \n                \n\n网络字节序一般是大端。\n\n"},"notes/cpp/宏":{"slug":"notes/cpp/宏","filePath":"notes/cpp/宏.md","title":"宏","links":[],"tags":["cpp","macro"],"content":"do {…} while (0) 在宏定义中的作用\n使用do{…}while(0)构造后的宏定义不会受到大括号、分号等的影响，总是会按你期望的方式调用运行。\nsee more in www.cnblogs.com/lanxuezaipiao/p/3535626.html"},"notes/cpp/智能指针":{"slug":"notes/cpp/智能指针","filePath":"notes/cpp/智能指针.md","title":"智能指针","links":[],"tags":["cpp","smart-pointer"],"content":"智能指针\n循环引用\nCf.\n\nM.7 — std::shared_ptr\nM.8 — Circular dependency issues with std::shared_ptr, and std::weak_ptr\n\n \n#include &lt;memory&gt;\n#include &lt;stdio.h&gt;\n \n#define PRINT_FUNC do { printf(&quot;%s called.\\n&quot;, __FUNCTION__); }while(0);\n \nusing std::shared_ptr;\nusing std::weak_ptr;\n \nstruct B;\n \nstruct A\n{\n    A() { PRINT_FUNC }\n    ~A() { PRINT_FUNC }\n    shared_ptr&lt;B&gt; B_ptr;\n};\n \nstruct B\n{\n    B() { PRINT_FUNC }\n    ~B() {PRINT_FUNC}\n    shared_ptr&lt;A&gt; A_ptr; // change to weak_ptr\n};\n \n \nint main()\n{\n    auto a_ptr = std::make_shared&lt;A&gt;();  // a对象\n    auto b_ptr = std::make_shared&lt;B&gt;();  // b对象\n    a_ptr-&gt;B_ptr = b_ptr;\n    b_ptr-&gt;A_ptr = a_ptr;\n    return 0;\n}\nmain函数结束时，b_ptr先销毁1，检查引用计数发现a.B_ptr引用了同一个资源（b，此时引用计数为2），将自身引用解掉（此时引用计数减1），由于引用计数尚未减到0，因此，堆上b对象不会销毁。\n接着，a_ptr销毁，检查引用计数，发现b.A_ptr引用了同一个资源（a，此时引用计数为2），将自身引用解掉（此时内部的引用计数为1），由于引用计数尚未减到0，因此，堆上a对象不会销毁。\n整体看来，a持有b，b持有a，互相阻止了自己的释放。\n如何解决？\n将A、B中至少一个shared_ptr改为weak_ptr（弱引用）。\nshared_ptr&lt;T&gt; sptr = xxx;\nweak_ptr&lt;T&gt; wptr = sptr;  // 不会增加sptr内部的引用计数，弱引用\n注意，如果仅将B中的shared_ptr改为weak_ptr，b对象必然会在a对象之后销毁。因为b对象销毁时，如果a对象未销毁，由于a.B_ptr是shared_ptr，会持有b对象，导致b对象的引用计数无法减为0，因此无法销毁。\nstd::shared_ptr\n\n\n                  \n                  Tip\n                  \n                \n\n优先使用std::make_shared构造sthared_ptr. unique_ptr也有同样的规则。\n\n\n写法更简洁\nauto sptr(std::make_shared&lt;YourClass&gt;());\nstd::shared_ptr&lt;YourClass&gt; sptr2(new YourClass());\n提升异常安全\n假设有函数：\nvoid foo(std::shared_ptr&lt;A&gt; spa, int priority);\n用户调用如下：\nfoo(std::shared_ptr&lt;A&gt;(new A()), compute_priority());\n在foo的函数体执行之前需要做三件事：\n\nnew A 分配A对象\n构造shared_ptr管理对象\n执行compute_priority函数\n\n编译器只能保证1在2之前执行，如果执行顺序是1-3-2，且compute_priority抛了未捕获的异常，会导致A对象无法释放。\n也就是说，在你new一个对象和将它交给shared_ptr管理中间，可能会发生一些事情，导致后面的逻辑走不到。而使用std::make_shared会在分配对象之后立刻交给shared_ptr管理。\nreview\nT sp = std::shared_ptr&lt;T&gt;(new T()); // #1\nT sp = std::make_shared&lt;T&gt;(); // #2\n\nmake_shared只分配一次内存（分配时考虑T对象的大小和shared_ptr控制块的大小）。而第一种写法实际上是两个阶段，第一个阶段是分配内存，构造T对象。第二个阶段是把构造好的对象指针传给std::shared_ptr的构造函数（此时会触发控制块的内存分配），交由shared_ptr管理。因此，如果有weak_ptr引用了这个对象，会导致shared_ptr的控制块无法释放（因为要给weak_ptr提供信息），如果只申请一次内存，将会附带T对象的内存也暂时无法释放2。而使用new就没这个问题。\nmake_shared只支持public构造函数\nmake_shared异常安全性更好，考虑如下两个调用，\nfoo(std::shared_ptr(new int(3)), bar()); // #1\nfoo(std::make_shared&lt;int&gt;(3), bar()); // #2\n由于函数参数的求值顺序是不确定的，调用#1包含了三个部分：分配内存，构造shared_ptr，调用bar. 如果求值顺序是先分配内存，再调用bar，此时抛了异常，那之前分配的内存就泄漏了。而调用#2只包含两个部分：调用make_shared （这一步会完成内存分配和构造shared_ptr）和调用bar. 问题的关键在于构造完对象之后有没有立刻把原始指针交给shared_ptr，中间会不会发生其他事情。\n\n更多区别参考cppreference\nFootnotes\n\n\n总体遵循后创建先销毁的原则。 ↩\n\n\nstackoverflow.com/a/20895705 ↩\n\n\n"},"notes/cpp/模板":{"slug":"notes/cpp/模板","filePath":"notes/cpp/模板.md","title":"模板","links":["tags/cpp.html","tags/template.html"],"tags":["cpp","template"],"content":"模板特化\n背景：编写单一模板，使之对任何可能的模板实参都是最合适的，都能实例化，这并不总是能办到。当我们不能（或不希望）使用模板版本时，可以定义类或函数模板的一个特例化版本。\n函数模板特化\n举个例子，我们构造一个compare函数用于比较不同类型的大小，并重载了compare函数来处理字符串字面常量：\n// 函数模板一: 可以比较任意两个类型\ntemplate &lt;typename T&gt; int compare(const T&amp;, const T&amp;); // #1\n// 函数模板二: 处理字符串字面常量\ntemplate &lt;size_t N, size_t M&gt; int compare(const char(&amp;)[N], const char(&amp;)[M]); // #2\n需要注意的是，只有当我们传递给compare一个字符串字面常量或者一个数组时，编译器才会调用接收两个非类型模板参数的版本。如果我们传递给它字符指针，它就会调用第一个版本（因为我们无法将一个指针转换成一个数组的引用）：\nconst char *p1 = &quot;tomo&quot;, *p2 = &quot;cat&quot;;\ncompare(p1, p2);         // 调用#1\ncompare(&quot;tomo&quot;, &quot;cat&quot;);  // 调用#2\n为了处理字符指针（而不是数组），可以为第一个版本的compare定义一个模板特例化版本。当我们特例化一个函数模板时，必须为原模板中的每个模板参数都提供实参。为了指出我们正在实例化一个模板，应该使用关键字template后跟一个空尖括号对&lt;&gt;：\n// 函数模板\ntemplate &lt;typename T&gt;\nint compare(const T&amp;, const T&amp;);\n// compare的特殊版本, 处理字符数组的指针\ntemplate &lt;&gt;\nint compare(const char* const &amp;p1, const char* const &amp;p2) {\n    return strcmp(p1, p2);\n}\n需要注意的是，一个特例化版本本质上是一个实例，而非函数名的一个重载版本。如果我们将接收字符指针的compare版本定义为一个普通的非模板函数（而不是函数模板的一个特例化版本），此调用的解析就会不同。在此情况下，将由三个可行的函数：两个模板和非模板的字符指针版本。\n类模板特化\n作为一个例子，我们为标准库hash模板定义一个特例化，可以用它来将Foo对象保存在无序容器中。默认情况下，无序容器使用hash&lt;key_type&gt;来组织其元素，为了让我们的数据类型也能使用这种默认组织方式，必须定义hash模板的一个特例化版本。一个hash类必须定义：\n\n一个重载的调用运算符，它接受一个容器关键字类型的对象，返回一个size_t\n两个类型成员，result_type和argument_type，分别是调用运算符的返回类型和参数类型\n默认构造函数和拷贝赋值运算符（可以隐式定义）\n\n在定义此特例化版本的hash时，唯一复杂的地方是：必须在原模板定义所在的命名空间中特例化它。为了达到这一目的，首先必须打开命名空间：\nstruct Foo {\n    string str;\n    double d;\n};\n \n// 打开std命名空间, 以便特例化std::hash\nnamespace std {\n \ntemplate &lt;&gt;  // 我们正在定义一个特例化版本, 模板参数为Foo\nstruct hash&lt;Foo&gt; {\n    // 用来散列一个无序容器的类型必须要定义下列类型\n    typedef size_t result_type;\n    typedef Foo argument_type;\n    size_t operator()(const Foo&amp; foo) const;\n    // 我们的类使用合成的拷贝控制成员和默认构造函数\n};\n \nsize_t hash&lt;Foo&gt;::operator()(const Foo&amp; foo) const {\n    return hash&lt;string&gt;()(foo.str) ^\n           hash&lt;double&gt;()(s.d);\n}\n \n}  // 关闭std命名空间, 注意右花括号之后没有分号\n\nTips：为了让Foo的用户能使用hash特例化版本，我们应该在Foo的头文件中定义该特例化版本。\n\n成员函数模板，可以当成普通函数模板来处理，只是需要额外传入类模板参数：\n// 定义Foo的构造函数, 接受两个迭代器表示要拷贝的元素范围\ntemplate &lt;typename T&gt; class Foo {\n public:\n    template &lt;typename It&gt; Foo(It b, It e);\n private:\n    std::shared_ptr&lt;std::vector&lt;T&gt;&gt; data_;\n};\n \ntemplate &lt;typename T&gt;\ntemplate &lt;typename It&gt;\nFoo&lt;T&gt;::Foo(It b, It e) : data_(std::make_shared&lt;std::vector&lt;T&gt;&gt;(b, e)) { }\n重载与特化\n从编译到函数模板的调用，编译器必须在非模板重载、模板重载和模板重载的特化间决定。\ntemplate&lt; class T &gt; void f(T);              // #1 ：模板重载\ntemplate&lt; class T &gt; void f(T*);             // #2 ：模板重载\nvoid                     f(double);         // #3 ：非模板重载\ntemplate&lt;&gt;          void f(int);            // #4 ： #1 的特化\n \nf(&#039;a&#039;);        // 调用 #1\nf(new int(1)); // 调用 #2\nf(1.0);        // 调用 #3\nf(1);          // 调用 #4\n注意只有非模板和初等模板重载参与重载决议。特化不是重载，且不受考虑。只有在重载决议选择最佳匹配初等函数模板后，才检验其特化以查看何为最佳匹配。\ntemplate&lt; class T &gt; void f(T);    // #1 ：所有类型的重载\ntemplate&lt;&gt;          void f(int*); // #2 ：为指向 int 的指针特化 #1\ntemplate&lt; class T &gt; void f(T*);   // #3 ：所有指针类型的重载\n \nf(new int(1)); // 调用 #3 ，即使通过 #1 的特化会是完美匹配\n即重载的优先级要高于特化。\n关于模板函数重载的更多内容，参考[function_template][1]。\n模板偏特化\n\n\n                  \n                  TIPS\n                  \n                \n\n我们只能偏特化类模板，而不能偏特化函数模板。\n\n\n类模板偏特化之后仍然是一个模板，使用时需要提供特化后的模板实参。\n举个例子，标准库remove_reference类型是一个模板类，它是通过一系列的特例化版本来完成其功能的：\n// 原始的、最通用的版本\ntemplate &lt;class T&gt; struct remove_reference {\n    typedef T type;\n};\n// 部分特例化版本, 将用于左值引用和右值引用\ntemplate &lt;class T&gt; struct remove_reference&lt;T&amp;&gt; {\n    typedef T type;\n};\ntemplate &lt;class T&gt; struct remove_reference&lt;T&amp;&amp;&gt; {\n    typedef T type;\n};\n \nint i;\n// decltype(42)为int, 使用原始模板\nremove_reference&lt;decltype(42)&gt;::type a;\n// decltype(i)为int&amp;, 使用第一个(即T&amp;)部分特例化版本\nremove_reference&lt;decltype(i)&gt;::type b;\n// decltype(std::move(i))为int&amp;&amp;, 使用第二个(即T&amp;&amp;)部分特例化版本\nremove_reference&lt;decltype(std::move(i))&gt;::type c;\n#include &lt;iostream&gt;  \n#include &lt;string&gt;  \n  \n  \nusing std::cout, std::endl, std::string;  \n  \ntemplate&lt;typename T&gt;  \nclass Executor;  // declaration\n  \ntemplate&lt;typename R, typename... Args&gt;  \nclass Executor&lt;R(Args...)&gt;  // partial specification\n{  \nprivate:  \n    using FunctionType = R (*)(Args...);  \n    FunctionType const func_;  \n    int count_ {0};  \npublic:  \n    Executor(FunctionType f): func_(f) {}  \n    R execute(Args ...args)  // hook function\n    {  \n        ++count_;  \n        return func_(args...);  \n    }  \n    [[nodiscard]] int CallCount() const { return count_; }  \n};  \n  \nint read(int i, float f, double d)  \n{  \n    cout &lt;&lt; i &lt;&lt; f &lt;&lt; d &lt;&lt; endl;  \n    return i;  \n}  \n  \n  \nint main()  \n{  \n    auto executor = Executor&lt;decltype(read)&gt;(read);  \n    executor.execute(3, 4.4f, 5.5);  \n    executor.execute(4, 5, 6);  \n    cout &lt;&lt; &quot;\\n exe count=&quot; &lt;&lt; executor.CallCount() &lt;&lt; endl;  \n    return 0;  \n}\n模板编译\n\n模板类的声明和实现需要放在一起，无法分开编译。See more in stackoverflow.com/a/2143606\nsee alse isocpp.org/wiki/faq/templates#separate-template-fn-defn-from-decl-export-keyword\nIt is not possible to write the implementation of a template class in a separate cpp file and compile. All the ways to do so, if anyone claims, are workarounds to mimic the usage of separate cpp file but practically if you intend to write a template class library and distribute it with header and lib files to hide the implementation, it is simply not possible.\nTo know why, let us look at the compilation process. The header files are never compiled. They are only preprocessed. The preprocessed code is then clubbed with the cpp file which is actually compiled. Now if the compiler has to generate the appropriate memory layout for the object it needs to know the data type of the template class.\nActually it must be understood that template class is not a class at all but a template for a class the declaration and definition of which is generated by the compiler at compile time after getting the information of the data type from the argument. As long as the memory layout cannot be created, the instructions for the method definition cannot be generated. Remember the first argument of the class method is the ‘this’ operator. All class methods are converted into individual methods with name mangling and the first parameter as the object which it operates on. The ‘this’ argument is which actually tells about size of the object which incase of template class is unavailable for the compiler unless the user instantiates the object with a valid type argument. In this case if you put the method definitions in a separate cpp file and try to compile it the object file itself will not be generated with the class information. The compilation will not fail, it would generate the object file but it won&#039;t generate any code for the template class in the object file. This is the reason why the linker is unable to find the symbols in the object files and the build fails.\n分离编译为什么不行：因为在编译实现模板的那个cpp文件时，如果该cpp文件中没有显示使用到模板的某个实例化版本，那么，编译器不会为模板的实现生成代码，它也不知道怎么生成。（因为模板参数不知道，你说其他文件中传了？抱歉，c++是一个文件一个文件编译，编一个丢一个的。你想的那些依赖关系都是交给链接器去做的，所以链接器找不到模板定义。）\n参考这里。\nWhy can’t I separate the definition of my templates class from its declaration and put it inside a .cpp file?\nIn order to understand why things are the way they are, first accept these facts:\n\nA template is not a class or a function. A template is a “pattern” that the compiler uses to generate a family of classes or functions.\nIn order for the compiler to generate the code, it must see both the template definition (not just declaration) and the specific types/whatever used to “fill in” the template. For example, if you’re trying to use a Foo&lt;int&gt;, the compiler must see both the Foo template and the fact that you’re trying to make a specific Foo&lt;int&gt;.\nYour compiler probably doesn’t remember the details of one .cpp file while it is compiling another .cpp file. It could, but most do not and if you are reading this FAQ, it almost definitely does not. BTW this is called the “separate compilation model.”\n\nNow based on those facts, here’s an example that shows why things are the way they are. Suppose you have a template Foo defined like this:\ntemplate&lt;typename T&gt;\nclass Foo {\npublic:\n  Foo();\n  void someMethod(T x);\nprivate:\n  T x;\n};\nAlong with similar definitions for the member functions:\ntemplate&lt;typename T&gt;\nFoo&lt;T&gt;::Foo()\n{\n  // ...\n}\ntemplate&lt;typename T&gt;\nvoid Foo&lt;T&gt;::someMethod(T x)\n{\n  // ...\n}\nNow suppose you have some code in file Bar.cpp that uses Foo&lt;int&gt;:\n// Bar.cpp\nvoid blah_blah_blah()\n{\n  // ...\n  Foo&lt;int&gt; f;\n  f.someMethod(5);\n  // ...\n}\nClearly somebody somewhere is going to have to use the “pattern” for the constructor definition and for the someMethod() definition and instantiate those when T is actually int. But if you had put the definition of the constructor and someMethod() into file Foo.cpp, the compiler would see the template code when it compiled Foo.cpp and it would see Foo&lt;int&gt; when it compiled Bar.cpp, but there would never be a time when it saw both the template code and Foo&lt;int&gt;. So by rule #2 above, it could never generate the code for Foo&lt;int&gt;::someMethod()\ncpp template\n\n留意由于模板造成的代码膨胀\n如下代码中，由于Method1和Method2都是虚函数，c++编译器无法知道Bar&lt;int&gt;::Method1是否会被调用，因此必须要为它生成代码。随着虚函数的增多，以及模板实例的增多，代码就会以两者乘积的速度膨胀。在书写模板类时，应留意这种情况。\nclass Foo {\npublic:\n    virtual size_t Method1() = 0;\n    virtual size_t Method2() { return 0; }\n};\n \ntemplate&lt;typename T&gt;\nclass Bar : public Foo {\npublic:\n    size_t Method1() override { return sizeof(T); }\n    size_t Method2() override { return sizeof(T) * 2; }\n};\n \nBar&lt;int&gt; x;  // 生成一份 Method1&lt;int&gt; 和 Method2&lt;int&gt;\nBar&lt;std::string&gt; y;  // 生成一份 Method1&lt;string&gt; 和 Method2&lt;string&gt;\n留意不依赖模板参数的成员是否合理\n模板类的所有成员（包括内部类）都应该对模板参数有依赖，否则考虑是否移到模板外边。\n如下代码中，Result类型实际上不依赖模板参数T，却被放在了模板类Foo中。使得Foo&lt;int&gt;::Result和Foo&lt;string&gt;::Result是不同的类型。可以考虑在类外或者基类中定义Result类型。\ntemplate&lt;typename T&gt;\nclass Foo {\npublic:\n    enum class Result { SUCCESS, FALIURE };\n    Result DoSomething(const T obj);\n};\n\n类型推导的工具\ntemplate &lt;class T, T v&gt;\nstruct integral_constant {\n    static const T value = v;\n    typedef T value_type;\n    typedef integral_const type;\n}\n它将一个值T v唯一地映射到一个类型integral_constant&lt;T, v&gt;，然后在这个类型里，我们可以通过value取回那个值；我们还可以通过value_type取回那个值地类型。这样，我们就建立了从类型到值得一一映射。\n\n在模板元编程中，使用类型要比使用值方便很多。使用值，你得明确规定值的类型；使用类型，你直接写typename就完事儿了，不需要提供更多信息，它可以是任意类型。\n使用代表值的类型要比使用值更方便。\n\n重载决议的过程\n\n根据名称找出所有使用的函数和函数模板\n对于使用的函数模板，要根据实际情况对模板形参进行替换\n\n替换过程中如果发生错误，这个模板会被丢弃（SFINAE：Substitution Failure Is Not An Error.）\n\n\n在上面两步生成的可行函数集合中，编译器会寻找一个最佳匹配，产生对该函数的调用\n如果没有找到最佳匹配，或者找到多个匹配成都相当的函数，则编译器需要报错\n\n函数模板的返回值\n函数模板可以自动推导形参模板类型，但不能推导返回值类型，因此，需要显示指定返回值的模板形参类型，否则编译报错。\ntemplate &lt;typename T1, typename T2, typename T3&gt;\nT3 add(T1 x, T2 y)\n{\n    return x + y;\n}\n \ndouble x = add(1, 2.2f);  // 错误，没有指定返回值模板形参类型\ndouble x = add&lt;int, float, double&gt;(1, 2.2f); // 正确，指定了返回值模板形参类型T3=double\n注意上面的例子中，为了指定T3的类型，必须依次指定T1，T2的类型。\nReferences\n\ncpp-note:模板特性\n"},"notes/cpp/类":{"slug":"notes/cpp/类","filePath":"notes/cpp/类.md","title":"类","links":["notes/cpp/类.html","notes/cpp/多态.html"],"tags":["cpp"],"content":"Constructor\nClasses control default initialization by defining a special constructor, known as the default constructor. The default constructor is one that takes no arguments.\nIf our class does not explicitly define any constructors, the compiler will implicitly define the default constructor for us. The compiler-generated constructor is known as the synthesized default constructor. For most classes, this synthesized constructor initializes each data member of the class as follows:\n\nIf there is an in-class initializer, use it to initialize the member.\nOtherwise, default-initialize the member.\n\n\nThe compiler generates a default constructor automatically only if a class declares no constructors.\n\n\nclass A\n{\npublic:\n    A()=default;\n};\nFirst, note that this constructor defines the default constructor because it takes no arguments1. We are defining this constructor only because we want to provide other constructors as well as the default constructor. We want this constructor to do exactly the same work as the synthesized version we had been using.\nUnder the new standard, if we want the default behavior, we can ask the compiler to generate the constructor for us by writing = default after the parameter list. The = default can appear with the declaration inside the class body or on the definition outside the class body. Like any other function, if the = default appears inside the class body, the default constructor will be inlined; if it appears on the definition outside the class, the member will not be inlined by default.\n几种构造函数的签名（包含赋值运算符）：\n// cf. learn.microsoft.com/zh-cn/cpp/cpp/constructors-cpp\nclass Box2\n{\npublic:\n    Box2() = delete;  // default ctor\n    Box2(const Box2&amp; other) = default;  // copy ctor\n    Box2&amp; operator=(const Box2&amp; other) = default;  // copy assignment\n    Box2(Box2&amp;&amp; other) = default;  // move ctor\n    Box2&amp; operator=(Box2&amp;&amp; other) = default;  // move assignment\n    //...\n};\nConstructor Initializer List\nstruct Vector3\n{\n    Vector3()=default;\n    Vector3(float _x, float _y, float _z)\n        : x(_x), y(_y), z(_z) {}  // ctor initializer list\n    int x, y, z;\n}\n这就叫Constructor Initializer List.\nIt is usually best for a constructor to use an in-class initializer if one exists and gives the member the correct value.\nConstructors should not override in-class initializers except to use a different initial value. If you can’t use in-class initializers, each constructor should explicitly initialize every member of built-in type.\nRevisited\nWhen we define variables, we typically initialize them immediately rather than defining them and then assigning to them:\nstring foo = &quot;Hello World!&quot;; // define and initialize\nstring bar; // default initialized to the empty string\nbar = &quot;Hello World!&quot;; // assign a new value to bar\nExactly the same distinction between initialization and assignment applies to the data members of objects. If we do not explicitly initialize a member in the constructor initializer list, that member is default initialized before the constructor body starts executing.\nAs a result, see below:\n\nWe must use the constructor initializer list to provide values for members that are const, reference, or of a class type that does not have a default constructor.\n\nDelegating Constructors (since c++11)\nA delegating constructor uses another constructor from its own class to perform its initialization. It is said to “delegate” some (or all) of its work to this other constructor. For example:\nclass Sales_data {\npublic:\n// nondelegating constructor initializes members from corresponding arguments\nSales_data(std::string s, unsigned cnt, double price):\nbookNo(s), units_sold(cnt), revenue(cnt*price) { }\n// remaining constructors all delegate to another constructor\nSales_data(): Sales_data(&quot;&quot;, 0, 0) {}\nSales_data(std::string s): Sales_data(s, 0,0) {}\nSales_data(std::istream &amp;is): Sales_data()\n{ read(is, *this); }\n// other members as before\n};\nImplicit Class-Type Conversions\nEvery constructor that can be called with a single argument defines an implicit conversion to a class type. Such constructors are sometimes referred to as converting constructors.\n\nA constructor that can be called with a single argument defines an implicit conversion from the constructor’s parameter type to the class type.\n\nNote: Only One Class-Type Conversion Is Allowed. 只能做一步转换，否则调不到对应构造函数。如下例\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n \nusing namespace std;\n \nstruct A\n{\n    A(string _s): s(_s) { cout &lt;&lt; &quot;A::ctor called\\n&quot;; }\n    string s;\n};\n \n \nint main()\n{\n    vector&lt;A&gt; a;\n    a.push_back(string(&quot;abc&quot;));  // valid, implicit call A::A(string)\n    a.push_back(&quot;def&quot;);  // invalid, need two conversion, char*-&gt;string, string-&gt;A\n    return 0;\n}\n如果不想要这种转换，使用explicit关键字阻止之。\nSuppressing Implicit Conversions Defined by Constructors\nWe can prevent the use of a constructor in a context that requires an implicit conversion by declaring the constructor as explicit:\nstruct A\n{\n    explicit A(string _s): s(_s) { cout &lt;&lt; &quot;A::ctor called\\n&quot;; }\n    string s;\n};\n \n \nint main()\n{\n    vector&lt;A&gt; a;\n    a.push_back(string(&quot;abc&quot;));  // error, A::A(string) is now explicit\n    return 0;\n}\n意思是用explict修饰的构造函数，必须显式的调用。\nThe explicit keyword is meaningful only on constructors that can be called with a single argument.\n\nWhen a constructor is declared explicit, it can be used only with the direct form of initialization (§ 3.2.1, p. 84). Moroever, the compiler will not use this constructor in an automatic conversion.\n\nMember initialization\nclass A\n{\n    int a = 1;  // 简单数据成员的in-class initializer\n    vector&lt;int&gt; b = vector&lt;int&gt;(1, 2, 3); // 复杂数据成员的in-class intializer\n    vector&lt;int&gt; c {4, 5, 6}; // since c++11\n    vector&lt;int&gt; d = {7, 8, 9}; // not recommended\n};\nAs we’ve seen, in-class initializers must use either the = form of initialization (which we used when we initialized the the data members of Screen) or the direct form of initialization using curly braces (as we do for screens).\n\nWhen we provide an in-class initializer, we must do so following an = sign or inside braces.\n\n原本类的数据成员的定义和初始化是分开的，成员定义在类中，成员初始化由构造函数负责。而现在提供一种叫做”in-class initializer”的方式，它的语法如上所述。\n所以，不要纳闷为啥在成员声明中不能直接调用构造函数。\nstruct Vector3\n{\n    Vector3()=default;\n    Vector3(float _x, float _y, float _z)\n        : x(_x), y(_y), z(_z) {}\n    int x, y, z;\n};\n \nstruct A\n{\n    Vector3 pos {1,2,3};\n    Vector3 velocity = Vector3(4,5,6);\n    Vector3 v(7,8,9); // invalid syntax\n};\n \nint main()\n{\n    Vector3 v(1,2,3);  // valid, 定义变量v\n    return 0;\n}\n因为你在试图使用in-class initializer，但你没有遵循它的格式（a = sign or inside braces）。\nConstructors, Destructors, and Assignment Operators\nIf you don’t declare them yourself, compilers will declare their own versions of a copy constructor, a copy assignment operator, and a destructor. Furthermore, if you declare no constructors at all, compilers will also declare a default constructor  for you. All these functions will be both public and inline.\nAs a result, if you write\nclass Empty{};\nit’s essentially the same as if you’d written this:\nclass Empty {\npublic:\n    Empty() { ... } // default constructor\n    Empty(const Empty&amp; rhs) { ... } // copy constructor\n    ~Empty() { ... } // destructor — see below\n                     // for whether it’s virtual\n    Empty&amp; operator=(const Empty&amp; rhs) { ... } // copy assignment operator\n};\nThese functions are generated only if they are needed, the following code will cause each function to be generated:\nEmpty e1;     // default constructor;\n              // destructor\nEmpty e2(e1); // copy constructor\ne2 = e1;      // copy assignment operator\nThings to Remember\n✦ Compilers may implicitly generate a class’s default constructor, copy constructor, copy assignment operator, and destructor.\nC++98有4个特殊非静态成员函数：\n\n默认构造函数：没有任何其他构造函数时默认提供\n拷贝构造函数：用户不提供时默认提供\n拷贝赋值运算符：用户不提供时默认提供\n析构函数：用户不提供时默认提供\n\n三法则由是呼之而出：\n\n\n                  \n                  三法则 \n                  \n                \n\n如果某个类需要用户定义的析构函数，用户定义的拷贝构造函数或用户定义的拷贝赋值运算符，则它几乎肯定三者全部都需要。\n\n\n调用时机（from cpprefernce）\nCOPY CONSTRUCTOR\nThe copy constructor is called whenever an object is initialized (by direct-initialization or copy-initialization) from another object of the same type (unless overload resolution selects a better match or the call is elided), which includes\n\ninitialization: T a = b; or T a(b);, where b is of type T;\nfunction argument passing: f(a);, where a is of type T and f is void f(T t);\nfunction return: return a; inside a function such as T f(), where a is of type T, which has no move constructor.\n\nMOVE CONSTRUCTOR\nThe move constructor is typically called when an object is initialized (by direct-initialization or copy-initialization) from rvalue (xvalue or prvalue) (until C++17)xvalue (since C++17) of the same type, including\n\ninitialization: T a = std::move(b); or T a(std::move(b));, where b is of type T;\nfunction argument passing: f(std::move(a));, where a is of type T and f is void f(T t);\nfunction return: return a; inside a function such as T f(), where a is of type T which has a move constructor.\n\nCOPY ASSIGNMENT\nThe copy assignment operator is called whenever selected by overload resolution, e.g. when an object appears on the left side of an assignment expression.\nMOVE ASSIGNMENT\nThe move assignment operator is called whenever it is selected by overload resolution, e.g. when an object appears on the left-hand side of an assignment expression, where the right-hand side is an rvalue of the same or implicitly convertible type.\n\n注意T a = b;是一个initialization expression而不是assignment expression.\n\nPrevent copies for your object\n\n「将构造函数显式声明为私有」By declaring a member function explicitly, you prevent compilers from generating their own version, and by making the function private, you keep people from calling it.\n「将copy ctor声明为delete（since c++11）」。\n\nclass HomeForSale {\npublic:\n    ...\n    HomeForSale(const HomeForSale&amp;)=delete;\n    HomeForSale&amp; operator=(const HomeForSale&amp;)=delete;\n};\n第一种方法常见用法：\nclass HomeForSale {\npublic:\n    ...\nprivate:\n    ...\n    HomeForSale(const HomeForSale&amp;); // declarations only\n    HomeForSale&amp; operator=(const HomeForSale&amp;);\n};\nWith the above class definition, compilers will thwart client attempts to copy HomeForSale objects, and if you inadvertently try to do it in a member or a friend function, the linker will complain.\nIt’s possible to move the link-time error up to compile time (always a good thing — earlier error detection is better than later) by declaring the copy constructor and copy assignment operator private not in HomeForSale itself, but in a base class specifically designed to prevent copying. The base class is simplicity itself:\nclass Uncopyable {\nprotected: // allow construction\n    Uncopyable() {} // and destruction of\n    ~Uncopyable() {} // derived objects...\nprivate:\n    Uncopyable(const Uncopyable&amp;); // ...but prevent copying\n    Uncopyable&amp; operator=(const Uncopyable&amp;);\n};\nTo keep HomeForSale objects from being copied, all we have to do now is inherit from Uncopyable:\nclass HomeForSale: private Uncopyable { // class no longer\n    ...                                 // declares copy ctor or\n};                                      // copy assign. operator\nThis works, because compilers will try to generate a copy constructor and a copy assignment operator if anybody — even a member or friend function — tries to copy a HomeForSale object. As Item 12 explains, the compiler-generated versions of these functions will try to call their base class counterparts, and those calls will be rejected, because the copying operations are private in the base class.\nDeclare destructors virtual in polymorphic base classes\nsee also When should my destructor be virtual.\n\nDeleting a derived class object through a pointer to a base class with a non-virtual destructor results in undefined behavior.\n\nThings to Remember\n✦ Polymorphic base classes should declare virtual destructors. If a class has any virtual functions, it should have a virtual destructor.\n✦ Classes not designed to be base classes or not designed to be used polymorphically should not declare virtual destructors. 会增加空间开销\n不要在析构函数里面抛异常！\nThings to Remember\n✦ Destructors should never emit exceptions. If functions called in a destructor may throw, the destructor should catch any exceptions, then swallow them or terminate the program.\n✦ If class clients need to be able to react to exceptions thrown during an operation, the class should provide a regular (i.e., non-destructor) function that performs the operation.\nHandle assignment to self in operator=\nAn assignment to self occurs when an object is assigned to itself:\nclass Widget { ... };\nWidget w;\n...\nw = w; // assignment to self\nThis looks silly, but it’s legal, so rest assured that clients will do it. Besides, assignment isn’t always so recognizable. For example,\na[i] = a[j]; // potential assignment to self\nis an assignment to self if i and j have the same value, and\n*px = *py; // potential assignment to self\nis an assignment to self if px and py happen to point to the same thing.\nSuppose you create a class that holds a raw pointer to a dynamically allocated bitmap\nclass Bitmap { ... };\nclass Widget {\n...\nprivate:\n    Bitmap *pb; // ptr to a heap-allocated object\n};\nHere’s an implementation of operator= that looks reasonable on the surface but is unsafe in the presence of assignment to self. (It’s also not exception-safe, but we’ll deal with that in a moment.)\nWidget&amp;\nWidget::operator=(const Widget&amp; rhs) // unsafe impl. of operator=\n{\n    delete pb; // stop using current bitmap\n    pb = new Bitmap(*rhs.pb); // start using a copy of rhs’s bitmap\n    return *this;\n}\nThe self-assignment problem here is that inside operator=, *this (the target of the assignment) and rhs could be the same object. When they are, the delete not only destroys the bitmap for the current object, it destroys the bitmap for rhs, too. At the end of the function, the Widget — which should not have been changed by the assignment to self — finds itself holding a pointer to a deleted object!\nThe traditional way to prevent this error is to check for assignment to self via an identity test at the top of operator=:\nWidget&amp; Widget::operator=(const Widget&amp; rhs)\n{\n    if (this == &amp;rhs) return *this; // identity test: if a self-assignment,\n    // do nothing\n    delete pb;\n    pb = new Bitmap(*rhs.pb);\n    return *this;\nReferences\n\nC++ Primer, 3rd; ch7\nEffective C++, 3rd Edition; ch2\n\nFootnotes\n\n\nA constructor that supplies default arguments for all its parameters also defines the default constructor. ↩\n\n\n"},"notes/cpp/继承":{"slug":"notes/cpp/继承","filePath":"notes/cpp/继承.md","title":"权限控制","links":[],"tags":["cpp","public","private","protected"],"content":"Public inheritance\npublic inheritance means &quot;is-a&quot;.\nIf you write that class D (“Derived”) publicly inherits from class B (“Base”), you are telling C++ compilers (as well as human readers of your code) that every object of type D is also an object of type B, but not vice versa.\n— 《Effective C++》item 32\nAny function that expects an argument of type Person (or pointer-to-Person or reference-to-Person) will also take a Student object (or pointer-to-Student or reference-to-Student):\nvoid eat(const Person&amp; p); // anyone can eat\nvoid study(const Student&amp; s); // only students study\nPerson p; // p is a Person\nStudent s; // s is a Student\neat(p); // fine, p is a Person\neat(s); // fine, s is a Student, and a Student is-a Person\nstudy(s); // fine\nstudy(p); // error! p isn’t a Student\nThis is true only for public inheritance.\n\n意味着只有公有继承，派生类的指针或引用才能转化为基类指针或引用\n\nPublic inheritance asserts that everything that applies to base class objects — everything! — also applies to derived class objects.\nThings to Remember\n✦ Public inheritance means “is-a.” Everything that applies to base classes must also apply to derived classes, because every derived class object is a base class object.\nPrivate inheritance\nTwo features:\n\nin contrast to public inheritance, compilers will generally not convert a derived class object (such as Student) into a base class object (such as Person) if the inheritance relationship between the classes is private;\nmembers inherited from a private base class become private members of the derived class, even if they were protected or public in the base class.\n\nsee more in isocpp.org/wiki/faq/private-inheritance#overview-priv-inherit\nPrivate inheritance means is-implemented-in-terms-of.\nIf you make a class D privately inherit from a class B, you do so because you are interested in taking advantage of some of the features available in class B, not because there is any conceptual relationship between objects of types B and D. As such, private inheritance is purely an implementation technique. (That’s why everything you inherit from a private base class becomes private in your class: it’s all just implementation detail.)\nPrivate inheritance means that implementation only should be inherited; interface should be ignored.\n派生类私有继承基类，旨在利用基类已经写好的一些功能，并不在意基类的接口，继承过来的成员统统变成私有。一般用于software implementation，而非software design.\nThings to Remember\n✦ Private inheritance means is-implemented-in-terms of. It’s usually inferior to composition, but it makes sense when a derived class needs access to protected base class members or needs to redefine inherited virtual functions.\n✦ Unlike composition, private inheritance can enable the empty base optimization. This can be important for library developers who strive to minimize object sizes.\nHow are “private inheritance” and “composition” similar?\nprivate inheritance is a syntactic variant of composition (AKA aggregation and/or has-a).\nE.g., the “Car has-a Engine” relationship can be expressed using simple composition:\nclass Engine {\npublic:\n  Engine(int numCylinders);\n  void start();                 // Starts this Engine\n};\nclass Car {\npublic:\n  Car() : e_(8) { }             // Initializes this Car with 8 cylinders\n  void start() { e_.start(); }  // Start this Car by starting its Engine\nprivate:\n  Engine e_;                    // Car has-a Engine\n};\nThe “Car has-a Engine” relationship can also be expressed using private inheritance:\nclass Car : private Engine {    // Car has-a Engine\npublic:\n  Car() : Engine(8) { }         // Initializes this Car with 8 cylinders\n  using Engine::start;          // Start this Car by starting its Engine\n};\nThere are several similarities between these two variants:\n\nIn both cases there is exactly one Engine member object contained in every Car object\nIn neither case can users (outsiders) convert a Car* to an Engine*\nIn both cases the Car class has a start() method that calls the start() method on the contained Engine object.\n\nThere are also several distinctions:\n\nThe simple-composition variant is needed if you want to contain several Engines per Car\nThe private-inheritance variant can introduce unnecessary multiple inheritance\nThe private-inheritance variant allows members of Car to convert a Car* to an Engine*\nThe private-inheritance variant allows access to the protected members of the base class\nThe private-inheritance variant allows Car to override Engine’s virtual functions\nThe private-inheritance variant makes it slightly simpler (20 characters compared to 28 characters) to give Car a start() method that simply calls through to the Engine’s start() method\n\nNote that private inheritance is usually used to gain access into the protected members of the base class, but this is usually a short-term solution (translation: a band-aid).\nWhat are the access rules with private and protected inheritance?\nTake these calsses as examples:\nclass B                    { /*...*/ };\nclass D_priv : private   B { /*...*/ };\nclass D_prot : protected B { /*...*/ };\nclass D_publ : public    B { /*...*/ };\nclass UserClass            { B b; /*...*/ };\nNone of the derived classes can access anything that is private in B.\n\nIn D_priv, the public and protected parts of B are private;\nIn D_prot, the public and protected parts of B are protected;\nIn D_publ, the public parts of B are public and the protected parts of B are protected (D_publ is-a-kind-of-a B);\nclass UserClass can access only the public parts of B, which “seals off” UserClass from B.\n\nTo make a public member of B public in D_priv or D_prot, state the name of the member with a B:: prefix. E.g., to make member B::f(int, float) public in D_prot, you would say:\nclass D_prot : protected B {\npublic:\n  using B::f;  // Note: Not using B::f(int,float)\n};\nConclusion\n\n公有继承(public) 公有继承的特点是基类的公有成员和保护成员作为派生类的成员时，它们都保持原有的状态，而基类的私有成员仍然是私有的，不能被这个派生类的子类所访问。\n私有继承(private) 私有继承的特点是基类的公有成员和保护成员都作为派生类的私有成员，并且不能被这个派生类的子类所访问。\n保护继承(protected) 保护继承的特点是基类的所有公有成员和保护成员都成为派生类的保护成员，并且只能被它的派生类成员函数或友元访问，基类的私有成员仍然是私有的。\nsee more in C++继承：公有，私有，保护\n\nReferences\n\nInheritance — private and protected inheritance\n"},"notes/cpp/输入输出":{"slug":"notes/cpp/输入输出","filePath":"notes/cpp/输入输出.md","title":"输入输出","links":[],"tags":["cpp"],"content":"使用stringstream分割字符串\n#include &lt;iostream&gt;\n#include &lt;sstream&gt;\n \nusing namespace std;\n \nint main() {\n    stringstream ss(&quot;i,love, you&quot;);\n    string token;\n    while (getline(ss, token)) { /* mark */\n        cout &lt;&lt; token &lt;&lt; endl;\n    }\n    return 0;\n}\ngetline可以传入额外的分割符参数，类型为const char*，默认是换行符\\n. 上面的代码片段mark处可变：\nwhile (getline(ss, token)) 输出\ni,love, you\n\nwhile (getline(ss, token, &#039; &#039;)) 输出\ni,love,\nyou\n\nwhile (getline(ss, token, &#039;,&#039;)) 输出\ni\nlove\n you\n\n读取两行整数，每一行放入一个vector\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;sstream&gt;\n \nusing namespace std;\n \nint main()\n{\n  vector&lt;int&gt; v1, v2;\n  for (int i = 0; i != 2; ++i)\n  {\n    string line;\n    std::getline(cin, line);\n    istringstream is(line);\n    if (i == 0)\n    { // use implicit conversion\n      for (int val; is &gt;&gt; val; v1.push_back(val)) { }\n    }\n    else\n    { // or use std::stoi\n      for (string val; is &gt;&gt; val; v2.push_back(std::stoi(val))) { }\n    }\n  }\n \n  for (auto e : v1) cout &lt;&lt; e &lt;&lt; &quot; &quot;;\n  cout &lt;&lt; endl;\n  for (auto e : v2) cout &lt;&lt; e &lt;&lt; &quot; &quot;;\n \n  return 0;\n}"},"notes/cpp/链接":{"slug":"notes/cpp/链接","filePath":"notes/cpp/链接.md","title":"链接","links":["notes/cpp/CPP基础.html"],"tags":["cpp","linkage"],"content":"链接（Linkage）\nA name that denotes object, reference, function, type, template, namespace, or value, may have linkage. If a name has linkage, it refers to the same entity as the same name introduced by a declaration in another scope. If a variable, function, or another entity with the same name is declared in several scopes, but does not have sufficient linkage, then several instances of the entity are generated.\nCf. www.learncpp.com/cpp-tutorial/internal-linkage/\nIdentifiers have another property named linkage. An identifier’s linkage determines whether other declarations of that name refer to the same object or not.\nLocal variables have no linkage, which means that each declaration refers to a unique object.\nGlobal variable and functions identifiers can have either internal linkage or external linkage.\nInternal linkage\nAn identifier with internal linkage can be seen and used within a single file, but it is not accessible from other files (that is, it is not exposed to the linker). This means that if two files have identically named identifiers with internal linkage, those identifiers will be treated as independent.\nTo make a non-constant global variable internal, we use the static keyword.\nstatic int g_x; // non-constant globals have external linkage by default, but can be given internal linkage via the static keyword\n \nconst int g_y { 1 }; // const globals have internal linkage by default\nconstexpr int g_z { 2 }; // constexpr globals have internal linkage by default\n \nint main()\n{\n    return 0;\n}\nTo see it, we take\na.cpp:\nint g_x = 22;\nconst int g_y = 33;\nconstexpr int g_z = 44;\nmain.cpp:\n#include &lt;stdio.h&gt;\n \nint g_x = 222;\nconst int g_y = 333;\nconstexpr int g_z = 444;\n \nint main()\n{\n    printf(&quot;glabal variable (g_x, g_y, g_z) is (%d, %d, %d)&quot;, g_x, g_y, g_z);\n    return 0;\n}\nif we compile only main.cpp, it works fine and outputs:\nglabal variable (g_x, g_y, g_z) is (222, 333, 444)\n\nBut if we compile both, it gets\n$ clang main.cpp a.cpp\n/usr/bin/ld: /tmp/a-ea4f54.o:(.data+0x0): multiple definition of `g_x&#039;; /tmp/main-c44eb4.o:(.data+0x0): first defined here\nclang-13: error: linker command failed with exit code 1 (use -v to see invocation)\nAs we sligtly modify main.cpp:\n#include &lt;stdio.h&gt;\n \nextern int g_x;\nconst int g_y = 333;\nconstexpr int g_z = 444;\n \nint main()\n{\n    printf(&quot;glabal variable (g_x, g_y, g_z) is (%d, %d, %d)&quot;, g_x, g_y, g_z);\n    return 0;\n}\nit’s compiled and linked properly with the output:\nglabal variable (g_x, g_y, g_z) is (22, 333, 444)\n\nnoting that the g_x has the value 22 which is defined in a.cpp, we find out the global non-const variable has external linkage. And the properly compilation and linking show that global const has internal linkage.\nExternal linkage\nCf. www.learncpp.com/cpp-tutorial/external-linkage/\nAn identifier with external linkage can be seen and used both from the file in which it is defined, and from other code files (via a forward declaration). In this sense, identifiers with external linkage are truly “global” in that they can be used anywhere in your program!\nFunctions have external linkage by default\nIn order to call a function defined in another file, you must place a forward declaration for the function in any other files wishing to use the function. The forward declaration tells the compiler about the existence of the function, and the linker connects the function calls to the actual function definition.\nGlobal variables with external linkage\nGlobal variables with external linkage are sometimes called external variables. To make a global variable external (and thus accessible by other files), we can use the extern keyword to do so:\nint g_x { 2 }; // non-constant globals are external by default\n \nextern const int g_y { 3 }; // const globals can be defined as extern, making them external\nextern constexpr int g_z { 3 }; // constexpr globals can be defined as extern, making them external (but this is useless, see the note in the next section)\n \nint main()\n{\n    return 0;\n}\nNon-const global variables are external by default (if used, the extern keyword will be ignored).\nTo actually use an external global variable that has been defined in another file, you also must place a forward declaration for the global variable in any other files wishing to use the variable. For variables, creating a forward declaration is also done via the extern keyword (with no initialization value).\nHere is an example of using a variable forward declaration:\na.cpp:\n// global variable definitions\nint g_x { 2 }; // non-constant globals have external linkage by default\nextern const int g_y { 3 }; // this extern gives g_y external linkage\nmain.cpp:\n#include &lt;iostream&gt;\n \nextern int g_x; // this extern is a forward declaration of a variable named g_x that is defined somewhere else\nextern const int g_y; // this extern is a forward declaration of a const variable named g_y that is defined somewhere else\n \nint main()\n{\n    std::cout &lt;&lt; g_x; // prints 2\n    return 0;\n}\nNote that the extern keyword has different meanings in different contexts. In some contexts, extern means “give this variable external linkage”. In other contexts, extern means “this is a forward declaration for an external variable that is defined somewhere else”.\nSee also 静态链接, 动态链接."},"notes/cpp/默认参数":{"slug":"notes/cpp/默认参数","filePath":"notes/cpp/默认参数.md","title":"默认参数","links":[],"tags":["cpp"],"content":"默认参数\nMinimal example\nint foo(int x, int y=1) { return x + y; }\n \nint main()\n{\n    cout &lt;&lt; foo(5);  // call foo(5, 1)\n    return 0;\n}\n分离编译带来的隐患\n如果函数声明和定义分离，此时就有一个pitfall。由于默认参数可以定义在函数声明（declaration）中，也可以定义在函数定义（definition）中。\nDefault argument in function definition\n// foo.h\nint foo(int x, int y);\n \n// foo.cpp\n#include &quot;foo.h&quot;\nint foo(int x, int y=1) { return x + y; }\n \n// main.cpp\n#include &lt;iostream&gt;\n#include &quot;foo.h&quot;\n \nint main()\n{\n    std::cout &lt;&lt; foo(3);  // error\n}\n如果改写main.cpp:\n#include &lt;iostream&gt;\nint foo(int x, int y=2);\n \nint main()\n{\n    std::cout &lt;&lt; foo(3);\n}\n使用命令行编译\ng++ foo.cpp main.cpp\n\n运行之，猜一下结果？4 or 5？（答案5）\n很违背直觉是吗？这就是默认参数所带的一系列副作用。所以，在实际工程中，除非特别简单的情况，否则不建议使用默认参数。\n我目前没看过底层原理，只作个简单猜想。这其实是函数定义的不一致，但由于这两个文件是分离编译的，编译器无法处理两个文件中不一致的声明，因为编译器是一个文件一个文件处理的。处理一个丢一个。所以，上述代码可以通过编译，并能成功链接（foo.cpp中提供了foo的定义，main.cpp中提供了foo的前置声明，二者函数原型是一样的，因此也能链接上）。但最后输出的结果，在调用foo(5)是，编译器查找默认参数的时候，优先使用了本文件（main.cpp）函数声明中定义的默认参数，而非其他文件（foo.cpp）中函数定义中定义的默认参数。\n如果继续改写main.cpp\n#include &lt;iostream&gt;\nint foo(int x, char y=2);\n \nint main()\n{\n    std::cout &lt;&lt; foo(3);\n}\n你会发现此时链接器就报错了，说找不到int foo(int, char)的定义。\n$ g++ foo.cpp main.cpp\n/usr/bin/ld: /tmp/ccdz0bAH.o: in function `main&#039;:\nmain.cpp:(.text+0xf): undefined reference to `foo(int, char)&#039;\ncollect2: 错误：ld 返回 1\n这也印证了，上一个例子确实是函数声明中对默认参数的定义不一致，但编译器无法察觉。\nDefault arguments in function declaration\n// foo.h\nint foo(int x, int y=1);\n \n// foo.cpp\n#include &quot;foo.h&quot;\nint foo(int x, int y) { return x + y; }\n \n// main.cpp\n#include &lt;iostream&gt;\n#include &quot;foo.h&quot;\n \nint main()\n{\n    std::cout &lt;&lt; foo(3);  // ok, call foo(3, 1)\n}\n此时在main.cpp中可以省略默认参数，因为编译main.cpp的时候，先将foo.h插入（预处理），此时当走到foo(3)的时候，编译器能拿到默认参数的定义，所以可以成功调用。\n如果改写foo.cpp：\n#incldue &quot;foo.h&quot;\nint foo(int x, int y=2) { return x + y; }\n此时使用g++可以编译成功，运行结果为4（使用的foo.h中函数声明中定义的默认参数）。\n但使用clang时，无法通过编译，会报一个redefinition of default argument的错误：\n$ clang++ main.cpp foo.cpp\nfoo.cpp:3:20: error: redefinition of default argument\nint foo(int x, int y=2)\n                   ^ ~\n./foo.h:4:20: note: previous definition is here\nint foo(int x, int y=1);\n                   ^ ~\n1 error generated.\n需要说明的是，这是合理的结果，clang的做法无疑是更科学的。\ngodbolt.org/z/Wfcz7dsrE\n与虚函数结合带来的隐患\nstruct Cat {\n    virtual void speak(const char *s = &quot;meow&quot;)\n        { printf(&quot;%s.\\n&quot;, s); }\n};\nstruct Tiger : public Cat {\n    void speak(const char *s = &quot;roar&quot;) override\n        { printf(&quot;%s!!\\n&quot;, s); }\n};\n \nCat c;       c.speak();  // &quot;meow.&quot;\nTiger t;     t.speak();  // &quot;roar!!&quot;\nCat *p = &amp;t; p-&gt;speak(); // &quot;meow!!&quot;\n可以看到，当用基类指针调虚函数时，默认参数使用的是基类中提供的那个，是不是又违反直觉了？因为默认参数是编译时确定的，而动态绑定是运行时确定的。在编译完成时，默认参数已经根据静态类型（因为是基类指针，所以是基类类型）进行了填充，运行时发生动态绑定调用派生类的方法这没问题，但是参数传的是基类默认参数。\n更多pitfall参见ref1，其中提到了默认参数的种种罪恶，并奉劝大家不要使用默认参数！\nReferences\n\nquuxplusone.github.io/blog/2020/04/18/default-function-arguments-are-the-devil/\nwww.geeksforgeeks.org/default-arguments-and-virtual-function-in-cpp/\n"},"notes/git/Manage-Dotfiles-by-Git":{"slug":"notes/git/Manage-Dotfiles-by-Git","filePath":"notes/git/Manage-Dotfiles-by-Git.md","title":"使用Git管理配置文件","links":[],"tags":["git"],"content":"对于Linux用户，在 $HOME 文件夹下，一般都有大量的隐藏文件，形如.conf,.xxxrc等，这些都是程序的配置文件。很多人也许花了一个下午，一天，甚至一个星期，折腾某某程序的配置文件。如果这些轻易丢失了，那就是浪费生命了！所以，如何将这些文件备份，成了很多人必须要问的一个问题。\n之前我就一直没有备份的意识。结果无论是重装系统，还是转移机器，都十分煎熬，很多软件都需要重新配置！这可是一个浩大的工程，费时费力还费心。于是终于想起来应该把苦心经营（大部分都是来自网络资源，然后自己改改）的配置文件给备份一下。\n\n于是在网上搜索了一下，发现很多人都用Github备份自己的配置文件。于是便尝试如下：\n常规操作是将所有需要备份的配置文件单独拎出来，放到一个专用文件夹MyConf下，该文件夹就作为 git repo 的根目录。然后将配置文件链接到需要原本需要它们的文件夹下。这应该是个比较不错的解决方案了，但是有的人可能不喜欢创建软链，很强迫症○|￣|_\n于是就有了接下来的方法：主要思想是使用家目录$HOME下的一个文件夹存储一个 Git bare repository 1. 然后使用命令别名去添加，删除，修改配置文件，这样做的好处是不需要在家目录下创建 .git/ 目录，否则会干扰其他子目录的 git 操作。\n1. 新建 bare 仓库\n在$HOME文件夹下新建一个文件夹用来存放 git 版本树。然后初始化为 bare 仓库。\nmkdir ~/.mydotfiles\ngit init --bare ~/.mydotfiles\n\n2. 创建命令别名\n接下来需要创建一个命令别名来进行git的各种操作。直接在家目录运行git命令肯定是不行的，因为家目录不是一个 git repo，不包含 .git 文件夹。所以甚至命令别名如下：\nalias config=&#039;/usr/bin/git --git-dir=$HOME/.mydotfiles/ --work-tree=$HOME&#039;\n\n像这样定义别名，是一种临时的方式。想要使它每次都生效，可以将其写入 .bashrc 或 .zshrc.\necho &quot;alias config=&#039;/usr/bin/git --git-dir=$HOME/.mydotfiles/ --work-tree=$HOME&#039;&quot; &gt;&gt; $HOME/.bashrc\n\n如此一来，每次进入shell，都可以使用这个别名。可以敲一个 config status看看效果。\n3. 使用.gitignore\n现在我们的工作目录是整个家目录，如果要把整个目录全备份的话，那就太可怕了。家目录一般动辄十几甚至几十个Gb，没有哪家免费服务可以让你把整个家目录都备份的。所以我们需要一个 .gitignore 文件。Git 会主动忽略.gitignore中所匹配的那些文件。在家目录中创建（如果没有）.gitignore 文件：\n#! $HOME/.gitignore\n\n#----[ ignore all ] -----\n*\n#---[ consider list ]---\n!*.[Xx]resources\n!*.conf\n!*config*\n!*[a-zA-Z]*rc\n!.config/\n!.config/*\n#---[ ignore list ]---\n\n上面的文件告诉 git 默认忽略所有文件及文件夹，然后反向添加我们想要考虑的那些文件或文件夹2。另外gitignore.io可以根据要求生成不同的 .gitignore 文件。\n忽略特定文件\nPermanently ignore changes to a file\n\nAdd the file in your .gitignore.\nRun the following: git rm —cached &lt;file&gt;\nCommit the removal of the file and the updated .gitignore to your repo.\n\n\n来自谷歌搜索，巨婴家Doc.\n\n4. 常规 git 操作\n现在你可以用config add -A来添加所有匹配到的文件。如之前的配置，可以匹配大部分的配置文件。如有遗漏，可以用config add -f &lt;file&gt; 来强制添加。然后可以 config commit -m &quot;initial git&quot; 来提交更改。最后连接 github 远程仓库。\n首先在github网站新建一个同名仓库。比如本地仓库为.mydotfiles, 那就新建一个同名的远程仓库。然后\nconfig remote add origin git@github.com:&lt;username&gt;/&lt;repo_name&gt;\nconfig push -u origin master\n\n就可以把本地仓库推送到远程，完成同步。\n5. 在新系统上还原配置文件\n同理，设置别名\nalias config=&#039;/usr/bin/git --git-dir=$HOME/.mydotfiles/ --work-tree=$HOME&#039;\n将.mydotfiles加入.gitignore以免递归克隆\necho .mydotfiles &gt;&gt; .gitignore\n克隆备份好的配置文件\ngit clone --bare &lt;git-repo-url&gt; $HOME/.mydotfiles\n检出克隆下来的配置文件\nconfig checkout\nReference\n\nUsing Git and Github to Manage Your Dotfiles\nDotfiles\nThe best way to store your dotfiles: A bare Git repository\nHow to use gitignore command in git - Stack Overflow\nGitignore doc\n\nFootnotes\n\n\nWhat is a bare git repository? ↩\n\n\n关于该文件的匹配规则参见：explain gitignore pattern matching - Stack Overflow ↩\n\n\n"},"notes/git/git手册":{"slug":"notes/git/git手册","filePath":"notes/git/git手册.md","title":"git手册","links":[],"tags":["git"],"content":"创建别名\n使用 git log 查看提交历史，但是输出冗杂。通常使用\ngit log --oneline --abbrev-commit --all --graph --decoreate --color\n来获得更美观易读的输出。但是每次输入这么多肯定很烦人，使用\ngit config --global alias.graph &quot;log --graph --oneline --decorate=short&quot;\n增加一个全局别名，这个别名对于任何地方的 git 都适用。如此一来，键入 git graph 会等效于\ngit log --graph --oneline --decorate=short\n样例输出：\n$ git graph\n \n* 36f2d65 (HEAD -&gt; master, origin/master, origin/HEAD) Forget it\n* 9b4a6d7 Update ref list\n* 3931d4d Using relative path for image\n* ba18821 Upload pics\n* ceca69a fixed reference\n* be15df2 fixed picture address\n* 97a36f3 Initial commit\n今天发现一个还不错的alias，效果如下\n$ git log --pretty=format:&#039;%Cgreen %ad %Cred%h%Creset -%C(yellow)%d%Creset %s %C(bold blue)&lt;%an&gt;%Creset&#039; --abbrev-commit --date=format:&#039;%F %T&#039;\n \n 2025-07-15 15:03:14 910a0c5 - (HEAD -&gt; master, origin/master) add getSHSZBarRTSnapshotRobo &lt;bing.hu&gt;\n 2025-07-11 11:23:49 d95d7c8 - [RTMDD-1461] add news contraint for specific users &lt;bing.hu&gt;\n 2025-07-08 17:13:40 df0681b - fix json empty double issue &lt;Shang.Wu&gt;\n 2025-07-08 10:35:29 8dd8a98 - refine redis merge &lt;Shang.Wu&gt;\n 2025-07-02 13:23:20 7ec1569 - [MDL-613] fix empty exchangeCD and currencyCD &lt;bing.hu&gt;\n 2025-06-04 16:02:11 17392f0 - [DATAIFS-15083] getSHSZBarRTSnapshot2 switch source to 13.115 &lt;bing.hu&gt;\n 2025-05-08 14:09:00 f884afb - improve s3 query &lt;Shang.Wu&gt;\n \n# 可以增加一个别名\n$ git config --global alias.plog &quot;log --pretty=format:&#039;%Cgreen %ad %Cred%h%Creset -%C(yellow)%d%Creset %s %C(bold blue)&lt;%an&gt;%Creset&#039; --abbrev-commit --date=format:&#039;%F %T&#039;&quot;\n忽略已经添加的文件\ngit rm --cached &lt;somefiles&gt;\n推送本地分支到远程\n# 远程分支如果不存在，则自动创建。\ngit push origin &lt;local_brach&gt;:&lt;remote_branch&gt;\n拉取远程分支到本地\n# 从远程分支切换（并创建，如果不存在）本地分支\ngit checkout -b &lt;local_branch&gt; origin/&lt;remote_branch&gt;\n \n# 另：取回远程分支并创建对应的本地分支，不换自动切换到该分支\ngit fetch origin &lt;remote_brach&gt;:&lt;local_branch&gt;\n删除commit历史\n如果不小心将隐私信息推送至远程仓库（如github），那么仅仅删除再更新再推送到远程仓库覆盖是不够的，别人还是可以通过你的commit历史查到你所做的更改，所以这种情况下必须删除之前所有的commit history. 大致思路是创建一个孤立分支，然后重新添加文件，再删除master分支，将新建的分支重命名为master，再推送到远程强制覆盖1。\n# Check out to a temporary branch:\ngit checkout --orphan TEMP_BRANCH\n \n# Add all the files:\ngit add -A\n \n# Commit the changes:\ngit commit -am &quot;Initial commit&quot;\n \n# Delete the old branch:\ngit branch -D master\n \n# Rename the temporary branch to master:\ngit branch -m master\n \n# Finally, force update to our repository:\ngit push -f origin master\n在commit之前撤销add操作\n要在 commit（提交）之前撤销 git add，运行  git reset &lt;file&gt;  或  git reset 取消所有更改即可。\n合并某个文件到当前分支\n例如当前在master分支，希望合并某个分支dev的某个或多个文件到当前分支：\ngit checkout dev file1 file2 ...\n但是上述做法会强行覆盖当前分支的文件，没有冲突处理，更安全的做法是先从当前分支新建分支master_temp，然后在master_temp中checkout，最后再将master_temp分支merge到master分支：\n# Create a branch based on master\ngit checkout -b master_temp\n \n# Chechkout file1 from dev to master_temp\ngit checkout dev file1\ngit commit -m &quot;checkout file1 from dev&quot;\n \n# Switch to master and merge, then delete\ngit checkout master\ngit merge master_temp\ngit branch -d master_temp\nRef: segmentfault.com/a/1190000008360855\nGit merge\n当你觉得很多时候对于一个命令的很多子命令或者选项不是很清晰，而且查了忘，忘了查，那多半是你不理解它的工作机制。或者说它对你来说不是那么自然易懂，这个时候就需要深入以下，了解以下它的基本原理，帮助自己理解，以便记忆。\ngit merge就是如此，你要知道merge的含义是什么？它其实就是在被merge的分支上重现要merge的commits. 比如说：\na---b---c---d---e (master)\n    \\\n     `--A---B---C (dev)\n\n你当前在master分支的e节点，你要merge dev分支。其实就是将A、B、C三个commit在master分支上重现，仿佛master分支上曾经也做过这些改动。那么冲突的来源就是你在两个分支中，对同一个文件作了不同的改动，如何解决不言而喻。\n小朋友，你是否有很多？\nQ: 我想只重现B节点怎么办？\nA: git checkout master &amp;&amp; git cherry-pick 62ecb3，这里62ecb3是节点B的commit标识。\nQ: 我想重现A-B，但不要C怎么办？\nA: git checkout -b newbranch 62ecb3 &amp;&amp; git rebase --onto master 76cada^，这里76cada是A节点的commit标识。先基于B创建一个分支，这个分支包含了A节点的改动，然后rebase到master上去，结果就是A和B重现在master分支上。\nRef:\n\nstackoverflow.com/questions/161813/how-to-resolve-merge-conflicts-in-git\nCherry-Picking specific commits from another branch\n\nFork之后如何同步fork源的更新\n# see remote status\ngit remote -v\n \n# add upstream if not exist one\ngit remote add upstream github.com/&lt;origin_owner&gt;/&lt;origin_repo&gt;.git\ngit remote -v\n从上游仓库 fetch 分支和提交点，提交给本地 master，并会被存储在一个本地分支 upstream/master\ngit fetch upstream\n切换到任意分支，merge已经fetch的分支即可：\ngit checkout somebrach\ngit merge upstream/master\nsee: www.zhihu.com/question/28676261\nRef:\n\nConfigureing a remote for a fork\nSyncing a fork\n\n从另一个分支检出某个文件并重命名\n有时候开了一个孤立分支，但是想参考其他分支的代码，而当前分支又有同名文件，此时就需要从其他分支检出文件并重命名。\n# show the content of a.cpp in specific commit HEAD^\ngit show HEAD^:a.cpp\n \n# that&#039;s done\ngit show HEAD^:a.cpp &gt; b.cpp\nRef: search “git-checkout older revision of a file under a new name” in stack overflow\n查看已被跟踪的文件\ngit ls-files\nRef: search “how can i make git show a list of the files that are being tracked” in stack overflow\nSubmodule\ngit submodule本质上是指向一个其他仓库的链接，默认clone不会将submodule对应的仓库克隆下来。\n# help\ngit submodule --help\n \n# 添加submodule\n#   1. 进入目标子文件夹\ngit submodule add github.com/imtianx/liba.git\n \n# 更新submodule\ncd xxx\ngit pull\ngit submodule update --recursive\n \n# 在主目录下更新submodule liba\ngit submodule update --remote liba\n \n# 删除submodule\nvim .gitmodules # 删除相应条目\nvim .git/config # 删除相应条目\nrm -rf .git/modules/liba # 删除对应的git文件夹\n \n# 在克隆时连同submodule一并克隆\ngit clone github.com/imtianx/MainProject.git --recursive\n# is equivalent to\ngit clone github.com/imtianx/MainProject.git\ngit submodule init\ngit submodule update\nRef:\n\nGit-工具-子模块\nGit 子模块：git submodule\n\n如何撤销本地commit\n有时候本地add了一写diff，随手commit了，接着又有些diff可以共用这个commit，就想撤销刚刚的commit，把所有的diff合并在一起作为一次commit。\n# for more info, type git reset -h\ngit reset --soft &lt;commit_id&gt;\n修改已提交的commit message\n# commit_id至少比要修改的那个commit早一个版本\ngit rebase -i &lt;commit_id&gt;\n \n# 列出 rebase 的 commit 列表，不包含 &lt;commit id&gt;\n$ git rebase -i &lt;commit id&gt;\n# 最近 3 条\n$ git rebase -i HEAD~3\n# 本地仓库没 push 到远程仓库的 commit 信息\n$ git rebase -i\n \n# vi 下，找到需要修改的 commit 记录，`pick` 修改为 `edit` 或 `e`，`:wq` 保存退出\n# 重复执行如下命令直到完成\n$ git commit --amend --message=&quot;modify message by daodaotest&quot; --author=&quot;jiangliheng &lt;jiang_liheng@163.com&gt;&quot;\n$ git rebase --continue\n \n# 中间也可跳过或退出 rebase 模式\n$ git rebase --skip\n$ git rebase --abort\n \n# 如果只是更改last commit\ngit commit --amend\nGit rebase\nCf. www.atlassian.com/git/tutorials/rewriting-history/git-rebase\nrebase和merge都是将另一分支的提交（commit）集成到当前分支的方法。而merge会保留两条分支的所有commit，然后解决冲突，然后形成一个merge commit，从git log上来看，原本线性的提交历史分了叉，然后又合了并。而rebase则是基于当前分支的某次提交去重现另一个分支，rebase之后依然能够保留提交历史的线性状态。\na---b---c---d---e (master)\n    \\\n     `--A---B---C (dev)\n\n\nFrom a content perspective, rebasing is changing the base of your branch from one commit to another making it appear as if you’d created your branch from a different commit. Internally, Git accomplishes this by creating new commits and applying them to the specified base. It’s very important to understand that even though the branch looks the same, it’s composed of entirely new commits.\nThe primary reason for rebasing is to maintain a linear project history. For example, consi der a situation where the main branch has progressed since you started working on a feature branch. You want to get the latest updates to the main branch in your feature branch, but you want to keep your branch’s history clean so it appears as if you’ve been working off the latest main branch.\nYou have two options for integrating your feature into the main branch: merging directly or rebasing and then merging. The former option results in a 3-way merge and a merge commit, while the latter results in a fast-forward merge and a perfectly linear history. The following diagram demonstrates how rebasing onto the main branch facilitates a fast-forward merge.\nRebasing is a common way to integrate upstream changes into your local repository. Pulling in upstream changes with Git merge results in a superfluous merge commit every time you want to see how the project has progressed. On the other hand, rebasing is like saying, “I want to base my changes on what everybody has already done.”\n\n注：写这个的时候，我自己对rebase的理解也很模糊。\n任何时候不清楚的时候请终止rebase:\ngit rebase --abort\n反复操练几次，git有友好的提示信息。\n查看提交记录\n# 查看最近一次提交了哪些文件\ngit log --status -n1\n\ngit-mm使用简介\ngit mm init -u ssh://git@lfg-y.codehub.huawei.com:2222/DCP_Industry_SIG/sig_back_main.git -b master -g C  # 初始化仓库，C表示只下载C语言的代码\n \ngit mm sync # 同步代码\ngit mm start br_dev # 创建分支\ngit mm upload -y # 上传代码，注意这个操作应该在每个git仓库使用常规方式提交之后，统一上传\ngit reset/restore/revert? 傻傻分不清楚\n补丁的创建和应用\n参考：note.alvinhtml.com/developer/git.html\nGit 提供了两种补丁方案，一是用 git diff 生成的 UNIX 标准补丁 .diff 文件，二是 git format-patch 生成的 Git 专用 .patch 文件。\n.diff 文件只是记录文件改变的内容，不带有 commit 记录信息,多个 commit 可以合并成一个 diff 文件。\n.patch 文件带有记录文件改变的内容，也带有 commit 记录信息,每个 commit 对应一个 patch 文件。\n使用 git 的 format-patch 和 am 命令进行生成 patch 和打 patch\n\n对于 git 这种以 project 为单位的修改，尤其是涉及到多个文件夹下的多个文件的改动时，非常方便，能够记录所有的改动（添加，修改，删除文件等）\n可以保存 commit 信息。\n能够灵活的获取 patch。可以获取任意两个 commit 之间的 patch 集。\n\n从本地修改生成diff：mazhuang.org/wiki/git/\n将未添加到暂存区的更改生成 diff 文件：\ngit diff &gt; demo.diff\n\n将已添加到暂存区的更改生成 diff 文件：\ngit diff --cached &gt; demo.diff\n\n合并上面两条命令生成的 diff 文件包含的更改：\ngit apply demo.diff\n\nFootnotes\n\n\ngist.github.com/heiswayi/350e2afda8cece810c0f6116dadbe651 ↩\n\n\n"},"notes/linux/Archlinux重置keyring":{"slug":"notes/linux/Archlinux重置keyring","filePath":"notes/linux/Archlinux重置keyring.md","title":"Archlinux重置keyring","links":["notes/linux/mailto:santiago@archlinux.org.html"],"tags":["linux"],"content":"Archlinux重置keyring\n今天pacman安装一个软件包的时候，突然提示XX作者的GPG key不受信任，网上一查1，原来是GPG存的key需要更新信息了。由于\npacman-key --refresh-keys\n执行过程漫长，我新开了一个窗口直接pacman -Syu了。果不其然，看起来一切都好了。然后回头发现还在更新keyring，心想：我都完活了，你还没执行完，遂直接杀了进程。\n\n一切看起来相安无事，但当我下次执行pacman相关指令的时候，会频繁报错，keyring有问题，然后我再想像之前那样刷新的时候呢，gpg报了一大堆看不懂的错误。这下糟了，看起来我是把所有key都弄坏了。于是一不做二不休，直接重置算了。\n重置过程参考此处，摘要如下\nrm -rf /etc/pacman.d/gnupg\npacman-key --init\npacman-key --populate\npacman -Syu\nReferences\n\nGnuPG-2.1 与 pacman 密钥环\n\nFootnotes\n\n\nArchlinux 长时间未更新报错：containerd: 来自 “Santiago Torres-Arias santiago@archlinux.org” 的签名是未知信任的 ↩\n\n\n"},"notes/linux/Swap分区扩容":{"slug":"notes/linux/Swap分区扩容","filePath":"notes/linux/Swap分区扩容.md","title":"管理swap分区","links":["notes/Blogs/post/linux-hibernate.html"],"tags":["linux","swap"],"content":"由于涉及到磁盘分区，一般来说swap分区在安装系统的时候就要确定。一般建议为总内存大小的一半。\n可以通过如下步骤设置一个swap分区：\nmkswap /dev/swap_partition\nswapon /dev/swap_partition\n先前安装系统的时候，swap分区给小了（机器内存的一半）。我的笔记本内存8G，swap给了4G，当系统已用内存超过4G，会导致无法休眠。如果swap给的和本机内存一样大，那么就不会存在swap放不下当前工作镜像的问题。但重新分区追加swap显然不现实，所以只能让两块swap拼凑一下，达到总体有8G可用swap的效果。\n\n像我之前，每当要休眠的时候，都要清一下系统内存，保证已用内存在4G以下再休眠。十分繁琐。\n\n无论是新建一块swap分区，抑或是创建一个swapfile，都能达到上述效果。下面介绍一下如何创建一个swapfile作为追加swap使用。\n当前，本机swap只有4G：\n$ free -h\n               total        used        free      shared  buff/cache   available\n内存：      7.7Gi       754Mi       6.0Gi       189Mi       978Mi       6.5Gi\n交换：      4.1Gi          0B       4.1Gi\n创建一个swapfile：\n# 创建一个4G大小的文件\ndd if=/dev/zero of=/tmp/swapfile bs=1M count=4096\n \n# 格式化为swap格式\nmkswap /tmp/swapfile\n \n# 启用swapfile\nswapon /tmp/swapfile\n \n# 查看当前可用swap\nfree -h\n               total        used        free      shared  buff/cache   available\n内存：      7.7Gi       822Mi       5.9Gi       189Mi       981Mi       6.5Gi\n交换：      8.1Gi          0B       8.1Gi\n \n# 关闭swap\nswapoff /tmp/swapfile\n \n# 查看已使用swap分区的摘要\nswapon -s\nFilename\t\t\t\t                Type\t\tSize\t\tUsed\t\tPriority\n/dev/nvme0n1p7                          partition\t4323648\t\t0\t\t-2\n/home/yychi/EXTRA/swapfile              file\t\t4194300\t\t0\t\t-3\n这样一来，就完成了swap扩容。但是，你会发现上述工作每次重启都会丢失，所以还要将swapfile写进fstab，保证每次启动都会加载这块swap.\n$ cat /etc/fstab\n# /dev/nvme0n1p7\nUUID=4227170f-0a4f-4a8e-fads-jasdfkjaskf\tnone      \tswap      \tdefaults,pri=-2\t0 0\n# extra swapfile\n/home/yychi/EXTRA/swapfile                  none        swap        defaults,pri=-1 0 0\n清空swap\ncf. www.cnblogs.com/EasonJim/p/8357973.html\n# 其实就是关闭再重新启用\nswapoff &lt;swap_partition&gt;\nswapon &lt;swap_partition&gt;\n \n# 特别的，可以全部关闭\nswapoff -a\nswapon -a"},"notes/linux/使用指北":{"slug":"notes/linux/使用指北","filePath":"notes/linux/使用指北.md","title":"使用指北","links":[],"tags":["linux","管理","手册","manual"],"content":"使用指北\n系统管理\n清理缓存\n$ free -h\n               total        used        free      shared  buff/cache   available\n内存：      7.7Gi       4.5Gi       231Mi       699Mi       2.9Gi       2.2Gi\n交换：      8.1Gi       2.7Gi       5.5Gi\nfree 命令中列出的几个项目中，available 是程序可申请的内存，其他几项如 shared，buff/cache 如何释放掉呢？\n# clear cache\nsync; echo 1 &gt; /proc/sys/vm/drop_caches\n \n# clear swap\nswapoff -a\nswapon -a\n参考： colobu.com/2015/10/31/How-to-Clear-RAM-Memory-Cache-Buffer-and-Swap-Space-on-Linux/\n信息查询\n查看磁盘型号，分区等：\n$ fdisk -l /dev/sda\nDisk /dev/sda：223.57 GiB，240057409536 字节，468862128 个扇区\n磁盘型号：TOSHIBA Q200 EX \n单元：扇区 / 1 * 512 = 512 字节\n扇区大小(逻辑/物理)：512 字节 / 512 字节\nI/O 大小(最小/最佳)：512 字节 / 512 字节\n磁盘标签类型：gpt\n磁盘标识符：44A6E8C5-8E84-674F-8B6F-4086158B8AFE\n \n设备            起点      末尾      扇区   大小 类型\n/dev/sda1       2048 230688767 230686720   110G Linux 文件系统\n/dev/sda2  230688768 468862094 238173327 113.6G Microsoft 基本数据\nJournal\n# 查看boot日志\njournalctl -b\n \n# 查看上一次的boot日志，同理-2/3/4...\njournalctl -b -1\n \n# 列出所有启动日志\njournalctl --list-boots\ncf. www.linode.com/docs/guides/how-to-use-journalctl/\nkernel相关\ncat /proc/cmdline # 查看内核启动参数\nlsmod # 查看启用的kernel module"},"notes/mathapp/K-Means":{"slug":"notes/mathapp/K-Means","filePath":"notes/mathapp/K-Means.md","title":"K-Means","links":[],"tags":["math"],"content":"K-Means\nsee: stanford.edu/~cpiech/cs221/handouts/kmeans.html"},"notes/network/IO模型":{"slug":"notes/network/IO模型","filePath":"notes/network/IO模型.md","title":"IO模型","links":["notes/asio/同步异步阻塞非阻塞.html"],"tags":["network","io-multiplex","io多路复用","select","poll"],"content":"I/O Multiplexing\n「定义」What we need is the capability to tell the kernel that we want to be notified if one or more I/O conditions are ready (i.e., input is ready to be read, or the descriptor is capable of taking more output). This capability is called I/O multiplexing and is provided by the select and poll functions.\ni/o多路复用的使用场景：\n\nWhen a client is handling multiple descriptors (normally interactive input and a network socket), I/O multiplexing should be used.\nIt is possible, but rare, for a client to handle multiple sockets at the same time.\nIf a TCP server handles both a listening socket and its connected sockets, I/O multiplexing is normally used.\nIf a server handles both TCP and UDP, I/O multiplexing is normally used.\nIf a server handles multiple services and perhaps multiple protocols (e.g., the inetd daemon),  I/O multiplexing is normally used.\n\nI/O Models\nThe five I/O models that are available to us under Unix:\n\nblocking I/O\nnonblocking I/O\nI/O multiplexing (select and poll)\nsignal driven I/O (SIGIO)\nasynchronous I/O (the POSIX aio_functions)\n\nThere are normally two distinct phases for an input operation:\n\nWaiting for the data to be ready\nCopying the data from the kernel to the process\n\nFor an input operation on a socket, the first step normally involves waiting for data to arrive on the network. When the packet arrives, it is copied into a buffer within the kernel. The second step is copying this data from the kernel’s buffer into our application buffer.\nBlocking I/O Model\nBy default, all sockets are blocking.\n\nIn Figure 6.1, the process calls recvfrom and the system call does not return until the datagram arrives and is copied into our application buffer, or an error occurs. The most common error is the system call being interrupted by a signal, as we described in Section 5.9. We say that our process is blocked the entire time from when it calls recvfrom until it returns. When recvfrom returns successfully, our application processes the datagram.\nNonblocking I/O Model\n\nWhen we set a socket to be nonblocking, we are telling the kernel ‘‘when an I/O operation that I request cannot be completed without putting the process to sleep, do not put the process to sleep, but return an error instead.’’\nThe first three times that we call recvfrom, there is no data to return, so the kernel immediately returns an error of EWOULDBLOCK instead. The fourth time we call\nrecvfrom, a datagram is ready, it is copied into our application buffer, and recvfrom returns successfully. We then process the data.\nWhen an application sits in a loop calling recvfrom on a nonblocking descriptor like this, it is called polling. The application is continually polling the kernel to see if some operation is ready. This is often a waste of CPU time, but this model is occasionally encountered, normally on systems dedicated to one function.\nI/O Multiplexing Model\nWith I/O multiplexing, we call select or poll and block in one of these two system calls, instead of blocking in the actual I/O system call. 「实际上是将阻塞的那次call转移到了select和poll.」\n\nWe block in a call to select, waiting for the datagram socket to be readable. When select returns that the socket is readable, we then call recvfrom to copy the datagram into our application buffer.\nSignal-Driven I/O Model\nRefer to UNP chapter 6.2.\nAsynchronous I/O Model\nIn general, these functions work by telling the kernel to start the operation and to notify us when the entire operation (including the copy of the data from the kernel to our buffer) is complete.\n\nThis system call returns immediately and our process is not blocked while waiting for the I/O to complete.\n\nSynchronous I/O versus Asynchronous I/O\nPOSIX defines these two terms as follows:\n• A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes.\n• An asynchronous I/O operation does not cause the requesting process to be blocked.\nUsing these definitions, the first four I/O models—blocking, nonblocking, I/O multiplexing, and signal-driven I/O—are all synchronous because the actual I/O operation (recvfrom) blocks the process. Only the asynchronous I/O model matches the asynchronous I/O definition.\n\nAsio doc says:\n\nSynchronous operations are functions that do not return control to the caller until the corresponding operating system operation completes.\nAsynchronous operations do not block the caller, but instead involve the delivery of a notification to the program when the corresponding operating system operation completes.\n\n\nsee also 同步异步阻塞非阻塞\n\nIO 多路复用是什么意思？ - 罗志宇的回答 - 知乎\nzhuanlan.zhihu.com/p/272891398\nsegmentfault.com/a/1190000003063859\njvns.ca/blog/2017/06/03/async-io-on-linux—select—poll—and-epoll/\ndaniel.haxx.se/docs/poll-vs-select.html\n\nReferences\n\nUnix Network Programming, chater 6\n"},"notes/network/tcp":{"slug":"notes/network/tcp","filePath":"notes/network/tcp.md","title":"tcp","links":[],"tags":[],"content":"tcp\nThree-Way Handshake\nThe following scenario occurs when a TCP connection is established:\n\nThe server must be prepared to accept an incoming connection. This is normally done by calling socket, bind, and listen and is called a passive open.\nThe client issues an active open by calling connect. This causes the client TCP to send a “synchronize” (SYN) segment, which tells the server the client’s initial sequence number for the data that the client will send on the connection. Normally, there is no data sent with the SYN; it just contains an IP header, a TCP header, and possible TCP options (which we will talk about shortly).\nThe server must acknowledge (ACK) the client’s SYN and the server must also send its own SYN containing the initial sequence number for the data that the server will send on the connection. The server sends its SYN and the ACK of the client’s SYN in a single segment.\nThe client must acknowledge the server’s SYN.\n\nThe minimum number of packets required for this exchange is three; hence, this is called TCP’s three-way handshake. 【叫三次握手是因为最少三个数据包，可能会超过三个】\n\nWe show the client’s initial sequence number as J and the server’s initial sequence number as K. The acknowledgment number in an ACK is the next expected sequence number for the end sending the ACK.\nTCP Connection Termination\nWhile it takes three segments to establish a connection, it takes four to terminate a connection.\n\nOne application calls close first, and we say that this end performs the active close (这一方主动关闭). This end’s TCP sends a FIN segment, which means it is finished sending data.\nThe other end that receives the FIN performs the passive close (另一方被动关闭). The received FIN is acknowledged by TCP. The receipt of the FIN is also passed to the application as an end-of-file (after any data that may have already been queued for the application to receive), since the receipt of the FIN means the application will not receive any additional data on the connection.\nSometime later, the application that received the end-of-file will close its socket. This causes its TCP to send a FIN. 另一方关闭，并发送FIN向主动关闭的一方\nThe TCP on the system that receives this final FIN (the end that did the active close) acknowledges the FIN. （主动关闭的一方确认此FIN）\n\nSince a FIN and an ACK are required in each direction, four segments are normally required.\nReferences\n\nUNP\n"},"notes/network/计算机网络基础":{"slug":"notes/network/计算机网络基础","filePath":"notes/network/计算机网络基础.md","title":"计算机网络基础","links":["tags/http.html"],"tags":["网络","tcp","udp","http"],"content":"网络\n\n摘自《程序员面试白皮书》\n\n网络分层\n计算级之间的交互模型通常是指Open System Interconnection model (OSI), 该模型将网络通信系统抽象成了七层。因其不太实用，工业界普遍使用简化的TCP/IP五层模型。\n\n\n应用层 针对特定的协议，为应用程序做服务,比如SMP,POP3,SSH,FTP等协议。\n表示层 负责数据格式的转换，把不同表现形式的信息转换成适合网络传输的格式。\n会话层 负责建立和断开通信连接，什么时候建立连接，什么时候断开连接以及保持多久的连接。\n传输层 在两个通信节点之间负责数据的传输，起着可靠传输的作用。(运行在这一层的设备有四层交换机，四层路由器)\n网络层 路由选择，在多个网络之间转发数据包，负责将数据包传送到目的地址。(运行在这一层的设备有路由器，三层交换机)\n数据链路层 负责物理层面互联设备之间的通信传输，比如一个以太网相连的两个节点之间的通信，是数据帧与1、0比特流之间的转换。(运行在这一层的设备是网桥、以太网交换机、网卡)\n物理层 主要是1、0比特流与电子信号的高低电平之间的转换。(运行在这一层的设备是中继器、双绞线)\n\n\n\n                  \n                  Tip\n                  \n                \n\nHTTP位于应用层，TCP/UDP位于传输层，IP协议位于网络层。\n\n\n路由\n从用户角度看，路由（routing）是指将数据从一个用户终端，通过网络节点（例如路由器、交换机等），发送到另一个用户节点的过程。理论上说，对于一个拥有多个节点的拓扑网络而言，路由是指在Network Layer（OSI model的第三层）将数据包（data packet）从一个节点以最优的路径发送到目标节点的实现方法。其核心包括：如何获得邻近节点的信息，如何估计链路质量，如何寻址，如何构建网络拓扑等等。通过路由器之间的路由协议（routing protocol）可以实现两个网络节点之间信息（包括网络域名，邻近节点，链路质量等）的交换和散布，通过不断重复该过程，每个节点都会获得足够多关于所在网络的拓扑信息。当有数据包需要传送时，路由器再通过路由算法（routing algorithm）计算传递当前数据包的最优路径，并把数据包发送给下一个邻近节点。许多路由算法基于图理论，实现了最小生成树，最短路径等等经典的拓扑算法。\n网络中，所谓地址是指IP地址，IPv4规定利用32bits作为IP地址（即4bytes，也就是我们常看到的x.x.x.x，x在0-255之间，2^8-1=255）。但随着网络设备的增多，IPv4已经不能满足人们的需求，故互联网逐渐向IPv6进行演进，IPv6利用128bits作为IP地址。\n事实上，直观而言，network routing的过程就相当于传统意义上的邮包寄送，IP地址可以类比于邮政编码，路由器就相当于邮局，通过目的地邮政编码与邮局系统中的递送路径进行比较，由此确定下一步应该把当前包裹传递到哪里。\n网络统计指标\n带宽/速率（Bandwidth/Rate）\n所谓带宽是指一个网络节点能以多快的速度将数据接收/发送出去，单位时bits per second（bps）。对于实时性要求不高的数据，例如下载等，带宽时影响用户体验的主要因素。两个终端节点之间的带宽由路径中所有节点的最小带宽决定。同时，重算的数据发送速度不应超过当前的上载带宽，否则会对网络造成压力导致拥塞（congestion）。\nOne-way Delay/Round Trip Time\nOne-way Delay用以衡量网络的延迟。假设在时间点A从一个节点发送数据到另一个节点，目的节点在时间B收到数据，则两个时间点之差即为One-way Delay. 类似的，RTT则是数据完成一个Round Trip回到始发节点的时间差，一般RTT可以近似估计为One-way Delay的两倍。对于网络会议，IP电话等，延迟时影响用户体验的主要因素。延迟可能是由网络中某个节点处理数据速度慢，突然有大规模数据需要传输，或者某条链路不断重传数据造成的。延迟与带宽有一定的相关性，但没有必然联系。\nTCP vs. UDP\n在Transport Layer，数据流被分块传输。最常见的协议是TCP和UDP。\nTCP\nReliable Protocol TCP（Transmission Control Protocol）是一种可靠的传输协议，在网络条件正常的情况下，TCP协议能够保证接收端收到所有数据，并且接受到的数据顺序与发送端一致。TCP通过在发送端给每个数据包分配单调递增的sequence number，以及在接收端发送ACK（acknowledgement）实现可靠传输。每个发送的数据包都包含序列号，当接收端收到数据包时，会发送ACK告诉发送端当前自己期待的下一个序列号是多少。例如，发送端分别发送了序列号为99、100、101、102的四个数据包，接收端收到数据包99后，会发送ACK 100，意味着接收端期待下一个数据包编号100. 如果由于某些原因，数据包100没有到达接收端，但数据包101、102到达了，那么接收端会继续发送ACK 100. 当发送端发现当前发送的数据包编号超过了100，但接收端仍然期望收到100，那么发送端就会重新发送数据包100. 如果接收端收到了重新发送的数据包100，那么接收端会回复ACK 103，继续进行剩下的数据传输，并且把数据包99、100、101、102按顺序传递给上一层。\nFlow Control TCP使用了end-to-end flow control以避免发送端发送数据过快导致接收端无法处理。TCP采用了滑动窗口（sliding window）实现流量控制。 接收端通过ACK告诉发送端自己还能接收多少数据，发送端不能发送超过该值的数据量。当接收端返回的窗口大小为0时，发送端停止发送数据，直到窗口大小被更新。由于ACK是由发送端发送的数据触发，可能接收端窗口已经打开，但是由于发送端已经停止发送，故接收端没有机会通过ACK告知发送端新的窗口大小，在这种情况下会造成死锁。在实际实现中，发送端会设置一个timer，如果timer到期，发送端会尝试发送小数据包，以触发接收端ACK.\nCongestion Control 为了控制传输速度防止堵塞网络，并且在网络容量允许的范围内尽可能多的传输数据，TCP引入congestion control，用以判断当前的网络负荷，并且调整传输速率。TCP通常采用additive increase， multiplicative decrease的算法，即如果按时收到对应的ACK，则下一次传输速率线性增加，否则视为发生了网络拥塞，下一次传输的比特数折半。所谓的“按时”基于RTT：发送端会估计RTT，并且期望当数据包发送以后，在RTT时间内收到对应的ACK。现在TCP需要分别实现slow-start，congestion avoidance，fast retransmit和fast-recovery，以达到最高的效率。\nUDP\n相比与TCP，UDP（User Datagram Protocol）简单许多：连接建立时不需要经过类似于TCP的三次握手，只需要知道接收端的IP和端口，发送端就可以直接发送数据。同时，UDP也没有ACK，flow control和congestion control，故UDP相较TCP传输更快，使用起来更简单。\nUDP介绍\n\n摘自《计算机网络 第四版》\n\nUDP面向无连接，它传输的数据段（segment）是由8字节的头和净荷域构成的。头包含源端口和目标端口，各占16位，共4字节。两个端口分别被用来标识源机器和目标机器内部的端点。当一个UDP分组到来的时候，它的净荷部分被递交给与目标端口相关联的那个进程。这种关联关系是在调用了bind原语或者其他某一种类似的做法之后建立起来的。实际上，采用UDP而不是原始的IP，其最主要的价值是增加了源端口和目标端口。如果没有端口域，则传输层将不知道该如何处理分组；而有了端口之后，它就可以正确地提交数据段了。\n当目标端必须将一个应答送回给源端地时候，源端口是必须地。发送应答的进程只要将进来的数据段中的source port域复制道输出的数据段中的destination port域，就可以指定在发送方机器上由哪个进程来接受应答。\n另外值得提出来的可能是UDP没有做到一些事情。UDP并不考虑流控制、错误控制，在收到一个坏的数据段之后它也不重传。所有这些工作都留给用户进程。UDP所作的事情就是提供一个接口，并且在接口中增加复用（demultiplexing）的特性。他利用端口的概念将数据段解复用到多个进程中。这就是它所做的全部工作。\nUDP尤其适用域C-S架构下，客户端给服务器发送一个短的请求，并且期望一个短的应答回来，如果请求或者应答丢失，只需要超时重传。\nUDP的一个应用时DNS（Domain Name System），简单来说，如果一个程序需要根据某一个主机名（比如www.cs.berkeley.edu）来查找它的IP地址，那么，它可以给DNS服务器发送一个包含该主机名的UDP分组。服务器用一个包含该主机IP地址的UDP分组作为应答。实现不需要建立连接，事后也不需要释放连接。在网络上只要两条消息就够了。DNS在进行区域传输(主从dns server之间的数据同步)的时候使用TCP，普通的查询使用UDP。因为普通查询数据量小，比较适合用udp这种速度更快。\nRPC\n从某种意义上讲，向一台远程主机发送一个消息并获得一个应答，就如同在编程语言中执行一个函数调用一样。在这两种情况下，你都要提供一个或多个参数，然后获得一个结果。这种现象导致人们试图将网络上的请求-应答交互过程，做成像过程调用那样可以进行类型匹配和转换。这样的结构是的网络应用更加易于编程，而且人们对这种处理方式也更加熟悉。例如，假设有一个名为getIPaddress(hostname)的过程，它的工作方式为：向DNS服务器发送一个UDP分组，然后等待应答，如果在规定的时间内没有接收到应答的话，则超时并重试。通过这种方式，网络的所有细节对于程序员而言全部隐藏。\n这个领域中的关键工作由Birrel和Nelson（1984）完成。简单来说：允许本地的程序调用远程主机上的过程。当机器A上的进程调用机器B上的一个过程的时候，机器A上的调用进程被挂起，而机器B上被调用的过程则开始执行。参数信息从调用方传输到被调用方，而过程的执行结果则从反方向传递回来。对于程序员而言，所有的消息传递都是不可见的。这项技术称为RPC（Remote Procedure Call），目前已成为许多网络应用的基础。按照传统，调用过程称为客户，被调用过程称为服务器。\n当然，RPC不一定非得使用UDP分组，但是，RPC和UDP是一对很好的搭档，而且，UDP常常被用于RPC。然而，当参数或者结果值可能超过最大的UDP分组的时候，或者当所请求的操作并不幂等（即不能安全地重复多次执行，比如计数器递增地操作）的时候，可能有必要建立一个TCP连接，然后利用该连接来发送请求，而不是使用UDP来完成远程调用。\nRTC\nUDP的还被广泛应用在实时多媒体：Internet广播电台、Internet电话、音乐点播、视频会议、视频点播等。人们发现每一种应用都在重复设计几乎相同的实时传输协议，逐渐地人们意识到，为多媒体应用制定一个通用的协议是一个很好的想法，因此就诞生了RTP（Real-time Transport Protocol）。\nTCP介绍\nUDP是一个简单的协议，它有一些非常合适的用途。但是对于大多数Internet应用来说，他们更需要可靠的，按序递交的特性。所以还需要另一个协议，这就是TCP，目前它是Internet上承担任务最为繁重的一个协议。\nTCP是专门为了在不可靠的互联网上提供一个可靠的端到端字节流而设计的。每台支持TCP的机器都有一个TCP传输实体，它或者是一个库过程，或者是一个用户进程，或者是内核的一部分。在所有这些情形下，它管理TCP流，以及与IP层之间的接口。TCP传输实体接受本地进程和用户数据流，并且将他们分割成不超过64KB（在实践中，考虑到每个帧中都希望有IP和TCP头，所以通常不超过1460数据字节）的分片，然后以单独的IP数据报的形式发送每一个分片。当包含TCP数据的数据报到达一台机器的时候，他们被递交给TCP传输实体，然后TCP传输实体再重构出原始的字节流。\nIP层并不保证数据报一定被正确的递交到目标端，所以TCP需要判断超时的情况，并且需要根据需要重传数据报。即使被正确递交的数据报，也可能存在错序的问题，这也是TCP的责任，他必须把接收到的数据报按照正确的顺序重新装配成用户消息。\nTCP服务模型\n要想获得TCP服务，发送方和接收方必须创建一种被称为套接字的端点。每个套接字有一个套接字号（地址），它是由主机的IP地址以及本地主机局部的一个16为数值组成的，此16为数值被称为端口（port）。端口是一个TSAP的TCP名字。为了获得TCP服务，首先必须要显示的再发送机器的套接字和接受机器的套接字之间建立一个连接。\n一个套接字有可能同时被用于多个连接。换句话说，两个或者多个连接可能终止与同一个套接字。每个连接可以用两端的套接字标识符来标识，即（socket1, socket2）。TCP不适用虚电路号或者其他的标识符。\n1024以下的端口号被称为知名端口（well-known port），其实就是系统保留端口，有很多约定的服务和特定的端口号对应，如ssh默认端口号是22.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n应用程序FTPTFTPTELNETSMTPDNSHTTPSSHMYSQL端口21, 206923255380223306传输层协议TCPUDPTCPTCPUDPTCPTCPTCP\n所有的TCP连接都是全双工的，并且是点到点的。所谓全双工，意味着同时可在两个方向上传输数据；而点到点则意味着每个连接恰好有两个端点。TCP并不支持多播或者广播传输模式。\n一个TCP连接就是一个字节流，而不是消息流。端到端之间并不比保留消息的边界。例如，如果发送进程将4个512字节的数据块写到一个TCP流中，那么在接收进程中，这些数据有可能按4个512字节快的方式被递交，也可能是2个1024字节的数据块，或是一个2048字节的数据块，或者其他方式。接收方无法获知这些数据被写入字节流时候的单元大小。\n正如Unix中文件一样，读文件的程序无法判断该文件是怎么写成的，是一次性还是分块写入，然而，程序也无意于去弄清这个事情。一个TCP软件不理解TCP字节流的含义，也无意于弄清其含义，一个字节就是一个字节而已。\n当一个应用将数据传递给TCP的时候，TCP可能立即将数据发送出去，也可能将它缓冲起来（为了收集更多的数据从而一次发送出去），这完全由TCP软件自己来决定。然而，有时候应用程序确实希望自己的数据立即被发送出去，例如，假设一个用户已经登陆到一台远程服务器上，用户每输入一行命令就会敲入回车键，这时候该命令行应该被立即发送到远程主机，而不应该缓冲起来等待下一行命令。为了强迫将数据发送出去，应用程序可以使用PUSH标志，它相当于告诉TCP不要延迟传输过程。\n有关TCP服务的最后一个值得在这里提出来的特性是紧急数据（urgent data）。当一个交互用户通过敲入DEL或者CTRL-C来打断一个已经开始运行的远程计算过程的时候，发送方应用把一些控制信息放在数据流中，然后将它联通URGETN标志一起交给TCP。这一事件将使得TCP停止继续积累数据，而是将该连接上已有的所有数据立即传输出去。当目标端接收到紧急数据的时候，接收方应用被中断（比如，按Unix的术语来说得到了一个信号），所以它停止当前正在做的工作，并且读入数据流以找到紧急数据。紧急数据的尾部应该被标记出来，所以，如何发现紧急数据要取决于具体的应用程序。这种方案基本上只是提供了一种原始的信号机制，其余的工作全部留给应用程序自己来处理。\nTCP协议\nTCP的一个关键特征，也是主导了整个协议设计的特征是，TCP连接上的每个字节都有它独有的32位序列号。发送端和接收端的TCP实体以数据段的形式交换数据。TCP数据段（TCP segment）是由一个固定的20字节的头（加上可选的部分）以及随后的0个或者多个数据字节构成的。TCP软件决定数据段的大小，它可以将多次写操作的数据累积起来放到一个数据段中，也可以将一次写操作的数据分割到多个数据段中。有两个因素限制了段的长度：第一，每个数据段，包括TCP头在内，必须适合IP的65515字节净荷大小；其次，每个网络都有一个最大传输单元（Maximum Transfer Unit）MTU，每个数据段必须适合于MTU。在实践中，MTU通常是1500字节（以太网的净荷大小），因此它规定了数据段长度的上界。\n\n\n源端口和目的端口，各占2个字节，分别写入源端口和目的端口；\n序号（seq number），占4个字节，TCP连接中传送的字节流中的每个字节都按顺序编号。例如，一段报文的序号字段值是 301 ，而携带的数据共有100字段，显然下一个报文段（如果还有的话）的数据序号应该从401开始；\n确认号（ack number），占4个字节，是期望收到对方下一个报文的第一个数据字节的序号。例如，B收到了A发送过来的报文，其序列号字段是501，而数据长度是200字节，这表明B正确的收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701；\n数据偏移，占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远；\n保留，占6位，保留今后使用，但目前应都位0；\n紧急URG，当URG=1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据；\n确认ACK，仅当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置1；\n推送PSH，当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH=1；\n复位RST，当RST=1，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接；\n同步SYN，在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1；\n终止FIN，用来释放连接。当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放；\n窗口，占2字节，指的是通知接收方，发送本报文你需要有多大的空间来接受；\n检验和，占2字节，校验首部和数据这两部分；\n紧急指针，占2字节，指出本报文段中的紧急数据的字节数；\n选项，长度可变，定义一些其他的可选的参数。\n\n\n注意：标志位ACK和确认序列号ack，ack是一个变量，它表示本机期待的下个包的序列号（seq），ack的全称叫做acknowledgement number. 而ACK是一个标志位，在TCP头部可以看到，标志位只能为0或1，用来传输特定的信息。\n\nTCP连接的建立\n\n关于TCP的三握四挥参见1，讲的很详细，以下绝大部分参考自该文。\n\nTCP使用三步握手法建立连接。为了一个建立一个连接，某一方，比如说服务器，通过执行LISTEN和ACCEPT primitives（既可以指定一个特定的源，也可以不指定）被动地等待一个进来地连接请求。\n另一端，比如客户端，执行一个CONNECT primitive，同时指定以下参数：它希望连接地IP地址和端口、它愿意接受地最大TCP分段长度，以及一些可选地用户数据（比如口令）。CONNECT primitive发送一个SYN=1和ACK=0的TCP数据段，然后等待应答。\n当这个数据段到达目标端的时候，那里的TCP实体查看一下是否有一个进程已经在Destination port域中指定的端口上执行的LISTEN。如果没有的话，它送回一个设置了RST位的应答，以拒绝客户的连接请求。\n如果某个进程正在监听端口，那么，TCP实体将进来的TCP数据段交给该进程。然后该进程可以接受或者拒绝这个连接请求。如果它接受的话，则送回一个确认数据段。在正常情况下发送的TCP数据段顺序如图（a）所示。请注意，SYN数据段只消耗1字节的序列号空间，所以它的确认是非常明确的，毫无二义性。\n\n如果两台主机同时企图在同样的两个套接字之间建立一个连接，则事件序列如上图（b）所示。这些事件的结果是，只有一个连接被建立起来，而不是两个，因为所有的连接都是由它们的端点来标识的。如果第一个请求导致建立了一个由(x,y)标识的连接，而第二个请求也建立了这样一个连接，那么，在TCP实体内部只有一个表项，即(x,y).\n具体来说：\n\n一方（客户端）发起连接请求，发送一个包（seq=x，SYN=1，ACK=0），进入SYN-SENT状态；\n另一方（服务端）收到请求，如果同意连接，则发出确认包（seq=y，ack=x+1，SYN=1，ACK=1），进入SYN-RCVD状态；\n客户端收到确认的包后，也需要向服务端发送确认包（seq=x+1，ack=y+1，SYN=0，ACK=1），进入ESTABLISHED状态；\n服务端收到确认的包后，进入ESTABLISHED状态，至此，连接已建立。\n\n\n为什么客户端最后还要发送一次确认？\n假设客户端发送的第一个连接请求没有丢失，只是在网络节点中滞留的时间太长了，由于客户端没有收到服务端的回复，所以会超时重传，无论如何，客户端发送了两个连接请求，如果采用两次握手，那么服务端因为收到了两次连接请求，会开启两个连接在等待数据传输，这会造成资源浪费。而如果是三次握手才建立连接，那么服务端会等待客户端的确认，才会建立连接。而客户端本意只有一次连接请求，所以只会发送一次确认，服务端收到确认之后建立连接。而对服务端的第二个返回确认，客户端会置之不理，因为客户端本意只有一次连接而已。 \nTCP连接的释放\n虽然TCP连接是全双工的，但是，为了理解TCP连接的释放过程，最好将TCP连接看成一对单工连接。每个单工连接被单独释放，两个单工连接之间相互独立。为了释放一个连接，任何一方都可以发送一个设置了FIN位的TCP数据段，这表示它已经没有数据要发送了。当FIN数据段被确认的时候，这个方向上就停止传送新数据。然而，另一个方向上可能还在继续无限制地传送数据，当两个方向都停止的时候，连接才被释放。通常情况下，为了释放一个连接，需要4个TCP数据段：每个方向一个FIN和一个ACK。然而，第一个ACK和第二个FIN有可能被包含在同一个数据段中，从而将总数降低到3个。\n四次挥手。blog.csdn.net/qq_33951180/article/details/60767876\nwww.imooc.com/article/17411\n具体来说：\n\n一方（客户端）主动发送连接释放请求，发送一个包（seq=u，FIN=1），其序列号为u，等于之前最后接收的包序列号加1，进入FIN-WAIT-1状态；\n另一方（服务端）收到释放请求，发出确认报文（seq=v，ack=u+1，ACK=1），进入CLOSE-WAIT状态。将TCP连接看成一对单工连接，此时客户端单方面停止向服务端发送消息，但服务端的发送还未停止，客户端仍要接收来自服务端的消息；这时服务端会通知上层应用客户端连接已经释放，但到服务端释放可能还需要一段时间；【full-duplex，全双工，主动断开的一方虽然发完了，但另一方可能还需要发送数据】\n客户端收到服务器的确认报文，进入FIN-WAIT-2状态；\n服务端处理完自己的事情之后，向客户端发送连接释放确认报文（seq=w，ack=u+1，ACK=1，FIN=1），进入LAST-ACK状态；\n客户端收到服务端的释放报文，必须发出确认报文（seq=u+1，ack=w+1，ACK=1），进入TIME-WAIT状态。此时连接还未释放，客户端会等待2个MSL (Maximum Segment Lifetime) 时间，才会进入CLOSED状态；\n服务端只要收到客户端的确认报文，立即进入CLOSED状态。\n\n\n为什么客户端最后还要等待2MSL？\n第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。\n第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。处在TIME_WAIT状态的两端端口都不能使用，等到2MSL时间结束后才能继续使用。当连接处于2MSL等待阶段时，任何迟到的报文段将会被丢弃。这样一来，就会有更大的机会让丢失的ACK字段再次被发送出去，并且也让“四次挥手”更加可靠。\nUNP的解释\nCf. UNP, ch2.7\nThere are two reasons for the TIME_WAIT state:\n\nTo implement TCP’s full-duplex connection termination reliably\nTo allow old duplicate segments to expire in the network’\n\nThe last\nHTTP协议\nhttp\n\nHTTP协议（HyperText Transfer Protocol，超文本传输协议）是因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准。\nHTTP是基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）\nHTTP协议通常承载于TCP协议之上，有时也承载于TLS或SSL协议层之上，这个时候，就成了我们常说的HTTPS。如下图\n\n\n\nHTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。\nHTTP默认的端口号为80，HTTPS的端口号为443。\n\nHTTP状态码\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n类别原因1XXInformational(信息性状态码)2XXSuccess(成功状态码)3XXRedirection(重定向)4XXClient Error(客户端错误状态码)5XXServer Error(服务器错误状态码)\n200(OK 客户端发过来的数据被正常处理\n204(Not Content 正常响应，没有实体\n206(Partial Content 范围请求，返回部分数据，响应报文中由Content-Range指定实体内容\n\n301(Moved Permanently) 永久重定向\n302(Found) 临时重定向，规范要求，方法名不变，但是都会改变\n303(See Other) 和302类似，但必须用GET方法\n304(Not Modified) 状态未改变， 配合(If-Match、If-Modified-Since、If-None_Match、If-Range、If-Unmodified-Since)\n307(Temporary Redirect) 临时重定向，不该改变请求方法\n\n400(Bad Request) 请求报文语法错误\n401 (unauthorized) 需要认证\n403(Forbidden) 服务器拒绝访问对应的资源\n404(Not Found) 服务器上无法找到资源\n\n500(Internal Server Error)服务器故障\n503(Service Unavailable) 服务器处于超负载或正在停机维护\n\n网络\n\nNote that\n\nthe actual flow of information between the client and server goes down the protocol stack on one side, across the network, and up the protocol stack on the other side;\nthe client and server are typically user processes.\n\n网络结构图：\n\nThe client and server need not be attached to the same local area network (LAN), we show the client and server on different LANs, with both LANs connected to a wide area network (WAN) using routers.\n\nRouters are the building blocks of WANs.\n\nTCP, UDP, SCTP (Stream Control Transmission Protocol), We need to understand the services provided by these transport protocols to the application, so that we know what is handled by the protocol and what we must handle in the application.\nUDP is a simple transport-layer protocol. It is described in RFC 768 [Postel 1980]. The application writes a message to a UDP socket, which is then encapsulated in a UDP datagram, which is then further encapsulated as an IP datagram, which is then sent to its destination. There is no guarantee that a UDP datagram will ever reach its final destination, that order will be preserved across the network, or that datagrams arrive only once.\nUDP datagram 具有固定长度，而TCP is a byte-stream protocol, without any record boundaries at all.\nUDP provides a connectionless service, as there need not be any long-term relationship between a UDP client and server. For example, a UDP client can create a socket and send a datagram to a given server and then immediately send another datagram on the same socket to a different server. Similarly, a UDP server can receive several datagrams on a single UDP socket, each from a different client.\n\nTCP connection is full-duplex. This means that an application can send and receive data in both directions on a given connection at any time. After a full-duplex connection is established, it can be turned into a simplex connection if desired;\nUDP can be full-duplex.\n\n如果仅仅是发一些小包，UDP可能更加节省网络带宽，因为一来一会只要两个包，而TCP需要先建立连接，收发包，断开连接的过程。因此回多发很多包。如果收发包的过程持续很短，这个浪费就尤为明显。但如果舍弃TCP，那么 But switching from TCP to UDP removes all the reliability that TCP provides to the application, pushing lots of these details from the transport layer (TCP) to the UDP application. Another\nimportant feature provided by TCP is congestion control, which must then be handled by the UDP application. Nevertheless, it is important to understand that many applications are built using UDP because the application exchanges small amounts of data and UDP avoids the overhead of TCP connection establishment and connection termination.\nTCP state transition diagram\n\nsee also\n\n\n\nIPv4协议\nTTL：time to live，防止ip报文转发时形成环路，每转发一跳，TTL减一，减至0时，该报文被丢弃。如果没有这个TTL，这个报文会一直循环转发，占用带宽。\nReferences\n\n5分钟让你明白HTTP协议\nLRU缓存算法\nHTTP协议及其工作流程\nTCP的三次握手与四次挥手（详解+动图）\n\nFootnotes\n\n\nTCP的三次握手与四次挥手（详解+动图） ↩\n\n\n"},"notes/nice_phrase_in_paper":{"slug":"notes/nice_phrase_in_paper","filePath":"notes/nice_phrase_in_paper.md","title":"nice_phrase_in_paper","links":[],"tags":[],"content":"Sentences\n\nTo our knowledge, there is now no publicly available datasets for Chinese document recognition.  END-TO-END CHINESE TEXT RECOGNITION, Jie Hu, Tszhang Guo, Ji Cao et.al.\nTo the best of our knowledge, this is the first optimal design proposed for the distributed matrix multiplication problem. Polynomial Codes: an Optimal Design for High-Dimensional Coded Matrix Multiplication, Qian Yu, MAM-Ali, and A.S Avestimehr\nUnfortunately, finding the CDF of a Beta distribution is difficult, let alone the inverse of the CDF. Book BH\nIn previous literature [9], … 在文献9中，......\n\nSome conjunction words\n\nmoreover\nhowever\nthereby, thus, therefore\nnoteworthy\nalbeit：虽然；即使。【一般用来连接单词短语，而非从句】\nwhilst\nhenceforth：今后，自此以后\n\nUseful words\n\noverhead： 开销\nstate of the art：最先进的\ndemonstrate：阐述，证明，展示，论证\ncut across：to affect or be true for different groups that usually remain separate\nalleviate：减轻，缓和\npreliminary：初步的\nfor instance：例如\nsubsequent：接下来，随之后\nad-hoc：特别指定\nLiterature Review：文献回顾，文献综述\nintensive reading：精读\neliminates：消除\nweave：交织，贬值\nembed：嵌入\nin sharp contrast to most coding applications：in sharp contrast to\na plethora of：大量的，过多的\nintriguing：有趣的，迷人的\nin lieu of：代替\ncarry out：执行，实行，贯彻，完成\nportion：部分\nprolong：延长\ntacit：不言而喻，默许的，心照不宣的\ncope：处理，竞争\nwhatsoever：无论什么\noff-the-shelf：现成的，现货，常备的，成品的\nnuanced：微妙的，具有细微差别\n"},"notes/python/pylearn":{"slug":"notes/python/pylearn","filePath":"notes/python/pylearn.md","title":"pylearn","links":[],"tags":["python","note"],"content":"Step deep in python\nOld style class\nclass A:\n    def __init__(self):\n        self.data = {}\n \n    def fun():\n        return 0\n \n    def __private_method():\n        return &quot;only used inside class&quot;\n上面是老式的class定义方法（python2.2以前），因为违背了对象完备性（万物皆继承自object类），在后续版本的python中可能会引起不必要的问题，所以不推荐使用。请使用新式类定义：\n\nNote: __private_method实际上可从外部访问，但是这么写从协议上来说我是不想让它从外面直接调用的。参见：www.liaoxuefeng.com/wiki/1016959663602400/1017496679217440\n\nclass B(object):\n    def __init__(self):\n        self.data = {}\n \n    def fun():\n        pass\n笼统的异常处理\ndef some_really_complicated_method():\n    try:\n        foo = bar...\n        # other long codes...\n    except Exception as e:\n        print(e)\n用try...except将整个函数包起来，那么里面的代码片抛出的异常全部被外层的笼统异常捕获，这对于定位异常是很麻烦的，因为它隐去了抛出异常的点及其细节。\nEverything is object (except keywords)\n\nprint在python2.x属于关键字，不是对象\nprint在python3中属于函数，是对象\n\nIterators\nfor i in xrange(n): pass\n \n# 3 ways to iterate a dict\nfor k in dict_obj.iterkeys(): pass\nfor v in dict_obj.itervalues(): pass\nfor k, v in dict_obj.iteritems(): pass\n \nfor index, value in enumerate(seq_obj): pass\nfor v1, v2 in zip(seq1, seq2): pass\nfor line in open(&quot;bigfile.txt&quot;, &quot;rt&quot;): pass\nImplement your iterator\nMeets iteration protocol:\n\niter()\nnext()\nException of StopIteration\n\nSemantic of for\nfor v in lst:\n    print v\nis equivalent to\nit = iter(lst)\ntry:\n    while True:\n        v = it.next()\n        print v\nexcept StopIteration:\n    pass\nFor example,\nclass Foo(object):\n    def __init__(self):\n        self._list = [1,2,3,4,5]\n        self._curr = 0\n \n    def __iter__(self):\n        self._curr = 0\n        return self\n \n    def __next__(self):\n        if self._curr &lt; len(self._list):\n            res = self._list[self._curr]\n            self._curr += 1\n            return res\n        else:\n            raise StopIteration\nFoo is iterable, let’s test\na = Foo()\nfor e in a:\n    print e\n \n# 1\n# 2\n# 3\n# 4\n# 5\none more\nfor e1 in a:\n    for e2 in a:\n        print (e1, e2)\n \n# (1,1)\n# (1,2)\n# (1,3)\n# (1,4)\n# (1,5)\nWhat’s the problem?\n内层循环已经耗尽了元素，抛出停止迭代的异常，外层循环已经没有元素可迭代了。\nWhat’s the solution?\nclass FooIterator(object):\n    def __init__(self, foo):\n        self._foo = foo\n        self._curr = 0\n \n    def next(self):\n        if self._curr &lt; len(self._foo):\n            res = self._foo[self._curr]\n            self._curr += 1\n            return res\n        else:\n            raise StopIteration\n \nclass Foo(objcet):\n    def __init__(self):\n        self._list = [1,2,3,4,5]\n \n    def __iter__(self):\n        return FooIterator(self)\n \n    def __len__(self):\n        return len(self._list)\n \n    def __getitem__(self, index):\n        return self._list[index]\nNow let’s test\na = Foo()\nfor e1 in a:\n    for e2 in a:\n        print (e1, e2)\nSemantic of yield\ndef foo():\n    lst = [1,2,3]\n    for v in lst:\n        yield v\n \ng = foo()\nprint g.next()\nprint g.next()\nprint g.next()\nprint g.next()\n\nFunction contains a yield will be considered as generator\nGenerator object will be created upon call of the function\nGenerator object supports iteration protocol\n\nSee the next:\nprint foo()\nprint foo()\nprint foo()\nprint foo()\n \n# &lt;generator object foo at 0x0000012DF0C1CDC8&gt;\n# &lt;generator object foo at 0x0000012DF0C1CDC8&gt;\n# &lt;generator object foo at 0x0000012DF0C1CDC8&gt;\n# &lt;generator object foo at 0x0000012DF0C1CDC8&gt;\n实际上每次生成的确实不是同一个对象，但因为内存的局部性。python垃圾回收使用引用计数，计数为0则销毁对象。foo()创建完没被引用，因此立即被销毁。然后下一个foo()被创建，由于内存的局部性，计算机很大可能会在刚刚那块内存上开辟空间，创建对象，并且两次创建的对象大小一样，内存对齐，所以更加有概率会在同一个地址上。因此，每次输出的地址一样，但其实是不同对象。\nIterator with closure\n\nctor\ncopy ctor\ncopy assignment\nmove ctor\nmove assignment\n\nPython basic type\n\nnumeric: immutable\nstring: immutable\nlist: mutable\ntuple: immutable\ndict: mutable\n\n参数传递：对于immutable的类型，传值；对于mutable的类型，传引用。\ndef foo(a, items=[], added=True):\n    if added:\n        items.append(a)\n    print items\n \nfoo(1)\nfoo(2)\nfoo(3, added=False\n    \n# [1]\n# [1, 2]\n# [1, 2]\n为何？Python参数默认值保存在函数对象上（一切皆对象），当需要读默认参数时，都从foo.param_list里面取，而list又是可变对象，所以一直存在函数对象上，不会在第二次调用时重新初始化，每次取默认参数都拿到同一个对象。\nNamesapce and object space\nA namespace is a mapping from names to objects. Most namespaces are currently implemented as python dictionaries.\n\neach function has its own local namespace\neach module has its own global namespace\npython built-in namespace (built-in is actually a module (__builtins__), and has its own global namespace, which is called built-in namespace)\n\nNamespace locating\nLGB rules: local → parent local → … → global → built-in\nThe global keyword just tell the interpreter the name is locating in global namespace, not the local.\n\nNote: write operation will sheild the namelooking process, see below\n\nclass Foo(object):\n    def __init__(self):\n        self._list = [1, 2, 3, 4, 5]\n \n    def __iter__(self):\n        counter = 0\n \n        def get():\n            if counter &gt;= len(self._list):\n                return None\n            res = self._list[counter]\n            counter += 1\n            return res\n \n        return iter(get, None)\n \na = Foo()\nfor e1 in a:\n    for e2 in a:\n        print (e1, e2)\nwill outputs\nTraceback (most recent call last):\n  File &quot;e:/Documents/learn2live/notes/test.py&quot;, line 38, in &lt;module&gt;\n    for e1 in a:\n  File &quot;e:/Documents/learn2live/notes/test.py&quot;, line 29, in get\n    if counter &gt;= len(self._list):\nUnboundLocalError: local variable &#039;counter&#039; referenced before assignment\nWhat’t the problem?\n解释器读到get函数时，为其创建local namespace, 因为其中有counter += 1这个写操作，所以local namespace为创建一个条目counter:\n__localnamespace__ = {\n    &#039;counter&#039;: ,   # empty map\n    &#039;others&#039;: ...,\n    ...\n}\n此时解释器认为在get函数内部找到了counter这个名字，因此不会再往上寻找。\nReflection\n\ndir(obj): return a list of names, which can be accessed by the mode obj.xxx\nobj.__dict__: a map of (name, object) pairs, which can be accessed in the object’s namespace (local)\n\n== v.s. is\na = &#039;abcdefg&#039;\nb = &#039;&#039;.join([chr(ord(&#039;a&#039;) + i) for i in xrange(7)])\n \nprint a == b\nprint a is b\n \n# True\n# False\nHold on…\na = &#039;a&#039;\nb = &#039;abcdefg&#039;[0]\nprint a == b\t# True\nprint a is b\t# True\n \na = 10**9\nb = 10**9\nprint a == b\t# True\nprint a is b\t# False\n \na = 10\nb = 10\nprint a == b\t# True\nprint a is b\t# True\n\nsemantics of ==: the values of two object are the same\nsemantics of is: the objects referenced by two names are the same one\n\na is b is equivalent to id(a) == id(b)\nsome types (str or int), use an object pool to manage some special objects for optimization purpose\nthe type NoneType has only one instance - None\nthe type bool has only two instance - True/False\n\n\n\n\n小整数及单字符优化：经验发现，大家在程序中使用的大部分都是较小的整数，或者是单个的字符，因此对于这种类型的对象，python做了缓存池。取的时候直接从池子里拿，所以两个id一样。但超出范围的话，就会重新构造对象，因此id不一样。\n\nSemantics of import\nimport m\n\nCheck if it is in sys.modules, (sys.modules.has_key(&#039;m&#039;))\nGoto 4, when it is true\nOtherwise, load the module “m” to create the module object\nPlace a name “m” in current namespace, and let the name refer to the object sys.modules[&#039;m&#039;]\n\nLoad the module\n\nOpen the carrier (i.e., xxx.py, xxx.pyc, xxx.pyd, xxx.o, xxx.dll, etc.) corresponding to “m” - the carrier differs in cases\nCreate an empty module object named “m” and place it into sys.modules\nExecute the statemtns in the module sequentially within the namespace of the module object, i.e., code-scan\n\n# file: t014.py\nprint &#039;t014&#039;\nimport t015\n \n# file: t015.py\nprint &#039;t015&#039;\nimport t016\na_in_t015 = 10\n \n# file t016.py\nprint &#039;t016&#039;\nimport t015\nprint t015.a_in_t015\n \n# now execute t014.py\nt014\nt015\nt016\nTraceback (most recent call last):\n  File &quot;e:/Documents/learn2live/notes/t014.py&quot;, line 2, in &lt;module&gt;\n    import t015\n  File &quot;e:\\Documents\\learn2live\\notes\\t015.py&quot;, line 2, in &lt;module&gt;\n    import t016\n  File &quot;e:\\Documents\\learn2live\\notes\\t016.py&quot;, line 3, in &lt;module&gt;\n    print t015.a_in_t015\nAttributeError: &#039;module&#039; object has no attribute &#039;a_in_t015&#039;\n为何？仔细看import的语义：\n\n执行t014.py，首先打印t014，然后import t015\n去sys.modules里面找，没有，创建之，执行t015.py的代码，打印t015，然后import t016\n去sys.modules里面找，没有，创建之，执行t016.py的代码，打印t016，然后import t015\n去sys.modules里面找，有，导入结束，继续执行t016.py的代码，打印t015.a_in_t015，但此时t015这个模块还没有这个成员，因为其代码还没有执行完，因此报错\n\nNOTE\n\nDo NOT do much consuming work at module level\nDo NOT form reference cycle\nDo NOT place all the import statement at the very begining of the module\n\nfrom m import sth\n\nExecute the import semantics above, WITHOUT put the name “m” into current namespace\nSearch the name “sth” in the namespace of the module “m”\nIf it exists, put the name “sth” into current namespace, and refer the name “sth” to the object that “m.sth” refers to\nIf it doesn’t exist, raise an exception\n\n# t017.py\nMaxHp = 100\na = [1, 2]\n \n# t018.py\nfrom t017 import MaxHp, a\nimport t017\n \nprint MaxHp\t\t# 100\nprint t017.MaxHp # 100\nprint a\t\t\t# [1, 2]\nprint t017.a\t# [1, 2]\n \nt017.MaxHp = 200\na = [1, 2, 3]\n \nprint MaxHp\t\t\t# 100\nprint t017.MaxHp\t# 200\nprint a\t\t\t# [1, 2, 3]\nprint t017.a\t# [1, 2]\n为何？仔细看from/import语义，第一串print很好理解。来看第二串，from/import语义将MaxHp放到t018的名称空间，并将其指向t017.MaxHp所指的对象，也就是100这个int对象。因此当执行t017.MaxHp = 200后，仅仅是将200这个对象赋给t017.MaxHp这个变量。但t018名称空间下的MaxHp仍然指向100这个对象。而a = [1,2,3]将[1,2,3]这个list对象赋给a，那么变量a就不再指向t017.a所指向的那个对象了。\nPython中的赋值仅仅是改变变量所指向的对象，不存在变量的引用，只有对象的引用。\na = 1\nb = a\t# b指向a所指的那个对象\na = 2\t# a现在换了一个对象指了，但b没换！\n \nprint a\t# 2\nprint b\t# 1\nNOTE\n\nfrom m import * would pollute the current namespace!\n\nSemantics of del\nSee: docs.python.org/3/reference/datamodel.html\nNote\ndel x doesn’t directly call x.__del__() — the former decrements the reference count for x by one, and the latter is only called when x’s reference count reaches zero.\nDecorator\nRef\n\nwww.runoob.com/w3cnote/python-func-decorators.html\n\nGenerator\nsee: stackoverflow.com/a/231855\nEnum\nRef: www.liaoxuefeng.com/wiki/1016959663602400/1017595944503424\nTo use enum in python, see\nfrom enum import Enum, unique\n \n@unique\nclass Month(Enum):\n    Jan = 0\n    Feb = 1\n    Mar = 2\n    # ...\n    Dec = 11\n    \nfor name, member in Month.__members__.items():\n    print name, &quot;=&gt;&quot;, member, &#039;=&gt;&#039;, member.value\nPython运行时函数创建\nclass A(object):\n    def func(self):\n        pass\n    \n&gt;&gt;&gt; a = A()\n&gt;&gt;&gt; id(a.func)\n44690448\n&gt;&gt;&gt; id(a.func)\n44690448\n&gt;&gt;&gt; b = a.func\n&gt;&gt;&gt; id(b)\n44690448\n&gt;&gt;&gt; id(b)\n44690448\n&gt;&gt;&gt; id(a.func)\n44610264\n&gt;&gt;&gt; id(A.func)\n44690528\n&gt;&gt;&gt; id(A.func)\n44610264\n&gt;&gt;&gt; id(A.func)\n44610264\n&gt;&gt;&gt; c = A.func\n&gt;&gt;&gt; id(c)\n44610264\n&gt;&gt;&gt; id(c)\n44610264\n&gt;&gt;&gt; id(A.func)\n44690528\n&gt;&gt;&gt; id(A.func)\n44690528\n&gt;&gt;&gt;\n可以看到，python调用类方法都是“即调即创”，即调用的时候才创建一个函数对象（object），调用完即销毁。上例中，虽然b和a.func逻辑一模一样，但却是两个不同的对象。\nMeta class\nsee: medium.com/@dboyliao/%E6%B7%BA%E8%AB%87-python-metaclass-dfacf24d6dd5\nKeep in mind two things:\n\nEverything is an object in python.\nEvery object has a type.\n\n對我來說，關於這個問題我喜歡引用在 C 語言規格書像是 c99 裡面對於 object 的定義:\n\nregion of data storage in the execution environment, the contents of which can represent values\n\nclass A(object):\n    def func(self):\n        print &#039;A.func&#039;\n \n&gt;&gt;&gt; a = A()\n&gt;&gt;&gt; type(a)\n&lt;class &#039;__main__.A&#039;&gt;\n&gt;&gt;&gt; type(A)\n&lt;type &#039;type&#039;&gt;\n&gt;&gt;&gt; isinstance(a, object)\nTrue\n&gt;&gt;&gt; isinstance(A, object)\nTrue  # A is a type, everything (type) is an object\n&gt;&gt;&gt; isinstance(type, object)\nTrue  # everything (type) is an object\n \n# here comes weird things\n&gt;&gt;&gt; isinstance(object, type)\nTrue  # object is a type\n&gt;&gt;&gt; isinstance(object, object)\nTrue  # everything (type) is an object\n \n&gt;&gt;&gt; type(type)\n&lt;type &#039;type&#039;&gt;  # type is not a function! It is a class, then an object, then a type!\n&gt;&gt;&gt; type(object)\n&lt;type &#039;type&#039;&gt;\n \n&gt;&gt;&gt; issubclass(type, object)\nTrue\n&gt;&gt;&gt; isinstance(type, object)\nTrue\n&gt;&gt;&gt; isinstance(object, type)\nTrue\nOh, what the fuck!\n根據 python 的 data model ， type.__new__ 的 signature 是長這樣的:\n\ntype.new(mcls, name, base, attribs)\n\n\nmcls: metaclass 物件本身\nname: 要被創建的 class 的名字\nbase: 要被創建的 class 所繼承的其他 class\nattribs: 要被創建的 class 本身的各項 attribute\n\n舉個例子來說，在 python 裡以下兩種寫法是等價的:\nclass MyClass(object):\n    ANSWER = 42\n    \n    def speak(self):\n        print(&#039;the answer to life is {}&#039;.format(self.ANSWER))\n# or\nMyClass = type(&#039;MyClass&#039;,\n              (object,),\n              {\n                  &#039;ANSWER&#039;: 42,\n                  &#039;speak&#039;: lambda self: print(&#039;the answer to life is {}&#039;.format(self.ANSWER))\n              }\n)\n\n眼尖的讀者或許會問: 那 mcls 跑哪兒去了?\n其實當你寫下 type(...) 時，其實 mcls 會是 type 自己。也就是說等同於使用 type.__new__(type, &#039;MyClass&#039;, (object,), ...)。"},"notes/python/weakref":{"slug":"notes/python/weakref","filePath":"notes/python/weakref.md","title":"weakref","links":[],"tags":["python"],"content":"weakref\n和许多其它的高级语言一样，Python使用了垃圾回收器来自动销毁那些不再使用的对象。每个对象都有一个引用计数，当这个引用计数为0时Python能够安全地销毁这个对象。\n引用计数会记录给定对象的引用个数，并在引用个数为零时收集该对象。由于一次仅能有一个对象被回收，引用计数无法回收循环引用的对象。\n一组相互引用的对象若没有被其它对象直接引用，并且不可访问，则会永久存活下来。一个应用程序如果持续地产生这种不可访问的对象群组，就会发生内存泄漏。\n在对象群组内部使用弱引用（即不会在引用计数中被计数的引用）有时能避免出现引用环，因此弱引用可用于解决循环引用的问题。\n在计算机程序设计中，弱引用，与强引用相对，是指不能确保其引用的对象不会被垃圾回收器回收的引用。一个对象若只被弱引用所引用，则可能在任何时刻被回收。弱引用的主要作用就是减少循环引用，减少内存中不必要的对象存在的数量。\n使用weakref模块，你可以创建到对象的弱引用，Python在对象的引用计数为0或只存在对象的弱引用时将回收这个对象。\n创建弱引用\n你可以通过调用weakref模块的ref(obj[,callback])来创建一个弱引用，obj是你想弱引用的对象，callback是一个可选的函数，当因没有引用导致Python要销毁这个对象时调用。回调函数callback要求单个参数（弱引用的对象）。\n一旦你有了一个对象的弱引用，你就能通过调用弱引用来获取被弱引用的对象。\n&gt;&gt;&gt;&gt;　import　sys\n&gt;&gt;&gt;　import　weakref\n&gt;&gt;&gt;　class　Man:\n　　def　__init__(self,name):\n　　　　print　self.name = name\n　　　　\n&gt;&gt;&gt;　o　=　Man(&#039;Jim&#039;)\n&gt;&gt;&gt;　sys.getrefcount(o)   \n2\n&gt;&gt;&gt;　r　=　weakref.ref(o)　#　创建一个弱引用\n&gt;&gt;&gt;　sys.getrefcount(o)　#　引用计数并没有改变\n2\n&gt;&gt;&gt;　r\n&lt;weakref　at　00D3B3F0;　to　&#039;instance&#039;　at　00D37A30&gt;　#　弱引用所指向的对象信息\n&gt;&gt;&gt;　o2　=　r()　#　获取弱引用所指向的对象\n&gt;&gt;&gt;　o　is　o2\nTrue\n&gt;&gt;&gt;　sys.getrefcount(o)\n3\n&gt;&gt;&gt;　o　=　None\n&gt;&gt;&gt;　o2　=　None\n&gt;&gt;&gt;　r　#　当对象引用计数为零时，弱引用失效。\n&lt;weakref　at　00D3B3F0;　dead&gt;\n上面的代码中，我们使用sys包中的getrefcount()来查看某个对象的引用计数。需要注意的是，当使用某个引用作为参数，传递给getrefcount()时，参数实际上创建了一个临时的引用。因此，getrefcount()所得到的结果，会比期望的多1。\n一旦没有了对这个对象的其它的引用，调用弱引用将返回None，因为Python已经销毁了这个对象。 注意：大部分的对象不能通过弱引用来访问。\nweakref模块中的getweakrefcount(obj)和getweakrefs(obj)分别返回弱引用数和关于所给对象的引用列表。\n弱引用对于创建对象(这些对象很费资源)的缓存是有用的。\n作者：王大吉\n链接：www.jianshu.com/p/0232b69bec1c"},"notes/python/编码问题":{"slug":"notes/python/编码问题","filePath":"notes/python/编码问题.md","title":"编码问题","links":[],"tags":[],"content":"Problem\nas3:~/ngokevin-site# nano content/blog/20140114_test-chinese.mkd\nas3:~/ngokevin-site# wok\nTraceback (most recent call last):\nFile &quot;/usr/local/bin/wok&quot;, line 4, in\nEngine()\nFile &quot;/usr/local/lib/python2.7/site-packages/wok/engine.py&quot;, line 104, in init\nself.load_pages()\nFile &quot;/usr/local/lib/python2.7/site-packages/wok/engine.py&quot;, line 238, in load_pages\np = Page.from_file(os.path.join(root, f), self.options, self, renderer)\nFile &quot;/usr/local/lib/python2.7/site-packages/wok/page.py&quot;, line 111, in from_file\npage.meta[&#039;content&#039;] = page.renderer.render(page.original)\nFile &quot;/usr/local/lib/python2.7/site-packages/wok/renderers.py&quot;, line 46, in render\nreturn markdown(plain, Markdown.plugins)\nFile &quot;/usr/local/lib/python2.7/site-packages/markdown/init.py&quot;, line 419, in markdown\nreturn md.convert(text)\nFile &quot;/usr/local/lib/python2.7/site-packages/markdown/init.py&quot;, line 281, in convert\nsource = unicode(source)\nUnicodeDecodeError: &#039;ascii&#039; codec can&#039;t decode byte 0xe8 in position 1: ordinal not in range(128). -- Note: Markdown only accepts unicode input!\nHow to fix it?\ntl;dr / quick fix\n\nDon’t decode/encode willy nilly\nDon’t assume your strings are UTF-8 encoded\nTry to convert strings to Unicode strings as soon as possible in your code\nFix your locale: How to solve UnicodeDecodeError in Python 3.6?\nDon’t be tempted to use quick reload hacks\n\nsee more in stackoverflow.com/a/35444608"},"notes/shell/shell基础":{"slug":"notes/shell/shell基础","filePath":"notes/shell/shell基础.md","title":"shell基础","links":[],"tags":["shell","bash"],"content":"Shell\n行内操作\n\n^a: jump to BOL\n^e: jump to EOL\n^u: delete the line\n^k: delete to EOL\n^w: delete a word forward\nalt+f: jump a word forward\nalt+b: jump a word backward\n^r: search history\nalt+.: complete second parameter\n\n任务控制\n\n执行command\n按^z挂起当前job\n按bg后台继续该job\n按fg召回前台\n\n后台运行命令\ncommand &amp;\n或者如果你不想看到任何输出，使用\ncommand &amp;&gt; /dev/null &amp;\n\n如此你可以继续使用当前shell\n使用bg查看是否有任务在后台运行\n使用jobs查看后台任务\n使用fg将任务召回前台\n不能退出shell，否则进程会被杀掉\n使用disown丢掉进程，可以退出shell\n\n又：\nnohup command &amp;&gt; /dev/null &amp;\n等价于以上的操作。单纯的nohup command会在当前目录创建一个隐藏文件以写入命令的输出。以上命令将程序的输出重定向至比特桶丢弃。\n同时输出到console和文件\n将命令输出重定向到文件：\nSomeCommand &gt; SomeFile.txt  # overwrite\nSomeCommand &gt;&gt; SomeFile.txt # append\n将命令输出(stdout)及报错(stderr)重定向到文件：\nSomeCommand &amp;&gt; SomeFile.txt\nSomeCommand &amp;&gt;&gt; SomeFile.txt\n同时输出到console和文件：\nSomeCommand 2&gt;&amp;1 | tee SomeFile.txt     # overwrite\nSomeCommand 2&gt;&amp;1 | tee -a SomeFile.txt  # append\n          || visible in terminal ||   visible in file   || existing\n  Syntax  ||  StdOut  |  StdErr  ||  StdOut  |  StdErr  ||   file\n==========++==========+==========++==========+==========++===========\n    &gt;     ||    no    |   yes    ||   yes    |    no    || overwrite\n    &gt;&gt;    ||    no    |   yes    ||   yes    |    no    ||  append\n          ||          |          ||          |          ||\n   2&gt;     ||   yes    |    no    ||    no    |   yes    || overwrite\n   2&gt;&gt;    ||   yes    |    no    ||    no    |   yes    ||  append\n          ||          |          ||          |          ||\n   &amp;&gt;     ||    no    |    no    ||   yes    |   yes    || overwrite\n   &amp;&gt;&gt;    ||    no    |    no    ||   yes    |   yes    ||  append\n          ||          |          ||          |          ||\n | tee    ||   yes    |   yes    ||   yes    |    no    || overwrite\n | tee -a ||   yes    |   yes    ||   yes    |    no    ||  append\n          ||          |          ||          |          ||\n n.e. (*) ||   yes    |   yes    ||    no    |   yes    || overwrite\n n.e. (*) ||   yes    |   yes    ||    no    |   yes    ||  append\n          ||          |          ||          |          ||\n|&amp; tee    ||   yes    |   yes    ||   yes    |   yes    || overwrite\n|&amp; tee -a ||   yes    |   yes    ||   yes    |   yes    ||  append\n\nRef:\n\naskubuntu.com/questions/420981/how-do-i-save-terminal-output-to-a-file\nwww.gnu.org/software/bash/manual/bash.html#Redirections\n\n从系统中踢出某个用户\n# See the pid of the user&#039;s login process.\n$ who -u\nyychi    tty1         2020-02-19 21:06  旧        460\n \n# Let him know he will be kick off.\n$ echo &quot;You&#039;ll be kick off by system administrator.&quot; | write yychi\n \n# Kick off.\n$ kill -9 460\n \n# Done.\nRef: www.putorius.net/kick-user-off-linux-system.html\n查看指定进程的所有连接\nCf. www.cnblogs.com/zl1991/p/10895485.html\n# 查看pid为4721的所有TCP连接\nlsof -p 4721 -nP | grep TCP"},"notes/tex/条件编译":{"slug":"notes/tex/条件编译","filePath":"notes/tex/条件编译.md","title":"条件编译","links":[],"tags":["tex"],"content":"条件编译\nUse \\newif\n\\newif\\ifanswers\n\\answerstrue % the logic variable is default to false, set it to true here\n \n\\documentclass{article}\n\\begin{document}\nQuestion\n\\ifanswers\nAnswer\n\\fi\n\\end{document}\nUse ifdefined\n\\documentclass{article}\n%\\newcommand*{\\DEBUG}{}%\n \n\\begin{document}\n\\ifdefined\\DEBUG\n    DEBUG was on\n\\else\n   DEBUG was off\n\\fi\nor\n \n\\ifx\\DEBUG\\undefined\n    DEBUG was off\n\\else\n    DEBUG is on\n\\fi\n\\end{document}\nReferences\n\nLaTeX programming: how to implement conditionals\nStackOverflow: Conditional typesetting / build\n"},"notes/tricks":{"slug":"notes/tricks","filePath":"notes/tricks.md","title":"Useful Tricks","links":["notes/mailto:guyueshui002@gmail.com.html","notes/shell/shell基础.html","notes/git手册.html"],"tags":[],"content":" __    __               __           __               ____    ___                       \n/\\ \\  /\\ \\             /\\ \\      __ /\\ \\             /\\  _`\\ /\\_ \\                      \n\\ `\\`\\\\/&#039;/__  __    ___\\ \\ \\___ /\\_\\\\ \\/      ____   \\ \\ \\L\\ \\//\\ \\     ___      __     \n `\\ `\\ /&#039;/\\ \\/\\ \\  /&#039;___\\ \\  _ `\\/\\ \\\\/      /&#039;,__\\   \\ \\  _ &lt;&#039;\\ \\ \\   / __`\\  /&#039;_ `\\   \n   `\\ \\ \\\\ \\ \\_\\ \\/\\ \\__/\\ \\ \\ \\ \\ \\ \\      /\\__, `\\   \\ \\ \\L\\ \\\\_\\ \\_/\\ \\L\\ \\/\\ \\L\\ \\  \n     \\ \\_\\\\/`____ \\ \\____\\\\ \\_\\ \\_\\ \\_\\     \\/\\____/    \\ \\____//\\____\\ \\____/\\ \\____ \\ \n      \\/_/ `/___/&gt; \\/____/ \\/_/\\/_/\\/_/      \\/___/      \\/___/ \\/____/\\/___/  \\/___L\\ \\\n              /\\___/                                                             /\\____/\n              \\/__/                                                              \\_/__/ &#039;`\n\n此页内容多为软件使用技巧，绝大部分内容来自互联网，如有侵权，请与我联系。也有部分内容系自己使用软件所得的一些经验，仅供参考。\nFFmepg\n转视频为gif\nffmpeg -i input.mkv out.gif\n又：加速播放。假设原视频 60 fps，输出降到 30 fps，丢掉一半的帧。\nffmpeg -r 60 -i input.mkv -r 30 out.gif\n又：不想丢帧。将输入扩大一倍，输出保留原样。\nffmpeg -r 120 -i input.mkv -r 60 out.gif\n又：不想全转。从视频的第2秒开始，截取3秒转化为gif。\n## 从视频中第二秒开始，截取时长为3秒的片段转化为 gif\nffmpeg -t 3 -ss 00:00:02 -i input.mkv out-clip.gif\n又：控制转化质量。\n## 默认转化是中等质量模式，若要转化出高质量的 gif，可以修改比特率\nffmpeg -i input.mkv -b 2048k out.gif\n\nImageMagick\n图片转换\n转换图片为指定分辨率。\nconvert -resize 1920x1080 src.jpg dst.jpg\n又：按百分比转换大小。\nconvert -resize 50%x50% src.jpg dst.jpg\n又：忽略原始宽高比。\nconvert -resize 300x300! src.jpg dst.jpg\n\nshell基础\nCommand find\n$ find --help\nUsage: find [-H] [-L] [-P] [-Olevel] [-D help|tree|search|stat|rates|opt|exec] [path...] [expression]\n前面的选项不常用，初级使用只需掌握\nfind [path...] [expression]\n\npath - search path\nexpression - expands to -options [-print -exec -ok]\n\n-options: 指定find常用选项\n-print: 将匹配到的文件写入标准输出[默认]\n-exec: 在匹配到的文件上执行一串命令。格式为&lt;command&gt; {} \\;，注意 {} 和 ; 之间的空格。\n\nfind . -size 0 -exec rm {} \\; - 删除当前目录下size为0的文件\nrm -i $(find . -size 0) - 同上\nfind . -size 0 | xargs rm -f &amp; - 同上\n\n\n-ok: 同上，执行命令前会询问\n\n\n\n常用选项\n\nname - 按照文件名查找\n\nfind &lt;dir&gt; -name &quot;*.cpp&quot;: 在目录dir下查找后缀为cpp的文件\n-name默认不支持正则表达式，顶多支持通配符*\n\n\nperm - 按照文件权限查找\nuser - 按照文件所有者查找\ngroup - 按照文件所有组查找\ntype - 按照文件类型查找\nsize - 按照文件大小查找\n…\n\n正则表达式\nfind path -regex &quot;&lt;regex&gt;&quot;\n但是默认的正则表达式引擎我也不知道是啥，反正不解析我习惯的那种正则语法。故使用：\nfind . -regextype posix-extended -regex &quot;.*\\.(log|aux|blg)&quot;\n上述命令找出当前文件夹及子文件夹所有后缀名为log,aux,blg的文件。\n几个例子\n\nfind . -name &quot;*name*&quot; - 找出当前文件夹文件名包含“name”的文件\nfind . ! -type d -print - 在当前目录查找非目录文件\nfind . -newer file1 ! file2 - 查找比file1新但比file2旧的文件\nfind -type d -empty | xargs -n 1 rmdir - 批量删除当前目录下的空文件夹\nfind -tyle l -exec ls -l {} + - 找出当前文件夹下损坏的软连接\n\n\nCommand grep\n最基本用法：\n# 查找somefile中匹配到something的行\n$ grep &quot;something&quot; somefile\n \n# 定位something所在的行并将接下来的3行一并输出\n$ grep &quot;something&quot; somefile -A 3\n \n# 定位something所在的行并将之前的3行一并输出\n$ grep &quot;something&quot; somefile -B 3\n \n# 定位something所在的行并将上下3行一并输出\n$ grep &quot;something&quot; somefile -C 3\n使用正则表达式\ngrep支持三种正则：basic (BRE), extend (ERE), perl (PCRE). 不同的grep实现方式不同，详见手册。一般extend最为常用，语法为\n# 在somefile中查找包含his或者her的行\n$ grep -E &quot;his|her&quot; somefile\nRef:\n\ngrep 命令系列：grep 中的正则表达式\n\n\nCommand xargs\n$ whatis xargs\nxargs (1)            - build and execute command lines from standard input\nRef:\n\nxargs命令：一个给其他命令传递参数的过滤器\n\n\nCommand sed\n\nCommand cut\n$ whatis cut\ncut (1)              - remove sections from each line of files\n基本用法：\n# 以:为分隔符分割每行，并选择第1,2,4列输出\n$ cut -d: -f1,2,4 /etc/passwd\nroot:x:0\nbin:x:1\ndaemon:x:2\nmail:x:12\nftp:x:11\nhttp:x:33\nnobody:x:65534\ndbus:x:81\n\ngit手册\nCommand g++\n自定义包含路径\ng++ main.cpp -I/usr/local/include\n自定义链接静态或动态库\ng++ main.cpp -L/path/to/lib_file\ng++ main.cpp -L/usr/lib64 -lcurl -lssl\n上面第二个命令链接了/usr/lib64/目录下的libcurl.so和libssl.so两个动态库文件。静态库也是同样链接。说起来静态库，想起了最近折腾的一个东西，你可能会想把多个静态库合成一个静态库，想当然的直接用ar合并，但是不行，必须要把两个静态库全解压出来，再合并所有的object file. 参见：here\n生成机器码\ng++ main.cpp -c\n生成汇编代码\ng++ main.cpp -S\n仅预编译\ng++ main.cpp -E &gt; main.i\n\nAria2c\naria2c 是个好东西。支持连接，磁力，种子下载。轻量且强大，可直接使用，也可作为服务端，配合WebUI使用。\n\n配置：参考 aria2配置示例\nWebUI:\n\nYAAW\nziahamza\nAriaNg\n\n\n\nNote: jsonrpc 地址格式为 http://token:&lt;rpc-secret&gt;@hostname:port/jsonrpc\n令牌填写自己设置的 rpc-secret\n\nxxx 替换为自己设置的 rpc-secret\n\nMPV\nMPV 是一个轻量、简约、跨平台的播放器。据我自己体验，在Linux下比mplayer播放效果要好，mplayer倍速会掉帧，而mpv则不太明显。\nHTML\n给网页添加BGM。\n&lt;embed src=&quot;bgm.mp3&quot; autostart=&quot;true&quot; loop=&quot;true&quot; width=&quot;300&quot; height=&quot;20&quot; hidden=&quot;true&quot;&gt;\n又，添加可以控制播放的音乐。\n&lt;audio autoplay=&quot;autoplay&quot; controls=&quot;controls&quot; loop=&quot;loop&quot; preload=&quot;auto&quot; src=&quot;music.mp3&quot;&gt;Your browser doesn&#039;t support H5 audio flag!&lt;/audio&gt;\n\n使用xrandr设置多屏显示\n$ xrandr\nScreen 0: minimum 320 x 200, current 1920 x 1080, maximum 8192 x 8192\neDP-1 connected primary 1920x1080+0+0 (normal left inverted right x axis y axis) 294mm x 165mm\n   1920x1080     59.93*+\n   1680x1050     59.95    59.88\n   1400x1050     59.98\n   1600x900      59.99    59.94    59.95    59.82\n   1280x1024     60.02\n   1400x900      59.96    59.88\n   1280x960      60.00\n   1440x810      60.00    59.97\n   1368x768      59.88    59.85\n   1280x800      59.99    59.97    59.81    59.91\n   1280x720      60.00    59.99    59.86    59.74\n   1024x768      60.04    60.00\n   960x720       60.00\n   928x696       60.05\n   896x672       60.01\n   1024x576      59.95    59.96    59.90    59.82\n   960x600       59.93    60.00\n   960x540       59.96    59.99    59.63    59.82\n   800x600       60.00    60.32    56.25\n   840x525       60.01    59.88\n   864x486       59.92    59.57\n   700x525       59.98\n   800x450       59.95    59.82\n   640x512       60.02\n   700x450       59.96    59.88\n   640x480       60.00    59.94\n   720x405       59.51    58.99\n   684x384       59.88    59.85\n   640x400       59.88    59.98\n   640x360       59.86    59.83    59.84    59.32\n   512x384       60.00\n   512x288       60.00    59.92\n   480x270       59.63    59.82\n   400x300       60.32    56.34\n   432x243       59.92    59.57\n   320x240       60.05\n   360x202       59.51    59.13\n   320x180       59.84    59.32\nDP-1 disconnected (normal left inverted right x axis y axis)\nHDMI-1 disconnected (normal left inverted right x axis y axis)\nHDMI-2 connected 1920x1080+0+0 (normal left inverted right x axis y axis) 527mm x 296mm\n   1920x1080     60.00*+  60.00    50.00    59.94\n   1920x1080i    60.00    60.00    50.00    59.94\n   1600x1200     60.00\n   1280x1024     75.02    60.02\n   1152x864      75.00\n   1280x720      60.00    60.00    50.00    59.94\n   1024x768      75.03    60.00\n   800x600       75.00    60.32\n   720x576       50.00    50.00\n   720x576i      50.00    50.00\n   720x480       60.00    60.00    59.94    59.94    59.94\n   720x480i      60.00    60.00    59.94    59.94\n   640x480       75.00    60.00    59.94    59.94\n   720x400       70.08\n观察输出可知，连接了两个显示器(eDP-1, HDMI-2)，其中eDP-1是主显示器。如果第二块屏幕无显示，执行下面的命令。\nxrandr --output HDMI-2\n又，指定分辨率为1920x1080，\nxrandr --output HDMI-2 --mode 1920x1080\n又，设置为右侧扩展屏，即光标向右可移动至第二块屏，\nxrandr --output HDMI-2 --right-of eDP-1\n又，连接上第二块屏，想关掉内置显示屏，（警告：不要随便关掉内置屏）\nxrandr --output eDP-1 --off\n又，开启内置屏。\nxrandr --output eDP-1 --auto\n\n网络\n查看被监听端口\nnetstat -tulpn | grep LISTEN\n\nHtop基本操作\nHtop类似于top，但比top更现代化，支持鼠标操作，支持颜色主题。在命令行键入htop，会呈现如下界面。(图片来源：blog.csdn.net/freeking101/article/details/79173903)\n\n平均负载区的三个数字分别表示过去5、10、15分钟系统的平均负载。进程区每一列的意义分别是：\n\nPID: 进程号\nUSER: 进程所有者的用户名\nPRI: 优先级别\nNI: NICE值（优先级别数值），越小优先级越高\nVIRT: 虚拟内存\nRES: 物理内存\nSHR: 共享内存\nS: 进程状态（S[leep], R[unning], Z[ombie], N表示优先级为负数）\nCPU%: 该进程占用的CPU使用率\nMEM%: 该进程占用的物理内存和总内存的百分比\nTIME+: 该进程启动后占用的CPU时间\nCommand: 该进程的启动命令\n\n常用快捷键可在htop界面按?显示。\n\nH: 显示/隐藏用户子线程\nSpace: 标记进程\nk: 杀死已标记进程\n\nReference\n\nlinux下视频转gif\nRunning Bash Commands in the Background the Right Way [Linux]\n"},"notes/操作系统":{"slug":"notes/操作系统","filePath":"notes/操作系统.md","title":"服务端开发预备知识","links":[],"tags":["操作系统"],"content":"操作系统\n\n摘自《程序员面试白皮书》\n\n进程vs.线程\n进程（process）与线程（thread）最大的区别是进程拥有自己的地址空间，某进程内的线程对于其他的进程不可见，即进程A不能通过传地址的方式直接读写进程B的存储区域。进程之间的通信需要通过进程间通信（Inter-process communication, IPC）。与之相对的，同一进程的各线程间可以直接通过传递地址或全局变量的方式传递信息。\n此外，进程作为操作系统中拥有资源和独立调度的基本单位，可以拥有多个线程。通常操作系统中运行的一个程序就对应一个进程。在同一进程中，线程的切换不会引起进程切换。在不同的进程中进行线程切换，若从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。相比进程切换，线程切换的开销要小很多。线程与进程相结合能够提高系统的运行效率。\n线程可以分为两类：\n一类是用户级线程（user level thread）。对于这类线程，有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在。在应用程序启动后，操作系统分配给该程序一个进程号，以及其对应的内存空间等资源。应用程序通常现在一个线程中运行，该线程被称为主线程。在其运行的某个时刻，可以通过调用线程库中的函数创建一个在相同进程中运行的新线程。用户级线程的好处是非常高效，不需要进入内核空间，但并发效率不高。\n另一类是内核级线程（kernel level thread）。对于这类线程，有关线程管理的所有工作由内核完成，应用程序没有进行线程管理的代码，只能调用内核线程的接口。内核维护进程及其内部的每个线程，调度也有内核基于线程架构完成。内核级线程的好处是，内核可以将不同的线程更好地分配到不同的CPU，以实现真正的并行计算。\n事实上，在现代操作系统中，往往使用组合方式实现多线程，即线程创建完全在用户空间中完成，并且一个应用程序中的多个用户级线程被映射到一些内核级线程上，相当于是一种折中方案。\n上下文切换\n对于单核单线程CPU而言，在某一时刻只能执行一条CPU指令。上下文切换（context switch）是一种将CPU资源从一个进程分配给另一个进程的机制。从用户角度看，计算机能够并行运行多个进程，这恰恰是操作系统通过快速上下文切换造成的结果。在切换的过程中，操作系统需要先存储当前进程的状态（包括内存空间的指针，当前执行完的指令等等），在读入下一个进程的状态，然后执行此进程。\n系统调用\n系统调用（system call）是程序向系统内核请求服务的方式。可以包括硬件相关的服务（访问硬盘等），或者创建进程，调度其他进程等。系统调用是程序和操作系统之间的重要接口。\nSemaphore/Mutex\n当用户创立了多个线程/进程时，如果不同线程/进程同时读写相同的内容，则可能造成读写错误，或者数据不一致。此时，需要通过加锁的方式，控制核心区域（critical section）的访问权限。对于semaphore而言，在初始化变量的时候可以控制允许多少个线程/进程同时访问一个critical section，其他的线程/进程会被堵塞，直到有人解锁。Mutex相当于只允许一个线程/进程访问的semaphore。此外，根据实际需要，人们还实现了一种读写锁（read-write lock），它允许同时存在多个reader，但任何时候之多只有一个writer，且不能和reader共存。\n死锁\n在引入锁的同时，我们遇到了一个新的问题：死锁（dead lock）。死锁是指两个或多个线程/进程之间相互阻塞，以至于任何一个都不能继续运行，因此也不能解锁其他线程/进程。例如，线程1占有锁A，并且尝试获取锁B；而线程2占有锁B，并尝试获取锁A。此时，两者相互阻塞，都无法继续运行。\n总结产生死锁的四个条件（只有当四个条件同时满足时才会产生死锁）：\n\nMutual Exclusion — Only one process may use a resource at a time「资源互斥」\nHold-and-Wait — Process holds resource while waiting for another\nNo Preemption — Can’t take a resouce away from a process\nCircular Wait — The waiting processes form a cycle「循环等待」\n\n生产者消费者\n生产者消费者模型是一种常见的通信模型：生产者和消费者共享一个数据管道，生产者将数据写入buffer，消费者从另一头读取数据。对于数据管道，需要考虑为空和溢出的情况。同时，通常还需要将这部份共享内存用mutex加锁。在只有一个生产者消费者的情况下，可以设计无锁队列（lockfree queue），线程安全地直接读写数据。\n进程间通信\n在介绍进程的时候，我们提起过不能直接读写另一个进程的数据。两者之间的通信需要通过进程间通信（inter-process communication，IPC）进行。进程通信的方式通常遵循生产者消费者模型，需要实现数据交换和同步两大功能。\n\nShared-memory + semaphore: 不同进程通过读写操作系统中特殊的共享内存进行数据交换，进程之间用semaphore实现同步。\nMessage passing: 进程在操作系统内部注册一个端口，并检测有没有数据，其他进程直接写数据到该端口。该通信方式更加接近与网络通信方式。事实上，网络通信也是一种IPC，知识进程分布在不同机器上而已。\n\nI/O\nUNIX/Linux 程序在执行任何形式的 I/O 操作时，都是在读取或者写入一个文件描述符。一个文件描述符只是一个和打开的文件相关联的整数，它的背后可能是一个硬盘上的普通文件、FIFO、管道、终端、键盘、显示器，甚至是一个网络连接。\n请注意，网络连接也是一个文件，它也有文件描述符！你必须理解这句话。\nc.biancheng.net/view/2123.html"},"求职/ToLearn":{"slug":"求职/ToLearn","filePath":"求职/ToLearn.md","title":"ToLearn","links":[],"tags":[],"content":"\n socket编程\n 进程间通信\n 多进程，多线程，并发\n 网络编程\n select, poll, epoll，iocp\n 网络同步框架\n 如何实现一个timer\n 数据库\n enum v.s. enum class\n\nR steven: www.kohala.com/\nContributing to Open Source Projects HOWTO\nC++, C, and Assembly Language Tutorials"},"求职/信息汇总":{"slug":"求职/信息汇总","filePath":"求职/信息汇总.md","title":"已投汇总","links":["求职/马鞍山市雨山区引进人才报名表-胡兵兵.doc.html"],"tags":[],"content":"信息汇总\n\n 阿里巴巴\n 51job\n\n南京紫东现代综合交通实验室\n公告\n材料\n\n 身份证正反面电子件或者复印件（须在有效期）\n 学历、学位证书电子件（如果是硕士学历，发本科+硕士）\n 学信网学历电子备案信息表（须在有效期）其中留学回国人员须出具教育部留学服务中心的学历认证材料\n 岗位所要求相关职称证书、执业资格证书电子件或者复印件\n 应聘登记表1份\n 工作经验证明（备注：工作经历证明指社保缴费记录，经单位盖章的工作证明、劳动合同或（三者选择其一即可）年限是2年以上）应届生略过\n\n马鞍山市雨山区人才引进\n公告\n材料\n\n 《马鞍山市雨山区引进人才报名表》\n 本人身份证\n 学生证\n 学历学位证书（留学回国人员需提供国（境）外学历学位认证证明）\n 加盖学校公章的毕业生就业推荐表和相关荣誉证明材料扫描件（或照片）\n"},"求职/基本问答":{"slug":"求职/基本问答","filePath":"求职/基本问答.md","title":"基本问答","links":[],"tags":[],"content":"基本问答\n自我介绍\n职业规划\nQ: 你对未来的发展期望是什么样的？\nA: 本意想学习c++服务器开发相关的知识和工具，以后还是想往后端发展，学习一些高并发，多线程的知识。有机会的话，了解一下量化策略相关的知识。\nQ：工作中遇到的技术难题？\nA：\nQ：工作地点在南京，你怎么想？\nA：个人非常想回南京工作，一是离家更近，二是以后也想在南京定居。\n反问环节\n做好准备：大概知道应聘的工作是做什么的，有不清楚的地方可以向面试官提问，一定要表现的对这些工作内容非常感兴趣。\n\n\n了解下岗位职责，是做什么的？（表示感兴趣）\n\n\n平时有加班吗？加班有补偿吗？\n\n\n升职涨薪有什么规章流程吗？一年调几次，涨幅大概多少？晋升渠道？\n\n\n有没有带薪假？年假，病假等。\n\n\ngithub.com/yifeikong/reverse-interview-zh\n\n\ngithub.com/yifeikong/interview\n\n"},"求职/算法题/场景题":{"slug":"求职/算法题/场景题","filePath":"求职/算法题/场景题.md","title":"场景题","links":["求职/算法题/树相关.html"],"tags":["coding-problem"],"content":"场景题\n题一：最高得分\n一个长度为N的序列，玩家每次只能从头部或尾部拿数字，不能从中间拿。拿走的数字依次从左到右排列在自己面前。拿完N个数字之后，游戏结束。此时N个数字在玩家面前组成一个新的排列，这个数列每相邻两个数字之差的绝对值之和为玩家最终得分。假设玩家前面的N个数字从左到右标号为 n_1,n_2, \\dots, n_N，则最终得分S的计算方式如下：\nS = \\text{abs}(n_1-n_2) + \\text{abs}(n_2-n_3) + \\cdots + \\text{abs}(n_{N-1} - n_N).\n请计算玩家在以上游戏规则中把所有数字拿完可以获得的最大得分。\n\n思路：拿到这个问题，感觉像是动态规划。得想办法把子问题拆出来。但是一般情况下，并不是这么好拆的。所以从最简单的用例开始。假设只有两个数，这很简单，无论怎么拿，得分都一样。再加一个数呢？你就要考虑从哪里先拿，然后再从哪里先拿的问题。假设现在有三个数，你从前端拿了一个数，则下一步你得考虑从哪里拿的增益比较大。从前端拿得到一个front_gain, 从末端拿得到一个back_gain. 你得比一比哪个会让你的得分最大化。然后下一步继续这样考虑，这就形成了一个递归步。就是说你已经拆出来了！专业店说就是你找除了递推关系式。\n题外话：Case analysis is more powerful than you thought!\n\n#include&lt;iostream&gt;\n#include&lt;vector&gt;\n#include&lt;cmath&gt;\n \nusing namespace std;\n \n/**\n * @breif Calculate the max score of the given array.\n * @param arr     The origin array.\n * @param beg     The begining of the range.\n * @param end     The end of the range.\n * @param isFront Is the last taken from the front or not.\n * @return        The max score in a paticular setting.\n *\n * Note that the @c arr is the origin array, and [beg, end)\n * range is considered from the second step, with @c isFront.\n * For example:\n *   Suppose @c arr.size() = 5\n *   If @c isFront = true, means the last taken is from the front,\n *   then [beg, end) = [1, 5).\n *   If @c isFront = false, means the last taken is from the back,\n *   then [beg, end) = [0, 4).\n */\nint opt(const vector&lt;int&gt;&amp; arr, int beg, int end, bool isFront) {\n    // base cases\n    if (beg &gt;= end) return 0;\n    if (end - beg == 1) {\n        if (isFront)\n            return abs(arr[beg] - arr[beg-1]);\n        else\n            return abs(arr[beg] - arr[end]);\n    }\n \n    // ELSE\n    int front_gain = 0; // the gain if take front at current step\n    int back_gain = 0;  // the gain if take back at current step\n    \n    if (isFront)\n    {\n        front_gain = abs(arr[beg] - arr[beg-1]);\n        back_gain = abs(arr[end-1] - arr[beg-1]);\n    }\n    else\n    {\n        front_gain = abs(arr[beg] - arr[end]);\n        back_gain = abs(arr[end-1] - arr[end]);\n    }\n    return max(\n            front_gain + opt(arr, beg+1, end, true),\n            back_gain + opt(arr, beg, end-1, false));\n}\n \n \nint main()\n{\n    int N = 0;\n    cin &gt;&gt; N;\n    vector&lt;int&gt; arr;\n    for (int i=0; i!=N; ++i)\n    {\n        int tmp;\n        cin &gt;&gt; tmp;\n        arr.push_back(tmp);\n    }\n \n    int maxwin = max(\n            opt(arr, 1, arr.size(), true),\n            opt(arr, 0, arr.size()-1, false));\n    cout &lt;&lt; maxwin;\n \n    return 0;\n}\n题二：最少硬币\n\n2019腾讯实习生笔试题\n\n小Q去商场购物，经常会遇到找零钱的问题。小Q现在手上有n种不同面值的硬币，每种面值的硬币有无限多个。为了方便购物，小Q希望带尽量少的硬币，并且要能组合出1到m之间（包含1和m）的所有面值。\n输入描述：\n第一行包含两个整数m, n ~(1 \\le n \\le 100, ~1 \\le m \\le 10^9)，含义如题所述。\n接下来n行，每行一个整数，每i+1行的整数表示第i种硬币的面值。\n输出描述：\n输出一个整数，表示最少需要携带的硬币数量。如果无解，则输出-1.\n示例输入：\n20 4\n1\n2\n5\n10\n\n示例输出：\n5\n\n\n思路：一拿到就让人联想到动态规划。但其实不是，因为它的条件是要构成所有1到m之间的面值。所以就得从1到m慢慢凑出来。假设当前选择的硬币已经可以构成[1, i], 那么我当然下次在选面值的之后，会很理想的去寻找一个面值为i+1的硬币。这样我可以使我构造的最大面值尽可能的大。如果这个面值大于m了，那我们就完事儿了。这是贪心的思想。具体来说，比方已选的硬币可以构造出1到5之间的任何面值，那我在选择一个面值为6的硬币，就可以构造出1到11之间的任何面值。所以我们从面值为1的开始加，记录当前可以构造的最大面值max_constructed，在选择下一个硬币的时候，优先选择面值⇐max_constructed+1的硬币。\n参考：blog.csdn.net/MOU_IT/article/details/89057036\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n \nusing namespace std;\n \nint MinimalCoin(const vector&lt;int&gt;&amp; coins, int amount)\n{\n  if (coins.empty())\n    throw std::invalid_argument(&quot;empty coins&quot;);\n  if (coins[0] != 1)\n    return -1;\n \n  int max_constructed = 0;\n  int cnt = 0;\n  do\n  {\n    for (int n = coins.size() - 1; n &gt;= 0; --n)\n    {\n      if (coins[n] &lt;= max_constructed + 1)\n      {\n        max_constructed += coins[n];\n        ++cnt;\n        break;\n      }\n    }\n    \n  } while (max_constructed &lt; amount);\n \n  return cnt;\n}\n \nint main()\n{\n  // address input\n  int n, m;\n  cin &gt;&gt; m &gt;&gt; n;\n \n  int val;\n  vector&lt;int&gt; coins;\n  for (int i = 0; i != n; ++i)\n  {\n    cin &gt;&gt; val;\n    coins.push_back(val); \n  }\n \n  std::sort(coins.begin(), coins.end());\n  cout &lt;&lt; MinimalCoin(coins, m);\n \n  return 0;\n}\n题四：舞会\n\n链接：www.nowcoder.com/questionTerminal/9efe02ab547d4a9995fc87a746d7eaec\n来源：牛客网\n\n今天，在冬木市举行了一场盛大的舞会。参加舞会的有n 位男士，从 1 到 n 编号；有 m 位女士，从 1 到 m 编号。对于每一位男士，他们心中都有各自心仪的一些女士，在这次舞会中，他们希望能与每一位自己心仪的女士跳一次舞。同样的，对于每一位女士，她们心中也有各自心仪的一些男士，她们也希望能与每一位自己心仪的男士跳一次舞。在舞会中，对于每一首舞曲，你可以选择一些男士和女士出来跳舞。但是显然的，一首舞曲中一位男士只能和一位女士跳舞，一位女士也只能和一位男士跳舞。由于舞会的时间有限，现在你想知道你最少需要准备多少首舞曲，才能使所有人的心愿都得到满足？\ninput:\n第一行包含两个整数n,m，表示男士和女士的人数。1≤n,m≤ 1000\n接下来n行，\n第i行表示编号为i的男士有ki个心仪的女生\n然后包含ki个不同的整数分别表示他心仪的女士的编号。\n接下来m行，以相同的格式描述每一位女士心仪的男士。\noutput:\n一个整数，表示最少需要准备的舞曲数目。\n示例输入：\n3 3\n2 1 2\n2 1 3\n2 2 3\n1 1\n2 1 3\n2 2 3\n\n示例输出：\n2\n\n说明：\n对于样例2，我们只需要两首舞曲，第一首舞曲安排（1,1），（2,3），（3,2）；第二首舞曲安排（1,2），(2,1)，（3,3）。\n\n\n思路：乍一看好象很难，不知道怎么处理。其实只要仔细看清楚题目要求：要求每个刃都能得到满足！这很重要，即便还有一个我喜欢的人没跟我跳，就得再放一首歌让我跳！了解到这个需求之后，问题就变的简单了，只要统计出每个人心仪人的数量，以及被心仪的数量，对所有人求一个最大值就行了。\n参考：www.nowcoder.com/questionTerminal/9efe02ab547d4a9995fc87a746d7eaec\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n \nusing std::vector;\n \nint main()\n{\n  // read input and built heartbeat matrix\n  int num_men, num_women, num_likes, val;\n  std::cin &gt;&gt; num_men &gt;&gt; num_women;\n  int total_num = num_men + num_women;\n  // the heartbeat matrix\n  vector&lt;vector&lt;int&gt; &gt; mat(total_num, vector&lt;int&gt;(total_num, 0));\n \n  for (int i = 0; i != total_num; ++i)\n  {\n    std::cin &gt;&gt; num_likes;\n    while (num_likes--)\n    {\n      std::cin &gt;&gt; val;\n      if (i &lt; num_men)  // man to woman\n        mat[i][val+num_men-1] = 1;\n      else // woman to man\n        mat[i][val-1] = 1;\n    }\n  }\n  // done\n  \n  // count for each persons hearbeats\n  int songs_needed = 0;\n  for (int i = 0; i != total_num; ++i)\n  {\n    int cnt = 0;\n    if (i &lt; num_men)  // counting for each man\n    {\n      for (int j = num_men; j != total_num; ++j)\n      {\n        if (mat[i][j] == 1) // man i like woman j\n          ++cnt;\n        else if (mat[j][i] == 1) // man i is liked by woman j\n          ++cnt;\n      }\n    }\n    else\n    {\n      for (int j = 0; j != num_men; ++j)\n      {\n        if (mat[i][j] == 1)\n          ++cnt;\n        else if (mat[j][i] == 1)\n          ++cnt;\n      }\n    }\n    if (songs_needed &lt; cnt) songs_needed = cnt; // update songs if needed\n  }\n  \n  std::cout &lt;&lt; songs_needed;\n  return 0;\n}\n题八：点击窗口的索引\n\n网易雷火游戏2019校招\n\n本题需要让你模拟一下在Windows系统里窗口和鼠标的点击操作，具体如下：\n\n屏幕分辨率为3840x2160，左上角坐标为(0, 0)，右下角坐标为(3839, 2159).\n窗口是一个矩形的形状，由左上角坐标(x, y), 和宽高(w, h)四给数字来定位。左上角坐标为(x, y), 右下角坐标为(x+w, y+h). 其中左上角坐标一定会在屏幕范围内，其他一些部分可能会超过屏幕范围。\n窗口的点击和遮挡规则同Windows，但是不考虑关闭窗口、最大化、最小化和强制置顶的情况。即，\n如果发生重叠，后面打开的窗口会显示在前面打开的窗口上面\n当鼠标发生一次点击的时候，需要判断点击到了哪个窗口，如果同个坐标有多个窗口，算点击到最上层的那个\n当一个窗口被点击的时候，会浮动到最上层\n\n输入描述：\n每个测试输入包含1个测试用例。第一行为2个整数N，M。其中N表示打开窗口的数目，M表示鼠标点击的数目，其中0&lt;N,M &lt; 1000.\n接下来N行，每一行四个整数x_i, y_i, w_i, h_i, 分别表示第i个窗口（窗口id为i，从1开始计数）的左上角坐标以及宽高，初始时窗口是按输入的顺序依次打开。其中0 \\le x_i &lt; 3840, 0 \\le y_i &lt; 2160, 0 &lt; w_i &lt; 3840, 0 &lt; h_i &lt; 2160.\n再接下来有M行，每一行两个整数x_j, y_j, 分别表示接下来发生的鼠标点击坐标。其中0 \\le x_j &lt; 3840, ~0 \\le y_j &lt; 2160\n输出描述：\n对于每次鼠标点击，输出本次点击到的窗口id。如果没有点击到窗口，输出-1.\n示例输入：\n2 4\n100 100 100 100\n10 10 150 150\n105 105\n180 180\n105 105\n1 1\n\n示例输出：\n2\n1\n1\n-1\n\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n \nusing namespace std;\n \n// global const\nenum {\n  WIDTH = 3840,\n  HEIGHT = 2160\n};\n \n// abstraction for 2D point\nstruct Pos\n{\n  int x;\n  int y;\n  Pos(int xx, int yy): x(xx), y(yy)\n  {\n  }\n};\n \n// abstraction for window\nstruct Window\n{\n  int id;\n  Pos point;\n  int width;\n  int height;\n  Window(int idx, int x, int y, int w, int h)\n    : id(idx), point(x, y), width(w), height(h)\n  {\n  }\n};\n \n/// is the point @c p in the window @c w\nbool IsInWindow(const Window&amp; w, const Pos&amp; p)\n{\n  int left = w.point.x;\n  int right = \n    (left + w.width &lt; WIDTH) ? (left + w.width) : WIDTH-1;\n  int top = w.point.y;\n  int bot = \n    (top + w.height &lt; HEIGHT) ? (top + w.height) : HEIGHT-1;\n \n  if (p.x &gt;= left &amp;&amp; p.x &lt;= right)\n  {\n    if (p.y &gt;= top &amp;&amp; p.y &lt;= bot)\n      return true;\n  }\n  return false;\n}\n \n///  which window do i click on\nint ClickWhich(vector&lt;Window&gt;&amp; windows, const Pos&amp; click)\n{\n  // 窗口叠放次序，从上层到下层\n  for (int i = windows.size() - 1; i &gt;= 0; --i)\n  {\n    if (IsInWindow(windows[i], click))\n    {\n      int ret = windows[i].id + 1;\n      windows.push_back(windows[i]);\n      windows.erase(windows.begin() + i);\n      return ret;\n    }\n  }\n  return -1;\n}\n \nint main()\n{\n  int num_open_windows, num_clicks;\n  cin &gt;&gt; num_open_windows &gt;&gt; num_clicks;\n  // read windows\n  vector&lt;Window&gt; windows;\n  for (int i = 0, x,y,w,h; i != num_open_windows; ++i)\n  {\n    cin &gt;&gt; x &gt;&gt; y &gt;&gt; w &gt;&gt; h;\n    windows.emplace_back(i, x, y, w, h);\n  }\n  // read clicks\n  vector&lt;Pos&gt; clicks;\n  for (int i = 0, x,y; i != num_clicks; ++i)\n  {\n    cin &gt;&gt; x &gt;&gt; y;\n    clicks.emplace_back(x, y);\n  }\n  // io done\n  \n  for (auto &amp;e : clicks)\n  {\n    cout &lt;&lt; ClickWhich(windows, e) &lt;&lt; endl;  \n  }\n \n  return 0;\n}\n树相关\nJosephus Problem\n\n这个问题是以弗拉维奥·约瑟夫命名的，他是1世纪的一名犹太历史学家。他在自己的日记中写道，他和他的40个战友被罗马军队包围在洞中。他们讨论是自杀还是被俘，最终决定自杀，并以抽签的方式决定谁杀掉谁。约瑟夫斯和另外一个人是最后两个留下的人。约瑟夫斯说服了那个人，他们将向罗马军队投降，不再自杀。约瑟夫斯把他的存活归因于运气或天意，他不知道是哪一个。\n——维基百科\n\n描述：人们站在一个等待被处决的圈子里。 计数从圆圈中的指定点开始，并沿指定方向围绕圆圈进行。 在跳过指定数量的人之后，执行下一个人。 对剩下的人重复该过程，从下一个人开始，朝同一方向跳过相同数量的人，直到只剩下一个人，并被释放。（牛客网上类似的题[^c]）\n问题即，给定人数、起点、方向和要跳过的数字，选择初始圆圈中的位置以避免被处决。\n解法：维基百科[^a]上也有，GeeksforGeeks[^b]还有视频教程。\n常见的有两种解法：\n\n单链表模拟\n数学递推\n\n显然，假设n个人编号：0,1,2,3,\\dots,n-1. 从0号开始报数（报数从0开始），报到m-1的将被处决，然后从下一个人开始报数。直到剩下最后一个人，赦免之。\n第一趟：报到 m 的自然是编号为(m-1) \\mod n.\n接着从 m \\mod n 开始报数，接下来又会是谁被处决呢？\n等等，先来看看问题是什么，我希望知道幸免者的编号。在n个人，报m个数的设定下，我希望知道幸免者编号，假设这个编号就是f(n,m), 这里 f 是个神奇的函数，我只要告诉它 n 和 m 它就能告诉我最后幸存者的编号。如果我能找到 f(n, m) 和 f(n-1, m) 的递推关系式，那将是极好的。\n在第一趟之后，报数从编号 k = m \\mod n 开始，但是此时只有 n-1个人，我还是想知道幸存者的编号。如果此时将编号重新映射一下，比如：\nk   -&gt; 0\nk+1 -&gt; 1\n...\nk-2 -&gt; n-2\n\n那么问题就变成了 n-1 个人，从0开始报数，报到 m-1 被处决，完完全全成了一个拥有同样结构的问题，但是规模更小了。显然，这个问题的解是 f(n-1, m). 但是呢，我们得到的编号却不是原来的编号了，得把编号还原回去。这很简单，假设得到的编号是 x，那么映射回原编号 y\ny = (x+k) mod n\n\n于是，如果我们能够知道 f(n-1, m), 那么\nf(n, m) = (f(n-1,m) + m) \\mod n.\n这就得到了递推公式，接着看一下边界条件，当n = 1时， f(1, m) = 0; 结束。\nint Josephus(int n, int m)\n{\n  if (n &lt; 1)\n    throw std::invalid_argument(&quot;we need n &gt;= 1&quot;);\n  if (n == 1)\n    return 0;\n  return (Josephus(n-1, m) + m) % n;\n}\n出列的顺序（类约瑟夫环）\n\nVIVO 2020校招正式批\n\n将N个人排成一排，从第一个人开始报数，如果报数是M的倍数就出列，报道队尾后则回到队头继续报数，直到所有人都出列。\n输入描述：\n输入2个正整数，空格分隔，第一个代表人数N，第二个代表M。\n输出描述：\n输出一个数组，每个数据表示原来在队列中的位置，用空格隔开，表示出列顺序\n输入实例：\n6 3\n\n输出示例：\n3 6 4 2 5 1\n\n说明：6个人排成一排，原始位置编号1-6，最终输出为3 6 4 2 5 1，\n表示的是原来编号为3的第一个出列，编号为1的最后出列。\n\n\n思路：类似于约瑟夫环，使用链表模拟整个过程即可。\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n \nusing namespace std;\n \nstruct Node\n{\n  int val;\n  Node* next;\n  Node(int n): val(n), next(nullptr) {}\n};\n \nvector&lt;int&gt; ToQueue(int num_employee, int mod)\n{\n  if (num_employee == 0) return vector&lt;int&gt;();\n  if (num_employee == 1) return vector&lt;int&gt;(1, 1);\n  // else num_employee &gt;= 2\n  \n  // build list\n  vector&lt;Node*&gt; nodes;\n  for (int i = 1; i &lt;= num_employee; ++i)\n  {\n    Node* p = new Node(i);\n    nodes.push_back(p);\n  }\n  for (size_t i = 1; i != nodes.size(); ++i)\n  {\n    nodes[i-1]-&gt;next = nodes[i];\n  }\n  nodes.back()-&gt;next = nodes.front();\n \n  Node* prev = nodes.back();\n  Node* cur = nodes.front();\n  vector&lt;int&gt; ret;\n  for (int count = 1; cur-&gt;next != cur; ++count)\n  {\n    if (count % mod == 0)\n    {\n      ret.push_back(cur-&gt;val);\n      prev-&gt;next = cur-&gt;next;\n      cur = cur-&gt;next;\n    }\n    else\n    {\n      prev = cur;\n      cur = cur-&gt;next;\n    }\n  }\n  ret.push_back(cur-&gt;val);\n  // memory clean\n  for (Node* p : nodes) delete p;\n  return ret;\n}\n \nint main()\n{\n  int num_employee, mod;\n  cin &gt;&gt; num_employee &gt;&gt; mod;\n  for (auto e : ToQueue(num_employee, mod))\n    cout &lt;&lt; e &lt;&lt; &quot; &quot;;\n  return 0;\n}\n最短通行时间\n\n度小满金融2020校招\n\n有N辆车要陆续通过一座最大承重为W的桥，其中第i辆车的重量为w[i], 过桥时间为t[i]. 要求：第辆车上桥时间不早于第i-1辆车上桥的时间；i任意时刻桥上所有车辆的总重量不超过W。那么，所有车辆都通过这座桥的所需的最短时间是多少？\n输入：\n第一行输入两个整数N，W（1 &lt;= N, W &lt;= 100000）\n第二行输入N个整数w[1]到w[N]（1 &lt;= w[i] &lt;= W）\n第三行输入N个整数t[1]到t[N]（1 &lt;= t[i] &lt;= 10000）\n\n4 2\n1 1 1 1\n2 1 2 2\n\n输出：\n4\n\n\n干就完了，模拟！\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n \nusing namespace std;\n \nint MinTime(const vector&lt;int&gt;&amp; car_weights,\n            vector&lt;int&gt;&amp; pass_times,\n            const int max_weight)\n{\n  int len = car_weights.size();\n  int elapsed_time = 0;\n  int cur = 0;\n  int w = max_weight;\n \n  for (;;)\n  {\n    int start = cur;\n    while (cur &lt; len &amp;&amp; w &gt;= car_weights[cur])\n    {\n      w -= car_weights[cur++];\n    }\n \n    if (cur &gt;= len) // reach the last car\n    {\n      elapsed_time += \n        *std::max_element(pass_times.begin() + start, pass_times.end());\n      return elapsed_time;\n    }\n    else\n    {\n      // each time a car passed, some other car may board the bridge\n      int mintime_idx = 0;\n      for (int i = 0; i &lt; cur; ++i)\n      {\n        if (pass_times[mintime_idx] &gt; pass_times[i] &amp;&amp; pass_times[i] != 0)\n          mintime_idx = i;\n      }\n      elapsed_time += pass_times[mintime_idx];\n \n      for (int i = 0; i &lt; cur; ++i) // update time\n        pass_times[i] = max(pass_times[i] - pass_times[mintime_idx], 0);\n \n      // car @mintime_idx has passed, now @w may be free to pass a new car\n      w += car_weights[mintime_idx];\n    }\n  }\n}\n \nint main()\n{\n  int num_car, max_weight;\n  cin &gt;&gt; num_car &gt;&gt; max_weight;\n  vector&lt;int&gt; car_weights;\n  for (int n = num_car, w; n--;)\n  {\n    cin &gt;&gt; w;\n    car_weights.push_back(w);\n  }\n  vector&lt;int&gt; pass_times;\n  for (int n = num_car, t; n--;)\n  {\n    cin &gt;&gt; t;\n    pass_times.push_back(t);\n  }\n  // io done\n  cout &lt;&lt; MinTime(car_weights, pass_times, max_weight);\n  return 0;\n}\n经过棋盘的最小开销\n\n58同城2020校招\n\n现有一个地图，由横线与竖线组成（参考围棋棋盘），起点在左上角，终点在右下角。每次行走只能沿线移动到相邻的点，每走一步产生一个开销。计算从起点到终点的最小开销为多少。\n输入描述：\nm \\times n 的地图表示如下\n3\n3\n1 3 4\n2 1 2\n4 3 1\n\n其中m=3，n=3表示3*3的矩阵\n行走路径为：下&gt;右&gt;右&gt;下\n\n输出描述：\n路径总长：1+2+1+2+1=7\n\n\n动态规划入门题，可惜我当时碰到DP就慌，而且只会递归DP，自顶向下，复杂度会高很多。\n\n假设用一个矩阵，名字就叫dp，表示最优结果。dp(i,j)表示从起点到坐标(i,j)的最小开销。很容易得到递推关系：\n\\text{dp}(i, j) = \n\\begin{cases}\n\\text{map}(i,j) + \\min(\\text{dp}(i, j-1), \\text{dp}(i-1, j)) &amp; i, j &gt; 0\\newline\n\\sum\\_{x=0}^{j-1} \\text{map}(i, j) &amp; i = 0 \\newline\n\\sum\\_{x=1}^{i-1} \\text{map}(i, j) &amp; j = 0\n\\end{cases}.\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n \nusing namespace std;\n \n// greedy\nint MinCost(const vector&lt;vector&lt;int&gt;&gt;&amp; mat)\n{\n  int row = static_cast&lt;int&gt;(mat.size());\n  int col = static_cast&lt;int&gt;(mat[0].size());\n  int i = 0;\n  int j = 0;\n  int ret = 0;\n  while (i &lt; row-1 &amp;&amp; j &lt; col-1)\n  {\n    ret += mat[i][j];\n    if (mat[i+1][j] &lt; mat[i][j+1]) ++i;\n    else ++j;\n  }\n  if (i == row-1)\n  {\n    for (int x = j; x &lt;= col-1; ++x)\n      ret += mat[i][x];\n  }\n  else\n  {\n    for (int x = i; x &lt;= row-1; ++x)\n      ret += mat[x][j];\n  }\n  return ret;\n}\n \n// dynamic programming\nint mincost(const vector&lt;vector&lt;int&gt;&gt;&amp; mat)\n{\n  int row = static_cast&lt;int&gt;(mat.size());\n  int col = static_cast&lt;int&gt;(mat[0].size());\n  vector&lt;vector&lt;int&gt;&gt; dp(row, vector&lt;int&gt;(col, 0));\n  // initialize\n  dp[0][0] = mat[0][0];\n  for (int i = 1; i &lt; row; ++i)\n    dp[i][0] = dp[i-1][0] + mat[i][0];\n  for (int j = 1; j &lt; col; ++j)\n    dp[0][j] = dp[0][j-1] + mat[0][j];\n \n  for (int i = 1; i &lt; row; ++i)\n  {\n    for (int j = 1; j &lt; col; ++j)\n    {\n      dp[i][j] = mat[i][j] + min(dp[i-1][j], dp[i][j-1]);\n    }\n  }\n  return dp[row-1][col-1];\n}\n \nint main()\n{\n  int num_rows, num_cols;\n  cin &gt;&gt; num_rows &gt;&gt; num_cols;\n  vector&lt;vector&lt;int&gt;&gt; mat(num_rows, vector&lt;int&gt;(num_cols, 0));\n  for (int i = 0; i != num_rows; ++i)\n  {\n    for (int j = 0, x; j != num_cols; ++j)\n    {\n      cin &gt;&gt; x;\n      mat[i][j] = x;\n    }\n  }\n  // io done\n  cout &lt;&lt; mincost(mat);\n  return 0;\n}"},"求职/算法题/基础题":{"slug":"求职/算法题/基础题","filePath":"求职/算法题/基础题.md","title":"基础题","links":[],"tags":[],"content":"基础题\n反转链表\n/******************************************************************************\n* File:             reverse_list.cpp\n*\n* Author:           yychi  \n* Created:          2022-12-29 20:35 \n* Description:      Reverse a linked list.\n*****************************************************************************/\n#include &lt;cstdio&gt;\n#include &lt;time.h&gt;\n#include &lt;stdlib.h&gt;\n \n \nstruct ListNode\n{\n    ListNode(int _val): val(_val), next(nullptr) {}\n    int val;\n    ListNode* next;\n    void print()\n    {\n        printf(&quot;%d&quot;, val);\n        if (next)\n        {\n            printf(&quot;-&gt;&quot;);\n            next-&gt;print();\n        }\n        else\n        {\n            printf(&quot;\\n&quot;);\n        }\n    }\n};\n \n \nListNode* ReverseList(ListNode* head)\n{ // O(n) time, O(1) space\n    if (!head || !head-&gt;next) return head;\n    ListNode *a = head, *b = head-&gt;next;\n    while (b)\n    {\n        ListNode* tmp = b-&gt;next;\n        b-&gt;next = a;\n        a = b;\n        b = tmp;\n    }\n    head-&gt;next = nullptr;\n    return a; \n}\n \n \nListNode* ReverseListRecursive(ListNode* head)\n{ // O(n^2) time\n    if (!head || !head-&gt;next) return head;\n    ListNode* ret = ReverseListRecursive(head-&gt;next);\n    ListNode* p = ret;\n    while (p-&gt;next)\n    {\n        p = p-&gt;next;\n    }\n    p-&gt;next = head;\n    head-&gt;next = nullptr;\n    return ret;\n} // 如果每一步返回尾后指针，走到底的时候记录下原来那个最末尾指针作为返回值（反转后指针的头），就可以把复杂度降下来啦\n \n// update 2024/9/25, 返回尾后指针的版本\nstruct ReverseListFunctor\n{\n    ListNode* head;\n    ListNode* operator()(ListNode* head)\n    {\n        // base case\n        if (!head || !head-&gt;next) return head;\n        helper(head)-&gt;next = nullptr;\n        return this-&gt;head;\n    };\n \n    // give the last element of the reversed list\n    ListNode* helper(ListNode* head)\n    {\n        if (head &amp;&amp; !head-&gt;next)\n        {\n            this-&gt;head = head;\n            return head;\n        }\n        helper(head-&gt;next)-&gt;next = head;\n        return head;\n    }\n};\n \n \nint main()\n{\n    srand(time(NULL));\n    ListNode head(345);\n    ListNode* p = &amp;head;\n    for (int i = 0; i &lt; 10; ++i)\n    {\n        int x = rand() % 99;\n        // auto node = ListNode(x);\n        // p-&gt;next = &amp;node;\n        p-&gt;next = new ListNode(x);\n        p = p-&gt;next;\n    }\n    head.print();\n \n    printf(&quot;recursive way:\\n&quot;);\n    ListNode* rhead = ReverseListRecursive(&amp;head);\n    rhead-&gt;print();\n \n    printf(&quot;iterative way:\\n&quot;);\n    ReverseList(rhead)-&gt;print();\n    return 0;\n}\n合并有序链表\n猛击此处获取live demo.\n/******************************************************************************\n* File:             lisuan.cpp\n*\n* Author:           yychi  \n* Created:          2022-08-10 22:44 \n* Description:      merge two sorted link list, iteratively and recursively.\n*****************************************************************************/\n#include &lt;stdio.h&gt;\n \n \nstruct ListNode\n{\n    ListNode(int _val): val(_val), next(nullptr) {}\n    int val;\n    ListNode* next;\n \n    void print()\n    {\n        printf(&quot;%d&quot;, val);\n        if (next)\n        {\n            printf(&quot;-&gt;&quot;);\n            next-&gt;print();\n        }\n        else\n        {\n            printf(&quot;\\n&quot;);\n        }\n    }\n};\n \n \nListNode* MergeLinkList(ListNode* a, ListNode* b)\n{\n    // two base cases.\n    if (!a) return b;\n    if (!b) return a;\n \n    ListNode ret(0);\n    ret.next = a;\n \n    ListNode* pa = &amp;ret;\n    for (; a &amp;&amp; b; )\n    {\n        if (a-&gt;val &lt;= b-&gt;val)\n        {\n            pa = a;\n            a = a-&gt;next;\n        }\n        else\n        {\n            ListNode* b_nex = b-&gt;next;\n            pa-&gt;next = b;\n            b-&gt;next = a;\n            pa = b;\n            b = b_nex;\n        }\n    }\n \n    // append tail\n    if (!a &amp;&amp; b) pa-&gt;next = b;\n    return ret.next;\n}\n \n \n/**\n * Recursive way.\n */\nListNode* MergeLinkListRecursive(ListNode* a, ListNode* b)\n{\n    if (!a) return b;\n    if (!b) return a;\n \n    if (a-&gt;val &lt;= b-&gt;val)\n    {\n        a-&gt;next = MergeLinkListRecursive(a-&gt;next, b);\n        return a;\n    }\n    else\n    {\n        b-&gt;next = MergeLinkListRecursive(a, b-&gt;next);\n        return b;\n    }\n}\n \n \n// test\nint main()\n{\n    ListNode* a = new ListNode(3);\n    ListNode* pa = a;\n    pa-&gt;next = new ListNode(5);\n    pa = pa-&gt;next;\n    pa-&gt;next = new ListNode(19);\n    pa = pa-&gt;next;\n    pa-&gt;next = new ListNode(21);\n    pa = pa-&gt;next;\n    pa-&gt;next = new ListNode(30);\n \n    ListNode* b = new ListNode(1);\n    ListNode* pb = b;\n    pb-&gt;next = new ListNode(4);\n    pb = pb-&gt;next;\n    pb-&gt;next = new ListNode(6);\n    pb = pb-&gt;next;\n    pb-&gt;next = new ListNode(8);\n    pb = pb-&gt;next;\n    pb-&gt;next = new ListNode(10);\n    pb = pb-&gt;next;\n    pb-&gt;next = new ListNode(45);\n \n    // print a, b\n    a-&gt;print();\n    b-&gt;print();\n \n    printf(&quot;before call a=%p, b=%p, a.next=%p, b.next=%p\\n&quot;, a, b, a-&gt;next, b-&gt;next);\n    MergeLinkList(a, b)-&gt;print();\n    printf(&quot;after call a=%p, b=%p, a.next=%p, b.next=%p\\n&quot;, a, b, a-&gt;next, b-&gt;next);\n    // MergeLinkListRecursive(a, b)-&gt;print();\n    return 0;\n}\n最大子数组的和\nsee: leetcode.com/problems/maximum-subarray/description/\n从头开始累加，关键是什么时候丢弃当前的累加进度，重新开始。答：当累加和小于当前元素的时候，不如丢弃累加和，直接从当前元素再开始累加。\nclass Solution {\npublic:\n    int maxSubArray(vector&lt;int&gt;&amp; nums) {\n        int ret = INT_MIN, sum = 0;\n        for (int e : nums)\n        {\n            sum = max(sum+e, e);\n            ret = max(ret, sum);\n        }\n        return ret;\n    }\n};\n最大子数组的乘积\nsee: leetcode.com/problems/maximum-product-subarray/description/\n和上面的问题类似，但是这里多了负负得正的情况，所以处理起来比较麻烦。关键点在于：每次遍历，记录当前最大乘积和当前最小乘积（因为最小乘积可能呈乘一个负数翻正从而比最大乘积更大）。然后更新全局最大乘积。\nclass Solution {\npublic:\n    int maxProduct(vector&lt;int&gt;&amp; nums) {\n        int ret = INT_MIN;\n        int pmin = 1, pmax = 1, n, m;\n        for (auto e : nums)\n        {\n            n = pmin * e;\n            m = pmax * e;\n            pmin = min({n, m, e});\n            pmax = max({n, m, e});\n            ret = max(pmax, ret);\n        }\n        return ret;\n    }\n};\n字符串相乘\nsee: leetcode.com/problems/multiply-strings/description/\n本质上是模拟竖式相乘，直接模拟即可，需要注意细节。\nclass Solution {\npublic:\n \n/**\n * 考虑竖式乘法中，单个位置上的结果累加，考虑循环进位。\n */\nvoid add_by_carrier(string&amp; o, size_t index, int value)\n{\n    if (value &lt;= 0 || index &gt;= o.size()) return;\n    int p = value + (o[index] - &#039;0&#039;);\n    o[index] = &#039;0&#039; + (p % 10);\n    add_by_carrier(o, index+1, p/10);\n}\n \nstring multiply(string num1, string num2)\n{\n    std::reverse(num1.begin(), num1.end());\n    std::reverse(num2.begin(), num2.end());\n    string ret(num1.size() + num2.size(), &#039;0&#039;);\n \n    for (size_t i = 0; i &lt; num1.size(); ++i)\n    {\n        int p1 = num1[i] - &#039;0&#039;;\n        for (size_t j = 0; j &lt; num2.size(); ++j)\n        {\n            add_by_carrier(ret, i+j, p1 * (num2[j]-&#039;0&#039;));\n        }\n    }\n    while (ret.size() &gt; 1 &amp;&amp; ret.back() == &#039;0&#039;)\n        ret.pop_back();\n \n    std::reverse(ret.begin(), ret.end());\n    return ret;\n}\n \n};\n二分查找\nleetcode cn #704 leetcode.cn/problems/binary-search/description/\n给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。\n\n\n                  \n                  变种 \n                  \n                \n\n如果存在多个目标值，要求返回索引最大/最小的那个。\n\n\n#define GREEDY true\n \nclass Solution {\npublic:\n    int search(vector&lt;int&gt;&amp; nums, int target) {\n        return my_binary_search(nums, target);\n    }\n \n \nint my_binary_search(const vector&lt;int&gt;&amp; arr, int target)\n{\n    int beg = 0, end = arr.size(), mid = 0;\n    while (beg + 1 &lt; end)\n    {\n        mid = (beg + end) / 2;\n        if (target == arr[mid])\n        {\n#if GREEDY\n            // in case of the array is not monotone increasing (i.e., it contains\n            // some duplicated elements), we want the maximal index `i&#039; such that\n            // arr[i] = target.\n            beg = mid;\n#else\n            return mid;\n#endif\n        }\n        if (target &lt; arr[mid])\n        {\n            end = mid;\n        }\n        if (target &gt; arr[mid])\n        {\n            beg = mid;\n        }\n    }\n    if (target == arr[beg]) return beg;\n    return -1;\n}\n};"},"求职/算法题/排序":{"slug":"求职/算法题/排序","filePath":"求职/算法题/排序.md","title":"排序","links":["求职/算法题/基础题.html"],"tags":["sort","coding-problem"],"content":"排序\n题十一：重排并计算逆序数\n\n腾讯2019校招\n\n作为程序员的小Q，它的数列和其他人的不太一样，他有2^n个数。老板问了小Q一共m次，每次给出一个整数q_i (1⇐i⇐m)，要求小Q把这些数每2^{q_i}分为一组，然后把每组进行翻转，小Q想知道每次操作后整个序列中的逆序对个数是多少呢？\n例如：\n对于序列1 3 4 2，逆序对有(4,2), (3,2)总数量为2.\n翻转之后为2 4 3 1，逆序对有(2,1), (4,3), (4,1), (3,1)总数量为4.\n输入描述：\n第一行一个数n（0⇐n⇐20）\n第二行2^n个数，表示初始序列（1⇐初始序列⇐10^9）\n第三行一个数m（1⇐m⇐10^6）\n第四行m个数表示q_i (0⇐q_i⇐n)\n输出描述：\nm行每行一个数表示答案\n输入示例：\n2\n2 1 4 3\n4\n1 2 0 2\n\n输出示例：\n0\n6\n6\n0\n\n说明：\n初始序列2 1 4 3\n2^{q_1} = 2 → 第一次：1 2 3 4 → 逆序对数0\n2^{q_2} = 4 → 第二次：4 3 2 1 → 逆序对数6\n2^{q_3} = 1 → 第三次：4 3 2 1 → 逆序对数6\n2^{q_4} = 4 → 第四次：1 2 3 4 → 逆序对数0\n\n首先如何计算逆序数，常用的方法是归并排序，可以顺带计算逆序数。但是由于我一开始用的是开销较大的归并，频繁的构造，复制vector，导致运行超时。后来改成了inplace的归并，速度明显提高很多。\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;time.h&gt;\n \nusing namespace std;\n \n// combine two sorted subseqs\nvector&lt;int&gt; merge(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b, int* invcount)\n{\n  vector&lt;int&gt; res; // result seq\n  vector&lt;int&gt;::iterator i = a.begin();\n  vector&lt;int&gt;::iterator j = b.begin();\n  while(i != a.end() &amp;&amp; j != b.end())\n  {\n    if (*i &lt;= *j) res.push_back(*(i++));\n    if (*i &gt; *j)\n    {\n    \tres.push_back(*(j++));\n    \t(*invcount) += (a.end() - i);\n    }\n  }\n\t\n  // tail appending ...\n  if (i == a.end())\n  {\n    for(auto iter = j; iter != b.end(); ++iter)\n      res.push_back(*iter);\n  }\n  if (j == b.end())\n  {\n    for(auto iter = i; iter != a.end(); ++iter)\n      res.push_back(*iter);\n  }\n  \n  return res;\n}\n \n// 归并排序的递归形式\nvector&lt;int&gt; mergesort(vector&lt;int&gt;&amp; seq, int* invcount)\n{\n  if (seq.size() == 1) return seq;\n  else{\n    // split the seq into two subseqs\n    int lsize = seq.size() &gt;&gt; 1;\n    vector&lt;int&gt; tmpl(seq.begin(), seq.begin() + lsize);\n    vector&lt;int&gt; tmpr(seq.begin() + lsize, seq.end());\n    \n    vector&lt;int&gt; lseq, rseq;\n    // recursively slove subproblems \n    lseq = mergesort(tmpl, invcount);\n    rseq = mergesort(tmpr, invcount);\n    \n    return merge(lseq, rseq, invcount);\n  }\n}\n \n// in-place merge sort\nnamespace inplace\n{\n/// Merge two sorted range [beg, mid), [mid, end).\nvoid Merge(vector&lt;int&gt;&amp; arr, int beg, int mid, int end, int* invcnt)\n{\n  for (int i = beg, j = mid; i &lt; mid &amp;&amp; j &lt; end;)\n  {\n    if (arr[i] &gt; arr[j])\n    {\n      *invcnt += (mid - i);\n      std::swap(arr[i], arr[j]);\n      // rearrange to keep the structure \n      for (int t = j; t &gt; i+1; --t)\n      {\n        std::swap(arr[t], arr[t-1]);\n      }\n      ++mid;\n      ++j;\n    } \n    ++i;\n  }\n}\n \n/// Inplace merge sort the range [beg, end).\nvoid MergeSort(vector&lt;int&gt;&amp; arr, int beg, int end, int* invcnt)\n{\n  if (end - beg &gt; 1) // need sort\n  {\n    int mid = (beg + end) / 2;\n    MergeSort(arr, beg, mid, invcnt);\n    MergeSort(arr, mid, end, invcnt);\n    Merge(arr, beg, mid, end, invcnt);\n  }\n}\n} // namespace inplace\n \n/// reverse the arr by length k\nvoid ReverseBy(vector&lt;int&gt;&amp; arr, int k)\n{\n  for (auto beg = arr.begin(); beg != arr.end(); beg += k)\n    std::reverse(beg, beg + k);\n}\n \n/// compute elapsed time from start_time\ninline double TimeElapsed(clock_t start_time)\n{\n  return static_cast&lt;double&gt;(clock()-start_time)\n    / CLOCKS_PER_SEC * 1000;\n}\n \n/// Test wrapper\nvoid UniTest(const vector&lt;int&gt;&amp; numbers, \n             const vector&lt;int&gt;&amp; qs,\n             bool inplace)\n{\n  vector&lt;int&gt; dummynum(numbers);\n  vector&lt;int&gt; buffer(numbers.size());\n  for (auto e : qs)\n  {\n    int invcount = 0;\n    ReverseBy(dummynum, 1&lt;&lt;e);\n    buffer.clear();\n    buffer.assign(dummynum.begin(), dummynum.end());\n \n    if (inplace)  // use inplace merge sort\n      inplace::MergeSort(buffer, 0, buffer.size(), &amp;invcount);\n    else\n      mergesort(buffer, &amp;invcount);\n \n    cout &lt;&lt; invcount &lt;&lt; endl;\n  }\n}\n \nint main()\n{\n  // io\n  int n;\n  cin &gt;&gt; n;\n  vector&lt;int&gt; numbers;\n  for (int i = 0, tmp = 0; i != (1&lt;&lt;n); ++i)\n  {\n    cin &gt;&gt; tmp;\n    numbers.push_back(tmp);\n  }\n  int m;\n  cin &gt;&gt; m;\n  vector&lt;int&gt; qs;\n  for (int i = 0, tmp = 0; i != m; ++i)\n  {\n    cin &gt;&gt; tmp;\n    qs.push_back(tmp); \n  }\n  // done\n \n  clock_t start = clock();\n  UniTest(numbers, qs, false);\n  cout &lt;&lt; TimeElapsed(start) &lt;&lt; &quot;ms for mergesort&quot; &lt;&lt; endl;\n \n  clock_t start2 = clock();\n  UniTest(numbers, qs, true);\n  cout &lt;&lt; TimeElapsed(start2) &lt;&lt; &quot;ms for inplace mergesort&quot; &lt;&lt; endl;\n  return 0;\n}\n附运行结果，体会一下：\n0\n6\n6\n0\n0.185ms for mergesort\n0\n6\n6\n0\n0.068ms for inplace mergesort\n\n差了3倍左右！\n基础题\nTop K\n给定一个无序序列，返回前K小的数。\n/******************************************************************************\n* File:             topk.cpp\n*\n* Author:           yychi  \n* Created:          2022-12-15 02:04 \n* Description:      Find the top k small elements of a sequence.\n*****************************************************************************/\n \n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;exception&gt;\n \nusing std::vector;\n \n \n/// The quick sort partition.\nsize_t partition(vector&lt;int&gt;&amp; arr, size_t beg, size_t end)\n{\n    size_t pivot = beg;\n    size_t i = pivot + 1;\n    for (auto j = i; j &lt; end; ++j)\n    {\n        if (arr[j] &lt; arr[pivot])\n        {\n            std::swap(arr[i], arr[j]);\n            ++i;\n        }\n    }\n    std::swap(arr[pivot], arr[i-1]);\n    return i - 1;\n}\n \n \n/**\n * Return the idx of `k`, with each element left of idx `k`, is smaller\n * than arr[k].\n */\nsize_t find_idx_of_k(vector&lt;int&gt;&amp; arr, size_t beg, size_t end, size_t k)\n{\n    size_t mid = partition(arr, beg, end);\n    if (mid == k)\n    {\n        return mid;\n    }\n    else if (mid &lt; k)\n    {\n        return find_idx_of_k(arr, mid+1, end, k);\n    }\n    else\n    {\n        return find_idx_of_k(arr, beg, mid, k);\n    }\n}\n \n \nvector&lt;int&gt; FindTopK(vector&lt;int&gt;&amp; arr, size_t k)\n{\n    if (k &gt; arr.size())\n    {\n        throw std::invalid_argument(&quot;&quot;);\n        return arr;\n    }\n    if (k == arr.size()) return arr;\n    size_t idx = find_idx_of_k(arr, 0, arr.size(), k);\n \n    vector&lt;int&gt; ret;\n    ret.reserve(idx);\n    for (size_t i = 0; i &lt; idx; ++i)\n    {\n        ret.push_back(arr[i]);\n    }\n    return ret;\n}\n \n \nvoid PrintVector(const vector&lt;int&gt;&amp; arr)\n{\n    for (auto e : arr) std::cout &lt;&lt; e &lt;&lt; &#039; &#039;;\n    std::cout &lt;&lt; std::endl;\n}\n \n \nint main()\n{\n    vector&lt;int&gt; arr {12,234,23423,42,34,2,435,123,5676,8787,9199};\n    PrintVector(arr);\n    auto ret = FindTopK(arr, 5);\n    PrintVector(ret);\n    return 0;\n}\nto be continued…"},"求职/算法题/栈和队列":{"slug":"求职/算法题/栈和队列","filePath":"求职/算法题/栈和队列.md","title":"栈和队列","links":[],"tags":["stack","queue","coding-problem"],"content":"栈和队列\n使用两个栈构造一个队列\n/*\n * Basic idea:\n *     1. the top of stack1 as queue rear\n *     2. the top of stack2 as queue front\n */\n \n#include &lt;stack&gt;\n#include &lt;iostream&gt;\n \nusing namespace std;\n \nclass Queue {\nprivate:\n    stack&lt;int&gt; s1;\n    stack&lt;int&gt; s2;\n \npublic:\n    void push(int _node) {\n        s1.push(_node);\n    }\n \n    int pop() {\n        if (s2.empty()) {\n            while (!s1.empty()) {\n                s2.push(s1.top());\n                s1.pop();\n            }\n        }\n        int res = s2.top();\n        s2.pop();\n        return res;\n    }\n};\n使用两个队列构造一个栈\n/*\n * 1. queue2 as a auxiliary storage\n * 2. push: push to the rear of queue1\n * 3. pop: \n *    3.1. quque1 has only one element, pop it\n *    3.2. pop the elements of queue1, push them to queue2\n *         till queue1 has exactly one left, pop it\n *    then pop elems of queue2 push to queue1\n */\n \n#include &lt;queue&gt;\n \nusing namespace std;\n \nclass Stack {\nprivate:\n    queue&lt;int&gt; q1;\n    queue&lt;int&gt; q2;\n \npublic:\n    void push(int _node) {\n        q1.push(_node);\n    }\n \n    int pop() {\n        while (q1.size() != 1) {\n            q2.push(q1.front());\n            q1.pop();\n        }\n        int res = q1.front();\n        q1.pop();\n        while (!q2.empty()) {\n            q1.push(q2.front());\n            q2.pop();\n        }\n        return res;\n    }\n};\n判断可能的出栈序列\n输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）\n/*\n * The idea is I push all elems of `pushV` into \n * a stack `s`, simultaneously, I track if the elems \n * of `popV` equal to the `s.top()`. If it is, I will\n * pop a elem from the stack and track the next elem\n * of `popV` till a mismatch. Then I&#039;ll continue to push\n * elems into the stack.\n *\n * When I run out all elems of `pushV`, I check if the\n * stack is empty, if it is, then the `popV` should be\n * a possible pop sequence or vice versa.\n *\n * Credit: www.nowcoder.com/profile/248554\n */\n \n#include&lt;iostream&gt;\n#include&lt;stack&gt;\n#include&lt;vector&gt;\n \nusing namespace std;\n \nclass Solution {\npublic:\n    bool IsPopOrder(vector&lt;int&gt; pushV, vector&lt;int&gt; popV) {\n        // border case\n        if (pushV.size() == 0) return false;\n        \n        stack&lt;int&gt; s;\n        auto i = 0, j = 0;\n        while (i != pushV.size()) {\n            s.push(pushV[i++]);\n            // KEY POINT here\n            while (!s.empty()\n                &amp;&amp; s.top() == popV[j]\n                &amp;&amp; j != popV.size()) {\n                s.pop();\n                j++;\n            }\n        }\n        return s.empty();\n    }\n};\n \n// test\nint main() {\n    vector&lt;int&gt; pushV = {1,2,3,4,5};\n    vector&lt;int&gt; popV = {4,5,3,2,1};\n    cout &lt;&lt; Solution().IsPopOrder(pushV, popV);\n    return 0;\n}"},"求职/算法题/树相关":{"slug":"求职/算法题/树相关","filePath":"求职/算法题/树相关.md","title":"树相关","links":[],"tags":["tree","coding-problem"],"content":"树相关\n打印二叉树最右边的节点\n给定一个二叉树，打印其每层最右边的节点的值。\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;functional&gt;\n \nusing std::vector;\n \nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int _val):\n        val(_val), left(nullptr), right(nullptr) { }\n};\n \n// print the right-most node of each layer of a tree.\nvector&lt;int&gt; PrintRightMost(TreeNode* root)\n{\n  // - time: O(N), where N is #TreeNodes\n  // - space: O(N + logN)\n  if (!root) return vector&lt;int&gt;(); \n  vector&lt;vector&lt;int&gt;&gt; mat;\n \n  std::function&lt;void(TreeNode*, int)&gt; layer_travel =\n    [&amp;mat, &amp;layer_travel](TreeNode* p, int depth)\n    {\n      if (p == nullptr) return;\n      if (depth == (int)mat.size())\n        mat.emplace_back(vector&lt;int&gt;());\n      mat[depth].push_back(p-&gt;val);\n      layer_travel(p-&gt;left, depth + 1);\n      layer_travel(p-&gt;right, depth + 1);\n    };\n \n  vector&lt;int&gt; ret;\n  for (auto &amp;row : mat) ret.push_back(row.back());\n  return ret;\n}\n二叉树的层次遍历\n给定一颗二叉树，按每一层从左往右的顺序遍历。（队列的典型应用）\n/*\n * This is a typical application of queue.\n * With the help of a queue, you can easily do this.\n *\n * You can also use recursion.\n */\n \n#include &lt;queue&gt;\n#include &lt;vector&gt;\n \nusing namespace std;\n \nclass TreeNode {\npublic:\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n \nclass Solution {\npublic:\n    vector&lt;int&gt; HierarchicalTraversal(TreeNode* root) {\n        if (root == nullptr) { \n            // further error handle\n            return vector&lt;int&gt;(); \n        }\n \n        vector&lt;int&gt; ret;\n        queue&lt;TreeNode*&gt; q;\n        q.push(root);\n \n        while(!q.empty()) {\n            auto cur = q.front();\n            // from left to right push the current\n            // root&#039;s children to the queue\n            if (cur -&gt; left) q.push(cur -&gt; left);\n            if (cur -&gt; right) q.push(cur -&gt; right);\n            ret.push_back(cur -&gt; val);\n            q.pop();\n        }\n        return ret;\n    }\n \n \n    /// recursive\n    vector&lt;vector&lt;int&gt; &gt; layerTraverse(TreeNode* root) {\n        if (root == nullptr) return ret;\n        build(root, 0); \n        return ret;\n    }\n \n    // recursion needs a member variable\n    vector&lt;vector&lt;int&gt; &gt; ret;\n    void build(TreeNode* p, int depth) {\n        if (p == nullptr) return;\n \n        if (ret.size() == depth)\n            ret.push_back(vector&lt;int&gt;());\n        ret[depth].push_back(p -&gt; val); // use depth to track layer\n        build(p -&gt; left, depth + 1);\n        build(p -&gt; right, depth + 1);\n    }\n};\n递增二叉树\n\n网易互娱2020校招正式批\n\n给定一颗二叉树，每个节点又一个正整数权值。若一棵二叉树，每一层的节点权值之和都严格小于下一层的节点权值之和，则称这颗二叉树为递增二叉树。现在给你一颗二叉树，请判断它是否是递增二叉树。\n输入描述：\n输入的第一行是一个正整数T（0 &lt; T ⇐ 50）。接下来有T组样例，对于每组样例，输入的第一行是一个正整数N，表示树的节点个数（0 &lt; N ⇐ 100，节点编号为0到N-1）。接下来是N行，第k行表示编号为k的节点，输入格式为：VALUE LEFT RIGHT，其中VALUE表示其权值，是一个不超过5000的自然数；LEFT和RIGHT分别表示该节点的左孩子编号和右孩子编号。如果其不存在左孩子或右孩子，则LEFT或RIGHT为-1.\n输出描述：\n对于每一组样例，输出一个字符串。如果该二叉树是一颗递增树，则输出YES，否则输出NO。\n样例输入：\n2\n8\n2 -1 -1\n1 5 3\n4 -1 6\n2 -1 -1\n3 0 2\n2 4 7\n7 -1 -1\n2 -1 -1\n8\n21 6 -1\n52 4 -1\n80 0 3\n31 7 -1\n21 -1 -1\n59 -1 -1\n50 5 -1\n48 -1 1\n\n样例输出：\nYES\nNO\n\n\n这题最恶心的是输入格式，居然不是直接给一颗建好的二叉树的根节点，而是给数据让你自己建树。处理输入还比较麻烦，首先每个节点都有编号，得先存起来，然后一个一个构造节点，然后再连接起来，关键是连好以后，头节点在哪？还得找一下，最后的判断，实际上是二叉树的层次遍历，遍历得到一个向量，判断是否为严格单调递增即可。\n\n\n上图是第一个样例画出来的二叉树，左边圆圈中对应的是节点编号，右边的数字是节点的权值。要画这棵树，首先画左边的编号之间的连接图，然后把对应编号换作节点的权值即可。那么头节点在哪呢？入度为0的就是了！\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;functional&gt;\n \nusing namespace std;\n \nstruct TreeNode\n{\n  int val;\n  TreeNode* left;\n  TreeNode* right;\n  TreeNode(int v)\n    : val(v), left(nullptr), right(nullptr) {}\n};\n \nstruct NodeInfo\n{\n  TreeNode* pnode;  \n  int left;\n  int right;\n \n  NodeInfo(TreeNode* p, int l, int r):\n    pnode(p), left(l), right(r) {}\n};\n \n// build the tree and return the root\nTreeNode* BuildTree(vector&lt;NodeInfo&gt;&amp; nodes)\n{\n  vector&lt;int&gt; counts(nodes.size(), 0);\n  // link\n  for (size_t i = 0; i != nodes.size(); ++i)\n  {\n    int left = nodes[i].left;\n    int right = nodes[i].right;\n    if (left != -1)\n    {\n      nodes[i].pnode-&gt;left = nodes[left].pnode;\n      ++counts[left];\n    }\n    if (right != -1)\n    {\n      nodes[i].pnode-&gt;right = nodes[right].pnode;\n      ++counts[right];\n    }\n  }\n  // find root\n  for (size_t i = 0; i != counts.size(); ++i)\n  {\n    if (counts[i] == 0)\n      return nodes[i].pnode;\n  }\n  throw std::logic_error(&quot;no root&quot;);\n}\n \n// Is the tree a increasing tree?\nbool IsIncrTree(TreeNode* root)\n{\n  if (!root) return false;\n  vector&lt;vector&lt;int&gt;&gt; mat; \n \n  // tranverse the tree by layer\n  std::function&lt;void(TreeNode*, int)&gt; layer_travel;\n  layer_travel = \n    [&amp;mat, &amp;layer_travel](TreeNode* p, int depth) mutable\n    {\n      if (p == nullptr) return;\n      if ((int)mat.size() == depth)\n        mat.emplace_back(vector&lt;int&gt;());\n        \n      mat[depth].push_back(p-&gt;val);\n      layer_travel(p-&gt;left, depth + 1);\n      layer_travel(p-&gt;right, depth + 1);\n    };\n \n  layer_travel(root, 0);\n  \n  vector&lt;int&gt; sums;\n  for (auto&amp; row : mat)\n  {\n    int sum = 0;\n    for (auto c : row) sum += c;\n    sums.push_back(sum);\n  }\n \n  for (size_t i = 1; i != sums.size(); ++i)\n  {\n    if (sums[i-1] &gt;= sums[i])\n      return false;\n  }\n  return true;\n}\n \nint main()\n{\n  int num_test;\n  cin &gt;&gt; num_test;\n  \n  for (int num_nodes = 0; num_test--;)\n  {\n    cin &gt;&gt; num_nodes;\n    vector&lt;NodeInfo&gt; nodes;\n    while (num_nodes--)\n    {\n      int v, l, r;\n      cin &gt;&gt; v &gt;&gt; l &gt;&gt; r;\n      TreeNode* p = new TreeNode(v);\n      nodes.emplace_back(p, l, r);\n    }\n    TreeNode* root = BuildTree(nodes);\n    if (IsIncrTree(root))\n      cout &lt;&lt; &quot;YES\\n&quot;;\n    else\n      cout &lt;&lt; &quot;NO\\n&quot;;\n \n    // memory clean\n    for (auto&amp; node : nodes)\n    {\n      delete node.pnode;\n      node.pnode = nullptr;\n    }\n  } // nodes released\n  return 0;\n}\n题九：Stern-Brocot Tree\n\n网易雷火游戏2019校招\n\nThe Stern-Brocot tree is an infinite complete binary tree in which the verices correspond one-for-one to the positive rational numbers, whose values are ordered from the left to the right as in a search tree.\n\nFigure above shows a part of the Stern-Brocot tree, which has the first 4 rows. The value in the node is the mediant of the left and right fractions. The mediant of two fractions A/B and C/D is defined as (A+C)/(B+D).\nTo construct the Stern-Brocot tree, we first define the left fraction of the root node is 0/1, and the right fraction of the root node is 1/0. So the value in the root node is the mediant of 0/1 and 1/0, which is (0+1)/(1+0)=1/1. Then the value of root node becomes the right fraction of the left child, and the left fraction of the right child. For example, the 1st node in row2 has 0/1 as its left fraction and 1/1(which is the value of its parent node) as its right fraction. So the value of the 1st node on row2 is (0+1)(1+1)=1/2. For the same reason, the value of the 2nd node in row2 is (1+1)/(1+0)=2/1. This construction progress goes on infinity. As a result, every positive rational number can be found on the Stern-Brocot tree, and can be found only once.\nGive a rational nunmber in form P/Q, find the position of P/Q in the Stern-Borcot tree.\nInput description:\nInput consists of two integers, P and Q (1⇐P,Q ⇐ 1000), which represent the rational number P/Q. We promise P and Q are relatively prime.\nOutput description:\nOutput consists of two integers, R and C. R indicates the row index of P/Q in the Stern-Brocot tree, C indicates the index of P/Q in that row.\nBoth R and C are base 1. We promise the position of P/Q is always in the first 12 rows of the Stern-Brocot tree, which means R⇐12.\nSample input:\n5 3\n\nSample output:\n4 6\n\n\nIdea: tree structure is natural for recursion.\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;utility&gt;\n \nusing namespace std;\n \n// build Rat abstraction\ntypedef std::pair&lt;int, int&gt; Rat;  // the rational numbers\n \nRat operator+(const Rat&amp; lhs, const Rat&amp; rhs)\n{\n  // 事实上这里需要化简使得分子分母互素\n  // 不过下面我判断等于的时候是交叉相乘判断的，故不影响结果\n  return std::make_pair(\n      lhs.first + rhs.first,\n      lhs.second + rhs.second);\n}\n \nbool operator&lt;(const Rat&amp; lhs, const Rat&amp; rhs)\n{\n  return (lhs.first * rhs.second)\n       &lt; (rhs.first * lhs.second);\n}\n \nbool operator&gt;(const Rat&amp; lhs, const Rat&amp; rhs)\n{\n  return !(lhs &lt; rhs);\n}\n \nbool operator==(const Rat&amp; lhs, const Rat&amp; rhs)\n{\n  return (lhs.first * rhs.second)\n      == (rhs.first * lhs.second);\n}\n \nvoid Printer(const Rat&amp; r)\n{\n  cout &lt;&lt; r.first &lt;&lt; &quot;/&quot; &lt;&lt; r.second &lt;&lt; endl;\n}\n// done\n \nstruct SBTreeNode\n{\n  Rat LF; // left fraction\n  Rat val;\n  Rat RF; // right fraction\n  SBTreeNode(Rat l, Rat v, Rat r)\n    : LF(l), val(v), RF(r)\n  {\n  }\n};\n \n/// search the SBTree for target, return the row and col index\nvoid SearchOnTree(\n    SBTreeNode&amp; root, const Rat&amp; target, int* prow, int* pcol)\n{\n  // base case\n  if (target == root.val) return;\n  \n  // 可以看到Stern-Brocot树具有二叉排序树的特征\n  // left-child &lt; parent &lt; right-child\n  if (target &lt; root.val)\n  { // go left\n    root.RF = root.val;\n    root.val = root.val + root.LF;\n    ++(*prow);\n    *pcol = (*pcol) * 2 - 1;\n    SearchOnTree(root, target, prow, pcol);\n  }\n  else if (target &gt; root.val)\n  { // go right\n    root.LF = root.val;\n    root.val = root.val + root.RF;\n    ++(*prow);\n    (*pcol) *= 2; // 注意列索引的增量，仔细看规律\n    SearchOnTree(root, target, prow, pcol);\n  }\n}\n \nint main()\n{\n  Rat query;\n  cin &gt;&gt; query.first &gt;&gt; query.second;\n  SBTreeNode root(Rat(0,1), Rat(1,1), Rat(1,0));\n  // root.RF = root.val;\n  // root.val = root.val + root.LF;\n  // cout &lt;&lt; &quot;LF &quot;; Printer(root.LF);\n  // cout &lt;&lt; &quot;val &quot;; Printer(root.val);\n  // cout &lt;&lt; &quot;RF &quot;; Printer(root.RF);\n \n  int row = 1, col = 1;\n  SearchOnTree(root, query, &amp;row, &amp;col);\n  cout &lt;&lt; row &lt;&lt; &quot; &quot; &lt;&lt; col &lt;&lt; endl;\n  return 0;\n}"},"求职/算法题/模式匹配":{"slug":"求职/算法题/模式匹配","filePath":"求职/算法题/模式匹配.md","title":"模式匹配","links":["求职/算法题/排序.html","求职/算法题/场景题.html","求职/算法题/树相关.html"],"tags":["coding-problem","pattern-match"],"content":"模式匹配\n题十：解码字符串\n\n腾讯2019校招\n\n小Q想要给他的朋友发送一个神秘的字符串，但是他发现字符串过长了，于是小Q发明了一种压缩算法对字符串中重复的部分进行了压缩，对于字符串中连续的m个相同的字符串S将会压缩为[m|S]（m为一个整数且1⇐m⇐100），例如字符串ABCABCABC将会被压缩为[3|ABC]，现在小Q的同学收到了小Q发送过来的字符串，你能帮助他进行解压缩么？\n输入描述：\n输入第一行包含一个字符串S，代表压缩后的字符串。\nS的长度&lt;=1000;\nS仅包含大写字母、[、]、|;\n解压缩后的字符串长度不超过100000;\n压缩递归层数不超过10层;\n\n输出描述：\n输出一个字符串，代表解压后的字符串。\n\n输入示例：\nHG[3|B[2|CA]]F\n\n输出示例：\nHGBCACABCACABCACAF\n\n说明：\nHG[3|B[2|CA]]F -&gt;\nHG[3|BCACA]F -&gt;\nHGBCACABCACABCACAF\n\n\n个人觉得我的解法很烂，而且太繁琐，但是目前还想不出更好的。代码也写的比较乱orz. 主要想法是遍历一遍字符串，如果不是特定的压缩模式，直接添加到结果中就好，如果遇到了特殊模式（[3|AB]），将该模式提取出来交给另一个函数解码，模式可能递归存在，所以使用一个栈确保提取出正确的模式。\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;stack&gt;\n \nusing namespace std;\n \n// decode pattern like &quot;[3|abc]&quot;\n// note: end is included\nstring PatternDecode(const string&amp; s, size_t beg, size_t end)\n{\n  // the minmal len: [3|a]\n  // beg=0, end=4\n  if (end - beg &gt;= 4)\n  {\n    string ret;\n    auto pos_delimiter = s.find(&#039;|&#039;, beg);\n    int num_repeats = std::stoi(s.substr(beg+1, pos_delimiter-beg-1));\n    {\n      auto pos_left = s.find(&#039;[&#039;, pos_delimiter);\n      if (pos_left &lt; end) // has sub-pattern\n      {\n        ret += s.substr(pos_delimiter+1, pos_left-pos_delimiter-1);\n        auto pos_right = s.rfind(&#039;]&#039;, end-1);\n        ret += PatternDecode(s, pos_left, pos_right);\n        ret += s.substr(pos_right+1, end-pos_right-1);\n      }\n      else  // has not sub-pattern\n      {\n        ret += s.substr(pos_delimiter+1, end-pos_delimiter-1);\n      }\n    }\n    string res;\n    while (num_repeats--)\n      res += ret;\n \n    return res;\n  }\n  else\n  {\n    throw std::invalid_argument(&quot;range too small&quot;);\n  }\n}\n \nvoid Decode(const string&amp; s, string* o)\n{\n  if (s.empty())\n    throw std::invalid_argument(&quot;empty coded string&quot;);\n \n  stack&lt;size_t&gt; stk;\n  for (size_t i = 0; i != s.size(); ++i)\n  {\n    if (stk.empty() &amp;&amp; std::isalpha(s[i]))\n    {\n      o-&gt;push_back(s[i]);\n    }\n    else if (s[i] == &#039;[&#039;)\n    {\n      stk.push(i);\n    }\n    else if (s[i] == &#039;]&#039;)\n    {\n      // if the stk has only one elem, then the last &#039;]&#039; of\n      // a pattern is determined, we shall first decode this\n      // pattern before going on.\n      if (stk.size() == 1)\n      {\n        size_t pattern_beg = stk.top();\n        o-&gt;append(PatternDecode(s, pattern_beg, i));\n      }\n      stk.pop();\n    }\n  }\n}\n \nint main()\n{\n  // io\n  string input;\n  cin &gt;&gt; input;\n  string output;\n  Decode(input, &amp;output);\n  cout &lt;&lt; output;\n  return 0;\n}\n排序\n场景题\n括号匹配\n原题：leetcode.com/problems/valid-parentheses/\nclass Solution {\npublic:  \n  bool isValid(string s) {    // 此解法还是比较elegant的\n    stack&lt;char&gt; stk;\n        \n    for (auto &amp;c : s)\n    {\n      switch (c)\n      {\n        case &#039;{&#039;: stk.push(&#039;}&#039;); break;\n        case &#039;(&#039;: stk.push(&#039;)&#039;); break;\n        case &#039;[&#039;: stk.push(&#039;]&#039;); break;\n        default:\n        {\n          if (stk.empty() || c != stk.top()) // 巧妙地判断了stk非空\n              return false;\n          else\n              stk.pop();\n        }\n      }\n    }\n    return stk.empty();\n  }\n};\n树相关"},"求职/经历":{"slug":"求职/经历","filePath":"求职/经历.md","title":"面试经历及笔记","links":["notes/操作系统.html","notes/cpp/多态.html"],"tags":["interview"],"content":"经历\n拓蛮八方（2022.07.16）\n算法题：10辆一模一样的小车，油箱最多装10升油，最多跑10公里。如何使得其中一辆小车跑出最大距离。例如：A车和B车同跑5公里，然后A车把剩下的油给B车加满，这样B车可以跑15公里。\n\nPython迭代器，生成器\nPython多进程，多线程，协程\nPython list，append复杂度，remove复杂度\n快排思想，最坏O(n^2)，如何改进\n\n\n首先，清楚快排原理的同志都知道，快排特别热衷于凌乱的数据，最好情况下时间复杂度能达到O(nlogn)，空间复杂度为O(logn)；但是对于基本有序或者倒序的数据则无能为力，时间复杂度直接降到O(n^2），空间复杂度为O( n ) 。对于这种情况，取一个合理的基准值就很重要了。\n一种较为稳妥的方法是随机选取数组中的某个位置，而不是总是顽固地选择最右端的元素，这样确实可以避免排序的退化。\n再回想我们为什么要取随机值？就是为了避免输入数据有序造成的异常，如果一种方法能够在这种情况下利用这种原有的有序性岂不是更好吗？三值取中法就是这样的方法，它的选取方法是先从数组的开头、结尾和中间选取3个元素，再取这3个元素的中间值作为划分的基准。首先，三值取中法本身带有一定的随机性，所以能够很好的处理随机数据；其次，它使得最坏情况几乎不可能发生，如果数组原本就具有有序性，那么按照原始的划分方法，取到的3个元素中必然有2个将被划分到大于（或小于）v的值所在的数组中，而三值取中法则扭转了这种不利；最后，与随机化方法相比，三值取中法省去了生成随机数的开销。\n\n\n其次，在快速排序算法的递归实现中，存在一种不太好的现象：随着递归层层深入，大量数据被分割成了小数组；快排对于大数组的划分可以迅速地将元素移动到它正确位置的附近，比如说对1024进行一次均等划分，那么某个元素可能会移动数百个单位位置，若进行4次均等划分，元素在正确位置上的概率就从1/1024骤升到1/64，考虑到64与1024的绝对数值，这是相当高的效率；然而对于小数组，快速排序的效率就不那么理想了，对于16个元素的数组，快速排序也要划分4次才能把它移动到正确的位置上，相对于之前几百个位置的移动，小数组排序一次只能移动几个单位的位置。\n换句话说，快速排序对少量数据的划分远不如它对大量数据的划分这么划算，当排序进入到小数组阶段后，它将多次因为这些小数组而频繁调用自身，但获得的收益并不大，我姑且把这种现象叫做小数组的边际效益。采取分治递归策略的排序算法（如归并排序）都存在同样的问题，所以这类排序都可以在这方面优化。对大量数据排序时，我们应该在前期利用快速排序的特点，让这些数据迅速移动到正确位置附近，然后在后期消除小数组的边际效应。\n消除边际效应的一个方法就是设定一个M值，当数组元素个数小于M时，视为小数组，此时快速排序就直接返回，最后把数组处理得差不多时，再用其它排序方法对数组进行最终排序。那么M值应该取多少？又应该选择何种排序算法进行最终排序？\n首先回答第二个问题，因为它的答案是显而易见的。对接近有序的数据排序，没有什么算法比插入排序更合适了，插入排序的执行开销与所有元素偏离自己正确位置的距离成正比。\nCf. blog.csdn.net/u013257679/article/details/79633299 and here\n\n\n\n数据库，内存数据库，redis\nLinux中如何实现一个timer\n一个大文件（10GB+），如何获取其中指定行数的数据\nTCP的保序性，快速重传，拥塞控制\nUDP和TCP的区别，如何实现可靠的TCP\nHTTP的报文格式\n平时开发中有没有遇到进程阻塞，孤儿进程，内存泄漏\n死锁的形成\n\n蒙玺投资（2022.07.22）\n\nstd::atomic使用场景（多读一写）\nlinux STL 标准库容器的内存分配策略\nmap和unordered_map的区别\npython如何提高并发量，多线程怎么管理\n\n二面（2022.07.26）\n\nsizeof(std::vector)是多少\n工作中有没有用到过将c++的一块内存交给python层管理的情况？\n在一台CPU负载很高的机器上，优先使用互斥锁还是自旋锁？\n当一个线程没有拿到互斥锁，他什么时候会再去尝试拿锁？\n死锁是什么，怎么形成的？\n如何避免，解决死锁问题？（破除循环等待？）\n你提到了条件变量，条件变量的典型使用场景是什么？\n常用的原子操作有哪些？\nsizeof(int)和sizeof(std::atomic&lt;int&gt;)分别是多少？\nTCP拆包，粘包有了解吗？\n\nclass Base {\npublic:\n    virtual ~Base() {}\n};\n \nclass Derived : public Base {\npublic:\n    virtual ~Derived() {}\n};\n \n// 1\nsizeof(Base) = ?\nsizeof(Derived) = ?\nBase* p = xx;\np-&gt;virutal_mfunc();\n \n/**\n * 这样调用虚函数成员，会根据具体对象类型，查找vtbl进而调用各自的成员。\n * 当p指向基类对象时，和指向派生类对象时，这样的调用在时间和空间复杂度\n * 方面有什么区别？\n */\n以下是map和unordered_map的定义\ntemplate&lt;\n    class Key,\n    class T,\n    class Hash = std::hash&lt;Key&gt;,\n    class KeyEqual = std::equal_to&lt;Key&gt;,\n    class Allocator = std::allocator&lt; std::pair&lt;const Key, T&gt; &gt;\n&gt; class unordered_map;\n \ntemplate&lt;\n    class Key,\n    class T,\n    class Compare = std::less&lt;Key&gt;,\n    class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt; &gt;\n&gt; class map;\n\n为什么unordered_map模板特化既需要传Hash，有需要传KeyEqual\n为什么map模板不需要KeyEqual ?\n\n\ntest\n#include &lt;vector&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;typeinfo&gt;\n#include &lt;cstring&gt;\n#include &lt;atomic&gt;\n \nusing namespace std;\n \n#define PRINT_FUNC(tag) do { \\\n    if (strlen(tag) &gt; 0) { \\\n        printf(&quot;__%s__&quot;, tag); \\\n    } \\\n    printf(&quot;call %s\\n&quot;, __func__); } while (0)\n \n \nclass Base {\npublic:\n    inline virtual ~Base() { PRINT_FUNC(&quot;&quot;); }\n};\n \nclass Derived : public Base\n{\npublic:\n    virtual ~Derived() override { PRINT_FUNC(&quot;dd&quot;); }\n};\n \ntemplate&lt;typename T&gt;\nvoid PrintSize(T /* t */)\n{\n    printf(&quot;the size of %s is %lu\\n&quot;, typeid(T).name(), sizeof(T));\n}\n \n \n \nint main()\n{\n    printf(&quot;size of vector is %lu\\n&quot;, sizeof(vector&lt;int&gt;));\n    vector&lt;uint32_t&gt; a;\n    printf(&quot;a.size=%lu, a.capacity=%lu\\n&quot;, a.size(), a.capacity());\n    PrintSize(vector&lt;int&gt;());\n    PrintSize(Base());\n    PrintSize(Derived());\n    printf(&quot;size of atomic int is %lu\\n&quot;, sizeof(atomic&lt;uint32_t&gt;));\n    uint32_t u = 0;\n    PrintSize(u);\n \n    return 0;\n}\n输出\nsize of vector is 24\na.size=0, a.capacity=0\nthe size of St6vectorIiSaIiEE is 24\nthe size of 4Base is 8\ncall ~Base\nthe size of 7Derived is 8\n__dd__call ~Derived\ncall ~Base\nsize of atomic int is 4\nthe size of j is 4\n\n砺算科技（2022.08.04）\n两个面试官依次上阵，以下问题汇总在一起。\n\n描述工作中遇到过的一个bug\n说说python中赋值、浅拷贝、深拷贝的区别（一直在问我自己的理解，不知道想问啥）\n说说进程和线程之间的区别\n在x86平台机器上（32位），一个进程的虚拟地址空间有多大？\n说说虚函数\n纯虚函数呢？\n平时有用过gdb吗\n一个函数A调另一个函数B，要在B中开辟一块内存，如何在A中拿到指向这块内存的指针？\n\n函数B return这个指针\n函数A中定义一个指针变量，以引用或地址（二级指针）的方式传给函数B，在B中给这个指针赋值\n\n\n说说内联函数的作用\n函数调用有什么开销？\n压栈都会压些什么东西？\n说说动态链接库和静态链接库的区别，优缺点？\n手写代码：合并两个升序链表，使其仍保持升序。循环+递归写法（循环写失败了QAQ）\n说说重载，重写，覆盖三者的区别\n说说模板工作的机制？\n\n每个特化的模板都会生成一份独立的代码，根据模板参数类型调用对应的版本。\n\n\n我们知道频繁创建，销毁小对象会造成内存碎片。如何通过预先申请一片连续的内存，然后控制这些小对象的创建和销毁都在这块内存上？\n\n回答了对象池，但又问：如果这些小对象中可能会申请新内存，如何确保这些能够受控制，通过constructor和destructor构造和析构对象，但不发生内存申请和释放，而是利用那一块预先申请好的内存。（答不上来）\n\n\n说说宏和constant区别\n\n玄信资产（2022.12.01）\n\n自我介绍\n手写一个vector类，实现push_back, pop_back方法\n\n必须使用模板写\n考虑模板参数为指针类型\n考虑模板参数为自己（你正在写的这个vector类）\n实现默认构造函数，拷贝构造函数，移动构造函数，析构函数\n\n\n手写一个PriorityQueue，可以使用std::vector（不会）\n给定三个整数：a, b, n；求第n个能被a或b整除的数。例如a=2,b=4,n=2，则第一个被a或b整除的是2，第二个被a或b整除的是4，所以结果为4.\n\n说了暴力求解（[\\min(a,b), ~nab]这个区间内一定含有至少n个被a或被b整除的数，排个序，取第n个），人家说不行\n要了个提示，人家说这是个数学题\n又要了个提示：不能暴力求解（O(n)），那往下的复杂度只有（O(\\log n)）了呀\n又问了是什么算法：O(\\log n)不就只有二分法么\n终于在沟通之中得到答案，但这题已经失败了\n方案：取a、b的最小公倍数记为c，则[\\min(a,b), nc]之间至少存在n个被a或b整除的数。向下折半取整\\lfloor\\frac{n}{2}\\rfloor\\cdot c，算出[\\min(a,b), \\lfloor\\frac{n}{2}\\rfloor c]之间有多少个被a或b整除的数：\n\n\\lfloor \\frac{n}{2} \\rfloor \\cdot \\frac{c}{a} 可得有这么多被a整除的数，\n\\lfloor \\frac{n}{2} \\rfloor \\cdot \\frac{c}{b} 可得有这么多被b整除的数，\n\\lfloor \\frac{n}{2} \\rfloor \\cdot \\frac{c}{c} 可得有这么多被a和b同时整除的数，\n因此，区间共有\\lfloor \\frac{n}{2} \\rfloor (\\frac{c}{a} + \\frac{c}{b} - 1)个被a或b整除的数\n判断其与n的关系，如果比n大，向左搜索[\\min(a,b), \\lfloor\\frac{n}{2}\\rfloor c]，反之向右搜索[\\lfloor\\frac{n}{2}\\rfloor c, nc]\n\n\n\n\n给定一棵二叉搜索树，以及一个vector，批量搜索vector中的值，返回搜到的节点指针列表。（搜单个，遍历，如何优化）\n\n芯华章（2022.12.12）\n\n算法题：求top k大的数？（当时知道求第k大的数，但不知道怎么求前k大的数。查询之后发现思路是一样的，用快排的分割法，如果pivot的索引恰好是k，则k之前的恰好就是前k小的数。如果比k大，则在左边继续分割；如果比k小，则在右边继续分割。如是直到找出索引为k的pivot，即可得到前k小的数，自然得到前n-k大的数。）\n\n变通问法，如果序列长度超过内存可读取的上限，应该如何？（等于在前面的基础上加了个限制，没法读完整个序列。此时可以利用小顶堆「注意是小顶堆」来处理。先读出k个元素，建立一个大小为k的小顶堆，再依次读这个序列，如果读出来的数a大于堆顶元素b，则丢弃堆顶元素，a入堆。这样，不用一次读完所有数据，但在遍历完之后，留下的也就是前k大的数了。）\n\n\nstd::vector的push_back和emplace_back的区别？\n是否任何场景下都偏向于用emplace_back？（答到对于POD类型，可能用push_back更好，但也没有实测过性能开销；面试官指导：当empalce_back一个临时对象，这个对象内部有个指针，管理了一块内存，如果用emplace_back，但vector扩容失败，比如内存满了，此时临时对象的布道析构）\nc++11中一般如何创建一个线程？\n传给线程的方法，如果需要传参，对参数有什么要求吗？（答到了参数的生命周期必须维持到线程结束）\n如果没法保证传的参数生命周期大于线程本身，比如传了一个引用，编译器会报错吗？\nshared_ptr和auto_ptr的区别？\n多线程中对shared_ptr的操作需要加锁吗？（=shared_ptr是线程安全的吗？）\n\n仅引用计数更新线程安全\n读写指向的对象，非线程安全\n直接修改shared_ptr本身的指向，非线程安全\n\n\ntcp的三次握手\ntcp连接是通过调用什么系统API实现的？（答到client: connect, server: listen）\n连接断开呢是通过什么系统调用？\n对于server，如何得知一个包是申请断开连接的包呢？（答到了tpc的包头，人家说这个实在协议层，应用层如何区分呢）\n\n二面（2022.12.15）\n\n手写vector的insert，erase\n\nH3C\n主管面（2023.02.04）\n\n一致性哈希：假如hash有10个桶，分别位于不同的设备上。现在有一个设备坏了，如何将坏掉的桶里的数据迁移至其他9个（或9个当中的几个）桶中，而不影响好数据（即，如果hash到另外9个桶，照样可以取到正确的数据）？\n说一下工作中遇到的难题，如何解决的。\n设想一个场景，一个进程误写了一段内存，但没造成crash，也就是说这个进程现在带病运行。之后某个进程，读取这段内存中错误的数据，引发段错误。如何定位是哪个进程写坏了这段内存？不会；\n对linux了解到什么程度？知道linux的进程管理，内核调度吗？\nB树和跳表的区别，各自有何优缺点？\n\n中电28所（2023.03.03）\n\n说说内存泄漏，如何定位，如何产生，如何避免？\n堆踩踏、堆溢出\nmap和unordered_map\nc++11的新特性\nlinux find命令\nlinux运行程序是，如何链接动态库？\n介绍下无锁队列\n\n小米汽车（2024.9.19）\n算法题（leetcode 110）：从数组构建二叉树，并判断是否为平衡二叉树（此处平衡是指任意一个节点，其左右子树高度差不超过1）\n时间太紧，从数组构建二叉树，利用一个队列即可；判断是否平衡使用暴力求法，不太行\n// Build binary tree from an array.\nTreeNode* build_binary_tree(const vector&lt;int&gt;&amp; arr)\n{\n    if (arr.empty()) return nullptr;\n    auto root = new TreeNode(arr[0]);\n    queue&lt;TreeNode*&gt; ptr_q;\n    ptr_q.push(root);\n    for (int i = 1; !ptr_q.empty() &amp;&amp; i &lt; arr.size(); i += 2)\n    {\n        auto p = ptr_q.front();\n        ptr_q.pop();\n        if (arr[i] != -1)\n        {\n            p-&gt;left = new TreeNode(arr[i]);\n            ptr_q.push(p-&gt;left);\n        }\n        if (i + 1 &lt; arr.size() &amp;&amp; arr[i+1] != -1)\n        {\n            p-&gt;right = new TreeNode(arr[i+1]);\n            ptr_q.push(p-&gt;right);\n        }\n    }\n    return root;\n}\n \nint calc_tree_height(TreeNode* root)\n{\n    if (!root) return 0;\n    int lh = calc_tree_height(root-&gt;left);\n    int rh = calc_tree_height(root-&gt;right);\n    return 1 + std::max(lh, rh);\n}\n \nbool is_balanced_tree(TreeNode *root)\n{\n    if (!root) return true;\n    int lh = calc_tree_height(root-&gt;left);\n    int rh = calc_tree_height(root-&gt;right);\n    if (std::abs(lh - rh) &gt; 1) return false;\n    return is_balanced_tree(root-&gt;left) &amp;&amp; is_balanced_tree(root-&gt;right);\n}\n以上暴力的原因在于计算高度的函数对于同一个节点会被调用多次（有多少个祖先就调用多少次）。所以可以简单优化一下，采用自底向上的递归。\nint judge_tree_height(TreeNode* root)\n{\n    if (!root) return 0;\n    int lh = judge_tree_height(root-&gt;left);\n    if (lh == -1) return -1;\n    int rh = judge_tree_height(root-&gt;right);\n    // Note this: when calc tree height, we can do on more thing together\n    // that is judging the balance of the tree.\n    if (rh == -1 || std::abs(lh - rh) &gt; 1) return -1;\n    return 1 + std::max(lh, rh);\n}\n \nbool is_balanced_tree_bottom_up(TreeNode* root)\n{\n    return judge_tree_height(root) &gt;= 0;\n}\n\n\n\n                  \n                  以下为校招经历，从博客迁移至此。 \n                  \n                \n\n总结一下这几个月的面试经历中被问到的问题，虽说问得都很浅，但是，问深了我也不会呀！\nC++相关\nQ: std::vector push_back 的复杂度是多少？\nA: O(1), amortized constant.\nQ: vector从1到n push n个元素，假设发生扩容时按两倍增长，写出复杂度关于n的表达式？\nA: 不会。\n假设第一次只分配一个元素的空间。那么发生扩容的点依次如下：\n1,2,4,8,16,..., 2^{\\lfloor{\\log_2 n}\\rfloor}\n每次扩容都会copy之前内存中的所有元素，所以总共发生的拷贝次数为:\n1+2+4+\\cdots+2^{\\lfloor{\\log_2 n}\\rfloor}\n注意这里共有\\lfloor \\log_2 n \\rfloor项相加，于是有\n1+2+4+\\cdots+2^{\\lfloor{\\log_2 n}\\rfloor} = O(\\lfloor \\log_2 n \\rfloor \\cdot\n2^{\\lfloor{\\log_2 n}\\rfloor}) = O(n\\log n)\n加上push_back操作的次数n，所以有\nT(n) = O(n\\log n + n) = O(n \\log n)\nQ: 对于一个vector容器，删除元素后迭代器会失效吗？\nA: 对于删除给定元素前的迭代器不会失效，被删除元素之后的迭代器全部失效。\n\n向容器添加元素后：\n\n如果容器是vector或string，且存储空间重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前的迭代器、指针和引用仍有效，但指向插入位置之后元素的迭代器、指针和引用将会失效。\n对于deque，插入到除首尾元素以外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在元素的指针和引用不会失效。\n对于list和forward_list，指向容器的迭代器（包括尾后迭代器和首前迭代）、指针和引用都有效。\n\n当我们从一个容器中删除元素后，指向被删除元素的迭代器、指针和引用会失效，这应该不会令人惊讶。毕竟，这些元素已经被销毁了。当我们删除一个元素后：\n\n对于list和forward_list，指向容器其他位置的迭代器（包括尾后和首前）、引用和指针仍有效。\n对于deque，如果在首尾之外的任何位置删除元素指向被删除元素外其他元素的迭代器、引用和指针也会失效。如果是删除deque的尾元素，则尾后迭代器也会失效，但其他迭代器、引用和指针不受影响；如果是删除首元素，这些也不会受影响。\n对于vector和string，指向被删除元素之前的元素迭代器、引用和指针仍有效。注意：当我们删除元素时，尾后迭代器总是会失效。\n\n──《C++ Primer》\n\n关于迭代器失效的问题，另参阅：blog.csdn.net/lujiandong1/article/details/49872763\nQ: 对于使用hash函数组织的unordered_map，对于给定的hash函数，假设我总能构造一个集合，使得该集合内所有元素的hash值相同，即该集合内所有的key都映射到一个桶内。这种问题该如何解决？\nA: 不会。\n可以使用两个hash函数，例如h1和h2，然后将同一个key的hash值用某种方式连接起来，以此定义一个新的复杂hash函数。对于这个函数，碰撞的概率将会非常小，因此可以认为你设计不出这样的集合，使得集合内的元素都发生碰撞。\nQ: new/delete和malloc/free有什么区别？\nA: new/delete在C++中是运算符，但malloc/free是继承自C的内存管理函数。malloc只负责开辟指定大小的内存，并不负责初始化，而new及开辟内存，也会构造对象，如果要为自定义的类型申请动态内存，则必须使用new，new一个类型会调用该类型的构造函数。而delete和free的区别也是类似，delete调用类的析构函数，然后在释放内存，free仅释放内存。\nQ: 以下调用哪个函数？\nclass base {\npublic:\n    virtual void fun(int a) { cout &lt;&lt; a &lt;&lt; endl; }\n};\n \nclass derived : public base {\npublic:\n    void fun(int b) { cout &lt;&lt; &quot;derived&quot; &lt;&lt; endl; }\n};\n \nbase* pb = new derived();\npb-&gt;fun(3);\nA: derived. 虚函数的动态绑定，根据运行时类型调用对应的版本，虽然是基类指针，但实际上是派生类对象，所以调用派生类中的函数。动态绑定是C++支持多态的根本原因。关于动态绑定，参见：here.\n另外，定义虚函数会增加空间开销，一旦定义了虚函数，就会生成虚函数表和虚指针，动态绑定实际上是通过查表来确定具体调用哪个版本的函数。另外构造函数不能声明为虚函数，析构函数可以，但析构函数不能声明为纯虚函数。\nQ: 重载（overload）和重写（override）有什么区别？\nA: 重载指函数签名（函数原型）不同的两个函数名字相同，重写是指子类覆盖（重写）基类的方法，签名必须相同。注意，返回值不算函数签名，const算重载！ \n另外，还涉及到隐藏的概念。所谓隐藏，其实就是子作用域如果出现和父作用域相同的名字，那么父作用域的该名字在子作用域下被隐藏，不可见，因为被子作用域同名覆盖掉了。派生类的成员将隐藏基类同名成员。请看下例：\n#include &lt;iostream&gt;\n \nusing namespace std;\n \nclass Base {\npublic:\n    virtual void f(int x) { cout &lt;&lt; &quot;Base::f(int)&quot; &lt;&lt; endl; }\n    void g(float x) { cout &lt;&lt; &quot;Base::g(float)&quot; &lt;&lt; endl; }\n};\n \nclass Derived : public Base {\npublic:\n    void f(float x) { cout &lt;&lt; &quot;Derived::f(float)&quot; &lt;&lt; endl; }\n    void g(float x) { cout &lt;&lt; &quot;Derived::g(float)&quot; &lt;&lt; endl; }\n    void g(int x) { cout &lt;&lt; &quot;Derived::g(int)&quot; &lt;&lt; endl; }\n};\n \n// test\nint main()\n{\n    Derived dobj;\n    Base* pd = &amp;dobj;\n    pd-&gt;f(3);       // Base::f(int)\n    pd-&gt;g(3.3f);    // Base::g(float)\n    dobj.f(3.3f);   // Derived::f(float)\n    dobj.g(3.3f);   // Derived::g(float)\n    dobj.g(3);      // Derived::g(int)\n    return 0;\n}\n子类中g发生了重载。而基类指针调用f时，发现是虚函数，会去查表（发生动态绑定），但子类中并没有相应的重写（override），子类中的f仅仅是另一个函数，所以查表得知还是调用基类的f; 基类指针调用g时，发现不是虚函数，直接调用基类的g. 此间，子类的两个g对基类的g都是隐藏！\nQ：memcpy 和 memmove 的区别\nA：memcpy不能应对内存重叠，memmove可以。详见man pages.\nQ：为什么要内存对齐？\nA：不会。\n我们关注内存对齐不外乎下面两大原因：\n\n平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取\n某些特定类型的数据，否则抛出硬件异常。（平台移植是驱动程序开发者经常需要考虑的问题）。\n性能原因：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。\n\n\n可以使用预编译指令pragma pack(n)来指定对齐系数，n=1,2,4,8,16. 结构体对齐将按照最大成员大小和n中的较小值来对齐。\n\n算法相关\nQ: 从一个数组中删除一个元素，复杂度是多少？如果不关心索引和值的对应关系。\nA: O(1), 将要删除的元素与最后一个元素互换，将数组的长度减一。\n注意：这里他说不关心数组的索引和值的对应关系。连续存储就是数组，只不过先前通过索引i获得的值，并不一定和删除后通过索引i获得的值相同。我答的是O(n),因为要删除一个元素，还得将删除元素之后的元素前移一位，这样才是我理解的删除的语义。但是面试官说不关心索引与值的对应关系，那么假设数组长度为n，删除元素位置为i，在互换A[i]和A[n]之后，删除后数组的A[i]变成了原先的A[n], 但一般认为删除后A[i]应该是原先的A[i+1], 这就是他说的不关心索引和值的对应，和我所理解的不一样。\nQ: 生成50个[0, 50)间的随机整数，构成一个序列，要求不能重复？\nA: 用一个长度为50的数组用作map，初始化全为0. 然后使用随机数发生器生成[0, 50)之间的整数，并在map对应索引位置+1. 依次生成随机整数，且判断其索引对应的值是否为0，等于0说明还未生成过，等于1说明已经生成过，应该换一个。但是这样不能保证收敛，也许它永远生成不满50个随机整数。\n其实有O(n)的解法，延承自上一问。设有一副扑克牌，共50张，你怎样将它随机地分给排成一列的50个人？很简单，每次随机抽出一张给一个人，抽完了，也就分完了。现在你有一个随机数发生器，每次随机生成一个索引，你抽出该索引位置的牌（从数组中删除该元素），这个操作等价与将该索引的元素与数组最后一个元素互换。下一次，从[0, 49)里随机生成一个索引，纵然该索引与之前的可能一样，但对应位置的牌已经换了，所以不会抽出重复的牌。如此反复，抽完为止。这样你每删除一个元素的复杂度是O(1), 所以总共的复杂度就是O(n).\n机器学习相关\nQ: K-均值聚类中k如何选取，评价指标，他很不稳定，如何让它稳定一些。\n评价指标：类间相似度低，类内相似度高。K-means的稳定性较差，可能每次随机选取的初始聚类中心不一样，而导致聚类的效果不一样。从某种程度上来说，K-means对数据较为敏感，无法识别离群点。传统聚类采用的距离度量通常为欧式距离，Kernel k-means将所有样本映射到另外一个特征空间中再进行聚类，就有可能改善聚类效果。\n一种改进：K-means++，它的思想是在已经选定n个聚类中心后，选取第n+1个聚类中心时：距离当前n个聚类中心越远的点会有更高的概率被选为第n+1个聚类中心。在选取第一个聚类中心时同样使用随机的方法，这个改单简单有效。\n另外，一个很重要的问题，K的值如何选取？在低维度时，可以将数据画出来看大致有几个类，而在面对高维和复杂数据时，这种方法难以使用。关于K的选取：ISODATA，迭代自组织数据分析法，它的思想是：当属与某个类别的样本数量过少时就把该类别去除；当属与某个类别的样本数量过多时，分散程度较大时，将该类别分裂为两个子类。\nQ: 正则化如何克服过拟合？背后的原理是什么？\n正则化控制模型的复杂度。正则系数越大，模型拟合能力越差（偏差大，方差小），复杂度越低，一定程度上克服了过拟合。考虑正则系数从小变大，一开始偏差较小，方差较大。因为模型足够复杂，可以很好的学到数据特征，但也容易过拟合，对特定的数据集很敏感，也许换一个数据集就会是不一样的结果，此时已经发生了过拟合。随着正则系数不断变大，偏差也跟着增加，但方差会随之减小，因为正则项事实上限制了模型的拟合能力，降低了模型的复杂度。牺牲了偏差（变大），换取了方差（变小）。而在有限的训练数据集上，方差过大就意味着过拟合，意味着模型对数据集敏感。这不是我们想要的。整个过程的泛化误差先减小（方差减小）后增大（偏差增大），先是方差主导，后是偏差主导。最佳的正则系数应该对应着最小的泛化误差。详见PRML p.151\nQ: 有没有接触过其他的网络模型，CNN，RNN等？\n没有。\nQ: vae是生成网络吗？可不可以和infogan结合？了解一下vae？\n是。\n纽劢\n\nrandom forest 需要对特征做什么处理吗？\n常用的特征选择方法有哪些？\n主成分分析做特征选择有哪些缺点？\nl1 regularization 也可以做特征选择？\n特征有离散有连续该怎么处理？ one-hot encoding\n\n小米\n一面\nQ: 了解LRU缓存吗？\nA: 没听说过。\n这里说的缓存是一种广义的概念，在计算机存储层次结构中，低一层的存储器都可以看做是高一层的缓存。比如Cache是内存的缓存，内存是硬盘的缓存，硬盘是网络的缓存等等。\n缓存可以有效地解决存储器性能与容量的这对矛盾，但绝非看上去那么简单。如果缓存算法设计不当，非但不能提高访问速度，反而会使系统变得更慢。\n从本质上来说，缓存之所以有效是因为程序和数据的局部性（locality）。程序会按固定的顺序执行，数据会存放在连续的内存空间并反复读写。这些特点使得我们可以缓存那些经常用到的数据，从而提高读写速度。\n缓存的大小是固定的，它应该只保存最常被访问的那些数据。然而未来不可预知，我们只能从过去的访问序列做预测，于是就有了各种各样的缓存替换策略。本文介绍一种简单的缓存策略，称为最近最少使用（LRU，Least Recently Used）算法。\nQ: https加密方式？\nA: 不知道啊。\nQ: 输入网址到浏览器展示的过程？\nA: 不知道。\nHTTP的工作流程大致如下：\n\n地址解析\n封装HTTP请求。将访问信息以及本机的一些信息封装成一个HTTP请求数据包\n封装TCP包。建立 TCP 连接 , 也就是常说的”三次握手” . 由于HTTP位于最上层的应用层 , 所以HTTP在工作之前要由 TCP 和 IP 协议建立网络连接。\n客户端发送请求命令。在连接建立之后 , 客户端发送 HTTP 请求到服务端与请求相关的信息都会包含在请求头和请求体中发送给服务器端 .\n服务端响应。服务器端在收到请求之后 , 根据客户端的请求发送给客户端相应的信息 , 相关的响应信息都会放在响应头和响应体中 .\n关闭连接。服务器端在发送完响应之后 , 就会关闭连接 , 如果过客户端的请求的头部信息中有 Connection: keep-alive , 那么客户端在响应完这个请求之后不会关闭连接 , 知道客户端的所有请求都响应完毕 , 才会关闭连接 , 这样大大节省了带宽和 IO 资源 .\n\n二面\n(Sept. 6)\n\n自我介绍，实习工作内容\n局部静态对象和全局静态对象有什么区别\n进程间通信的方式\n有哪些同步原语\n堆内存和栈内存的区别\nint a, *b;有什么区别？（考察指针默认不开辟内存，指针变量仍然只用内存，只是说指针所指的地方不会给你开辟一个int的内存）\n\n58同城\n(Sept. 20)\n\n挑一个你最熟的项目说下？\nPooling是怎么回事，有什么用？\n二叉树序列化，空指针序列化为null，e.g., [1,2,3,4,null,null,5]\nCNN和DNN的区别？\n卷积有什么作用？\n\n一面面完之后，建议我转后端，我说好啊，然后二面面的后端，似乎是个leader，主要就是问问实习经历，然后让我等HR面。下午三点到的58，二面面完三点四五十，然后等HR等了大概40分钟，好像是好多人排队等HR面，后来我找人问情况，说我五点有事，能不能安排一下，然后就有一个看着像技术的HR，承担了我的HR面。面完等结果，说是择优录用。\n网易游戏\n一面\n(Spet. 20)\n面完58已经四点五十了，想着怎么着也赶不上网易面试了。所以下了大楼，就找了个人不多的地方，掏出电脑，席地而坐，打开手机热点，打开面试地址（这里真要吐槽一下，我是Linux系统，这次面试它没发邮件，只以短信形式发了面试链接，我电脑上又没有微信QQ，只好手敲网址，那时候已经要开始了，可把我急坏了，还敲错了几次，把大写的I误认为小写的l），就开始面试起来。\n\n自我介绍\nstatic关键字有何作用\nconst_cast是干嘛的\n说一下c++多态\n一个类有一个指针成员，拷贝构造函数的调用会造成什么问题？（拷贝构造函数只做指针的拷贝，所以新的对象并不拥有资源，可能原对象的资源已经释放，这就导致了空悬指针，而且如果在析构函数中释放资源的话，可能会造成二次释放）\n如何解决这种问题？（std::shared_ptr）\nstd::shared_ptr实现原理，循环引用怎么解决？（RAII，std::weak_ptr）\n编程：手写memcpy（注意overlap，从后往前拷贝）\nmap和hash map的区别？\n红黑树的特性？\n了解图形学吗？（不）\n基本的渲染流程知道吗（不）\n一个游戏服务端，出现了大量的TIME_WAIT，可能是什么原因？（不知道）\nTIME_WAIT知道吗？为什么又TIME_WAIT？（TCP四次挥手）\n编程：实现一个接口，从M个玩家中随机选取N个发放奖品（数组shuffle，我当时有点紧张，写的很乱）\n设计题：如果一个游戏，很多玩家同时登陆，需要排队，我想展示给玩家前方排队人数以及预计等待时间，怎么实现？（妈呀，不会，但是还是得扯）\n\n队列？\n随机访问怎么办？\n实现随机访问的接口\n玩家中途退出怎么办？\n用链表，节点中存有前面等待的人数，时间可以简单相乘\n中间玩家退出，后续节点都要更新？\n跳表，链表之上加个索引调表，这样既能很快计算前方等待人数，又方便更新（问到这里，他就没再问了，说时间差不多了，就到这里，希望给个二面）\n\n\n\n二面\n(Oct. 17)\n还是盼来了二面，然而很那个，怎么说呢，感觉不是很擅长。全程问我怎么设计游戏，不太会。\n\n自我介绍\n为什么投网易游戏？\n平时喜欢玩游戏吗？玩的最多的是什么游戏？\n你说喜欢玩安琪拉，如果让你设计一个安琪拉，你会怎么设计？（一边瞎写，一边瞎扯）\n你会添加哪些成员函数，和成员变量？\n你说到了装备，如果让你设计一个装备系统，你会怎么做？\n我们知道角色HP受很多因素影响，比方说装备，受到攻击，增益buf等，那么你是如何更新角色HP的呢？（说到了观察者模式）\n谁是观察者，谁是被观察者？\n我们知道装备的属性大部分是静态的，对于静态属性的也要用观察者模式订阅吗？\n你说到了观察者模式，平时项目中有用到过哪些设计模式？\n你是如何学习设计模式的？\n说说你对protobuf的理解？\n我们知道proto文件，使用proto文件有什么好处？\n大概知道protobuf的压缩原理吗？比方说如何编码int32.\n现在有一个老版本的protobuf序列化之后的字符串，但是后来又新加了一个变量。具体来说，\nrequired int32 hp;\noptional int32 lv;\n===saved===\n\noptional int32 mp;\n===readed===\n\n我们知道，proto是支持这种添加之后，仍然能够正确反序列化旧版本的字符串。你知道protobuf是怎么做的吗？\n实现一个带max()函数的栈？\n使用辅助栈，需要额外O(n)的空间，如果没有这么多空间给你，假设只有O(logn)，如何优化？（没答出来）\n说说你对boost::asio的理解？\n说说你实习中遇到的多线程问题？\n学过哪些计算机基础课？（没有）\n压力最大的一件事？\n目前手上有offer吗？\n方便说下哪几家吗？\n期望薪资大概多少？\n我这边差不多了，你有什么要问我的吗？\n\n看样子网易平均50分钟，面的感觉一般吧，51分，希望给个三面！\n原来没有三面，今天（Oct. 22）已经收到意向书，感动！\n在定位并处理应用程序出现的网络问题时，了解系统默认网络配置是非常必要的。ipv4网络协议的默认配置可以在/proc/sys/net/ipv4/下查看，其中与TCP协议栈相关的配置项均以tcp_xxx命名。可以使用cat查看，也可以使用sysctl批量查看。\n$ cat /proc/sys/net/ipv4/tcp_tw_reuse\n2\n \n$ whatis sysctl\nsysctl (2)           - read/write system parameters\nsysctl (8)           - configure kernel parameters at runtime\n \n$ sysctl net/ipv4\nnet.ipv4.cipso_cache_bucket_size = 10\nnet.ipv4.cipso_cache_enable = 1\nnet.ipv4.cipso_rbm_optfmt = 0\nnet.ipv4.conf.all.accept_local = 0\n...\n白山云科技\n(Sept. 20)\n面完网易之后，已经下午六点了，又赶去了白山的宣讲会，还好还没结束，那边研发还有几个人在面。等了一会之后，可能面试官们已经累了，直接leader面的我，并且本来应该有三轮技术面，一轮HR面。可能我去的太晚了，leader面过之后就算作二面通过，等了一会儿之后，直接HR面了。顺利拿到offer，秋招第一个offer，感谢！听说本来研发是几个人一起面，和面试官坐在一个圆桌上，面试官挨个问问题，好可怕。\n百度\n(Sept. 25)\n畅谈50分钟，反手挂！是我太菜，打扰了（这里吐槽一下百度选的垃圾酒店，太偏僻了，太难找了）面试官全程盯着简历问。\n\n自我介绍\n实习工作\n说一下异步和同步以及各自的优缺点？\n数据库了解吗？（不）\n在项目中做过索引吗？（没）\nB树B+树了解吗？（不，一问三不知，笑）\n链表和数组的区别？\nlinux查找包含特定内容的文件？\n如果还想查找当前目录的子目录呢？\n查找一个文件中特定内容出现的总行数？\n说一下TCP三次握手？\n手写代码：求一个二叉树的高度？（当时用的层次遍历到一个矩阵，然后输出行数，很笨的方法）\n说一下KNN？\n那k-means呢？（怪我光准备后台了，算法没复习，这两个搅浑了，恐怕是导致反手挂的直接原因）\n\n后面就没再问了，估计那时候面试官已经给我挂了，然后象征性的问我有没有问题问他，我也象征性的问了几个，然后就没有然后了。\n上海银行？\n(Sept. 25)\n我是去搞笑的，约的面试时间是下午三点，面完百度开始往那赶，赶到哪里的时候三点一刻，还怕来不及。结果去了等了两个多小时，还没排上我！听面完回来的同学说，5个面试官，同时面3个同学，算是群面？然后这样一组要面40-50分钟。三人一组的去，面完一组按编号叫下一组。虽然我是迟到了，排到了101号，但是两个小时后，才面到85号。也就是说，还有15人，三组，120分钟！三点去，要等的七点才能面上！算了，银行都这么高冷，（让我想起找实习的时候面招行，12个人分两组，一起搭积木，不，是按要求搭积木，还要能扯，把你搭好的积木吹上天，关于技术问题，一个都不问！）我惹不起，等到五点半就溜了。\n依图\n(Sept. 27)\n\n自我介绍\n看到我实习里面有用过protobuf，问了一下protobuf的优点\nTCP协议？（感觉问了很多网络）\n如何查看系统负载？各CPU负载？\n如果你写了一个模块，上线后用户反映其他模块的相应变慢了，你如何确定是不是你的原因？排查步骤如何？\n手撕代码：最大子序列和（leetcode原题，之前看到了，但是没做出来，然后不了了之，于是现场可想而知，虽然最后在讨论下写出来了，但是很糟糕，写的很乱，然后很慢，据说依图看重写代码的速度orz）\n由于写代码花了太长时间，直接结束\n\n（果然，凉凉）\n招银网络科技\n电面\n(Sept. 28)\n忘得差不多了。\n\n自我介绍\nsizeof 和 strlen 区别\n如果字符串不以空字符结尾，会引发什么错误？（我说undefined behavior，他说invalid address）\nconst 成员意义\n数据库了解吗？（不，银行数据库还是比较重要的，这方面很弱势orz）\n如何用两个栈模拟一个队列（剑指offer原题）\n\n(Oct. 13) 现场\n一面\n\n自我介绍\n有哪些进程间通信的机制？\n如何避免死锁？\n平时如何解决内存泄漏？（智能指针，少用动态内存）\n说说几种智能指针的原理？\n说说socket编程的基本步骤？\n说说常见的I/O模型\n知道epoll吗？\nepoll的两种出发模式ET和LT了解吗？（不）\n异步I/O有什么优点？（提高吞吐量）\n数据库了解吗？（不）\n说说数据库事务有什么特性？（不会）\n手撕代码：合并两个有序链表\n\n二面\n二面面试官看起来想速战速决，自我介绍都掠过了？\n\n挑一个项目跟我介绍一下？\n你说到异步，为什么要用异步？\n异步是如何实现的，底层原理了解吗？（大概说了一下，可能不对）\n你说到protobuf，为什么要用protobuf？\nprotobuf的底层IO模型是什么？（？？？还有这个）\n为什么要进行序列化？\nprotobuf如何反序列化的？为什么能够反序列化？（我说按照一定方式编码，自然能按照一定规则解码鸭）\n有两个小朋友A、B给其他小朋友派发水果，A给出两个苹果，B就得给出一个梨。如何实现这段逻辑？（用两个队列，一个放苹果，一个放梨，一个pop两次，一个pop一次；或者设一个flag，当为0或1，则A发苹果，当为2，则B发梨，再置为0）\n如果让你设计一个死锁，你会怎么做？\n\nHR面\n应该是去现场的都会面完三轮，不过结果如何就不知道了。问了HR，说两周内出结果，求个offer。\n新东方\n(Oct. 11)\n\n自我介绍\n进程和线程的区别\n进程间通信机制\n说一下内存池和线程池？\nTCP和UDP的区别？\n说一下数据库的主键、外键、和索引（一顿瞎说，他说知道思想就行）\n（后面记不得了）\n\n面试官意外的好说话，全程笑嘻嘻，我还迟到了10分钟。这次体验很好，可惜base北京。\n中移（苏州）软件研发中心\n(Oct. 14)\n一面\n\n自我介绍\nscoket编程的基本步骤\n说一下TCP四层模型？\ntelnet在哪一层？\ntelnet和ssh有什么区别？\nTCP和UDP的区别？\n说一下TCP的三握四挥？\nTIME_WAIT的含义，为什么会有TIME_WAIT？\n能大概说说TCP的协议头吗？\nPSH标志有什么作用？\nTCP的滑动窗口是干嘛用的？\n有什么方法可以查看socket状态？\n你说对linux比较熟悉，比如一个磁盘快被占满了，如何得知是哪些文件占用了磁盘？（df -h, du -hd 1）\n有一个实时更新的日志文件，如何查看该文件的动态更新？（这个不知道，直接tail -F就行）\n如何去掉一个文件中的空行？你能想到几种方法？\n如何替换文件中的某个字符串？（sed）\n排序算法有了解吗？\n写个快排吧（紧张，没在规定时间内写出来，然后就说了下思路）\n我们这边没什么问得了，你有什么想问的吗？\n\n一面两个面试官轮流夹击，我一度十分惊慌。\n二面\n人格面试什么的最不擅长。\n三面\n等了很久，三面面试官似乎出去办事去了。以至于面试的时候，面试官似乎想快点结束。\n\n自我介绍一下？\n有哪些稳定的排序算法？（插入、冒泡、归并）\n快排为什么不稳定？\npoll/epoll的区别是什么？\n这些东西你是怎么学的，看书还是看博客？（看man pages，面试官眼睛就亮了）\n手上有几个offer？\n挺好，我觉得你很不错，基础很扎实（#手动滑稽）\n很好，今天就面到这里，你回去等消息吧。\n\n事实上我连自我介绍都没说完，就被打断了，然后也就问了几个问题，不到10分钟就结束了。希望给个offer吧！\n米哈游\n(Oct. 17)\n\n自我介绍\nC++多态\n动态绑定的原理\n虚函数原理\n虚函数表是一个对象一个还是一个类一个？（不会）\n说一下C++四个智能指针以及各自用法？\nSTL了解吗？\nmap的底层实现使用的什么数据结构？\n红黑树的插入、删除、查找的平均和最坏复杂度是多少？（O(logn)和O(n)）\nvector底层实现？\nvector push_back 和 pop_back 的复杂度\n操作系统的大端序和小端序知道吗？\n写一个程序判断某个机器是大端序还是小端序？（不会：www.cnblogs.com/yooyoo/p/4717709.html）\n写一个程序判断某个机器是32位还是64位？（不会，32位指针占4字节，64位指针占8字节）\n如果起了一个进程，该进程使用tcp连接绑定了一个端口，如何查看这个端口是多少？（netstat -tp）\n如何查看一个进程所占用的内存？（htop）\nhtop/top会显示很多个内存，哪个才是你要的？\n有一个基本有序的数组，用什么排序算法比较好？（答了希尔排序，错的，插入排序）\n讲一下希尔排序？（推广的插入排序）\n对于有序数组，插入排序的时间复杂度是多少？（答了O(n^2)，没救了，面试官已经告诉我答案了，我居然还没发现！O(n)）\n快排的最好最快复杂度是多少？（问排序问崩了，脑子已经糊了，答了O(n)和O(n^2)，实际上快排最好也就O(nlogn)）\n快排在什么情况下性能最差？（答了在倒序的时候，尼玛正序的时候也是啊）\n那什么情况下最好呢？（答了正序的时候，尼玛快把这个沙雕拖出去！应该是每次划分正好左右两边平衡的时候，这样生成的递归树最平衡，复杂度最低）\n你实习都干了啥？看你写了Asio，你说说你实习的时候网络模型是什么样的，就是网络和业务的对接？（没接触业务）\n（针对我实习时候protobuf部分的内容问了很多，但是我都没说清楚，有点忘了）\n为什么投游戏行业？\n平时玩游戏吗？（玩了很久的崩坏3）\n多少级？（满级，80）\n哇，80级大佬！（后来把号卖了）\n卖了？（肝不动啊！）\n我这边问完了，你有什么想问的？（问了针对岗位的建议）\n应届生还是应该注重基础：数据结构、算法、网络、高并发等等。\n\n层次分明：语言+操作系统+算法+简历，感觉米忽悠的面试官水平挺高的。\nReferences\n\n大量TIME_WAIT的终极详解和解决方案\n"}}